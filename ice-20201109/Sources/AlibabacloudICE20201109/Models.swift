import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddCategoryRequest : Tea.TeaModel {
    public var cateName: String?

    public var parentId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateName") && dict["CateName"] != nil {
            self.cateName = dict["CateName"] as! String
        }
        if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddCategoryResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: Int64?

        public var cateName: String?

        public var level: Int64?

        public var parentId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") && dict["CateId"] != nil {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") && dict["CateName"] != nil {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var category: AddCategoryResponseBody.Category?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            var model = AddCategoryResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialMaps: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialMaps != nil {
            map["MaterialMaps"] = self.materialMaps!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialMaps") && dict["MaterialMaps"] != nil {
            self.materialMaps = dict["MaterialMaps"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class AddEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public class LiveMaterials : Tea.TeaModel {
        public var appName: String?

        public var domainName: String?

        public var liveUrl: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.liveUrl != nil {
                map["LiveUrl"] = self.liveUrl!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("LiveUrl") && dict["LiveUrl"] != nil {
                self.liveUrl = dict["LiveUrl"] as! String
            }
            if dict.keys.contains("StreamName") && dict["StreamName"] != nil {
                self.streamName = dict["StreamName"] as! String
            }
        }
    }
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") && dict["FileType"] != nil {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") && dict["Region"] != nil {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                    var model = AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") && dict["DeletedTime"] != nil {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") && dict["InputURL"] != nil {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") && dict["MediaTags"] != nil {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") && dict["SpriteImages"] != nil {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") && dict["TranscodeStatus"] != nil {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") && dict["UserData"] != nil {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: AddEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") && dict["FileInfoList"] != nil {
                var tmp : [AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") && dict["MediaBasicInfo"] != nil {
                var model = AddEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var liveMaterials: [AddEditingProjectMaterialsResponseBody.LiveMaterials]?

    public var mediaInfos: [AddEditingProjectMaterialsResponseBody.MediaInfos]?

    public var projectId: String?

    public var projectMaterials: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveMaterials != nil {
            var tmp : [Any] = []
            for k in self.liveMaterials! {
                tmp.append(k.toMap())
            }
            map["LiveMaterials"] = tmp
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectMaterials != nil {
            map["ProjectMaterials"] = self.projectMaterials!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveMaterials") && dict["LiveMaterials"] != nil {
            var tmp : [AddEditingProjectMaterialsResponseBody.LiveMaterials] = []
            for v in dict["LiveMaterials"] as! [Any] {
                var model = AddEditingProjectMaterialsResponseBody.LiveMaterials()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.liveMaterials = tmp
        }
        if dict.keys.contains("MediaInfos") && dict["MediaInfos"] != nil {
            var tmp : [AddEditingProjectMaterialsResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = AddEditingProjectMaterialsResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectMaterials") && dict["ProjectMaterials"] != nil {
            self.projectMaterials = dict["ProjectMaterials"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddFavoritePublicMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") && dict["MediaIds"] != nil {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class AddFavoritePublicMediaResponseBody : Tea.TeaModel {
    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IgnoredList") && dict["IgnoredList"] != nil {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddFavoritePublicMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddFavoritePublicMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddFavoritePublicMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") && dict["MediaMarks"] != nil {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
    }
}

public class AddMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") && dict["MediaMarkIds"] != nil {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTemplateRequest : Tea.TeaModel {
    public var config: String?

    public var coverUrl: String?

    public var name: String?

    public var previewMedia: String?

    public var relatedMediaids: String?

    public var source: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.previewMedia != nil {
            map["PreviewMedia"] = self.previewMedia!
        }
        if self.relatedMediaids != nil {
            map["RelatedMediaids"] = self.relatedMediaids!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PreviewMedia") && dict["PreviewMedia"] != nil {
            self.previewMedia = dict["PreviewMedia"] as! String
        }
        if dict.keys.contains("RelatedMediaids") && dict["RelatedMediaids"] != nil {
            self.relatedMediaids = dict["RelatedMediaids"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var config: String?

        public var coverUrl: String?

        public var createSource: String?

        public var modifiedSource: String?

        public var name: String?

        public var previewMedia: String?

        public var status: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.previewMedia != nil {
                map["PreviewMedia"] = self.previewMedia!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("CreateSource") && dict["CreateSource"] != nil {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("ModifiedSource") && dict["ModifiedSource"] != nil {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PreviewMedia") && dict["PreviewMedia"] != nil {
                self.previewMedia = dict["PreviewMedia"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var template: AddTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") && dict["Template"] != nil {
            var model = AddTemplateResponseBody.Template()
            model.fromMap(dict["Template"] as! [String: Any])
            self.template = model
        }
    }
}

public class AddTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchGetMediaInfosRequest : Tea.TeaModel {
    public var additionType: String?

    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionType != nil {
            map["AdditionType"] = self.additionType!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionType") && dict["AdditionType"] != nil {
            self.additionType = dict["AdditionType"] as! String
        }
        if dict.keys.contains("MediaIds") && dict["MediaIds"] != nil {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class BatchGetMediaInfosResponseBody : Tea.TeaModel {
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") && dict["FileType"] != nil {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") && dict["Region"] != nil {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                    var model = BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") && dict["DeletedTime"] != nil {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") && dict["InputURL"] != nil {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") && dict["MediaTags"] != nil {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") && dict["SpriteImages"] != nil {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") && dict["TranscodeStatus"] != nil {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") && dict["UserData"] != nil {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: BatchGetMediaInfosResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") && dict["FileInfoList"] != nil {
                var tmp : [BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") && dict["MediaBasicInfo"] != nil {
                var model = BatchGetMediaInfosResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var mediaInfos: [BatchGetMediaInfosResponseBody.MediaInfos]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfos") && dict["MediaInfos"] != nil {
            var tmp : [BatchGetMediaInfosResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = BatchGetMediaInfosResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchGetMediaInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchGetMediaInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchGetMediaInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelDNAJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CancelDNAJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelDNAJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelDNAJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelDNAJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelFavoritePublicMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") && dict["MediaIds"] != nil {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class CancelFavoritePublicMediaResponseBody : Tea.TeaModel {
    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IgnoredList") && dict["IgnoredList"] != nil {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelFavoritePublicMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelFavoritePublicMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelFavoritePublicMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAuditRequest : Tea.TeaModel {
    public var appId: String?

    public var auditContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.auditContent != nil {
            map["AuditContent"] = self.auditContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AuditContent") && dict["AuditContent"] != nil {
            self.auditContent = dict["AuditContent"] as! String
        }
    }
}

public class CreateAuditResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAuditResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAuditResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAuditResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomTemplateRequest : Tea.TeaModel {
    public var name: String?

    public var subtype: Int32?

    public var templateConfig: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Subtype") && dict["Subtype"] != nil {
            self.subtype = dict["Subtype"] as! Int32
        }
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class CreateCustomTemplateResponseBody : Tea.TeaModel {
    public class CustomTemplate : Tea.TeaModel {
        public var createTime: String?

        public var isDefault: Bool?

        public var modifiedTime: String?

        public var status: String?

        public var subtype: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") && dict["Subtype"] != nil {
                self.subtype = dict["Subtype"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var customTemplate: CreateCustomTemplateResponseBody.CustomTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplate != nil {
            map["CustomTemplate"] = self.customTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplate") && dict["CustomTemplate"] != nil {
            var model = CreateCustomTemplateResponseBody.CustomTemplate()
            model.fromMap(dict["CustomTemplate"] as! [String: Any])
            self.customTemplate = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDNADBRequest : Tea.TeaModel {
    public var description_: String?

    public var model: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateDNADBResponseBody : Tea.TeaModel {
    public class DBInfo : Tea.TeaModel {
        public var DBId: String?

        public var description_: String?

        public var model: String?

        public var name: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBId != nil {
                map["DBId"] = self.DBId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.model != nil {
                map["Model"] = self.model!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DBId") && dict["DBId"] != nil {
                self.DBId = dict["DBId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Model") && dict["Model"] != nil {
                self.model = dict["Model"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var DBInfo: CreateDNADBResponseBody.DBInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DBInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInfo != nil {
            map["DBInfo"] = self.DBInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBInfo") && dict["DBInfo"] != nil {
            var model = CreateDNADBResponseBody.DBInfo()
            model.fromMap(dict["DBInfo"] as! [String: Any])
            self.DBInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDNADBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDNADBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDNADBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEditingProjectRequest : Tea.TeaModel {
    public var businessConfig: String?

    public var clipsParam: String?

    public var coverURL: String?

    public var description_: String?

    public var materialMaps: String?

    public var projectType: String?

    public var templateId: String?

    public var templateType: String?

    public var timeline: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessConfig != nil {
            map["BusinessConfig"] = self.businessConfig!
        }
        if self.clipsParam != nil {
            map["ClipsParam"] = self.clipsParam!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.materialMaps != nil {
            map["MaterialMaps"] = self.materialMaps!
        }
        if self.projectType != nil {
            map["ProjectType"] = self.projectType!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessConfig") && dict["BusinessConfig"] != nil {
            self.businessConfig = dict["BusinessConfig"] as! String
        }
        if dict.keys.contains("ClipsParam") && dict["ClipsParam"] != nil {
            self.clipsParam = dict["ClipsParam"] as! String
        }
        if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MaterialMaps") && dict["MaterialMaps"] != nil {
            self.materialMaps = dict["MaterialMaps"] as! String
        }
        if dict.keys.contains("ProjectType") && dict["ProjectType"] != nil {
            self.projectType = dict["ProjectType"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateEditingProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var clipsParam: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var duration: Double?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: Int64?

        public var statusName: String?

        public var templateId: String?

        public var templateType: String?

        public var timeline: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusName != nil {
                map["StatusName"] = self.statusName!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") && dict["BusinessConfig"] != nil {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") && dict["BusinessStatus"] != nil {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("ClipsParam") && dict["ClipsParam"] != nil {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") && dict["CreateSource"] != nil {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("ModifiedSource") && dict["ModifiedSource"] != nil {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") && dict["ProjectType"] != nil {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("StatusName") && dict["StatusName"] != nil {
                self.statusName = dict["StatusName"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var project: CreateEditingProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") && dict["Project"] != nil {
            var model = CreateEditingProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveRecordTemplateRequest : Tea.TeaModel {
    public class RecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var ossObjectPrefix: String?

        public var sliceDuration: Int32?

        public var sliceOssObjectPrefix: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.ossObjectPrefix != nil {
                map["OssObjectPrefix"] = self.ossObjectPrefix!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            if self.sliceOssObjectPrefix != nil {
                map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CycleDuration") && dict["CycleDuration"] != nil {
                self.cycleDuration = dict["CycleDuration"] as! Int32
            }
            if dict.keys.contains("Format") && dict["Format"] != nil {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("OssObjectPrefix") && dict["OssObjectPrefix"] != nil {
                self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
            }
            if dict.keys.contains("SliceDuration") && dict["SliceDuration"] != nil {
                self.sliceDuration = dict["SliceDuration"] as! Int32
            }
            if dict.keys.contains("SliceOssObjectPrefix") && dict["SliceOssObjectPrefix"] != nil {
                self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
            }
        }
    }
    public var name: String?

    public var recordFormat: [CreateLiveRecordTemplateRequest.RecordFormat]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormat != nil {
            var tmp : [Any] = []
            for k in self.recordFormat! {
                tmp.append(k.toMap())
            }
            map["RecordFormat"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") && dict["RecordFormat"] != nil {
            var tmp : [CreateLiveRecordTemplateRequest.RecordFormat] = []
            for v in dict["RecordFormat"] as! [Any] {
                var model = CreateLiveRecordTemplateRequest.RecordFormat()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordFormat = tmp
        }
    }
}

public class CreateLiveRecordTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var recordFormatShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormatShrink != nil {
            map["RecordFormat"] = self.recordFormatShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") && dict["RecordFormat"] != nil {
            self.recordFormatShrink = dict["RecordFormat"] as! String
        }
    }
}

public class CreateLiveRecordTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var overwriteFormat: String?

    public var sequenceFormat: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OverwriteFormat") && dict["OverwriteFormat"] != nil {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("SequenceFormat") && dict["SequenceFormat"] != nil {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") && dict["TimeInterval"] != nil {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class CreateLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveTranscodeTemplateRequest : Tea.TeaModel {
    public class TemplateConfig : Tea.TeaModel {
        public class AudioParams : Tea.TeaModel {
            public var bitrate: String?

            public var channels: String?

            public var codec: String?

            public var profile: String?

            public var samplerate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.samplerate != nil {
                    map["Samplerate"] = self.samplerate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Channels") && dict["Channels"] != nil {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Samplerate") && dict["Samplerate"] != nil {
                    self.samplerate = dict["Samplerate"] as! String
                }
            }
        }
        public class VideoParams : Tea.TeaModel {
            public var bitrate: String?

            public var codec: String?

            public var fps: String?

            public var gop: String?

            public var height: String?

            public var profile: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Fps") && dict["Fps"] != nil {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Gop") && dict["Gop"] != nil {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Height") && dict["Height"] != nil {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Width") && dict["Width"] != nil {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audioParams: CreateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams?

        public var videoParams: CreateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audioParams?.validate()
            try self.videoParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioParams != nil {
                map["AudioParams"] = self.audioParams?.toMap()
            }
            if self.videoParams != nil {
                map["VideoParams"] = self.videoParams?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioParams") && dict["AudioParams"] != nil {
                var model = CreateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams()
                model.fromMap(dict["AudioParams"] as! [String: Any])
                self.audioParams = model
            }
            if dict.keys.contains("VideoParams") && dict["VideoParams"] != nil {
                var model = CreateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams()
                model.fromMap(dict["VideoParams"] as! [String: Any])
                self.videoParams = model
            }
        }
    }
    public var name: String?

    public var templateConfig: CreateLiveTranscodeTemplateRequest.TemplateConfig?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            var model = CreateLiveTranscodeTemplateRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfigShrink: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePipelineRequest : Tea.TeaModel {
    public var name: String?

    public var priority: Int32?

    public var speed: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.speed != nil {
            map["Speed"] = self.speed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Priority") && dict["Priority"] != nil {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Speed") && dict["Speed"] != nil {
            self.speed = dict["Speed"] as! String
        }
    }
}

public class CreatePipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public var createTime: String?

        public var modifiedTime: String?

        public var name: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var speed: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Speed") && dict["Speed"] != nil {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipeline: CreatePipelineResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") && dict["Pipeline"] != nil {
            var model = CreatePipelineResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreatePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadMediaRequest : Tea.TeaModel {
    public var appId: String?

    public var entityId: String?

    public var fileInfo: String?

    public var mediaMetaData: String?

    public var postProcessConfig: String?

    public var uploadTargetConfig: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.fileInfo != nil {
            map["FileInfo"] = self.fileInfo!
        }
        if self.mediaMetaData != nil {
            map["MediaMetaData"] = self.mediaMetaData!
        }
        if self.postProcessConfig != nil {
            map["PostProcessConfig"] = self.postProcessConfig!
        }
        if self.uploadTargetConfig != nil {
            map["UploadTargetConfig"] = self.uploadTargetConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EntityId") && dict["EntityId"] != nil {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("FileInfo") && dict["FileInfo"] != nil {
            self.fileInfo = dict["FileInfo"] as! String
        }
        if dict.keys.contains("MediaMetaData") && dict["MediaMetaData"] != nil {
            self.mediaMetaData = dict["MediaMetaData"] as! String
        }
        if dict.keys.contains("PostProcessConfig") && dict["PostProcessConfig"] != nil {
            self.postProcessConfig = dict["PostProcessConfig"] as! String
        }
        if dict.keys.contains("UploadTargetConfig") && dict["UploadTargetConfig"] != nil {
            self.uploadTargetConfig = dict["UploadTargetConfig"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class CreateUploadMediaResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var mediaId: String?

    public var mediaURL: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaURL != nil {
            map["MediaURL"] = self.mediaURL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaURL") && dict["MediaURL"] != nil {
            self.mediaURL = dict["MediaURL"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") && dict["UploadAddress"] != nil {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") && dict["UploadAuth"] != nil {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class CreateUploadMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateUploadMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadStreamRequest : Tea.TeaModel {
    public var definition: String?

    public var fileExtension: String?

    public var HDRType: String?

    public var mediaId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.fileExtension != nil {
            map["FileExtension"] = self.fileExtension!
        }
        if self.HDRType != nil {
            map["HDRType"] = self.HDRType!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definition") && dict["Definition"] != nil {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("FileExtension") && dict["FileExtension"] != nil {
            self.fileExtension = dict["FileExtension"] as! String
        }
        if dict.keys.contains("HDRType") && dict["HDRType"] != nil {
            self.HDRType = dict["HDRType"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class CreateUploadStreamResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var mediaId: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") && dict["UploadAddress"] != nil {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") && dict["UploadAuth"] != nil {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class CreateUploadStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateUploadStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") && dict["CateId"] != nil {
            self.cateId = dict["CateId"] as! Int64
        }
    }
}

public class DeleteCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDNADBRequest : Tea.TeaModel {
    public var DBId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBId") && dict["DBId"] != nil {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteDNADBResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDNADBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDNADBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDNADBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDNAFilesRequest : Tea.TeaModel {
    public var DBId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var primaryKeys: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.primaryKeys != nil {
            map["PrimaryKeys"] = self.primaryKeys!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBId") && dict["DBId"] != nil {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrimaryKeys") && dict["PrimaryKeys"] != nil {
            self.primaryKeys = dict["PrimaryKeys"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteDNAFilesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDNAFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDNAFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDNAFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialIds: String?

    public var materialType: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialIds != nil {
            map["MaterialIds"] = self.materialIds!
        }
        if self.materialType != nil {
            map["MaterialType"] = self.materialType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialIds") && dict["MaterialIds"] != nil {
            self.materialIds = dict["MaterialIds"] as! String
        }
        if dict.keys.contains("MaterialType") && dict["MaterialType"] != nil {
            self.materialType = dict["MaterialType"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DeleteEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEditingProjectsRequest : Tea.TeaModel {
    public var projectIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectIds != nil {
            map["ProjectIds"] = self.projectIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectIds") && dict["ProjectIds"] != nil {
            self.projectIds = dict["ProjectIds"] as! String
        }
    }
}

public class DeleteEditingProjectsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEditingProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEditingProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEditingProjectsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveRecordFilesRequest : Tea.TeaModel {
    public var recordIds: [String]?

    public var removeFile: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordIds != nil {
            map["RecordIds"] = self.recordIds!
        }
        if self.removeFile != nil {
            map["RemoveFile"] = self.removeFile!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordIds") && dict["RecordIds"] != nil {
            self.recordIds = dict["RecordIds"] as! [String]
        }
        if dict.keys.contains("RemoveFile") && dict["RemoveFile"] != nil {
            self.removeFile = dict["RemoveFile"] as! Bool
        }
    }
}

public class DeleteLiveRecordFilesResponseBody : Tea.TeaModel {
    public class DeleteFileInfoList : Tea.TeaModel {
        public var code: String?

        public var message: String?

        public var recordId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! String
            }
        }
    }
    public var deleteFileInfoList: [DeleteLiveRecordFilesResponseBody.DeleteFileInfoList]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFileInfoList != nil {
            var tmp : [Any] = []
            for k in self.deleteFileInfoList! {
                tmp.append(k.toMap())
            }
            map["DeleteFileInfoList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteFileInfoList") && dict["DeleteFileInfoList"] != nil {
            var tmp : [DeleteLiveRecordFilesResponseBody.DeleteFileInfoList] = []
            for v in dict["DeleteFileInfoList"] as! [Any] {
                var model = DeleteLiveRecordFilesResponseBody.DeleteFileInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deleteFileInfoList = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveRecordFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRecordFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLiveRecordFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveRecordTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveRecordTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveSnapshotFilesRequest : Tea.TeaModel {
    public var createTimestampList: [Int64]?

    public var deleteOriginalFile: Bool?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimestampList != nil {
            map["CreateTimestampList"] = self.createTimestampList!
        }
        if self.deleteOriginalFile != nil {
            map["DeleteOriginalFile"] = self.deleteOriginalFile!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimestampList") && dict["CreateTimestampList"] != nil {
            self.createTimestampList = dict["CreateTimestampList"] as! [Int64]
        }
        if dict.keys.contains("DeleteOriginalFile") && dict["DeleteOriginalFile"] != nil {
            self.deleteOriginalFile = dict["DeleteOriginalFile"] as! Bool
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteLiveSnapshotFilesShrinkRequest : Tea.TeaModel {
    public var createTimestampListShrink: String?

    public var deleteOriginalFile: Bool?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimestampListShrink != nil {
            map["CreateTimestampList"] = self.createTimestampListShrink!
        }
        if self.deleteOriginalFile != nil {
            map["DeleteOriginalFile"] = self.deleteOriginalFile!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimestampList") && dict["CreateTimestampList"] != nil {
            self.createTimestampListShrink = dict["CreateTimestampList"] as! String
        }
        if dict.keys.contains("DeleteOriginalFile") && dict["DeleteOriginalFile"] != nil {
            self.deleteOriginalFile = dict["DeleteOriginalFile"] as! Bool
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteLiveSnapshotFilesResponseBody : Tea.TeaModel {
    public class DeleteFileResultList : Tea.TeaModel {
        public var createTimestamp: Int64?

        public var result: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimestamp") && dict["CreateTimestamp"] != nil {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! String
            }
        }
    }
    public var deleteFileResultList: [DeleteLiveSnapshotFilesResponseBody.DeleteFileResultList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFileResultList != nil {
            var tmp : [Any] = []
            for k in self.deleteFileResultList! {
                tmp.append(k.toMap())
            }
            map["DeleteFileResultList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteFileResultList") && dict["DeleteFileResultList"] != nil {
            var tmp : [DeleteLiveSnapshotFilesResponseBody.DeleteFileResultList] = []
            for v in dict["DeleteFileResultList"] as! [Any] {
                var model = DeleteLiveSnapshotFilesResponseBody.DeleteFileResultList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deleteFileResultList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveSnapshotFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSnapshotFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLiveSnapshotFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveTranscodeJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteLiveTranscodeJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveTranscodeTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaInfosRequest : Tea.TeaModel {
    public var deletePhysicalFiles: Bool?

    public var inputURLs: String?

    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deletePhysicalFiles != nil {
            map["DeletePhysicalFiles"] = self.deletePhysicalFiles!
        }
        if self.inputURLs != nil {
            map["InputURLs"] = self.inputURLs!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeletePhysicalFiles") && dict["DeletePhysicalFiles"] != nil {
            self.deletePhysicalFiles = dict["DeletePhysicalFiles"] as! Bool
        }
        if dict.keys.contains("InputURLs") && dict["InputURLs"] != nil {
            self.inputURLs = dict["InputURLs"] as! String
        }
        if dict.keys.contains("MediaIds") && dict["MediaIds"] != nil {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class DeleteMediaInfosResponseBody : Tea.TeaModel {
    public var forbiddenList: [String]?

    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenList != nil {
            map["ForbiddenList"] = self.forbiddenList!
        }
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenList") && dict["ForbiddenList"] != nil {
            self.forbiddenList = dict["ForbiddenList"] as! [String]
        }
        if dict.keys.contains("IgnoredList") && dict["IgnoredList"] != nil {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMediaInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") && dict["MediaMarkIds"] != nil {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
    }
}

public class DeleteMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") && dict["MediaMarkIds"] != nil {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePipelineRequest : Tea.TeaModel {
    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
            self.pipelineId = dict["PipelineId"] as! String
        }
    }
}

public class DeletePipelineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeletePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeletePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePlayInfoRequest : Tea.TeaModel {
    public var deletePhysicalFiles: Bool?

    public var fileURLs: String?

    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deletePhysicalFiles != nil {
            map["DeletePhysicalFiles"] = self.deletePhysicalFiles!
        }
        if self.fileURLs != nil {
            map["FileURLs"] = self.fileURLs!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeletePhysicalFiles") && dict["DeletePhysicalFiles"] != nil {
            self.deletePhysicalFiles = dict["DeletePhysicalFiles"] as! Bool
        }
        if dict.keys.contains("FileURLs") && dict["FileURLs"] != nil {
            self.fileURLs = dict["FileURLs"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class DeletePlayInfoResponseBody : Tea.TeaModel {
    public var forbiddenList: [String]?

    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenList != nil {
            map["ForbiddenList"] = self.forbiddenList!
        }
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenList") && dict["ForbiddenList"] != nil {
            self.forbiddenList = dict["ForbiddenList"] as! [String]
        }
        if dict.keys.contains("IgnoredList") && dict["IgnoredList"] != nil {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeletePlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSmartJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteSmartJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSmartJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSmartJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSmartJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTemplateRequest : Tea.TeaModel {
    public var templateIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateIds") && dict["TemplateIds"] != nil {
            self.templateIds = dict["TemplateIds"] as! String
        }
    }
}

public class DeleteTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFilterConfigsRequest : Tea.TeaModel {
    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeFilterConfigsResponseBody : Tea.TeaModel {
    public class FilterConfigs : Tea.TeaModel {
        public var filterName: String?

        public var itemConfigs: String?

        public var type: String?

        public var uuId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.filterName != nil {
                map["FilterName"] = self.filterName!
            }
            if self.itemConfigs != nil {
                map["ItemConfigs"] = self.itemConfigs!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uuId != nil {
                map["UuId"] = self.uuId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FilterName") && dict["FilterName"] != nil {
                self.filterName = dict["FilterName"] as! String
            }
            if dict.keys.contains("ItemConfigs") && dict["ItemConfigs"] != nil {
                self.itemConfigs = dict["ItemConfigs"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UuId") && dict["UuId"] != nil {
                self.uuId = dict["UuId"] as! String
            }
        }
    }
    public var filterConfigs: [DescribeFilterConfigsResponseBody.FilterConfigs]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filterConfigs != nil {
            var tmp : [Any] = []
            for k in self.filterConfigs! {
                tmp.append(k.toMap())
            }
            map["FilterConfigs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilterConfigs") && dict["FilterConfigs"] != nil {
            var tmp : [DescribeFilterConfigsResponseBody.FilterConfigs] = []
            for v in dict["FilterConfigs"] as! [Any] {
                var model = DescribeFilterConfigsResponseBody.FilterConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filterConfigs = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFilterConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFilterConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFilterConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterIceEditUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterIceEditUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var profile: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.profile != nil {
                map["Profile"] = self.profile!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Profile") && dict["Profile"] != nil {
                self.profile = dict["Profile"] as! String
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterIceEditUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterIceEditUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterIceEditUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterIceEditUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterIceEditUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterIceEditUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterIceLiveMediaConvertUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterIceLiveMediaConvertUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") && dict["Specification"] != nil {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterIceLiveMediaConvertUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterIceLiveMediaConvertUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterIceLiveMediaConvertUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterIceLiveMediaConvertUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterIceLiveMediaConvertUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterIceLiveMediaConvertUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterIceMediaConvertUHDUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: String?

    public var regionId: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterIceMediaConvertUHDUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") && dict["Specification"] != nil {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterIceMediaConvertUHDUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterIceMediaConvertUHDUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterIceMediaConvertUHDUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterIceMediaConvertUHDUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterIceMediaConvertUHDUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterIceMediaConvertUHDUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterIceMediaConvertUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterIceMediaConvertUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") && dict["Specification"] != nil {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterIceMediaConvertUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterIceMediaConvertUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterIceMediaConvertUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterIceMediaConvertUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterIceMediaConvertUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterIceMediaConvertUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterIceMpsAiUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterIceMpsAiUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var time: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [DescribeMeterIceMpsAiUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterIceMpsAiUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterIceMpsAiUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterIceMpsAiUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterIceMpsAiUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterIceMpsAiUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsEditUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsEditUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var profile: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.profile != nil {
                map["Profile"] = self.profile!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Profile") && dict["Profile"] != nil {
                self.profile = dict["Profile"] as! String
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsEditUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterImsEditUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsEditUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsEditUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsEditUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterImsEditUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsLiveEditUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsLiveEditUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var profile: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.profile != nil {
                map["Profile"] = self.profile!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Profile") && dict["Profile"] != nil {
                self.profile = dict["Profile"] as! String
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsLiveEditUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterImsLiveEditUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsLiveEditUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsLiveEditUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsLiveEditUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterImsLiveEditUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsLiveMediaConvertUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsLiveMediaConvertUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") && dict["Specification"] != nil {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsLiveMediaConvertUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterImsLiveMediaConvertUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsLiveMediaConvertUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsLiveMediaConvertUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsLiveMediaConvertUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterImsLiveMediaConvertUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsLiveRecordUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsLiveRecordUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var channels: Double?

        public var duration: Int64?

        public var time: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channels != nil {
                map["Channels"] = self.channels!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Channels") && dict["Channels"] != nil {
                self.channels = dict["Channels"] as! Double
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [DescribeMeterImsLiveRecordUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterImsLiveRecordUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsLiveRecordUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsLiveRecordUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsLiveRecordUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterImsLiveRecordUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsLiveSnapshotUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsLiveSnapshotUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: Int64?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int64
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsLiveSnapshotUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterImsLiveSnapshotUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsLiveSnapshotUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsLiveSnapshotUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsLiveSnapshotUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterImsLiveSnapshotUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsMediaConvertUHDUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: String?

    public var regionId: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsMediaConvertUHDUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") && dict["Specification"] != nil {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsMediaConvertUHDUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterImsMediaConvertUHDUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsMediaConvertUHDUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsMediaConvertUHDUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsMediaConvertUHDUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterImsMediaConvertUHDUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsMediaConvertUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsMediaConvertUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") && dict["Specification"] != nil {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsMediaConvertUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterImsMediaConvertUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsMediaConvertUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsMediaConvertUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsMediaConvertUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterImsMediaConvertUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsMpsAiUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsMpsAiUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var time: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [DescribeMeterImsMpsAiUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterImsMpsAiUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsMpsAiUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsMpsAiUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsMpsAiUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterImsMpsAiUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsSummaryRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var editingDuration: String?

        public var liveEditDuration: String?

        public var liveRecordDuration: String?

        public var liveSnapshotCount: String?

        public var liveTranscodeDuration: Int64?

        public var mpsAiDuration: Int64?

        public var mpsTranscodeDuration: Int64?

        public var mpsTranscodeUHDDuration: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.editingDuration != nil {
                map["EditingDuration"] = self.editingDuration!
            }
            if self.liveEditDuration != nil {
                map["LiveEditDuration"] = self.liveEditDuration!
            }
            if self.liveRecordDuration != nil {
                map["LiveRecordDuration"] = self.liveRecordDuration!
            }
            if self.liveSnapshotCount != nil {
                map["LiveSnapshotCount"] = self.liveSnapshotCount!
            }
            if self.liveTranscodeDuration != nil {
                map["LiveTranscodeDuration"] = self.liveTranscodeDuration!
            }
            if self.mpsAiDuration != nil {
                map["MpsAiDuration"] = self.mpsAiDuration!
            }
            if self.mpsTranscodeDuration != nil {
                map["MpsTranscodeDuration"] = self.mpsTranscodeDuration!
            }
            if self.mpsTranscodeUHDDuration != nil {
                map["MpsTranscodeUHDDuration"] = self.mpsTranscodeUHDDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EditingDuration") && dict["EditingDuration"] != nil {
                self.editingDuration = dict["EditingDuration"] as! String
            }
            if dict.keys.contains("LiveEditDuration") && dict["LiveEditDuration"] != nil {
                self.liveEditDuration = dict["LiveEditDuration"] as! String
            }
            if dict.keys.contains("LiveRecordDuration") && dict["LiveRecordDuration"] != nil {
                self.liveRecordDuration = dict["LiveRecordDuration"] as! String
            }
            if dict.keys.contains("LiveSnapshotCount") && dict["LiveSnapshotCount"] != nil {
                self.liveSnapshotCount = dict["LiveSnapshotCount"] as! String
            }
            if dict.keys.contains("LiveTranscodeDuration") && dict["LiveTranscodeDuration"] != nil {
                self.liveTranscodeDuration = dict["LiveTranscodeDuration"] as! Int64
            }
            if dict.keys.contains("MpsAiDuration") && dict["MpsAiDuration"] != nil {
                self.mpsAiDuration = dict["MpsAiDuration"] as! Int64
            }
            if dict.keys.contains("MpsTranscodeDuration") && dict["MpsTranscodeDuration"] != nil {
                self.mpsTranscodeDuration = dict["MpsTranscodeDuration"] as! Int64
            }
            if dict.keys.contains("MpsTranscodeUHDDuration") && dict["MpsTranscodeUHDDuration"] != nil {
                self.mpsTranscodeUHDDuration = dict["MpsTranscodeUHDDuration"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsSummaryResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeMeterImsSummaryResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsSummaryResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeterImsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayDetailRequest : Tea.TeaModel {
    public var playTs: String?

    public var sessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.playTs != nil {
            map["PlayTs"] = self.playTs!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PlayTs") && dict["PlayTs"] != nil {
            self.playTs = dict["PlayTs"] as! String
        }
        if dict.keys.contains("SessionId") && dict["SessionId"] != nil {
            self.sessionId = dict["SessionId"] as! String
        }
    }
}

public class DescribePlayDetailResponseBody : Tea.TeaModel {
    public class BaseInfos : Tea.TeaModel {
        public var appName: String?

        public var bps: String?

        public var broadcastPace: String?

        public var clientIP: String?

        public var codec: String?

        public var decodeStuckTime: String?

        public var definition: String?

        public var firstFrameDuration: String?

        public var fps: String?

        public var isHardDecode: String?

        public var mdat: String?

        public var moov: String?

        public var network: String?

        public var networkDuration: String?

        public var networkStuckTime: String?

        public var os: String?

        public var playTs: String?

        public var playerLoadDuration: String?

        public var playerPreDealDuration: String?

        public var playerReadyDuration: String?

        public var sdkVersion: String?

        public var sessionId: String?

        public var status: String?

        public var terminalType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.bps != nil {
                map["Bps"] = self.bps!
            }
            if self.broadcastPace != nil {
                map["BroadcastPace"] = self.broadcastPace!
            }
            if self.clientIP != nil {
                map["ClientIP"] = self.clientIP!
            }
            if self.codec != nil {
                map["Codec"] = self.codec!
            }
            if self.decodeStuckTime != nil {
                map["DecodeStuckTime"] = self.decodeStuckTime!
            }
            if self.definition != nil {
                map["Definition"] = self.definition!
            }
            if self.firstFrameDuration != nil {
                map["FirstFrameDuration"] = self.firstFrameDuration!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.isHardDecode != nil {
                map["IsHardDecode"] = self.isHardDecode!
            }
            if self.mdat != nil {
                map["Mdat"] = self.mdat!
            }
            if self.moov != nil {
                map["Moov"] = self.moov!
            }
            if self.network != nil {
                map["Network"] = self.network!
            }
            if self.networkDuration != nil {
                map["NetworkDuration"] = self.networkDuration!
            }
            if self.networkStuckTime != nil {
                map["NetworkStuckTime"] = self.networkStuckTime!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.playTs != nil {
                map["PlayTs"] = self.playTs!
            }
            if self.playerLoadDuration != nil {
                map["PlayerLoadDuration"] = self.playerLoadDuration!
            }
            if self.playerPreDealDuration != nil {
                map["PlayerPreDealDuration"] = self.playerPreDealDuration!
            }
            if self.playerReadyDuration != nil {
                map["PlayerReadyDuration"] = self.playerReadyDuration!
            }
            if self.sdkVersion != nil {
                map["SdkVersion"] = self.sdkVersion!
            }
            if self.sessionId != nil {
                map["SessionId"] = self.sessionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.terminalType != nil {
                map["TerminalType"] = self.terminalType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Bps") && dict["Bps"] != nil {
                self.bps = dict["Bps"] as! String
            }
            if dict.keys.contains("BroadcastPace") && dict["BroadcastPace"] != nil {
                self.broadcastPace = dict["BroadcastPace"] as! String
            }
            if dict.keys.contains("ClientIP") && dict["ClientIP"] != nil {
                self.clientIP = dict["ClientIP"] as! String
            }
            if dict.keys.contains("Codec") && dict["Codec"] != nil {
                self.codec = dict["Codec"] as! String
            }
            if dict.keys.contains("DecodeStuckTime") && dict["DecodeStuckTime"] != nil {
                self.decodeStuckTime = dict["DecodeStuckTime"] as! String
            }
            if dict.keys.contains("Definition") && dict["Definition"] != nil {
                self.definition = dict["Definition"] as! String
            }
            if dict.keys.contains("FirstFrameDuration") && dict["FirstFrameDuration"] != nil {
                self.firstFrameDuration = dict["FirstFrameDuration"] as! String
            }
            if dict.keys.contains("Fps") && dict["Fps"] != nil {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("IsHardDecode") && dict["IsHardDecode"] != nil {
                self.isHardDecode = dict["IsHardDecode"] as! String
            }
            if dict.keys.contains("Mdat") && dict["Mdat"] != nil {
                self.mdat = dict["Mdat"] as! String
            }
            if dict.keys.contains("Moov") && dict["Moov"] != nil {
                self.moov = dict["Moov"] as! String
            }
            if dict.keys.contains("Network") && dict["Network"] != nil {
                self.network = dict["Network"] as! String
            }
            if dict.keys.contains("NetworkDuration") && dict["NetworkDuration"] != nil {
                self.networkDuration = dict["NetworkDuration"] as! String
            }
            if dict.keys.contains("NetworkStuckTime") && dict["NetworkStuckTime"] != nil {
                self.networkStuckTime = dict["NetworkStuckTime"] as! String
            }
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("PlayTs") && dict["PlayTs"] != nil {
                self.playTs = dict["PlayTs"] as! String
            }
            if dict.keys.contains("PlayerLoadDuration") && dict["PlayerLoadDuration"] != nil {
                self.playerLoadDuration = dict["PlayerLoadDuration"] as! String
            }
            if dict.keys.contains("PlayerPreDealDuration") && dict["PlayerPreDealDuration"] != nil {
                self.playerPreDealDuration = dict["PlayerPreDealDuration"] as! String
            }
            if dict.keys.contains("PlayerReadyDuration") && dict["PlayerReadyDuration"] != nil {
                self.playerReadyDuration = dict["PlayerReadyDuration"] as! String
            }
            if dict.keys.contains("SdkVersion") && dict["SdkVersion"] != nil {
                self.sdkVersion = dict["SdkVersion"] as! String
            }
            if dict.keys.contains("SessionId") && dict["SessionId"] != nil {
                self.sessionId = dict["SessionId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TerminalType") && dict["TerminalType"] != nil {
                self.terminalType = dict["TerminalType"] as! String
            }
        }
    }
    public var baseInfos: [DescribePlayDetailResponseBody.BaseInfos]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseInfos != nil {
            var tmp : [Any] = []
            for k in self.baseInfos! {
                tmp.append(k.toMap())
            }
            map["BaseInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseInfos") && dict["BaseInfos"] != nil {
            var tmp : [DescribePlayDetailResponseBody.BaseInfos] = []
            for v in dict["BaseInfos"] as! [Any] {
                var model = DescribePlayDetailResponseBody.BaseInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.baseInfos = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePlayDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePlayDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayEventListRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var playTs: String?

    public var sessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playTs != nil {
            map["PlayTs"] = self.playTs!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PlayTs") && dict["PlayTs"] != nil {
            self.playTs = dict["PlayTs"] as! String
        }
        if dict.keys.contains("SessionId") && dict["SessionId"] != nil {
            self.sessionId = dict["SessionId"] as! String
        }
    }
}

public class DescribePlayEventListResponseBody : Tea.TeaModel {
    public class EventList : Tea.TeaModel {
        public var description_: String?

        public var duration: Double?

        public var eventName: String?

        public var time: Int64?

        public var topic: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.eventName != nil {
                map["EventName"] = self.eventName!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("EventName") && dict["EventName"] != nil {
                self.eventName = dict["EventName"] as! String
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! Int64
            }
            if dict.keys.contains("Topic") && dict["Topic"] != nil {
                self.topic = dict["Topic"] as! String
            }
        }
    }
    public var eventList: [DescribePlayEventListResponseBody.EventList]?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventList != nil {
            var tmp : [Any] = []
            for k in self.eventList! {
                tmp.append(k.toMap())
            }
            map["EventList"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventList") && dict["EventList"] != nil {
            var tmp : [DescribePlayEventListResponseBody.EventList] = []
            for v in dict["EventList"] as! [Any] {
                var model = DescribePlayEventListResponseBody.EventList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.eventList = tmp
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePlayEventListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayEventListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePlayEventListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayFirstFrameDurationMetricDataRequest : Tea.TeaModel {
    public var beginTs: String?

    public var endTs: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTs") && dict["BeginTs"] != nil {
            self.beginTs = dict["BeginTs"] as! String
        }
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! String
        }
        if dict.keys.contains("TraceId") && dict["TraceId"] != nil {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribePlayFirstFrameDurationMetricDataResponseBody : Tea.TeaModel {
    public class Nodes : Tea.TeaModel {
        public var x: Int64?

        public var y: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.x != nil {
                map["X"] = self.x!
            }
            if self.y != nil {
                map["Y"] = self.y!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X") && dict["X"] != nil {
                self.x = dict["X"] as! Int64
            }
            if dict.keys.contains("Y") && dict["Y"] != nil {
                self.y = dict["Y"] as! Int64
            }
        }
    }
    public var nodes: [DescribePlayFirstFrameDurationMetricDataResponseBody.Nodes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["Nodes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Nodes") && dict["Nodes"] != nil {
            var tmp : [DescribePlayFirstFrameDurationMetricDataResponseBody.Nodes] = []
            for v in dict["Nodes"] as! [Any] {
                var model = DescribePlayFirstFrameDurationMetricDataResponseBody.Nodes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nodes = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePlayFirstFrameDurationMetricDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayFirstFrameDurationMetricDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePlayFirstFrameDurationMetricDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayListRequest : Tea.TeaModel {
    public var beginTs: String?

    public var endTs: String?

    public var orderName: String?

    public var orderType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var playType: String?

    public var status: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playType != nil {
            map["PlayType"] = self.playType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTs") && dict["BeginTs"] != nil {
            self.beginTs = dict["BeginTs"] as! String
        }
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! String
        }
        if dict.keys.contains("OrderName") && dict["OrderName"] != nil {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") && dict["OrderType"] != nil {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PlayType") && dict["PlayType"] != nil {
            self.playType = dict["PlayType"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TraceId") && dict["TraceId"] != nil {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribePlayListResponseBody : Tea.TeaModel {
    public class PlayList : Tea.TeaModel {
        public var firstFrameDuration: String?

        public var playDuration: String?

        public var playTs: String?

        public var playType: String?

        public var sessionId: String?

        public var status: String?

        public var stuckDuration: String?

        public var traceId: String?

        public var videoDuration: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.firstFrameDuration != nil {
                map["FirstFrameDuration"] = self.firstFrameDuration!
            }
            if self.playDuration != nil {
                map["PlayDuration"] = self.playDuration!
            }
            if self.playTs != nil {
                map["PlayTs"] = self.playTs!
            }
            if self.playType != nil {
                map["PlayType"] = self.playType!
            }
            if self.sessionId != nil {
                map["SessionId"] = self.sessionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stuckDuration != nil {
                map["StuckDuration"] = self.stuckDuration!
            }
            if self.traceId != nil {
                map["TraceId"] = self.traceId!
            }
            if self.videoDuration != nil {
                map["VideoDuration"] = self.videoDuration!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FirstFrameDuration") && dict["FirstFrameDuration"] != nil {
                self.firstFrameDuration = dict["FirstFrameDuration"] as! String
            }
            if dict.keys.contains("PlayDuration") && dict["PlayDuration"] != nil {
                self.playDuration = dict["PlayDuration"] as! String
            }
            if dict.keys.contains("PlayTs") && dict["PlayTs"] != nil {
                self.playTs = dict["PlayTs"] as! String
            }
            if dict.keys.contains("PlayType") && dict["PlayType"] != nil {
                self.playType = dict["PlayType"] as! String
            }
            if dict.keys.contains("SessionId") && dict["SessionId"] != nil {
                self.sessionId = dict["SessionId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StuckDuration") && dict["StuckDuration"] != nil {
                self.stuckDuration = dict["StuckDuration"] as! String
            }
            if dict.keys.contains("TraceId") && dict["TraceId"] != nil {
                self.traceId = dict["TraceId"] as! String
            }
            if dict.keys.contains("VideoDuration") && dict["VideoDuration"] != nil {
                self.videoDuration = dict["VideoDuration"] as! String
            }
            if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var pageNum: Int64?

    public var pageSize: Int64?

    public var playList: [DescribePlayListResponseBody.PlayList]?

    public var requestId: String?

    public var totalNum: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playList != nil {
            var tmp : [Any] = []
            for k in self.playList! {
                tmp.append(k.toMap())
            }
            map["PlayList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PlayList") && dict["PlayList"] != nil {
            var tmp : [DescribePlayListResponseBody.PlayList] = []
            for v in dict["PlayList"] as! [Any] {
                var model = DescribePlayListResponseBody.PlayList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.playList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalNum") && dict["TotalNum"] != nil {
            self.totalNum = dict["TotalNum"] as! Int64
        }
    }
}

public class DescribePlayListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePlayListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayMetricDataRequest : Tea.TeaModel {
    public var appName: String?

    public var beginTs: Int64?

    public var definition: String?

    public var endTs: Int64?

    public var experienceLevel: String?

    public var itemConfigs: String?

    public var metricType: String?

    public var network: String?

    public var os: String?

    public var sdkVersion: String?

    public var terminalType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.experienceLevel != nil {
            map["ExperienceLevel"] = self.experienceLevel!
        }
        if self.itemConfigs != nil {
            map["ItemConfigs"] = self.itemConfigs!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.network != nil {
            map["Network"] = self.network!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.sdkVersion != nil {
            map["SdkVersion"] = self.sdkVersion!
        }
        if self.terminalType != nil {
            map["TerminalType"] = self.terminalType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BeginTs") && dict["BeginTs"] != nil {
            self.beginTs = dict["BeginTs"] as! Int64
        }
        if dict.keys.contains("Definition") && dict["Definition"] != nil {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("ExperienceLevel") && dict["ExperienceLevel"] != nil {
            self.experienceLevel = dict["ExperienceLevel"] as! String
        }
        if dict.keys.contains("ItemConfigs") && dict["ItemConfigs"] != nil {
            self.itemConfigs = dict["ItemConfigs"] as! String
        }
        if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Network") && dict["Network"] != nil {
            self.network = dict["Network"] as! String
        }
        if dict.keys.contains("Os") && dict["Os"] != nil {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("SdkVersion") && dict["SdkVersion"] != nil {
            self.sdkVersion = dict["SdkVersion"] as! String
        }
        if dict.keys.contains("TerminalType") && dict["TerminalType"] != nil {
            self.terminalType = dict["TerminalType"] as! String
        }
    }
}

public class DescribePlayMetricDataResponseBody : Tea.TeaModel {
    public class Nodes : Tea.TeaModel {
        public var x: String?

        public var y: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.x != nil {
                map["X"] = self.x!
            }
            if self.y != nil {
                map["Y"] = self.y!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X") && dict["X"] != nil {
                self.x = dict["X"] as! String
            }
            if dict.keys.contains("Y") && dict["Y"] != nil {
                self.y = dict["Y"] as! String
            }
        }
    }
    public var nodes: [DescribePlayMetricDataResponseBody.Nodes]?

    public var requestId: String?

    public var summaryData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["Nodes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.summaryData != nil {
            map["SummaryData"] = self.summaryData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Nodes") && dict["Nodes"] != nil {
            var tmp : [DescribePlayMetricDataResponseBody.Nodes] = []
            for v in dict["Nodes"] as! [Any] {
                var model = DescribePlayMetricDataResponseBody.Nodes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nodes = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SummaryData") && dict["SummaryData"] != nil {
            self.summaryData = dict["SummaryData"] as! String
        }
    }
}

public class DescribePlayMetricDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayMetricDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePlayMetricDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayQoeListRequest : Tea.TeaModel {
    public var appName: String?

    public var beginTs: Int64?

    public var definition: String?

    public var endTs: Int64?

    public var itemConfigs: String?

    public var metricTypes: [String]?

    public var network: String?

    public var orderName: String?

    public var orderType: String?

    public var os: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var terminalType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.itemConfigs != nil {
            map["ItemConfigs"] = self.itemConfigs!
        }
        if self.metricTypes != nil {
            map["MetricTypes"] = self.metricTypes!
        }
        if self.network != nil {
            map["Network"] = self.network!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.terminalType != nil {
            map["TerminalType"] = self.terminalType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BeginTs") && dict["BeginTs"] != nil {
            self.beginTs = dict["BeginTs"] as! Int64
        }
        if dict.keys.contains("Definition") && dict["Definition"] != nil {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("ItemConfigs") && dict["ItemConfigs"] != nil {
            self.itemConfigs = dict["ItemConfigs"] as! String
        }
        if dict.keys.contains("MetricTypes") && dict["MetricTypes"] != nil {
            self.metricTypes = dict["MetricTypes"] as! [String]
        }
        if dict.keys.contains("Network") && dict["Network"] != nil {
            self.network = dict["Network"] as! String
        }
        if dict.keys.contains("OrderName") && dict["OrderName"] != nil {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") && dict["OrderType"] != nil {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Os") && dict["Os"] != nil {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TerminalType") && dict["TerminalType"] != nil {
            self.terminalType = dict["TerminalType"] as! String
        }
    }
}

public class DescribePlayQoeListShrinkRequest : Tea.TeaModel {
    public var appName: String?

    public var beginTs: Int64?

    public var definition: String?

    public var endTs: Int64?

    public var itemConfigs: String?

    public var metricTypesShrink: String?

    public var network: String?

    public var orderName: String?

    public var orderType: String?

    public var os: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var terminalType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.itemConfigs != nil {
            map["ItemConfigs"] = self.itemConfigs!
        }
        if self.metricTypesShrink != nil {
            map["MetricTypes"] = self.metricTypesShrink!
        }
        if self.network != nil {
            map["Network"] = self.network!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.terminalType != nil {
            map["TerminalType"] = self.terminalType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BeginTs") && dict["BeginTs"] != nil {
            self.beginTs = dict["BeginTs"] as! Int64
        }
        if dict.keys.contains("Definition") && dict["Definition"] != nil {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("ItemConfigs") && dict["ItemConfigs"] != nil {
            self.itemConfigs = dict["ItemConfigs"] as! String
        }
        if dict.keys.contains("MetricTypes") && dict["MetricTypes"] != nil {
            self.metricTypesShrink = dict["MetricTypes"] as! String
        }
        if dict.keys.contains("Network") && dict["Network"] != nil {
            self.network = dict["Network"] as! String
        }
        if dict.keys.contains("OrderName") && dict["OrderName"] != nil {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") && dict["OrderType"] != nil {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Os") && dict["Os"] != nil {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TerminalType") && dict["TerminalType"] != nil {
            self.terminalType = dict["TerminalType"] as! String
        }
    }
}

public class DescribePlayQoeListResponseBody : Tea.TeaModel {
    public class QoeInfoList : Tea.TeaModel {
        public var qoeFinishedVV: Double?

        public var qoeFinishedVVRate: Double?

        public var qoeUFinishedVVTime: Double?

        public var qoeUV: Double?

        public var qoeUVVDuration: Double?

        public var qoeUVVTime: Double?

        public var qoeVDuration: Double?

        public var qoeVVDuration: Double?

        public var traceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.qoeFinishedVV != nil {
                map["QoeFinishedVV"] = self.qoeFinishedVV!
            }
            if self.qoeFinishedVVRate != nil {
                map["QoeFinishedVVRate"] = self.qoeFinishedVVRate!
            }
            if self.qoeUFinishedVVTime != nil {
                map["QoeUFinishedVVTime"] = self.qoeUFinishedVVTime!
            }
            if self.qoeUV != nil {
                map["QoeUV"] = self.qoeUV!
            }
            if self.qoeUVVDuration != nil {
                map["QoeUVVDuration"] = self.qoeUVVDuration!
            }
            if self.qoeUVVTime != nil {
                map["QoeUVVTime"] = self.qoeUVVTime!
            }
            if self.qoeVDuration != nil {
                map["QoeVDuration"] = self.qoeVDuration!
            }
            if self.qoeVVDuration != nil {
                map["QoeVVDuration"] = self.qoeVVDuration!
            }
            if self.traceId != nil {
                map["TraceId"] = self.traceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("QoeFinishedVV") && dict["QoeFinishedVV"] != nil {
                self.qoeFinishedVV = dict["QoeFinishedVV"] as! Double
            }
            if dict.keys.contains("QoeFinishedVVRate") && dict["QoeFinishedVVRate"] != nil {
                self.qoeFinishedVVRate = dict["QoeFinishedVVRate"] as! Double
            }
            if dict.keys.contains("QoeUFinishedVVTime") && dict["QoeUFinishedVVTime"] != nil {
                self.qoeUFinishedVVTime = dict["QoeUFinishedVVTime"] as! Double
            }
            if dict.keys.contains("QoeUV") && dict["QoeUV"] != nil {
                self.qoeUV = dict["QoeUV"] as! Double
            }
            if dict.keys.contains("QoeUVVDuration") && dict["QoeUVVDuration"] != nil {
                self.qoeUVVDuration = dict["QoeUVVDuration"] as! Double
            }
            if dict.keys.contains("QoeUVVTime") && dict["QoeUVVTime"] != nil {
                self.qoeUVVTime = dict["QoeUVVTime"] as! Double
            }
            if dict.keys.contains("QoeVDuration") && dict["QoeVDuration"] != nil {
                self.qoeVDuration = dict["QoeVDuration"] as! Double
            }
            if dict.keys.contains("QoeVVDuration") && dict["QoeVVDuration"] != nil {
                self.qoeVVDuration = dict["QoeVVDuration"] as! Double
            }
            if dict.keys.contains("TraceId") && dict["TraceId"] != nil {
                self.traceId = dict["TraceId"] as! String
            }
        }
    }
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var qoeInfoList: [DescribePlayQoeListResponseBody.QoeInfoList]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.qoeInfoList != nil {
            var tmp : [Any] = []
            for k in self.qoeInfoList! {
                tmp.append(k.toMap())
            }
            map["QoeInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("QoeInfoList") && dict["QoeInfoList"] != nil {
            var tmp : [DescribePlayQoeListResponseBody.QoeInfoList] = []
            for v in dict["QoeInfoList"] as! [Any] {
                var model = DescribePlayQoeListResponseBody.QoeInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.qoeInfoList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePlayQoeListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayQoeListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePlayQoeListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayQosListRequest : Tea.TeaModel {
    public var appName: String?

    public var beginTs: String?

    public var definition: String?

    public var endTs: String?

    public var itemConfigs: String?

    public var metricTypes: [String]?

    public var network: String?

    public var orderName: String?

    public var orderType: String?

    public var os: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var terminalType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.itemConfigs != nil {
            map["ItemConfigs"] = self.itemConfigs!
        }
        if self.metricTypes != nil {
            map["MetricTypes"] = self.metricTypes!
        }
        if self.network != nil {
            map["Network"] = self.network!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.terminalType != nil {
            map["TerminalType"] = self.terminalType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BeginTs") && dict["BeginTs"] != nil {
            self.beginTs = dict["BeginTs"] as! String
        }
        if dict.keys.contains("Definition") && dict["Definition"] != nil {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! String
        }
        if dict.keys.contains("ItemConfigs") && dict["ItemConfigs"] != nil {
            self.itemConfigs = dict["ItemConfigs"] as! String
        }
        if dict.keys.contains("MetricTypes") && dict["MetricTypes"] != nil {
            self.metricTypes = dict["MetricTypes"] as! [String]
        }
        if dict.keys.contains("Network") && dict["Network"] != nil {
            self.network = dict["Network"] as! String
        }
        if dict.keys.contains("OrderName") && dict["OrderName"] != nil {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") && dict["OrderType"] != nil {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Os") && dict["Os"] != nil {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TerminalType") && dict["TerminalType"] != nil {
            self.terminalType = dict["TerminalType"] as! String
        }
    }
}

public class DescribePlayQosListShrinkRequest : Tea.TeaModel {
    public var appName: String?

    public var beginTs: String?

    public var definition: String?

    public var endTs: String?

    public var itemConfigs: String?

    public var metricTypesShrink: String?

    public var network: String?

    public var orderName: String?

    public var orderType: String?

    public var os: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var terminalType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.itemConfigs != nil {
            map["ItemConfigs"] = self.itemConfigs!
        }
        if self.metricTypesShrink != nil {
            map["MetricTypes"] = self.metricTypesShrink!
        }
        if self.network != nil {
            map["Network"] = self.network!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.terminalType != nil {
            map["TerminalType"] = self.terminalType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BeginTs") && dict["BeginTs"] != nil {
            self.beginTs = dict["BeginTs"] as! String
        }
        if dict.keys.contains("Definition") && dict["Definition"] != nil {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! String
        }
        if dict.keys.contains("ItemConfigs") && dict["ItemConfigs"] != nil {
            self.itemConfigs = dict["ItemConfigs"] as! String
        }
        if dict.keys.contains("MetricTypes") && dict["MetricTypes"] != nil {
            self.metricTypesShrink = dict["MetricTypes"] as! String
        }
        if dict.keys.contains("Network") && dict["Network"] != nil {
            self.network = dict["Network"] as! String
        }
        if dict.keys.contains("OrderName") && dict["OrderName"] != nil {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") && dict["OrderType"] != nil {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Os") && dict["Os"] != nil {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TerminalType") && dict["TerminalType"] != nil {
            self.terminalType = dict["TerminalType"] as! String
        }
    }
}

public class DescribePlayQosListResponseBody : Tea.TeaModel {
    public class QosInfoList : Tea.TeaModel {
        public var qosFirstFrame: String?

        public var qosKbps: String?

        public var qosPlay: String?

        public var qosPlayFail: String?

        public var qosRealPlay: String?

        public var qosSeedFailRate: String?

        public var qosStuckRate: String?

        public var traceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.qosFirstFrame != nil {
                map["QosFirstFrame"] = self.qosFirstFrame!
            }
            if self.qosKbps != nil {
                map["QosKbps"] = self.qosKbps!
            }
            if self.qosPlay != nil {
                map["QosPlay"] = self.qosPlay!
            }
            if self.qosPlayFail != nil {
                map["QosPlayFail"] = self.qosPlayFail!
            }
            if self.qosRealPlay != nil {
                map["QosRealPlay"] = self.qosRealPlay!
            }
            if self.qosSeedFailRate != nil {
                map["QosSeedFailRate"] = self.qosSeedFailRate!
            }
            if self.qosStuckRate != nil {
                map["QosStuckRate"] = self.qosStuckRate!
            }
            if self.traceId != nil {
                map["TraceId"] = self.traceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("QosFirstFrame") && dict["QosFirstFrame"] != nil {
                self.qosFirstFrame = dict["QosFirstFrame"] as! String
            }
            if dict.keys.contains("QosKbps") && dict["QosKbps"] != nil {
                self.qosKbps = dict["QosKbps"] as! String
            }
            if dict.keys.contains("QosPlay") && dict["QosPlay"] != nil {
                self.qosPlay = dict["QosPlay"] as! String
            }
            if dict.keys.contains("QosPlayFail") && dict["QosPlayFail"] != nil {
                self.qosPlayFail = dict["QosPlayFail"] as! String
            }
            if dict.keys.contains("QosRealPlay") && dict["QosRealPlay"] != nil {
                self.qosRealPlay = dict["QosRealPlay"] as! String
            }
            if dict.keys.contains("QosSeedFailRate") && dict["QosSeedFailRate"] != nil {
                self.qosSeedFailRate = dict["QosSeedFailRate"] as! String
            }
            if dict.keys.contains("QosStuckRate") && dict["QosStuckRate"] != nil {
                self.qosStuckRate = dict["QosStuckRate"] as! String
            }
            if dict.keys.contains("TraceId") && dict["TraceId"] != nil {
                self.traceId = dict["TraceId"] as! String
            }
        }
    }
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var qosInfoList: [DescribePlayQosListResponseBody.QosInfoList]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.qosInfoList != nil {
            var tmp : [Any] = []
            for k in self.qosInfoList! {
                tmp.append(k.toMap())
            }
            map["QosInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("QosInfoList") && dict["QosInfoList"] != nil {
            var tmp : [DescribePlayQosListResponseBody.QosInfoList] = []
            for v in dict["QosInfoList"] as! [Any] {
                var model = DescribePlayQosListResponseBody.QosInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.qosInfoList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePlayQosListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayQosListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePlayQosListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeQueryConfigsRequest : Tea.TeaModel {
    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeQueryConfigsResponseBody : Tea.TeaModel {
    public class Configs : Tea.TeaModel {
        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var configs: [DescribeQueryConfigsResponseBody.Configs]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configs != nil {
            var tmp : [Any] = []
            for k in self.configs! {
                tmp.append(k.toMap())
            }
            map["Configs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Configs") && dict["Configs"] != nil {
            var tmp : [DescribeQueryConfigsResponseBody.Configs] = []
            for v in dict["Configs"] as! [Any] {
                var model = DescribeQueryConfigsResponseBody.Configs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configs = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeQueryConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeQueryConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeQueryConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCategoriesRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") && dict["CateId"] != nil {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetCategoriesResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: Int64?

        public var cateName: String?

        public var level: Int64?

        public var parentId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") && dict["CateId"] != nil {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") && dict["CateName"] != nil {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SubCategories : Tea.TeaModel {
        public class Category : Tea.TeaModel {
            public var cateId: Int64?

            public var cateName: String?

            public var level: Int64?

            public var parentId: Int64?

            public var subTotal: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.subTotal != nil {
                    map["SubTotal"] = self.subTotal!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CateId") && dict["CateId"] != nil {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") && dict["CateName"] != nil {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! Int64
                }
                if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                    self.parentId = dict["ParentId"] as! Int64
                }
                if dict.keys.contains("SubTotal") && dict["SubTotal"] != nil {
                    self.subTotal = dict["SubTotal"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var category: [GetCategoriesResponseBody.SubCategories.Category]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                var tmp : [Any] = []
                for k in self.category! {
                    tmp.append(k.toMap())
                }
                map["Category"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                var tmp : [GetCategoriesResponseBody.SubCategories.Category] = []
                for v in dict["Category"] as! [Any] {
                    var model = GetCategoriesResponseBody.SubCategories.Category()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.category = tmp
            }
        }
    }
    public var category: GetCategoriesResponseBody.Category?

    public var requestId: String?

    public var subCategories: GetCategoriesResponseBody.SubCategories?

    public var subTotal: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
        try self.subCategories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCategories != nil {
            map["SubCategories"] = self.subCategories?.toMap()
        }
        if self.subTotal != nil {
            map["SubTotal"] = self.subTotal!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            var model = GetCategoriesResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCategories") && dict["SubCategories"] != nil {
            var model = GetCategoriesResponseBody.SubCategories()
            model.fromMap(dict["SubCategories"] as! [String: Any])
            self.subCategories = model
        }
        if dict.keys.contains("SubTotal") && dict["SubTotal"] != nil {
            self.subTotal = dict["SubTotal"] as! Int64
        }
    }
}

public class GetCategoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCategoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCategoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetContentAnalyzeConfigResponseBody : Tea.TeaModel {
    public class ContentAnalyzeConfig : Tea.TeaModel {
        public var auto: Bool?

        public var saveType: String?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auto != nil {
                map["Auto"] = self.auto!
            }
            if self.saveType != nil {
                map["SaveType"] = self.saveType!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Auto") && dict["Auto"] != nil {
                self.auto = dict["Auto"] as! Bool
            }
            if dict.keys.contains("SaveType") && dict["SaveType"] != nil {
                self.saveType = dict["SaveType"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var contentAnalyzeConfig: GetContentAnalyzeConfigResponseBody.ContentAnalyzeConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.contentAnalyzeConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentAnalyzeConfig != nil {
            map["ContentAnalyzeConfig"] = self.contentAnalyzeConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContentAnalyzeConfig") && dict["ContentAnalyzeConfig"] != nil {
            var model = GetContentAnalyzeConfigResponseBody.ContentAnalyzeConfig()
            model.fromMap(dict["ContentAnalyzeConfig"] as! [String: Any])
            self.contentAnalyzeConfig = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetContentAnalyzeConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetContentAnalyzeConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetContentAnalyzeConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCustomTemplateRequest : Tea.TeaModel {
    public var subtype: Int32?

    public var templateId: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Subtype") && dict["Subtype"] != nil {
            self.subtype = dict["Subtype"] as! Int32
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class GetCustomTemplateResponseBody : Tea.TeaModel {
    public class CustomTemplate : Tea.TeaModel {
        public var createTime: String?

        public var isDefault: Bool?

        public var modifiedTime: String?

        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") && dict["Subtype"] != nil {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") && dict["SubtypeName"] != nil {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var customTemplate: GetCustomTemplateResponseBody.CustomTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplate != nil {
            map["CustomTemplate"] = self.customTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplate") && dict["CustomTemplate"] != nil {
            var model = GetCustomTemplateResponseBody.CustomTemplate()
            model.fromMap(dict["CustomTemplate"] as! [String: Any])
            self.customTemplate = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDefaultStorageLocationResponseBody : Tea.TeaModel {
    public var bucket: String?

    public var path: String?

    public var requestId: String?

    public var status: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StorageType") && dict["StorageType"] != nil {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class GetDefaultStorageLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDefaultStorageLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDefaultStorageLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDynamicImageJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetDynamicImageJobResponseBody : Tea.TeaModel {
    public class DynamicImageJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") && dict["Object"] != nil {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetDynamicImageJobResponseBody.DynamicImageJob.Input.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") && dict["OssFile"] != nil {
                    var model = GetDynamicImageJobResponseBody.DynamicImageJob.Input.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") && dict["Object"] != nil {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetDynamicImageJobResponseBody.DynamicImageJob.Output.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") && dict["OssFile"] != nil {
                    var model = GetDynamicImageJobResponseBody.DynamicImageJob.Output.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var code: String?

        public var createTime: String?

        public var finishTime: String?

        public var input: GetDynamicImageJobResponseBody.DynamicImageJob.Input?

        public var jobId: String?

        public var message: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: GetDynamicImageJobResponseBody.DynamicImageJob.Output?

        public var outputUrl: String?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateConfig: String?

        public var templateId: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.outputUrl != nil {
                map["OutputUrl"] = self.outputUrl!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") && dict["Input"] != nil {
                var model = GetDynamicImageJobResponseBody.DynamicImageJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") && dict["Output"] != nil {
                var model = GetDynamicImageJobResponseBody.DynamicImageJob.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("OutputUrl") && dict["OutputUrl"] != nil {
                self.outputUrl = dict["OutputUrl"] as! String
            }
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var dynamicImageJob: GetDynamicImageJobResponseBody.DynamicImageJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dynamicImageJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicImageJob != nil {
            map["DynamicImageJob"] = self.dynamicImageJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicImageJob") && dict["DynamicImageJob"] != nil {
            var model = GetDynamicImageJobResponseBody.DynamicImageJob()
            model.fromMap(dict["DynamicImageJob"] as! [String: Any])
            self.dynamicImageJob = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDynamicImageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDynamicImageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDynamicImageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingProjectRequest : Tea.TeaModel {
    public var projectId: String?

    public var requestSource: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestSource != nil {
            map["RequestSource"] = self.requestSource!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestSource") && dict["RequestSource"] != nil {
            self.requestSource = dict["RequestSource"] as! String
        }
    }
}

public class GetEditingProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var clipsParam: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var duration: Int64?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: String?

        public var templateId: String?

        public var templateType: String?

        public var timeline: String?

        public var timelineConvertErrorMessage: String?

        public var timelineConvertStatus: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.timelineConvertErrorMessage != nil {
                map["TimelineConvertErrorMessage"] = self.timelineConvertErrorMessage!
            }
            if self.timelineConvertStatus != nil {
                map["TimelineConvertStatus"] = self.timelineConvertStatus!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") && dict["BusinessConfig"] != nil {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") && dict["BusinessStatus"] != nil {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("ClipsParam") && dict["ClipsParam"] != nil {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") && dict["CreateSource"] != nil {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("ModifiedSource") && dict["ModifiedSource"] != nil {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") && dict["ProjectType"] != nil {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("TimelineConvertErrorMessage") && dict["TimelineConvertErrorMessage"] != nil {
                self.timelineConvertErrorMessage = dict["TimelineConvertErrorMessage"] as! String
            }
            if dict.keys.contains("TimelineConvertStatus") && dict["TimelineConvertStatus"] != nil {
                self.timelineConvertStatus = dict["TimelineConvertStatus"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var project: GetEditingProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") && dict["Project"] != nil {
            var model = GetEditingProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingProjectMaterialsRequest : Tea.TeaModel {
    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class GetEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public class LiveMaterials : Tea.TeaModel {
        public var appName: String?

        public var domainName: String?

        public var liveUrl: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.liveUrl != nil {
                map["LiveUrl"] = self.liveUrl!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("LiveUrl") && dict["LiveUrl"] != nil {
                self.liveUrl = dict["LiveUrl"] as! String
            }
            if dict.keys.contains("StreamName") && dict["StreamName"] != nil {
                self.streamName = dict["StreamName"] as! String
            }
        }
    }
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") && dict["FileType"] != nil {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") && dict["Region"] != nil {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                    var model = GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") && dict["DeletedTime"] != nil {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") && dict["InputURL"] != nil {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") && dict["MediaTags"] != nil {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") && dict["SpriteImages"] != nil {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") && dict["TranscodeStatus"] != nil {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") && dict["UserData"] != nil {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: GetEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") && dict["FileInfoList"] != nil {
                var tmp : [GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") && dict["MediaBasicInfo"] != nil {
                var model = GetEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var liveMaterials: [GetEditingProjectMaterialsResponseBody.LiveMaterials]?

    public var mediaInfos: [GetEditingProjectMaterialsResponseBody.MediaInfos]?

    public var projectId: String?

    public var projectMaterials: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveMaterials != nil {
            var tmp : [Any] = []
            for k in self.liveMaterials! {
                tmp.append(k.toMap())
            }
            map["LiveMaterials"] = tmp
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectMaterials != nil {
            map["ProjectMaterials"] = self.projectMaterials!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveMaterials") && dict["LiveMaterials"] != nil {
            var tmp : [GetEditingProjectMaterialsResponseBody.LiveMaterials] = []
            for v in dict["LiveMaterials"] as! [Any] {
                var model = GetEditingProjectMaterialsResponseBody.LiveMaterials()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.liveMaterials = tmp
        }
        if dict.keys.contains("MediaInfos") && dict["MediaInfos"] != nil {
            var tmp : [GetEditingProjectMaterialsResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = GetEditingProjectMaterialsResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectMaterials") && dict["ProjectMaterials"] != nil {
            self.projectMaterials = dict["ProjectMaterials"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEventCallbackResponseBody : Tea.TeaModel {
    public var authKey: String?

    public var authSwitch: String?

    public var callbackQueueName: String?

    public var callbackType: String?

    public var callbackURL: String?

    public var eventTypeList: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.authSwitch != nil {
            map["AuthSwitch"] = self.authSwitch!
        }
        if self.callbackQueueName != nil {
            map["CallbackQueueName"] = self.callbackQueueName!
        }
        if self.callbackType != nil {
            map["CallbackType"] = self.callbackType!
        }
        if self.callbackURL != nil {
            map["CallbackURL"] = self.callbackURL!
        }
        if self.eventTypeList != nil {
            map["EventTypeList"] = self.eventTypeList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthKey") && dict["AuthKey"] != nil {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("AuthSwitch") && dict["AuthSwitch"] != nil {
            self.authSwitch = dict["AuthSwitch"] as! String
        }
        if dict.keys.contains("CallbackQueueName") && dict["CallbackQueueName"] != nil {
            self.callbackQueueName = dict["CallbackQueueName"] as! String
        }
        if dict.keys.contains("CallbackType") && dict["CallbackType"] != nil {
            self.callbackType = dict["CallbackType"] as! String
        }
        if dict.keys.contains("CallbackURL") && dict["CallbackURL"] != nil {
            self.callbackURL = dict["CallbackURL"] as! String
        }
        if dict.keys.contains("EventTypeList") && dict["EventTypeList"] != nil {
            self.eventTypeList = dict["EventTypeList"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEventCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEventCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetEventCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveEditingIndexFileRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var projectId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("StreamName") && dict["StreamName"] != nil {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class GetLiveEditingIndexFileResponseBody : Tea.TeaModel {
    public var indexFile: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexFile != nil {
            map["IndexFile"] = self.indexFile!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndexFile") && dict["IndexFile"] != nil {
            self.indexFile = dict["IndexFile"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveEditingIndexFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveEditingIndexFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLiveEditingIndexFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveEditingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveEditingJobResponseBody : Tea.TeaModel {
    public class LiveEditingJob : Tea.TeaModel {
        public class LiveStreamConfig : Tea.TeaModel {
            public var appName: String?

            public var domainName: String?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("StreamName") && dict["StreamName"] != nil {
                    self.streamName = dict["StreamName"] as! String
                }
            }
        }
        public class MediaProduceConfig : Tea.TeaModel {
            public var mode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Mode") && dict["Mode"] != nil {
                    self.mode = dict["Mode"] as! String
                }
            }
        }
        public class OutputMediaConfig : Tea.TeaModel {
            public var bitrate: Int64?

            public var fileName: String?

            public var height: Int32?

            public var mediaURL: String?

            public var storageLocation: String?

            public var vodTemplateGroupId: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.mediaURL != nil {
                    map["MediaURL"] = self.mediaURL!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.vodTemplateGroupId != nil {
                    map["VodTemplateGroupId"] = self.vodTemplateGroupId!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                    self.bitrate = dict["Bitrate"] as! Int64
                }
                if dict.keys.contains("FileName") && dict["FileName"] != nil {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("Height") && dict["Height"] != nil {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("MediaURL") && dict["MediaURL"] != nil {
                    self.mediaURL = dict["MediaURL"] as! String
                }
                if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("VodTemplateGroupId") && dict["VodTemplateGroupId"] != nil {
                    self.vodTemplateGroupId = dict["VodTemplateGroupId"] as! String
                }
                if dict.keys.contains("Width") && dict["Width"] != nil {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var clips: String?

        public var code: String?

        public var completeTime: String?

        public var creationTime: String?

        public var jobId: String?

        public var liveStreamConfig: GetLiveEditingJobResponseBody.LiveEditingJob.LiveStreamConfig?

        public var mediaId: String?

        public var mediaProduceConfig: GetLiveEditingJobResponseBody.LiveEditingJob.MediaProduceConfig?

        public var mediaURL: String?

        public var message: String?

        public var modifiedTime: String?

        public var outputMediaConfig: GetLiveEditingJobResponseBody.LiveEditingJob.OutputMediaConfig?

        public var projectId: String?

        public var status: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.liveStreamConfig?.validate()
            try self.mediaProduceConfig?.validate()
            try self.outputMediaConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clips != nil {
                map["Clips"] = self.clips!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.liveStreamConfig != nil {
                map["LiveStreamConfig"] = self.liveStreamConfig?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaProduceConfig != nil {
                map["MediaProduceConfig"] = self.mediaProduceConfig?.toMap()
            }
            if self.mediaURL != nil {
                map["MediaURL"] = self.mediaURL!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputMediaConfig != nil {
                map["OutputMediaConfig"] = self.outputMediaConfig?.toMap()
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Clips") && dict["Clips"] != nil {
                self.clips = dict["Clips"] as! String
            }
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("LiveStreamConfig") && dict["LiveStreamConfig"] != nil {
                var model = GetLiveEditingJobResponseBody.LiveEditingJob.LiveStreamConfig()
                model.fromMap(dict["LiveStreamConfig"] as! [String: Any])
                self.liveStreamConfig = model
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaProduceConfig") && dict["MediaProduceConfig"] != nil {
                var model = GetLiveEditingJobResponseBody.LiveEditingJob.MediaProduceConfig()
                model.fromMap(dict["MediaProduceConfig"] as! [String: Any])
                self.mediaProduceConfig = model
            }
            if dict.keys.contains("MediaURL") && dict["MediaURL"] != nil {
                self.mediaURL = dict["MediaURL"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputMediaConfig") && dict["OutputMediaConfig"] != nil {
                var model = GetLiveEditingJobResponseBody.LiveEditingJob.OutputMediaConfig()
                model.fromMap(dict["OutputMediaConfig"] as! [String: Any])
                self.outputMediaConfig = model
            }
            if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var liveEditingJob: GetLiveEditingJobResponseBody.LiveEditingJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveEditingJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveEditingJob != nil {
            map["LiveEditingJob"] = self.liveEditingJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveEditingJob") && dict["LiveEditingJob"] != nil {
            var model = GetLiveEditingJobResponseBody.LiveEditingJob()
            model.fromMap(dict["LiveEditingJob"] as! [String: Any])
            self.liveEditingJob = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveEditingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveEditingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLiveEditingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveRecordJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveRecordJobResponseBody : Tea.TeaModel {
    public class RecordJob : Tea.TeaModel {
        public class RecordOutput : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var notifyUrl: String?

        public var recordOutput: GetLiveRecordJobResponseBody.RecordJob.RecordOutput?

        public var status: String?

        public var streamInput: GetLiveRecordJobResponseBody.RecordJob.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordOutput?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            if self.recordOutput != nil {
                map["RecordOutput"] = self.recordOutput?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyUrl") && dict["NotifyUrl"] != nil {
                self.notifyUrl = dict["NotifyUrl"] as! String
            }
            if dict.keys.contains("RecordOutput") && dict["RecordOutput"] != nil {
                var model = GetLiveRecordJobResponseBody.RecordJob.RecordOutput()
                model.fromMap(dict["RecordOutput"] as! [String: Any])
                self.recordOutput = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
                var model = GetLiveRecordJobResponseBody.RecordJob.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var recordJob: GetLiveRecordJobResponseBody.RecordJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordJob != nil {
            map["RecordJob"] = self.recordJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordJob") && dict["RecordJob"] != nil {
            var model = GetLiveRecordJobResponseBody.RecordJob()
            model.fromMap(dict["RecordJob"] as! [String: Any])
            self.recordJob = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveRecordJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveRecordJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLiveRecordJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveRecordTemplateRequest : Tea.TeaModel {
    public var jobId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetLiveRecordTemplateResponseBody : Tea.TeaModel {
    public class RecordTemplate : Tea.TeaModel {
        public class RecordFormatList : Tea.TeaModel {
            public var cycleDuration: Int32?

            public var format: String?

            public var ossObjectPrefix: String?

            public var sliceDuration: Int32?

            public var sliceOssObjectPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleDuration != nil {
                    map["CycleDuration"] = self.cycleDuration!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.ossObjectPrefix != nil {
                    map["OssObjectPrefix"] = self.ossObjectPrefix!
                }
                if self.sliceDuration != nil {
                    map["SliceDuration"] = self.sliceDuration!
                }
                if self.sliceOssObjectPrefix != nil {
                    map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CycleDuration") && dict["CycleDuration"] != nil {
                    self.cycleDuration = dict["CycleDuration"] as! Int32
                }
                if dict.keys.contains("Format") && dict["Format"] != nil {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("OssObjectPrefix") && dict["OssObjectPrefix"] != nil {
                    self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
                }
                if dict.keys.contains("SliceDuration") && dict["SliceDuration"] != nil {
                    self.sliceDuration = dict["SliceDuration"] as! Int32
                }
                if dict.keys.contains("SliceOssObjectPrefix") && dict["SliceOssObjectPrefix"] != nil {
                    self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
                }
            }
        }
        public var createTime: String?

        public var lastModified: String?

        public var name: String?

        public var recordFormatList: [GetLiveRecordTemplateResponseBody.RecordTemplate.RecordFormatList]?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordFormatList != nil {
                var tmp : [Any] = []
                for k in self.recordFormatList! {
                    tmp.append(k.toMap())
                }
                map["RecordFormatList"] = tmp
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModified") && dict["LastModified"] != nil {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordFormatList") && dict["RecordFormatList"] != nil {
                var tmp : [GetLiveRecordTemplateResponseBody.RecordTemplate.RecordFormatList] = []
                for v in dict["RecordFormatList"] as! [Any] {
                    var model = GetLiveRecordTemplateResponseBody.RecordTemplate.RecordFormatList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recordFormatList = tmp
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var recordTemplate: GetLiveRecordTemplateResponseBody.RecordTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordTemplate != nil {
            map["RecordTemplate"] = self.recordTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordTemplate") && dict["RecordTemplate"] != nil {
            var model = GetLiveRecordTemplateResponseBody.RecordTemplate()
            model.fromMap(dict["RecordTemplate"] as! [String: Any])
            self.recordTemplate = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveSnapshotJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveSnapshotJobResponseBody : Tea.TeaModel {
    public class SnapshotOutput : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("StorageType") && dict["StorageType"] != nil {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public class StreamInput : Tea.TeaModel {
        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var callbackUrl: String?

    public var createTime: String?

    public var jobId: String?

    public var jobName: String?

    public var lastModified: String?

    public var overwriteFormat: String?

    public var requestId: String?

    public var sequenceFormat: String?

    public var snapshotOutput: GetLiveSnapshotJobResponseBody.SnapshotOutput?

    public var status: String?

    public var streamInput: GetLiveSnapshotJobResponseBody.StreamInput?

    public var templateId: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotOutput?.validate()
        try self.streamInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.lastModified != nil {
            map["LastModified"] = self.lastModified!
        }
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.snapshotOutput != nil {
            map["SnapshotOutput"] = self.snapshotOutput?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") && dict["CallbackUrl"] != nil {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobName") && dict["JobName"] != nil {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("LastModified") && dict["LastModified"] != nil {
            self.lastModified = dict["LastModified"] as! String
        }
        if dict.keys.contains("OverwriteFormat") && dict["OverwriteFormat"] != nil {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SequenceFormat") && dict["SequenceFormat"] != nil {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("SnapshotOutput") && dict["SnapshotOutput"] != nil {
            var model = GetLiveSnapshotJobResponseBody.SnapshotOutput()
            model.fromMap(dict["SnapshotOutput"] as! [String: Any])
            self.snapshotOutput = model
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
            var model = GetLiveSnapshotJobResponseBody.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") && dict["TimeInterval"] != nil {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class GetLiveSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLiveSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var createTime: String?

    public var lastModified: String?

    public var overwriteFormat: String?

    public var requestId: String?

    public var sequenceFormat: String?

    public var templateId: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.lastModified != nil {
            map["LastModified"] = self.lastModified!
        }
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("LastModified") && dict["LastModified"] != nil {
            self.lastModified = dict["LastModified"] as! String
        }
        if dict.keys.contains("OverwriteFormat") && dict["OverwriteFormat"] != nil {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SequenceFormat") && dict["SequenceFormat"] != nil {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") && dict["TimeInterval"] != nil {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveTranscodeJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveTranscodeJobResponseBody : Tea.TeaModel {
    public class Job : Tea.TeaModel {
        public class OutputStream : Tea.TeaModel {
            public class StreamInfos : Tea.TeaModel {
                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OutputUrl") && dict["OutputUrl"] != nil {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var streamInfos: [GetLiveTranscodeJobResponseBody.Job.OutputStream.StreamInfos]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.streamInfos != nil {
                    var tmp : [Any] = []
                    for k in self.streamInfos! {
                        tmp.append(k.toMap())
                    }
                    map["StreamInfos"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("StreamInfos") && dict["StreamInfos"] != nil {
                    var tmp : [GetLiveTranscodeJobResponseBody.Job.OutputStream.StreamInfos] = []
                    for v in dict["StreamInfos"] as! [Any] {
                        var model = GetLiveTranscodeJobResponseBody.Job.OutputStream.StreamInfos()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.streamInfos = tmp
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var inputUrl: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputUrl") && dict["InputUrl"] != nil {
                    self.inputUrl = dict["InputUrl"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var outputStream: GetLiveTranscodeJobResponseBody.Job.OutputStream?

        public var startMode: Int32?

        public var status: Int32?

        public var streamInput: GetLiveTranscodeJobResponseBody.Job.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.outputStream?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputStream != nil {
                map["OutputStream"] = self.outputStream?.toMap()
            }
            if self.startMode != nil {
                map["StartMode"] = self.startMode!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputStream") && dict["OutputStream"] != nil {
                var model = GetLiveTranscodeJobResponseBody.Job.OutputStream()
                model.fromMap(dict["OutputStream"] as! [String: Any])
                self.outputStream = model
            }
            if dict.keys.contains("StartMode") && dict["StartMode"] != nil {
                self.startMode = dict["StartMode"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
                var model = GetLiveTranscodeJobResponseBody.Job.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var job: GetLiveTranscodeJobResponseBody.Job?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.job?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.job != nil {
            map["Job"] = self.job?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Job") && dict["Job"] != nil {
            var model = GetLiveTranscodeJobResponseBody.Job()
            model.fromMap(dict["Job"] as! [String: Any])
            self.job = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveTranscodeTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public class TemplateContent : Tea.TeaModel {
        public class TemplateConfig : Tea.TeaModel {
            public class AudioParams : Tea.TeaModel {
                public var bitrate: String?

                public var channels: String?

                public var codec: String?

                public var profile: String?

                public var samplerate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.samplerate != nil {
                        map["Samplerate"] = self.samplerate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Channels") && dict["Channels"] != nil {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("Codec") && dict["Codec"] != nil {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Profile") && dict["Profile"] != nil {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Samplerate") && dict["Samplerate"] != nil {
                        self.samplerate = dict["Samplerate"] as! String
                    }
                }
            }
            public class VideoParams : Tea.TeaModel {
                public var bitrate: String?

                public var codec: String?

                public var fps: String?

                public var gop: String?

                public var height: String?

                public var profile: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Codec") && dict["Codec"] != nil {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Fps") && dict["Fps"] != nil {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Gop") && dict["Gop"] != nil {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Profile") && dict["Profile"] != nil {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioParams: GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.AudioParams?

            public var videoParams: GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.VideoParams?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioParams?.validate()
                try self.videoParams?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioParams != nil {
                    map["AudioParams"] = self.audioParams?.toMap()
                }
                if self.videoParams != nil {
                    map["VideoParams"] = self.videoParams?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioParams") && dict["AudioParams"] != nil {
                    var model = GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.AudioParams()
                    model.fromMap(dict["AudioParams"] as! [String: Any])
                    self.audioParams = model
                }
                if dict.keys.contains("VideoParams") && dict["VideoParams"] != nil {
                    var model = GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.VideoParams()
                    model.fromMap(dict["VideoParams"] as! [String: Any])
                    self.videoParams = model
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var name: String?

        public var templateConfig: GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.templateConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                var model = GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig()
                model.fromMap(dict["TemplateConfig"] as! [String: Any])
                self.templateConfig = model
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateContent: GetLiveTranscodeTemplateResponseBody.TemplateContent?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateContent != nil {
            map["TemplateContent"] = self.templateContent?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateContent") && dict["TemplateContent"] != nil {
            var model = GetLiveTranscodeTemplateResponseBody.TemplateContent()
            model.fromMap(dict["TemplateContent"] as! [String: Any])
            self.templateContent = model
        }
    }
}

public class GetLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaInfoRequest : Tea.TeaModel {
    public var inputURL: String?

    public var mediaId: String?

    public var outputType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputURL") && dict["InputURL"] != nil {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OutputType") && dict["OutputType"] != nil {
            self.outputType = dict["OutputType"] as! String
        }
    }
}

public class GetMediaInfoResponseBody : Tea.TeaModel {
    public class MediaInfo : Tea.TeaModel {
        public class AiRoughData : Tea.TeaModel {
            public var aiCategory: String?

            public var aiJobId: String?

            public var result: String?

            public var saveType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiCategory != nil {
                    map["AiCategory"] = self.aiCategory!
                }
                if self.aiJobId != nil {
                    map["AiJobId"] = self.aiJobId!
                }
                if self.result != nil {
                    map["Result"] = self.result!
                }
                if self.saveType != nil {
                    map["SaveType"] = self.saveType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiCategory") && dict["AiCategory"] != nil {
                    self.aiCategory = dict["AiCategory"] as! String
                }
                if dict.keys.contains("AiJobId") && dict["AiJobId"] != nil {
                    self.aiJobId = dict["AiJobId"] as! String
                }
                if dict.keys.contains("Result") && dict["Result"] != nil {
                    self.result = dict["Result"] as! String
                }
                if dict.keys.contains("SaveType") && dict["SaveType"] != nil {
                    self.saveType = dict["SaveType"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class FileInfoList : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var fps: String?

                public var index: String?

                public var lang: String?

                public var numFrames: String?

                public var profile: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") && dict["ChannelLayout"] != nil {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") && dict["Channels"] != nil {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") && dict["Fps"] != nil {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("NumFrames") && dict["NumFrames"] != nil {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("Profile") && dict["Profile"] != nil {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("SampleFmt") && dict["SampleFmt"] != nil {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") && dict["SampleRate"] != nil {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var createTime: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var modifiedTime: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") && dict["FileType"] != nil {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Region") && dict["Region"] != nil {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class SubtitleStreamInfoList : Tea.TeaModel {
                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFPS: String?

                public var bitrate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var nbFrames: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timebase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFPS != nil {
                        map["AvgFPS"] = self.avgFPS!
                    }
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["HasBFrames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.nbFrames != nil {
                        map["Nb_frames"] = self.nbFrames!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvgFPS") && dict["AvgFPS"] != nil {
                        self.avgFPS = dict["AvgFPS"] as! String
                    }
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Dar") && dict["Dar"] != nil {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") && dict["Fps"] != nil {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("HasBFrames") && dict["HasBFrames"] != nil {
                        self.hasBFrames = dict["HasBFrames"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Nb_frames") && dict["Nb_frames"] != nil {
                        self.nbFrames = dict["Nb_frames"] as! String
                    }
                    if dict.keys.contains("NumFrames") && dict["NumFrames"] != nil {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") && dict["Profile"] != nil {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") && dict["Rotate"] != nil {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") && dict["Sar"] != nil {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                        self.timebase = dict["Timebase"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList]?

            public var fileBasicInfo: GetMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo?

            public var subtitleStreamInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList]?

            public var videoStreamInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.subtitleStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.subtitleStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["SubtitleStreamInfoList"] = tmp
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") && dict["AudioStreamInfoList"] != nil {
                    var tmp : [GetMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                    var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("SubtitleStreamInfoList") && dict["SubtitleStreamInfoList"] != nil {
                    var tmp : [GetMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList] = []
                    for v in dict["SubtitleStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subtitleStreamInfoList = tmp
                }
                if dict.keys.contains("VideoStreamInfoList") && dict["VideoStreamInfoList"] != nil {
                    var tmp : [GetMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var cateId: Int64?

            public var cateName: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var referenceId: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var uploadSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.uploadSource != nil {
                    map["UploadSource"] = self.uploadSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") && dict["Biz"] != nil {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("CateId") && dict["CateId"] != nil {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") && dict["CateName"] != nil {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") && dict["DeletedTime"] != nil {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") && dict["InputURL"] != nil {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") && dict["MediaTags"] != nil {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ReferenceId") && dict["ReferenceId"] != nil {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") && dict["SpriteImages"] != nil {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UploadSource") && dict["UploadSource"] != nil {
                    self.uploadSource = dict["UploadSource"] as! String
                }
                if dict.keys.contains("UserData") && dict["UserData"] != nil {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var aiRoughData: GetMediaInfoResponseBody.MediaInfo.AiRoughData?

        public var fileInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList]?

        public var mediaBasicInfo: GetMediaInfoResponseBody.MediaInfo.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.aiRoughData?.validate()
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiRoughData != nil {
                map["AiRoughData"] = self.aiRoughData?.toMap()
            }
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiRoughData") && dict["AiRoughData"] != nil {
                var model = GetMediaInfoResponseBody.MediaInfo.AiRoughData()
                model.fromMap(dict["AiRoughData"] as! [String: Any])
                self.aiRoughData = model
            }
            if dict.keys.contains("FileInfoList") && dict["FileInfoList"] != nil {
                var tmp : [GetMediaInfoResponseBody.MediaInfo.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") && dict["MediaBasicInfo"] != nil {
                var model = GetMediaInfoResponseBody.MediaInfo.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var mediaInfo: GetMediaInfoResponseBody.MediaInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfo != nil {
            map["MediaInfo"] = self.mediaInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfo") && dict["MediaInfo"] != nil {
            var model = GetMediaInfoResponseBody.MediaInfo()
            model.fromMap(dict["MediaInfo"] as! [String: Any])
            self.mediaInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaInfoJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") && dict["ChannelLayout"] != nil {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") && dict["Channels"] != nil {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") && dict["SampleFmt"] != nil {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") && dict["SampleRate"] != nil {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") && dict["FileType"] != nil {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") && dict["Region"] != nil {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") && dict["Avg_fps"] != nil {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") && dict["Bit_rate"] != nil {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") && dict["Codec_long_name"] != nil {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") && dict["Codec_name"] != nil {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") && dict["Codec_tag"] != nil {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") && dict["Codec_tag_string"] != nil {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") && dict["Codec_time_base"] != nil {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") && dict["Dar"] != nil {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") && dict["Fps"] != nil {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") && dict["Has_b_frames"] != nil {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") && dict["NumFrames"] != nil {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") && dict["Profile"] != nil {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") && dict["Rotate"] != nil {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") && dict["Sar"] != nil {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") && dict["Start_time"] != nil {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") && dict["Time_base"] != nil {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") && dict["AudioStreamInfoList"] != nil {
                    var tmp : [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                    var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") && dict["VideoStreamInfoList"] != nil {
                    var tmp : [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") && dict["Priority"] != nil {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: GetMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var mediaInfoProperty: GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: GetMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") && dict["Async"] != nil {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") && dict["Input"] != nil {
                var model = GetMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") && dict["MediaInfoProperty"] != nil {
                var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
                var model = GetMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") && dict["SubmitResultJson"] != nil {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: GetMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") && dict["MediaInfoJob"] != nil {
            var model = GetMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") && dict["MediaMarkIds"] != nil {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
    }
}

public class GetMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") && dict["MediaMarks"] != nil {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaProducingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetMediaProducingJobResponseBody : Tea.TeaModel {
    public class MediaProducingJob : Tea.TeaModel {
        public var clipsParam: String?

        public var code: String?

        public var completeTime: String?

        public var createTime: String?

        public var duration: Double?

        public var jobId: String?

        public var mediaId: String?

        public var mediaURL: String?

        public var message: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var status: String?

        public var templateId: String?

        public var timeline: String?

        public var vodMediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaURL != nil {
                map["MediaURL"] = self.mediaURL!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.vodMediaId != nil {
                map["VodMediaId"] = self.vodMediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") && dict["ClipsParam"] != nil {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaURL") && dict["MediaURL"] != nil {
                self.mediaURL = dict["MediaURL"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("VodMediaId") && dict["VodMediaId"] != nil {
                self.vodMediaId = dict["VodMediaId"] as! String
            }
        }
    }
    public var mediaProducingJob: GetMediaProducingJobResponseBody.MediaProducingJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaProducingJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaProducingJob != nil {
            map["MediaProducingJob"] = self.mediaProducingJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaProducingJob") && dict["MediaProducingJob"] != nil {
            var model = GetMediaProducingJobResponseBody.MediaProducingJob()
            model.fromMap(dict["MediaProducingJob"] as! [String: Any])
            self.mediaProducingJob = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaProducingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaProducingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMediaProducingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPackageJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetPackageJobResponseBody : Tea.TeaModel {
    public class PackageJob : Tea.TeaModel {
        public class Inputs : Tea.TeaModel {
            public class Input : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") && dict["Media"] != nil {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var input: GetPackageJobResponseBody.PackageJob.Inputs.Input?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.input?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Input") && dict["Input"] != nil {
                    var model = GetPackageJobResponseBody.PackageJob.Inputs.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var code: String?

        public var createTime: String?

        public var finishTime: String?

        public var inputs: [GetPackageJobResponseBody.PackageJob.Inputs]?

        public var jobId: String?

        public var message: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: GetPackageJobResponseBody.PackageJob.Output?

        public var outputUrl: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var status: String?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputs != nil {
                var tmp : [Any] = []
                for k in self.inputs! {
                    tmp.append(k.toMap())
                }
                map["Inputs"] = tmp
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.outputUrl != nil {
                map["OutputUrl"] = self.outputUrl!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Inputs") && dict["Inputs"] != nil {
                var tmp : [GetPackageJobResponseBody.PackageJob.Inputs] = []
                for v in dict["Inputs"] as! [Any] {
                    var model = GetPackageJobResponseBody.PackageJob.Inputs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputs = tmp
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") && dict["Output"] != nil {
                var model = GetPackageJobResponseBody.PackageJob.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("OutputUrl") && dict["OutputUrl"] != nil {
                self.outputUrl = dict["OutputUrl"] as! String
            }
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var packageJob: GetPackageJobResponseBody.PackageJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packageJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packageJob != nil {
            map["PackageJob"] = self.packageJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackageJob") && dict["PackageJob"] != nil {
            var model = GetPackageJobResponseBody.PackageJob()
            model.fromMap(dict["PackageJob"] as! [String: Any])
            self.packageJob = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPackageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPackageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPackageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPipelineRequest : Tea.TeaModel {
    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
            self.pipelineId = dict["PipelineId"] as! String
        }
    }
}

public class GetPipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public var createTime: String?

        public var modifiedTime: String?

        public var name: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var speed: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Speed") && dict["Speed"] != nil {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipeline: GetPipelineResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") && dict["Pipeline"] != nil {
            var model = GetPipelineResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPlayInfoRequest : Tea.TeaModel {
    public var inputURL: String?

    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputURL") && dict["InputURL"] != nil {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class GetPlayInfoResponseBody : Tea.TeaModel {
    public class MediaBase : Tea.TeaModel {
        public var coverURL: String?

        public var creationTime: String?

        public var mediaId: String?

        public var mediaType: String?

        public var status: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaType != nil {
                map["MediaType"] = self.mediaType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
                self.mediaType = dict["MediaType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class PlayInfoList : Tea.TeaModel {
        public var bitDepth: Int32?

        public var bitrate: String?

        public var creationTime: String?

        public var definition: String?

        public var duration: String?

        public var encrypt: Int64?

        public var encryptType: String?

        public var fileURL: String?

        public var format: String?

        public var fps: String?

        public var HDRType: String?

        public var height: Int64?

        public var jobId: String?

        public var modificationTime: String?

        public var narrowBandType: String?

        public var playURL: String?

        public var size: Int64?

        public var status: String?

        public var streamTags: String?

        public var streamType: String?

        public var transTemplateType: String?

        public var watermarkId: String?

        public var width: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitDepth != nil {
                map["BitDepth"] = self.bitDepth!
            }
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.definition != nil {
                map["Definition"] = self.definition!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.encrypt != nil {
                map["Encrypt"] = self.encrypt!
            }
            if self.encryptType != nil {
                map["EncryptType"] = self.encryptType!
            }
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.HDRType != nil {
                map["HDRType"] = self.HDRType!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.narrowBandType != nil {
                map["NarrowBandType"] = self.narrowBandType!
            }
            if self.playURL != nil {
                map["PlayURL"] = self.playURL!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamTags != nil {
                map["StreamTags"] = self.streamTags!
            }
            if self.streamType != nil {
                map["StreamType"] = self.streamType!
            }
            if self.transTemplateType != nil {
                map["TransTemplateType"] = self.transTemplateType!
            }
            if self.watermarkId != nil {
                map["WatermarkId"] = self.watermarkId!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BitDepth") && dict["BitDepth"] != nil {
                self.bitDepth = dict["BitDepth"] as! Int32
            }
            if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                self.bitrate = dict["Bitrate"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Definition") && dict["Definition"] != nil {
                self.definition = dict["Definition"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Encrypt") && dict["Encrypt"] != nil {
                self.encrypt = dict["Encrypt"] as! Int64
            }
            if dict.keys.contains("EncryptType") && dict["EncryptType"] != nil {
                self.encryptType = dict["EncryptType"] as! String
            }
            if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
                self.fileURL = dict["FileURL"] as! String
            }
            if dict.keys.contains("Format") && dict["Format"] != nil {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Fps") && dict["Fps"] != nil {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("HDRType") && dict["HDRType"] != nil {
                self.HDRType = dict["HDRType"] as! String
            }
            if dict.keys.contains("Height") && dict["Height"] != nil {
                self.height = dict["Height"] as! Int64
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("NarrowBandType") && dict["NarrowBandType"] != nil {
                self.narrowBandType = dict["NarrowBandType"] as! String
            }
            if dict.keys.contains("PlayURL") && dict["PlayURL"] != nil {
                self.playURL = dict["PlayURL"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StreamTags") && dict["StreamTags"] != nil {
                self.streamTags = dict["StreamTags"] as! String
            }
            if dict.keys.contains("StreamType") && dict["StreamType"] != nil {
                self.streamType = dict["StreamType"] as! String
            }
            if dict.keys.contains("TransTemplateType") && dict["TransTemplateType"] != nil {
                self.transTemplateType = dict["TransTemplateType"] as! String
            }
            if dict.keys.contains("WatermarkId") && dict["WatermarkId"] != nil {
                self.watermarkId = dict["WatermarkId"] as! String
            }
            if dict.keys.contains("Width") && dict["Width"] != nil {
                self.width = dict["Width"] as! Int64
            }
        }
    }
    public var mediaBase: GetPlayInfoResponseBody.MediaBase?

    public var playInfoList: [GetPlayInfoResponseBody.PlayInfoList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaBase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaBase != nil {
            map["MediaBase"] = self.mediaBase?.toMap()
        }
        if self.playInfoList != nil {
            var tmp : [Any] = []
            for k in self.playInfoList! {
                tmp.append(k.toMap())
            }
            map["PlayInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaBase") && dict["MediaBase"] != nil {
            var model = GetPlayInfoResponseBody.MediaBase()
            model.fromMap(dict["MediaBase"] as! [String: Any])
            self.mediaBase = model
        }
        if dict.keys.contains("PlayInfoList") && dict["PlayInfoList"] != nil {
            var tmp : [GetPlayInfoResponseBody.PlayInfoList] = []
            for v in dict["PlayInfoList"] as! [Any] {
                var model = GetPlayInfoResponseBody.PlayInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.playInfoList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPublicMediaInfoRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class GetPublicMediaInfoResponseBody : Tea.TeaModel {
    public class MediaInfo : Tea.TeaModel {
        public class DynamicMetaData : Tea.TeaModel {
            public var data: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") && dict["Data"] != nil {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class FileInfoList : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var fps: String?

                public var index: String?

                public var lang: String?

                public var numFrames: String?

                public var profile: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") && dict["ChannelLayout"] != nil {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") && dict["Channels"] != nil {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") && dict["Fps"] != nil {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("NumFrames") && dict["NumFrames"] != nil {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("Profile") && dict["Profile"] != nil {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("SampleFmt") && dict["SampleFmt"] != nil {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") && dict["SampleRate"] != nil {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") && dict["FileType"] != nil {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") && dict["Region"] != nil {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class SubtitleStreamInfoList : Tea.TeaModel {
                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFPS: String?

                public var bitrate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var nbFrames: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timebase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFPS != nil {
                        map["AvgFPS"] = self.avgFPS!
                    }
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["HasBFrames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.nbFrames != nil {
                        map["Nb_frames"] = self.nbFrames!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvgFPS") && dict["AvgFPS"] != nil {
                        self.avgFPS = dict["AvgFPS"] as! String
                    }
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Dar") && dict["Dar"] != nil {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") && dict["Fps"] != nil {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("HasBFrames") && dict["HasBFrames"] != nil {
                        self.hasBFrames = dict["HasBFrames"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Nb_frames") && dict["Nb_frames"] != nil {
                        self.nbFrames = dict["Nb_frames"] as! String
                    }
                    if dict.keys.contains("NumFrames") && dict["NumFrames"] != nil {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") && dict["Profile"] != nil {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") && dict["Rotate"] != nil {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") && dict["Sar"] != nil {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                        self.timebase = dict["Timebase"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList]?

            public var fileBasicInfo: GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo?

            public var subtitleStreamInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList]?

            public var videoStreamInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.subtitleStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.subtitleStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["SubtitleStreamInfoList"] = tmp
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") && dict["AudioStreamInfoList"] != nil {
                    var tmp : [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                    var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("SubtitleStreamInfoList") && dict["SubtitleStreamInfoList"] != nil {
                    var tmp : [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList] = []
                    for v in dict["SubtitleStreamInfoList"] as! [Any] {
                        var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subtitleStreamInfoList = tmp
                }
                if dict.keys.contains("VideoStreamInfoList") && dict["VideoStreamInfoList"] != nil {
                    var tmp : [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") && dict["DeletedTime"] != nil {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") && dict["MediaTags"] != nil {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") && dict["SpriteImages"] != nil {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UserData") && dict["UserData"] != nil {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var dynamicMetaData: GetPublicMediaInfoResponseBody.MediaInfo.DynamicMetaData?

        public var fileInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList]?

        public var mediaBasicInfo: GetPublicMediaInfoResponseBody.MediaInfo.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dynamicMetaData?.validate()
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dynamicMetaData != nil {
                map["DynamicMetaData"] = self.dynamicMetaData?.toMap()
            }
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DynamicMetaData") && dict["DynamicMetaData"] != nil {
                var model = GetPublicMediaInfoResponseBody.MediaInfo.DynamicMetaData()
                model.fromMap(dict["DynamicMetaData"] as! [String: Any])
                self.dynamicMetaData = model
            }
            if dict.keys.contains("FileInfoList") && dict["FileInfoList"] != nil {
                var tmp : [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") && dict["MediaBasicInfo"] != nil {
                var model = GetPublicMediaInfoResponseBody.MediaInfo.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var mediaInfo: GetPublicMediaInfoResponseBody.MediaInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfo != nil {
            map["MediaInfo"] = self.mediaInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfo") && dict["MediaInfo"] != nil {
            var model = GetPublicMediaInfoResponseBody.MediaInfo()
            model.fromMap(dict["MediaInfo"] as! [String: Any])
            self.mediaInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPublicMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPublicMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPublicMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSmartHandleJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetSmartHandleJobResponseBody : Tea.TeaModel {
    public class JobResult : Tea.TeaModel {
        public var aiResult: String?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiResult != nil {
                map["AiResult"] = self.aiResult!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiResult") && dict["AiResult"] != nil {
                self.aiResult = dict["AiResult"] as! String
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public class SmartJobInfo : Tea.TeaModel {
        public class InputConfig : Tea.TeaModel {
            public var inputFile: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputFile != nil {
                    map["InputFile"] = self.inputFile!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputFile") && dict["InputFile"] != nil {
                    self.inputFile = dict["InputFile"] as! String
                }
            }
        }
        public class OutputConfig : Tea.TeaModel {
            public var bucket: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Object") && dict["Object"] != nil {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public var createTime: String?

        public var description_: String?

        public var inputConfig: GetSmartHandleJobResponseBody.SmartJobInfo.InputConfig?

        public var jobType: String?

        public var modifiedTime: String?

        public var outputConfig: GetSmartHandleJobResponseBody.SmartJobInfo.OutputConfig?

        public var title: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inputConfig?.validate()
            try self.outputConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.inputConfig != nil {
                map["InputConfig"] = self.inputConfig?.toMap()
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputConfig != nil {
                map["OutputConfig"] = self.outputConfig?.toMap()
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InputConfig") && dict["InputConfig"] != nil {
                var model = GetSmartHandleJobResponseBody.SmartJobInfo.InputConfig()
                model.fromMap(dict["InputConfig"] as! [String: Any])
                self.inputConfig = model
            }
            if dict.keys.contains("JobType") && dict["JobType"] != nil {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputConfig") && dict["OutputConfig"] != nil {
                var model = GetSmartHandleJobResponseBody.SmartJobInfo.OutputConfig()
                model.fromMap(dict["OutputConfig"] as! [String: Any])
                self.outputConfig = model
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var jobId: String?

    public var jobResult: GetSmartHandleJobResponseBody.JobResult?

    public var output: String?

    public var requestId: String?

    public var smartJobInfo: GetSmartHandleJobResponseBody.SmartJobInfo?

    public var state: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobResult?.validate()
        try self.smartJobInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobResult != nil {
            map["JobResult"] = self.jobResult?.toMap()
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.smartJobInfo != nil {
            map["SmartJobInfo"] = self.smartJobInfo?.toMap()
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobResult") && dict["JobResult"] != nil {
            var model = GetSmartHandleJobResponseBody.JobResult()
            model.fromMap(dict["JobResult"] as! [String: Any])
            self.jobResult = model
        }
        if dict.keys.contains("Output") && dict["Output"] != nil {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SmartJobInfo") && dict["SmartJobInfo"] != nil {
            var model = GetSmartHandleJobResponseBody.SmartJobInfo()
            model.fromMap(dict["SmartJobInfo"] as! [String: Any])
            self.smartJobInfo = model
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class GetSmartHandleJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSmartHandleJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSmartHandleJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSnapshotJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetSnapshotJobResponseBody : Tea.TeaModel {
    public class SnapshotJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") && dict["Object"] != nil {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetSnapshotJobResponseBody.SnapshotJob.Input.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") && dict["OssFile"] != nil {
                    var model = GetSnapshotJobResponseBody.SnapshotJob.Input.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") && dict["Object"] != nil {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetSnapshotJobResponseBody.SnapshotJob.Output.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") && dict["OssFile"] != nil {
                    var model = GetSnapshotJobResponseBody.SnapshotJob.Output.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var async: Bool?

        public var code: String?

        public var count: Int32?

        public var createTime: String?

        public var finishTime: String?

        public var input: GetSnapshotJobResponseBody.SnapshotJob.Input?

        public var jobId: String?

        public var message: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: GetSnapshotJobResponseBody.SnapshotJob.Output?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateConfig: String?

        public var templateId: String?

        public var triggerSource: String?

        public var type: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") && dict["Async"] != nil {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") && dict["Input"] != nil {
                var model = GetSnapshotJobResponseBody.SnapshotJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") && dict["Output"] != nil {
                var model = GetSnapshotJobResponseBody.SnapshotJob.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var snapshotJob: GetSnapshotJobResponseBody.SnapshotJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotJob != nil {
            map["SnapshotJob"] = self.snapshotJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotJob") && dict["SnapshotJob"] != nil {
            var model = GetSnapshotJobResponseBody.SnapshotJob()
            model.fromMap(dict["SnapshotJob"] as! [String: Any])
            self.snapshotJob = model
        }
    }
}

public class GetSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSnapshotUrlsRequest : Tea.TeaModel {
    public var jobId: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int64
        }
    }
}

public class GetSnapshotUrlsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotUrls: [String]?

    public var total: Int32?

    public var webVTTUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotUrls != nil {
            map["SnapshotUrls"] = self.snapshotUrls!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.webVTTUrl != nil {
            map["WebVTTUrl"] = self.webVTTUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotUrls") && dict["SnapshotUrls"] != nil {
            self.snapshotUrls = dict["SnapshotUrls"] as! [String]
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
        if dict.keys.contains("WebVTTUrl") && dict["WebVTTUrl"] != nil {
            self.webVTTUrl = dict["WebVTTUrl"] as! String
        }
    }
}

public class GetSnapshotUrlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSnapshotUrlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSnapshotUrlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSystemTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetSystemTemplateResponseBody : Tea.TeaModel {
    public class SystemTemplate : Tea.TeaModel {
        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") && dict["Subtype"] != nil {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") && dict["SubtypeName"] != nil {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var requestId: String?

    public var systemTemplate: GetSystemTemplateResponseBody.SystemTemplate?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemTemplate != nil {
            map["SystemTemplate"] = self.systemTemplate?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemTemplate") && dict["SystemTemplate"] != nil {
            var model = GetSystemTemplateResponseBody.SystemTemplate()
            model.fromMap(dict["SystemTemplate"] as! [String: Any])
            self.systemTemplate = model
        }
    }
}

public class GetSystemTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSystemTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSystemTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateRequest : Tea.TeaModel {
    public var relatedMediaidFlag: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.relatedMediaidFlag != nil {
            map["RelatedMediaidFlag"] = self.relatedMediaidFlag!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RelatedMediaidFlag") && dict["RelatedMediaidFlag"] != nil {
            self.relatedMediaidFlag = dict["RelatedMediaidFlag"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var clipsParam: String?

        public var config: String?

        public var coverURL: String?

        public var createSource: String?

        public var creationTime: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var name: String?

        public var previewMedia: String?

        public var previewMediaStatus: String?

        public var relatedMediaids: String?

        public var status: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.previewMedia != nil {
                map["PreviewMedia"] = self.previewMedia!
            }
            if self.previewMediaStatus != nil {
                map["PreviewMediaStatus"] = self.previewMediaStatus!
            }
            if self.relatedMediaids != nil {
                map["RelatedMediaids"] = self.relatedMediaids!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") && dict["ClipsParam"] != nil {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") && dict["CreateSource"] != nil {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ModifiedSource") && dict["ModifiedSource"] != nil {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PreviewMedia") && dict["PreviewMedia"] != nil {
                self.previewMedia = dict["PreviewMedia"] as! String
            }
            if dict.keys.contains("PreviewMediaStatus") && dict["PreviewMediaStatus"] != nil {
                self.previewMediaStatus = dict["PreviewMediaStatus"] as! String
            }
            if dict.keys.contains("RelatedMediaids") && dict["RelatedMediaids"] != nil {
                self.relatedMediaids = dict["RelatedMediaids"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var template: GetTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") && dict["Template"] != nil {
            var model = GetTemplateResponseBody.Template()
            model.fromMap(dict["Template"] as! [String: Any])
            self.template = model
        }
    }
}

public class GetTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateMaterialsRequest : Tea.TeaModel {
    public var fileList: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileList != nil {
            map["FileList"] = self.fileList!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileList") && dict["FileList"] != nil {
            self.fileList = dict["FileList"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateMaterialsResponseBody : Tea.TeaModel {
    public var materialUrls: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialUrls != nil {
            map["MaterialUrls"] = self.materialUrls!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialUrls") && dict["MaterialUrls"] != nil {
            self.materialUrls = dict["MaterialUrls"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTemplateMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTemplateMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateParamsRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateParamsResponseBody : Tea.TeaModel {
    public class ParamList : Tea.TeaModel {
        public var content: String?

        public var coverUrl: String?

        public var key: String?

        public var mediaUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.mediaUrl != nil {
                map["MediaUrl"] = self.mediaUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("MediaUrl") && dict["MediaUrl"] != nil {
                self.mediaUrl = dict["MediaUrl"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var paramList: [GetTemplateParamsResponseBody.ParamList]?

    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.paramList != nil {
            var tmp : [Any] = []
            for k in self.paramList! {
                tmp.append(k.toMap())
            }
            map["ParamList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ParamList") && dict["ParamList"] != nil {
            var tmp : [GetTemplateParamsResponseBody.ParamList] = []
            for v in dict["ParamList"] as! [Any] {
                var model = GetTemplateParamsResponseBody.ParamList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.paramList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateParamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateParamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTemplateParamsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTranscodeJobRequest : Tea.TeaModel {
    public var parentJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.parentJobId != nil {
            map["ParentJobId"] = self.parentJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ParentJobId") && dict["ParentJobId"] != nil {
            self.parentJobId = dict["ParentJobId"] as! String
        }
    }
}

public class GetTranscodeJobResponseBody : Tea.TeaModel {
    public class TranscodeParentJob : Tea.TeaModel {
        public class InputGroup : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class OutputGroup : Tea.TeaModel {
            public class Output : Tea.TeaModel {
                public var media: String?

                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") && dict["Media"] != nil {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("OutputUrl") && dict["OutputUrl"] != nil {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") && dict["AudioIndex"] != nil {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") && dict["Start"] != nil {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") && dict["VideoIndex"] != nil {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") && dict["CipherText"] != nil {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") && dict["DecryptKeyUri"] != nil {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") && dict["EncryptType"] != nil {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") && dict["Media"] != nil {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") && dict["Type"] != nil {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") && dict["Start"] != nil {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") && dict["Dx"] != nil {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") && dict["Dy"] != nil {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") && dict["File"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") && dict["Height"] != nil {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") && dict["ReferPos"] != nil {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") && dict["Width"] != nil {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") && dict["Media"] != nil {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") && dict["Type"] != nil {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") && dict["CharEnc"] != nil {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") && dict["File"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") && dict["Format"] != nil {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") && dict["Adaptive"] != nil {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") && dict["BorderColor"] != nil {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") && dict["BorderWidth"] != nil {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") && dict["Content"] != nil {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") && dict["FontAlpha"] != nil {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") && dict["FontColor"] != nil {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") && dict["FontName"] != nil {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") && dict["FontSize"] != nil {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") && dict["Left"] != nil {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") && dict["Top"] != nil {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") && dict["IntegratedLoudnessTarget"] != nil {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") && dict["LoudnessRangeTarget"] != nil {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") && dict["Method"] != nil {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") && dict["TruePeak"] != nil {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") && dict["Channels"] != nil {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") && dict["Remove"] != nil {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") && dict["Samplerate"] != nil {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") && dict["Volume"] != nil {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") && dict["Format"] != nil {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") && dict["ForceSegTime"] != nil {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") && dict["Segment"] != nil {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") && dict["AbrMax"] != nil {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") && dict["Bufsize"] != nil {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") && dict["Crf"] != nil {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") && dict["Crop"] != nil {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") && dict["Fps"] != nil {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") && dict["Gop"] != nil {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") && dict["Height"] != nil {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") && dict["LongShortMode"] != nil {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") && dict["Maxrate"] != nil {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") && dict["Pad"] != nil {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") && dict["Preset"] != nil {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") && dict["Remove"] != nil {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") && dict["ScanMode"] != nil {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") && dict["Width"] != nil {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var video: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") && dict["Audio"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") && dict["Container"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") && dict["MuxConfig"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Video") && dict["Video"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs]?

                public var encryption: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption?

                public var imageWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks]?

                public var subtitles: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles]?

                public var textWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks]?

                public var transcode: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") && dict["CombineConfigs"] != nil {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") && dict["Encryption"] != nil {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") && dict["ImageWatermarks"] != nil {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("Subtitles") && dict["Subtitles"] != nil {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") && dict["TextWatermarks"] != nil {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") && dict["Transcode"] != nil {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public var output: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output?

            public var processConfig: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
                try self.processConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Output") && dict["Output"] != nil {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ProcessConfig") && dict["ProcessConfig"] != nil {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") && dict["Priority"] != nil {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public class TranscodeJobList : Tea.TeaModel {
            public class InputGroup : Tea.TeaModel {
                public var inputUrl: String?

                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inputUrl != nil {
                        map["InputUrl"] = self.inputUrl!
                    }
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InputUrl") && dict["InputUrl"] != nil {
                        self.inputUrl = dict["InputUrl"] as! String
                    }
                    if dict.keys.contains("Media") && dict["Media"] != nil {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class OutFileMeta : Tea.TeaModel {
                public class AudioStreamInfoList : Tea.TeaModel {
                    public var bitrate: String?

                    public var channelLayout: String?

                    public var channels: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var duration: String?

                    public var index: String?

                    public var lang: String?

                    public var sampleFmt: String?

                    public var sampleRate: String?

                    public var startTime: String?

                    public var timebase: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channelLayout != nil {
                            map["ChannelLayout"] = self.channelLayout!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codecLongName != nil {
                            map["CodecLongName"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["CodecName"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["CodecTag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["CodecTagString"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["CodecTimeBase"] = self.codecTimeBase!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.sampleFmt != nil {
                            map["SampleFmt"] = self.sampleFmt!
                        }
                        if self.sampleRate != nil {
                            map["SampleRate"] = self.sampleRate!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.timebase != nil {
                            map["Timebase"] = self.timebase!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("ChannelLayout") && dict["ChannelLayout"] != nil {
                            self.channelLayout = dict["ChannelLayout"] as! String
                        }
                        if dict.keys.contains("Channels") && dict["Channels"] != nil {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                            self.codecLongName = dict["CodecLongName"] as! String
                        }
                        if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                            self.codecName = dict["CodecName"] as! String
                        }
                        if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                            self.codecTag = dict["CodecTag"] as! String
                        }
                        if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                            self.codecTagString = dict["CodecTagString"] as! String
                        }
                        if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                        }
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Index") && dict["Index"] != nil {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") && dict["Lang"] != nil {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("SampleFmt") && dict["SampleFmt"] != nil {
                            self.sampleFmt = dict["SampleFmt"] as! String
                        }
                        if dict.keys.contains("SampleRate") && dict["SampleRate"] != nil {
                            self.sampleRate = dict["SampleRate"] as! String
                        }
                        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                            self.timebase = dict["Timebase"] as! String
                        }
                    }
                }
                public class FileBasicInfo : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var fileName: String?

                    public var fileSize: String?

                    public var fileStatus: String?

                    public var fileType: String?

                    public var fileUrl: String?

                    public var formatName: String?

                    public var height: String?

                    public var mediaId: String?

                    public var region: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileName != nil {
                            map["FileName"] = self.fileName!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.fileStatus != nil {
                            map["FileStatus"] = self.fileStatus!
                        }
                        if self.fileType != nil {
                            map["FileType"] = self.fileType!
                        }
                        if self.fileUrl != nil {
                            map["FileUrl"] = self.fileUrl!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.mediaId != nil {
                            map["MediaId"] = self.mediaId!
                        }
                        if self.region != nil {
                            map["Region"] = self.region!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileName") && dict["FileName"] != nil {
                            self.fileName = dict["FileName"] as! String
                        }
                        if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                            self.fileStatus = dict["FileStatus"] as! String
                        }
                        if dict.keys.contains("FileType") && dict["FileType"] != nil {
                            self.fileType = dict["FileType"] as! String
                        }
                        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                            self.fileUrl = dict["FileUrl"] as! String
                        }
                        if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("Height") && dict["Height"] != nil {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                            self.mediaId = dict["MediaId"] as! String
                        }
                        if dict.keys.contains("Region") && dict["Region"] != nil {
                            self.region = dict["Region"] as! String
                        }
                        if dict.keys.contains("Width") && dict["Width"] != nil {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class VideoStreamInfoList : Tea.TeaModel {
                    public var avgFps: String?

                    public var bitRate: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var dar: String?

                    public var duration: String?

                    public var fps: String?

                    public var hasBFrames: String?

                    public var height: String?

                    public var index: String?

                    public var lang: String?

                    public var level: String?

                    public var numFrames: String?

                    public var pixFmt: String?

                    public var profile: String?

                    public var rotate: String?

                    public var sar: String?

                    public var startTime: String?

                    public var timeBase: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgFps != nil {
                            map["Avg_fps"] = self.avgFps!
                        }
                        if self.bitRate != nil {
                            map["Bit_rate"] = self.bitRate!
                        }
                        if self.codecLongName != nil {
                            map["Codec_long_name"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["Codec_name"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["Codec_tag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["Codec_tag_string"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["Codec_time_base"] = self.codecTimeBase!
                        }
                        if self.dar != nil {
                            map["Dar"] = self.dar!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.hasBFrames != nil {
                            map["Has_b_frames"] = self.hasBFrames!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.numFrames != nil {
                            map["NumFrames"] = self.numFrames!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.rotate != nil {
                            map["Rotate"] = self.rotate!
                        }
                        if self.sar != nil {
                            map["Sar"] = self.sar!
                        }
                        if self.startTime != nil {
                            map["Start_time"] = self.startTime!
                        }
                        if self.timeBase != nil {
                            map["Time_base"] = self.timeBase!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Avg_fps") && dict["Avg_fps"] != nil {
                            self.avgFps = dict["Avg_fps"] as! String
                        }
                        if dict.keys.contains("Bit_rate") && dict["Bit_rate"] != nil {
                            self.bitRate = dict["Bit_rate"] as! String
                        }
                        if dict.keys.contains("Codec_long_name") && dict["Codec_long_name"] != nil {
                            self.codecLongName = dict["Codec_long_name"] as! String
                        }
                        if dict.keys.contains("Codec_name") && dict["Codec_name"] != nil {
                            self.codecName = dict["Codec_name"] as! String
                        }
                        if dict.keys.contains("Codec_tag") && dict["Codec_tag"] != nil {
                            self.codecTag = dict["Codec_tag"] as! String
                        }
                        if dict.keys.contains("Codec_tag_string") && dict["Codec_tag_string"] != nil {
                            self.codecTagString = dict["Codec_tag_string"] as! String
                        }
                        if dict.keys.contains("Codec_time_base") && dict["Codec_time_base"] != nil {
                            self.codecTimeBase = dict["Codec_time_base"] as! String
                        }
                        if dict.keys.contains("Dar") && dict["Dar"] != nil {
                            self.dar = dict["Dar"] as! String
                        }
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Fps") && dict["Fps"] != nil {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Has_b_frames") && dict["Has_b_frames"] != nil {
                            self.hasBFrames = dict["Has_b_frames"] as! String
                        }
                        if dict.keys.contains("Height") && dict["Height"] != nil {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Index") && dict["Index"] != nil {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") && dict["Lang"] != nil {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("Level") && dict["Level"] != nil {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("NumFrames") && dict["NumFrames"] != nil {
                            self.numFrames = dict["NumFrames"] as! String
                        }
                        if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Profile") && dict["Profile"] != nil {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Rotate") && dict["Rotate"] != nil {
                            self.rotate = dict["Rotate"] as! String
                        }
                        if dict.keys.contains("Sar") && dict["Sar"] != nil {
                            self.sar = dict["Sar"] as! String
                        }
                        if dict.keys.contains("Start_time") && dict["Start_time"] != nil {
                            self.startTime = dict["Start_time"] as! String
                        }
                        if dict.keys.contains("Time_base") && dict["Time_base"] != nil {
                            self.timeBase = dict["Time_base"] as! String
                        }
                        if dict.keys.contains("Width") && dict["Width"] != nil {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var audioStreamInfoList: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList]?

                public var fileBasicInfo: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo?

                public var videoStreamInfoList: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.fileBasicInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.audioStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["AudioStreamInfoList"] = tmp
                    }
                    if self.fileBasicInfo != nil {
                        map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                    }
                    if self.videoStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.videoStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["VideoStreamInfoList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioStreamInfoList") && dict["AudioStreamInfoList"] != nil {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList] = []
                        for v in dict["AudioStreamInfoList"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.audioStreamInfoList = tmp
                    }
                    if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo()
                        model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                        self.fileBasicInfo = model
                    }
                    if dict.keys.contains("VideoStreamInfoList") && dict["VideoStreamInfoList"] != nil {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList] = []
                        for v in dict["VideoStreamInfoList"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.videoStreamInfoList = tmp
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public var media: String?

                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") && dict["Media"] != nil {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("OutputUrl") && dict["OutputUrl"] != nil {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") && dict["AudioIndex"] != nil {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") && dict["Start"] != nil {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") && dict["VideoIndex"] != nil {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") && dict["CipherText"] != nil {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") && dict["DecryptKeyUri"] != nil {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") && dict["EncryptType"] != nil {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") && dict["Media"] != nil {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") && dict["Type"] != nil {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") && dict["Start"] != nil {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") && dict["Dx"] != nil {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") && dict["Dy"] != nil {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") && dict["File"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") && dict["Height"] != nil {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") && dict["ReferPos"] != nil {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") && dict["Width"] != nil {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") && dict["Media"] != nil {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") && dict["Type"] != nil {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") && dict["CharEnc"] != nil {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") && dict["File"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") && dict["Format"] != nil {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") && dict["Adaptive"] != nil {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") && dict["BorderColor"] != nil {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") && dict["BorderWidth"] != nil {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") && dict["Content"] != nil {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") && dict["FontAlpha"] != nil {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") && dict["FontColor"] != nil {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") && dict["FontName"] != nil {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") && dict["FontSize"] != nil {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") && dict["Left"] != nil {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") && dict["Top"] != nil {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") && dict["IntegratedLoudnessTarget"] != nil {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") && dict["LoudnessRangeTarget"] != nil {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") && dict["Method"] != nil {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") && dict["TruePeak"] != nil {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") && dict["Channels"] != nil {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") && dict["Remove"] != nil {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") && dict["Samplerate"] != nil {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") && dict["Volume"] != nil {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") && dict["Format"] != nil {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") && dict["ForceSegTime"] != nil {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") && dict["Segment"] != nil {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") && dict["AbrMax"] != nil {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") && dict["Bufsize"] != nil {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") && dict["Crf"] != nil {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") && dict["Crop"] != nil {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") && dict["Fps"] != nil {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") && dict["Gop"] != nil {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") && dict["Height"] != nil {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") && dict["LongShortMode"] != nil {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") && dict["Maxrate"] != nil {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") && dict["Pad"] != nil {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") && dict["Preset"] != nil {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") && dict["Remove"] != nil {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") && dict["ScanMode"] != nil {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") && dict["Width"] != nil {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var tags: [String: String]?

                        public var video: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.tags != nil {
                                map["Tags"] = self.tags!
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") && dict["Audio"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") && dict["Container"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") && dict["MuxConfig"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                                self.tags = dict["Tags"] as! [String: String]
                            }
                            if dict.keys.contains("Video") && dict["Video"] != nil {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs]?

                public var encryption: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption?

                public var imageWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks]?

                public var isInheritTags: Bool?

                public var subtitles: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles]?

                public var textWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks]?

                public var transcode: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.isInheritTags != nil {
                        map["IsInheritTags"] = self.isInheritTags!
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") && dict["CombineConfigs"] != nil {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") && dict["Encryption"] != nil {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") && dict["ImageWatermarks"] != nil {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("IsInheritTags") && dict["IsInheritTags"] != nil {
                        self.isInheritTags = dict["IsInheritTags"] as! Bool
                    }
                    if dict.keys.contains("Subtitles") && dict["Subtitles"] != nil {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") && dict["TextWatermarks"] != nil {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") && dict["Transcode"] != nil {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public class ScheduleConfig : Tea.TeaModel {
                public var pipelineId: String?

                public var priority: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                        self.pipelineId = dict["PipelineId"] as! String
                    }
                    if dict.keys.contains("Priority") && dict["Priority"] != nil {
                        self.priority = dict["Priority"] as! Int32
                    }
                }
            }
            public var createTime: String?

            public var finishTime: String?

            public var inputGroup: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup]?

            public var jobId: String?

            public var jobIndex: Int32?

            public var name: String?

            public var outFileMeta: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta?

            public var output: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output?

            public var parentJobId: String?

            public var processConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig?

            public var requestId: String?

            public var scheduleConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig?

            public var status: String?

            public var submitResultJson: [String: Any]?

            public var submitTime: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outFileMeta?.validate()
                try self.output?.validate()
                try self.processConfig?.validate()
                try self.scheduleConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inputGroup != nil {
                    var tmp : [Any] = []
                    for k in self.inputGroup! {
                        tmp.append(k.toMap())
                    }
                    map["InputGroup"] = tmp
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobIndex != nil {
                    map["JobIndex"] = self.jobIndex!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outFileMeta != nil {
                    map["OutFileMeta"] = self.outFileMeta?.toMap()
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.parentJobId != nil {
                    map["ParentJobId"] = self.parentJobId!
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.scheduleConfig != nil {
                    map["ScheduleConfig"] = self.scheduleConfig?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitResultJson != nil {
                    map["SubmitResultJson"] = self.submitResultJson!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("InputGroup") && dict["InputGroup"] != nil {
                    var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup] = []
                    for v in dict["InputGroup"] as! [Any] {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputGroup = tmp
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobIndex") && dict["JobIndex"] != nil {
                    self.jobIndex = dict["JobIndex"] as! Int32
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OutFileMeta") && dict["OutFileMeta"] != nil {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta()
                    model.fromMap(dict["OutFileMeta"] as! [String: Any])
                    self.outFileMeta = model
                }
                if dict.keys.contains("Output") && dict["Output"] != nil {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ParentJobId") && dict["ParentJobId"] != nil {
                    self.parentJobId = dict["ParentJobId"] as! String
                }
                if dict.keys.contains("ProcessConfig") && dict["ProcessConfig"] != nil {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
                if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig()
                    model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                    self.scheduleConfig = model
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitResultJson") && dict["SubmitResultJson"] != nil {
                    self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
                }
                if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("UserData") && dict["UserData"] != nil {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var inputGroup: [GetTranscodeJobResponseBody.TranscodeParentJob.InputGroup]?

        public var jobCount: Int32?

        public var name: String?

        public var outputGroup: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup]?

        public var parentJobId: String?

        public var percent: Int32?

        public var requestId: String?

        public var scheduleConfig: GetTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig?

        public var status: String?

        public var submitTime: String?

        public var transcodeJobList: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList]?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputGroup != nil {
                var tmp : [Any] = []
                for k in self.inputGroup! {
                    tmp.append(k.toMap())
                }
                map["InputGroup"] = tmp
            }
            if self.jobCount != nil {
                map["JobCount"] = self.jobCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroup != nil {
                var tmp : [Any] = []
                for k in self.outputGroup! {
                    tmp.append(k.toMap())
                }
                map["OutputGroup"] = tmp
            }
            if self.parentJobId != nil {
                map["ParentJobId"] = self.parentJobId!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.transcodeJobList != nil {
                var tmp : [Any] = []
                for k in self.transcodeJobList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJobList"] = tmp
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("InputGroup") && dict["InputGroup"] != nil {
                var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.InputGroup] = []
                for v in dict["InputGroup"] as! [Any] {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.InputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputGroup = tmp
            }
            if dict.keys.contains("JobCount") && dict["JobCount"] != nil {
                self.jobCount = dict["JobCount"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroup") && dict["OutputGroup"] != nil {
                var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup] = []
                for v in dict["OutputGroup"] as! [Any] {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroup = tmp
            }
            if dict.keys.contains("ParentJobId") && dict["ParentJobId"] != nil {
                self.parentJobId = dict["ParentJobId"] as! String
            }
            if dict.keys.contains("Percent") && dict["Percent"] != nil {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
                var model = GetTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TranscodeJobList") && dict["TranscodeJobList"] != nil {
                var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList] = []
                for v in dict["TranscodeJobList"] as! [Any] {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeJobList = tmp
            }
            if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeParentJob: GetTranscodeJobResponseBody.TranscodeParentJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeParentJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeParentJob != nil {
            map["TranscodeParentJob"] = self.transcodeParentJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeParentJob") && dict["TranscodeParentJob"] != nil {
            var model = GetTranscodeJobResponseBody.TranscodeParentJob()
            model.fromMap(dict["TranscodeParentJob"] as! [String: Any])
            self.transcodeParentJob = model
        }
    }
}

public class GetTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUrlUploadInfosRequest : Tea.TeaModel {
    public var jobIds: String?

    public var uploadURLs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.uploadURLs != nil {
            map["UploadURLs"] = self.uploadURLs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") && dict["JobIds"] != nil {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("UploadURLs") && dict["UploadURLs"] != nil {
            self.uploadURLs = dict["UploadURLs"] as! String
        }
    }
}

public class GetUrlUploadInfosResponseBody : Tea.TeaModel {
    public class URLUploadInfoList : Tea.TeaModel {
        public var completeTime: String?

        public var creationTime: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var fileSize: String?

        public var jobId: String?

        public var mediaId: String?

        public var status: String?

        public var uploadURL: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uploadURL != nil {
                map["UploadURL"] = self.uploadURL!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                self.fileSize = dict["FileSize"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UploadURL") && dict["UploadURL"] != nil {
                self.uploadURL = dict["UploadURL"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var nonExists: [String]?

    public var requestId: String?

    public var URLUploadInfoList: [GetUrlUploadInfosResponseBody.URLUploadInfoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExists != nil {
            map["NonExists"] = self.nonExists!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.URLUploadInfoList != nil {
            var tmp : [Any] = []
            for k in self.URLUploadInfoList! {
                tmp.append(k.toMap())
            }
            map["URLUploadInfoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExists") && dict["NonExists"] != nil {
            self.nonExists = dict["NonExists"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("URLUploadInfoList") && dict["URLUploadInfoList"] != nil {
            var tmp : [GetUrlUploadInfosResponseBody.URLUploadInfoList] = []
            for v in dict["URLUploadInfoList"] as! [Any] {
                var model = GetUrlUploadInfosResponseBody.URLUploadInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.URLUploadInfoList = tmp
        }
    }
}

public class GetUrlUploadInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUrlUploadInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUrlUploadInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkflowTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetWorkflowTaskResponseBody : Tea.TeaModel {
    public class WorkflowTask : Tea.TeaModel {
        public class Workflow : Tea.TeaModel {
            public var createTime: String?

            public var modifiedTime: String?

            public var name: String?

            public var status: String?

            public var type: String?

            public var workflowId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("WorkflowId") && dict["WorkflowId"] != nil {
                    self.workflowId = dict["WorkflowId"] as! String
                }
            }
        }
        public var activityResults: String?

        public var createTime: String?

        public var finishTime: String?

        public var status: String?

        public var taskId: String?

        public var taskInput: String?

        public var userData: String?

        public var workflow: GetWorkflowTaskResponseBody.WorkflowTask.Workflow?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.workflow?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityResults != nil {
                map["ActivityResults"] = self.activityResults!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskInput != nil {
                map["TaskInput"] = self.taskInput!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.workflow != nil {
                map["Workflow"] = self.workflow?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityResults") && dict["ActivityResults"] != nil {
                self.activityResults = dict["ActivityResults"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskInput") && dict["TaskInput"] != nil {
                self.taskInput = dict["TaskInput"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("Workflow") && dict["Workflow"] != nil {
                var model = GetWorkflowTaskResponseBody.WorkflowTask.Workflow()
                model.fromMap(dict["Workflow"] as! [String: Any])
                self.workflow = model
            }
        }
    }
    public var requestId: String?

    public var workflowTask: GetWorkflowTaskResponseBody.WorkflowTask?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workflowTask?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.workflowTask != nil {
            map["WorkflowTask"] = self.workflowTask?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WorkflowTask") && dict["WorkflowTask"] != nil {
            var model = GetWorkflowTaskResponseBody.WorkflowTask()
            model.fromMap(dict["WorkflowTask"] as! [String: Any])
            self.workflowTask = model
        }
    }
}

public class GetWorkflowTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkflowTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetWorkflowTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAllPublicMediaTagsRequest : Tea.TeaModel {
    public var businessType: String?

    public var entityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("EntityId") && dict["EntityId"] != nil {
            self.entityId = dict["EntityId"] as! String
        }
    }
}

public class ListAllPublicMediaTagsResponseBody : Tea.TeaModel {
    public class MediaTagList : Tea.TeaModel {
        public class Options : Tea.TeaModel {
            public var optionChineseName: String?

            public var optionEnglishName: String?

            public var optionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.optionChineseName != nil {
                    map["OptionChineseName"] = self.optionChineseName!
                }
                if self.optionEnglishName != nil {
                    map["OptionEnglishName"] = self.optionEnglishName!
                }
                if self.optionId != nil {
                    map["OptionId"] = self.optionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OptionChineseName") && dict["OptionChineseName"] != nil {
                    self.optionChineseName = dict["OptionChineseName"] as! String
                }
                if dict.keys.contains("OptionEnglishName") && dict["OptionEnglishName"] != nil {
                    self.optionEnglishName = dict["OptionEnglishName"] as! String
                }
                if dict.keys.contains("OptionId") && dict["OptionId"] != nil {
                    self.optionId = dict["OptionId"] as! String
                }
            }
        }
        public var mediaTagId: String?

        public var mediaTagNameChinese: String?

        public var mediaTagNameEnglish: String?

        public var options: [ListAllPublicMediaTagsResponseBody.MediaTagList.Options]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaTagId != nil {
                map["MediaTagId"] = self.mediaTagId!
            }
            if self.mediaTagNameChinese != nil {
                map["MediaTagNameChinese"] = self.mediaTagNameChinese!
            }
            if self.mediaTagNameEnglish != nil {
                map["MediaTagNameEnglish"] = self.mediaTagNameEnglish!
            }
            if self.options != nil {
                var tmp : [Any] = []
                for k in self.options! {
                    tmp.append(k.toMap())
                }
                map["Options"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaTagId") && dict["MediaTagId"] != nil {
                self.mediaTagId = dict["MediaTagId"] as! String
            }
            if dict.keys.contains("MediaTagNameChinese") && dict["MediaTagNameChinese"] != nil {
                self.mediaTagNameChinese = dict["MediaTagNameChinese"] as! String
            }
            if dict.keys.contains("MediaTagNameEnglish") && dict["MediaTagNameEnglish"] != nil {
                self.mediaTagNameEnglish = dict["MediaTagNameEnglish"] as! String
            }
            if dict.keys.contains("Options") && dict["Options"] != nil {
                var tmp : [ListAllPublicMediaTagsResponseBody.MediaTagList.Options] = []
                for v in dict["Options"] as! [Any] {
                    var model = ListAllPublicMediaTagsResponseBody.MediaTagList.Options()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.options = tmp
            }
        }
    }
    public var mediaTagList: [ListAllPublicMediaTagsResponseBody.MediaTagList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaTagList != nil {
            var tmp : [Any] = []
            for k in self.mediaTagList! {
                tmp.append(k.toMap())
            }
            map["MediaTagList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaTagList") && dict["MediaTagList"] != nil {
            var tmp : [ListAllPublicMediaTagsResponseBody.MediaTagList] = []
            for v in dict["MediaTagList"] as! [Any] {
                var model = ListAllPublicMediaTagsResponseBody.MediaTagList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaTagList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAllPublicMediaTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllPublicMediaTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAllPublicMediaTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomTemplatesRequest : Tea.TeaModel {
    public var name: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var subtype: String?

    public var templateId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Subtype") && dict["Subtype"] != nil {
            self.subtype = dict["Subtype"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListCustomTemplatesResponseBody : Tea.TeaModel {
    public class CustomTemplateList : Tea.TeaModel {
        public var createTime: String?

        public var isDefault: Bool?

        public var modifiedTime: String?

        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") && dict["Subtype"] != nil {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") && dict["SubtypeName"] != nil {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var customTemplateList: [ListCustomTemplatesResponseBody.CustomTemplateList]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplateList != nil {
            var tmp : [Any] = []
            for k in self.customTemplateList! {
                tmp.append(k.toMap())
            }
            map["CustomTemplateList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplateList") && dict["CustomTemplateList"] != nil {
            var tmp : [ListCustomTemplatesResponseBody.CustomTemplateList] = []
            for v in dict["CustomTemplateList"] as! [Any] {
                var model = ListCustomTemplatesResponseBody.CustomTemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customTemplateList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListCustomTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCustomTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDNADBRequest : Tea.TeaModel {
    public var DBIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBIds != nil {
            map["DBIds"] = self.DBIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBIds") && dict["DBIds"] != nil {
            self.DBIds = dict["DBIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListDNADBResponseBody : Tea.TeaModel {
    public class DBList : Tea.TeaModel {
        public var DBId: String?

        public var description_: String?

        public var model: Int32?

        public var name: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBId != nil {
                map["DBId"] = self.DBId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.model != nil {
                map["Model"] = self.model!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DBId") && dict["DBId"] != nil {
                self.DBId = dict["DBId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Model") && dict["Model"] != nil {
                self.model = dict["Model"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var DBList: [ListDNADBResponseBody.DBList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBList != nil {
            var tmp : [Any] = []
            for k in self.DBList! {
                tmp.append(k.toMap())
            }
            map["DBList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBList") && dict["DBList"] != nil {
            var tmp : [ListDNADBResponseBody.DBList] = []
            for v in dict["DBList"] as! [Any] {
                var model = ListDNADBResponseBody.DBList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.DBList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDNADBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDNADBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDNADBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDNAFilesRequest : Tea.TeaModel {
    public var DBId: String?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBId") && dict["DBId"] != nil {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListDNAFilesResponseBody : Tea.TeaModel {
    public class FileList : Tea.TeaModel {
        public class InputFile : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") && dict["Object"] != nil {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public var inputFile: ListDNAFilesResponseBody.FileList.InputFile?

        public var primaryKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inputFile?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputFile != nil {
                map["InputFile"] = self.inputFile?.toMap()
            }
            if self.primaryKey != nil {
                map["PrimaryKey"] = self.primaryKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputFile") && dict["InputFile"] != nil {
                var model = ListDNAFilesResponseBody.FileList.InputFile()
                model.fromMap(dict["InputFile"] as! [String: Any])
                self.inputFile = model
            }
            if dict.keys.contains("PrimaryKey") && dict["PrimaryKey"] != nil {
                self.primaryKey = dict["PrimaryKey"] as! String
            }
        }
    }
    public var fileList: [ListDNAFilesResponseBody.FileList]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileList != nil {
            var tmp : [Any] = []
            for k in self.fileList! {
                tmp.append(k.toMap())
            }
            map["FileList"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileList") && dict["FileList"] != nil {
            var tmp : [ListDNAFilesResponseBody.FileList] = []
            for v in dict["FileList"] as! [Any] {
                var model = ListDNAFilesResponseBody.FileList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fileList = tmp
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDNAFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDNAFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDNAFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDynamicImageJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") && dict["EndOfCreateTime"] != nil {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") && dict["StartOfCreateTime"] != nil {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListDynamicImageJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var input: ListDynamicImageJobsResponseBody.Jobs.Input?

        public var jobId: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: ListDynamicImageJobsResponseBody.Jobs.Output?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateId: String?

        public var triggerSource: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") && dict["Input"] != nil {
                var model = ListDynamicImageJobsResponseBody.Jobs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") && dict["Output"] != nil {
                var model = ListDynamicImageJobsResponseBody.Jobs.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                self.triggerSource = dict["TriggerSource"] as! String
            }
        }
    }
    public var jobs: [ListDynamicImageJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") && dict["Jobs"] != nil {
            var tmp : [ListDynamicImageJobsResponseBody.Jobs] = []
            for v in dict["Jobs"] as! [Any] {
                var model = ListDynamicImageJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDynamicImageJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDynamicImageJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDynamicImageJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordFilesRequest : Tea.TeaModel {
    public var endTime: String?

    public var jobIds: [String]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var recordFormat: String?

    public var sortBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordFormat != nil {
            map["RecordFormat"] = self.recordFormat!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("JobIds") && dict["JobIds"] != nil {
            self.jobIds = dict["JobIds"] as! [String]
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecordFormat") && dict["RecordFormat"] != nil {
            self.recordFormat = dict["RecordFormat"] as! String
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListLiveRecordFilesResponseBody : Tea.TeaModel {
    public class Files : Tea.TeaModel {
        public var createTime: String?

        public var duration: Double?

        public var endTime: String?

        public var format: String?

        public var height: Int32?

        public var jobId: String?

        public var jobName: String?

        public var recordId: String?

        public var recordOutput: String?

        public var recordUrl: String?

        public var startTime: String?

        public var streamUrl: String?

        public var width: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.recordOutput != nil {
                map["RecordOutput"] = self.recordOutput!
            }
            if self.recordUrl != nil {
                map["RecordUrl"] = self.recordUrl!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.streamUrl != nil {
                map["StreamUrl"] = self.streamUrl!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("Format") && dict["Format"] != nil {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Height") && dict["Height"] != nil {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobName") && dict["JobName"] != nil {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("RecordOutput") && dict["RecordOutput"] != nil {
                self.recordOutput = dict["RecordOutput"] as! String
            }
            if dict.keys.contains("RecordUrl") && dict["RecordUrl"] != nil {
                self.recordUrl = dict["RecordUrl"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("StreamUrl") && dict["StreamUrl"] != nil {
                self.streamUrl = dict["StreamUrl"] as! String
            }
            if dict.keys.contains("Width") && dict["Width"] != nil {
                self.width = dict["Width"] as! Int32
            }
        }
    }
    public var files: [ListLiveRecordFilesResponseBody.Files]?

    public var pageNo: Int64?

    public var pageSize: String?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.files != nil {
            var tmp : [Any] = []
            for k in self.files! {
                tmp.append(k.toMap())
            }
            map["Files"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Files") && dict["Files"] != nil {
            var tmp : [ListLiveRecordFilesResponseBody.Files] = []
            for v in dict["Files"] as! [Any] {
                var model = ListLiveRecordFilesResponseBody.Files()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.files = tmp
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListLiveRecordFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLiveRecordFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListLiveRecordJobsResponseBody : Tea.TeaModel {
    public class LiveRecordJobs : Tea.TeaModel {
        public class RecordOutput : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var notifyUrl: String?

        public var recordOutput: ListLiveRecordJobsResponseBody.LiveRecordJobs.RecordOutput?

        public var status: String?

        public var streamInput: ListLiveRecordJobsResponseBody.LiveRecordJobs.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordOutput?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            if self.recordOutput != nil {
                map["RecordOutput"] = self.recordOutput?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyUrl") && dict["NotifyUrl"] != nil {
                self.notifyUrl = dict["NotifyUrl"] as! String
            }
            if dict.keys.contains("RecordOutput") && dict["RecordOutput"] != nil {
                var model = ListLiveRecordJobsResponseBody.LiveRecordJobs.RecordOutput()
                model.fromMap(dict["RecordOutput"] as! [String: Any])
                self.recordOutput = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
                var model = ListLiveRecordJobsResponseBody.LiveRecordJobs.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var liveRecordJobs: [ListLiveRecordJobsResponseBody.LiveRecordJobs]?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveRecordJobs != nil {
            var tmp : [Any] = []
            for k in self.liveRecordJobs! {
                tmp.append(k.toMap())
            }
            map["LiveRecordJobs"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveRecordJobs") && dict["LiveRecordJobs"] != nil {
            var tmp : [ListLiveRecordJobsResponseBody.LiveRecordJobs] = []
            for v in dict["LiveRecordJobs"] as! [Any] {
                var model = ListLiveRecordJobsResponseBody.LiveRecordJobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.liveRecordJobs = tmp
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveRecordJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLiveRecordJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordTemplatesRequest : Tea.TeaModel {
    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var templateIds: [String]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TemplateIds") && dict["TemplateIds"] != nil {
            self.templateIds = dict["TemplateIds"] as! [String]
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListLiveRecordTemplatesResponseBody : Tea.TeaModel {
    public class RecordTemplateList : Tea.TeaModel {
        public class RecordFormatList : Tea.TeaModel {
            public var cycleDuration: Int32?

            public var format: String?

            public var ossObjectPrefix: String?

            public var sliceDuration: Int32?

            public var sliceOssObjectPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleDuration != nil {
                    map["CycleDuration"] = self.cycleDuration!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.ossObjectPrefix != nil {
                    map["OssObjectPrefix"] = self.ossObjectPrefix!
                }
                if self.sliceDuration != nil {
                    map["SliceDuration"] = self.sliceDuration!
                }
                if self.sliceOssObjectPrefix != nil {
                    map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CycleDuration") && dict["CycleDuration"] != nil {
                    self.cycleDuration = dict["CycleDuration"] as! Int32
                }
                if dict.keys.contains("Format") && dict["Format"] != nil {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("OssObjectPrefix") && dict["OssObjectPrefix"] != nil {
                    self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
                }
                if dict.keys.contains("SliceDuration") && dict["SliceDuration"] != nil {
                    self.sliceDuration = dict["SliceDuration"] as! Int32
                }
                if dict.keys.contains("SliceOssObjectPrefix") && dict["SliceOssObjectPrefix"] != nil {
                    self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
                }
            }
        }
        public var createTime: String?

        public var lastModified: String?

        public var name: String?

        public var recordFormatList: [ListLiveRecordTemplatesResponseBody.RecordTemplateList.RecordFormatList]?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordFormatList != nil {
                var tmp : [Any] = []
                for k in self.recordFormatList! {
                    tmp.append(k.toMap())
                }
                map["RecordFormatList"] = tmp
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModified") && dict["LastModified"] != nil {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordFormatList") && dict["RecordFormatList"] != nil {
                var tmp : [ListLiveRecordTemplatesResponseBody.RecordTemplateList.RecordFormatList] = []
                for v in dict["RecordFormatList"] as! [Any] {
                    var model = ListLiveRecordTemplatesResponseBody.RecordTemplateList.RecordFormatList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recordFormatList = tmp
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var recordTemplateList: [ListLiveRecordTemplatesResponseBody.RecordTemplateList]?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordTemplateList != nil {
            var tmp : [Any] = []
            for k in self.recordTemplateList! {
                tmp.append(k.toMap())
            }
            map["RecordTemplateList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RecordTemplateList") && dict["RecordTemplateList"] != nil {
            var tmp : [ListLiveRecordTemplatesResponseBody.RecordTemplateList] = []
            for v in dict["RecordTemplateList"] as! [Any] {
                var model = ListLiveRecordTemplatesResponseBody.RecordTemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordTemplateList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveRecordTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLiveRecordTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveSnapshotFilesRequest : Tea.TeaModel {
    public var endTime: String?

    public var jobId: String?

    public var limit: Int32?

    public var sortBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Limit") && dict["Limit"] != nil {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListLiveSnapshotFilesResponseBody : Tea.TeaModel {
    public class FileList : Tea.TeaModel {
        public var createTime: String?

        public var createTimestamp: Int64?

        public var isOverlay: Bool?

        public var ossBucket: String?

        public var ossEndpoint: String?

        public var ossObject: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.isOverlay != nil {
                map["IsOverlay"] = self.isOverlay!
            }
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossEndpoint != nil {
                map["OssEndpoint"] = self.ossEndpoint!
            }
            if self.ossObject != nil {
                map["OssObject"] = self.ossObject!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateTimestamp") && dict["CreateTimestamp"] != nil {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("IsOverlay") && dict["IsOverlay"] != nil {
                self.isOverlay = dict["IsOverlay"] as! Bool
            }
            if dict.keys.contains("OssBucket") && dict["OssBucket"] != nil {
                self.ossBucket = dict["OssBucket"] as! String
            }
            if dict.keys.contains("OssEndpoint") && dict["OssEndpoint"] != nil {
                self.ossEndpoint = dict["OssEndpoint"] as! String
            }
            if dict.keys.contains("OssObject") && dict["OssObject"] != nil {
                self.ossObject = dict["OssObject"] as! String
            }
        }
    }
    public var fileList: [ListLiveSnapshotFilesResponseBody.FileList]?

    public var nextStartTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileList != nil {
            var tmp : [Any] = []
            for k in self.fileList! {
                tmp.append(k.toMap())
            }
            map["FileList"] = tmp
        }
        if self.nextStartTime != nil {
            map["NextStartTime"] = self.nextStartTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileList") && dict["FileList"] != nil {
            var tmp : [ListLiveSnapshotFilesResponseBody.FileList] = []
            for v in dict["FileList"] as! [Any] {
                var model = ListLiveSnapshotFilesResponseBody.FileList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fileList = tmp
        }
        if dict.keys.contains("NextStartTime") && dict["NextStartTime"] != nil {
            self.nextStartTime = dict["NextStartTime"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListLiveSnapshotFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveSnapshotFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLiveSnapshotFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveSnapshotJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchKeyWord: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKeyWord") && dict["SearchKeyWord"] != nil {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListLiveSnapshotJobsResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class SnapshotOutput : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var storageType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.storageType != nil {
                    map["StorageType"] = self.storageType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("StorageType") && dict["StorageType"] != nil {
                    self.storageType = dict["StorageType"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var jobName: String?

        public var snapshotOutput: ListLiveSnapshotJobsResponseBody.JobList.SnapshotOutput?

        public var status: String?

        public var templateId: String?

        public var templateName: String?

        public var timeInterval: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.snapshotOutput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.snapshotOutput != nil {
                map["SnapshotOutput"] = self.snapshotOutput?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.timeInterval != nil {
                map["TimeInterval"] = self.timeInterval!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobName") && dict["JobName"] != nil {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("SnapshotOutput") && dict["SnapshotOutput"] != nil {
                var model = ListLiveSnapshotJobsResponseBody.JobList.SnapshotOutput()
                model.fromMap(dict["SnapshotOutput"] as! [String: Any])
                self.snapshotOutput = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TimeInterval") && dict["TimeInterval"] != nil {
                self.timeInterval = dict["TimeInterval"] as! Int32
            }
        }
    }
    public var jobList: [ListLiveSnapshotJobsResponseBody.JobList]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            var tmp : [Any] = []
            for k in self.jobList! {
                tmp.append(k.toMap())
            }
            map["JobList"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") && dict["JobList"] != nil {
            var tmp : [ListLiveSnapshotJobsResponseBody.JobList] = []
            for v in dict["JobList"] as! [Any] {
                var model = ListLiveSnapshotJobsResponseBody.JobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobList = tmp
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveSnapshotJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveSnapshotJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLiveSnapshotJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveSnapshotTemplatesRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchKeyWord: String?

    public var sortBy: String?

    public var templateIds: [String]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKeyWord") && dict["SearchKeyWord"] != nil {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TemplateIds") && dict["TemplateIds"] != nil {
            self.templateIds = dict["TemplateIds"] as! [String]
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListLiveSnapshotTemplatesResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public var createTime: String?

        public var templateId: String?

        public var templateName: String?

        public var timeInterval: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.timeInterval != nil {
                map["TimeInterval"] = self.timeInterval!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TimeInterval") && dict["TimeInterval"] != nil {
                self.timeInterval = dict["TimeInterval"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sortBy: String?

    public var templateList: [ListLiveSnapshotTemplatesResponseBody.TemplateList]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.templateList != nil {
            var tmp : [Any] = []
            for k in self.templateList! {
                tmp.append(k.toMap())
            }
            map["TemplateList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TemplateList") && dict["TemplateList"] != nil {
            var tmp : [ListLiveSnapshotTemplatesResponseBody.TemplateList] = []
            for v in dict["TemplateList"] as! [Any] {
                var model = ListLiveSnapshotTemplatesResponseBody.TemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateList = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveSnapshotTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveSnapshotTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLiveSnapshotTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveTranscodeJobsRequest : Tea.TeaModel {
    public var keyWord: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var startMode: Int32?

    public var status: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startMode != nil {
            map["StartMode"] = self.startMode!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyWord") && dict["KeyWord"] != nil {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartMode") && dict["StartMode"] != nil {
            self.startMode = dict["StartMode"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListLiveTranscodeJobsResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class OutputStream : Tea.TeaModel {
            public class StreamInfos : Tea.TeaModel {
                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OutputUrl") && dict["OutputUrl"] != nil {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var streamInfos: [ListLiveTranscodeJobsResponseBody.JobList.OutputStream.StreamInfos]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.streamInfos != nil {
                    var tmp : [Any] = []
                    for k in self.streamInfos! {
                        tmp.append(k.toMap())
                    }
                    map["StreamInfos"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("StreamInfos") && dict["StreamInfos"] != nil {
                    var tmp : [ListLiveTranscodeJobsResponseBody.JobList.OutputStream.StreamInfos] = []
                    for v in dict["StreamInfos"] as! [Any] {
                        var model = ListLiveTranscodeJobsResponseBody.JobList.OutputStream.StreamInfos()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.streamInfos = tmp
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var inputUrl: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputUrl") && dict["InputUrl"] != nil {
                    self.inputUrl = dict["InputUrl"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var outputStream: ListLiveTranscodeJobsResponseBody.JobList.OutputStream?

        public var startMode: Int32?

        public var status: Int32?

        public var streamInput: ListLiveTranscodeJobsResponseBody.JobList.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.outputStream?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputStream != nil {
                map["OutputStream"] = self.outputStream?.toMap()
            }
            if self.startMode != nil {
                map["StartMode"] = self.startMode!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputStream") && dict["OutputStream"] != nil {
                var model = ListLiveTranscodeJobsResponseBody.JobList.OutputStream()
                model.fromMap(dict["OutputStream"] as! [String: Any])
                self.outputStream = model
            }
            if dict.keys.contains("StartMode") && dict["StartMode"] != nil {
                self.startMode = dict["StartMode"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
                var model = ListLiveTranscodeJobsResponseBody.JobList.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var jobList: [ListLiveTranscodeJobsResponseBody.JobList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            var tmp : [Any] = []
            for k in self.jobList! {
                tmp.append(k.toMap())
            }
            map["JobList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") && dict["JobList"] != nil {
            var tmp : [ListLiveTranscodeJobsResponseBody.JobList] = []
            for v in dict["JobList"] as! [Any] {
                var model = ListLiveTranscodeJobsResponseBody.JobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListLiveTranscodeJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveTranscodeJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLiveTranscodeJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveTranscodeTemplatesRequest : Tea.TeaModel {
    public var category: String?

    public var keyWord: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var type: String?

    public var videoCodec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.videoCodec != nil {
            map["VideoCodec"] = self.videoCodec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("KeyWord") && dict["KeyWord"] != nil {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VideoCodec") && dict["VideoCodec"] != nil {
            self.videoCodec = dict["VideoCodec"] as! String
        }
    }
}

public class ListLiveTranscodeTemplatesResponseBody : Tea.TeaModel {
    public class TemplateContentList : Tea.TeaModel {
        public class TemplateConfig : Tea.TeaModel {
            public class AudioParams : Tea.TeaModel {
                public var bitrate: String?

                public var channels: String?

                public var codec: String?

                public var profile: String?

                public var samplerate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.samplerate != nil {
                        map["Samplerate"] = self.samplerate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Channels") && dict["Channels"] != nil {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("Codec") && dict["Codec"] != nil {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Profile") && dict["Profile"] != nil {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Samplerate") && dict["Samplerate"] != nil {
                        self.samplerate = dict["Samplerate"] as! String
                    }
                }
            }
            public class VideoParams : Tea.TeaModel {
                public var bitrate: String?

                public var codec: String?

                public var fps: String?

                public var gop: String?

                public var height: String?

                public var profile: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Codec") && dict["Codec"] != nil {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Fps") && dict["Fps"] != nil {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Gop") && dict["Gop"] != nil {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Profile") && dict["Profile"] != nil {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioParams: ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.AudioParams?

            public var videoParams: ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.VideoParams?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioParams?.validate()
                try self.videoParams?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioParams != nil {
                    map["AudioParams"] = self.audioParams?.toMap()
                }
                if self.videoParams != nil {
                    map["VideoParams"] = self.videoParams?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioParams") && dict["AudioParams"] != nil {
                    var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.AudioParams()
                    model.fromMap(dict["AudioParams"] as! [String: Any])
                    self.audioParams = model
                }
                if dict.keys.contains("VideoParams") && dict["VideoParams"] != nil {
                    var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.VideoParams()
                    model.fromMap(dict["VideoParams"] as! [String: Any])
                    self.videoParams = model
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var name: String?

        public var templateConfig: ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.templateConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig()
                model.fromMap(dict["TemplateConfig"] as! [String: Any])
                self.templateConfig = model
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateContentList: [ListLiveTranscodeTemplatesResponseBody.TemplateContentList]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateContentList != nil {
            var tmp : [Any] = []
            for k in self.templateContentList! {
                tmp.append(k.toMap())
            }
            map["TemplateContentList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateContentList") && dict["TemplateContentList"] != nil {
            var tmp : [ListLiveTranscodeTemplatesResponseBody.TemplateContentList] = []
            for v in dict["TemplateContentList"] as! [Any] {
                var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateContentList = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListLiveTranscodeTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveTranscodeTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLiveTranscodeTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaBasicInfosRequest : Tea.TeaModel {
    public var businessType: String?

    public var endTime: String?

    public var includeFileBasicInfo: Bool?

    public var maxResults: Int32?

    public var mediaId: String?

    public var mediaType: String?

    public var nextToken: String?

    public var sortBy: String?

    public var source: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.includeFileBasicInfo != nil {
            map["IncludeFileBasicInfo"] = self.includeFileBasicInfo!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IncludeFileBasicInfo") && dict["IncludeFileBasicInfo"] != nil {
            self.includeFileBasicInfo = dict["IncludeFileBasicInfo"] as! Bool
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListMediaBasicInfosResponseBody : Tea.TeaModel {
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var createTime: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var modifiedTime: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") && dict["FileType"] != nil {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Region") && dict["Region"] != nil {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                    var model = ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var cateId: Int64?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var referenceId: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var uploadSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.uploadSource != nil {
                    map["UploadSource"] = self.uploadSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") && dict["Biz"] != nil {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("CateId") && dict["CateId"] != nil {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") && dict["DeletedTime"] != nil {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") && dict["InputURL"] != nil {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") && dict["MediaTags"] != nil {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ReferenceId") && dict["ReferenceId"] != nil {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") && dict["SpriteImages"] != nil {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") && dict["TranscodeStatus"] != nil {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UploadSource") && dict["UploadSource"] != nil {
                    self.uploadSource = dict["UploadSource"] as! String
                }
                if dict.keys.contains("UserData") && dict["UserData"] != nil {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: ListMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") && dict["FileInfoList"] != nil {
                var tmp : [ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") && dict["MediaBasicInfo"] != nil {
                var model = ListMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var mediaInfos: [ListMediaBasicInfosResponseBody.MediaInfos]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaInfos") && dict["MediaInfos"] != nil {
            var tmp : [ListMediaBasicInfosResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = ListMediaBasicInfosResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListMediaBasicInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaBasicInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMediaBasicInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaInfoJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") && dict["EndOfCreateTime"] != nil {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") && dict["StartOfCreateTime"] != nil {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListMediaInfoJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") && dict["ChannelLayout"] != nil {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") && dict["Channels"] != nil {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") && dict["SampleFmt"] != nil {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") && dict["SampleRate"] != nil {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") && dict["FileType"] != nil {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") && dict["Region"] != nil {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") && dict["Avg_fps"] != nil {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") && dict["Bit_rate"] != nil {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") && dict["Codec_long_name"] != nil {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") && dict["Codec_name"] != nil {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") && dict["Codec_tag"] != nil {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") && dict["Codec_tag_string"] != nil {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") && dict["Codec_time_base"] != nil {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") && dict["Dar"] != nil {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") && dict["Fps"] != nil {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") && dict["Has_b_frames"] != nil {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") && dict["NumFrames"] != nil {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") && dict["Profile"] != nil {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") && dict["Rotate"] != nil {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") && dict["Sar"] != nil {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") && dict["Start_time"] != nil {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") && dict["Time_base"] != nil {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") && dict["AudioStreamInfoList"] != nil {
                    var tmp : [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                    var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") && dict["VideoStreamInfoList"] != nil {
                    var tmp : [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") && dict["Priority"] != nil {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: ListMediaInfoJobsResponseBody.Jobs.Input?

        public var jobId: String?

        public var mediaInfoProperty: ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: ListMediaInfoJobsResponseBody.Jobs.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") && dict["Async"] != nil {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") && dict["Input"] != nil {
                var model = ListMediaInfoJobsResponseBody.Jobs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") && dict["MediaInfoProperty"] != nil {
                var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
                var model = ListMediaInfoJobsResponseBody.Jobs.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") && dict["SubmitResultJson"] != nil {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var jobs: [ListMediaInfoJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") && dict["Jobs"] != nil {
            var tmp : [ListMediaInfoJobsResponseBody.Jobs] = []
            for v in dict["Jobs"] as! [Any] {
                var model = ListMediaInfoJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaInfoJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaInfoJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMediaInfoJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") && dict["MediaMarkIds"] != nil {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
    }
}

public class ListMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") && dict["MediaMarks"] != nil {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPackageJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") && dict["EndOfCreateTime"] != nil {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") && dict["StartOfCreateTime"] != nil {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListPackageJobsResponseBody : Tea.TeaModel {
    public class PackageJobList : Tea.TeaModel {
        public class PackageJobs : Tea.TeaModel {
            public class Inputs : Tea.TeaModel {
                public class Input : Tea.TeaModel {
                    public var media: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.media != nil {
                            map["Media"] = self.media!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Media") && dict["Media"] != nil {
                            self.media = dict["Media"] as! String
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var input: ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs.Input?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.input?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.input != nil {
                        map["Input"] = self.input?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Input") && dict["Input"] != nil {
                        var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs.Input()
                        model.fromMap(dict["Input"] as! [String: Any])
                        self.input = model
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") && dict["Media"] != nil {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var code: String?

            public var createTime: String?

            public var finishTime: String?

            public var inputs: [ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs]?

            public var jobId: String?

            public var message: String?

            public var modifiedTime: String?

            public var name: String?

            public var output: ListPackageJobsResponseBody.PackageJobList.PackageJobs.Output?

            public var pipelineId: String?

            public var priority: Int32?

            public var status: String?

            public var submitTime: String?

            public var triggerSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inputs != nil {
                    var tmp : [Any] = []
                    for k in self.inputs! {
                        tmp.append(k.toMap())
                    }
                    map["Inputs"] = tmp
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.triggerSource != nil {
                    map["TriggerSource"] = self.triggerSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Inputs") && dict["Inputs"] != nil {
                    var tmp : [ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs] = []
                    for v in dict["Inputs"] as! [Any] {
                        var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputs = tmp
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Output") && dict["Output"] != nil {
                    var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") && dict["Priority"] != nil {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                    self.triggerSource = dict["TriggerSource"] as! String
                }
                if dict.keys.contains("UserData") && dict["UserData"] != nil {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var nextPageToken: String?

        public var packageJobs: [ListPackageJobsResponseBody.PackageJobList.PackageJobs]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextPageToken != nil {
                map["NextPageToken"] = self.nextPageToken!
            }
            if self.packageJobs != nil {
                var tmp : [Any] = []
                for k in self.packageJobs! {
                    tmp.append(k.toMap())
                }
                map["PackageJobs"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
                self.nextPageToken = dict["NextPageToken"] as! String
            }
            if dict.keys.contains("PackageJobs") && dict["PackageJobs"] != nil {
                var tmp : [ListPackageJobsResponseBody.PackageJobList.PackageJobs] = []
                for v in dict["PackageJobs"] as! [Any] {
                    var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.packageJobs = tmp
            }
        }
    }
    public var packageJobList: ListPackageJobsResponseBody.PackageJobList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packageJobList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packageJobList != nil {
            map["PackageJobList"] = self.packageJobList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackageJobList") && dict["PackageJobList"] != nil {
            var model = ListPackageJobsResponseBody.PackageJobList()
            model.fromMap(dict["PackageJobList"] as! [String: Any])
            self.packageJobList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPackageJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPackageJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPackageJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelinesRequest : Tea.TeaModel {
    public var speed: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.speed != nil {
            map["Speed"] = self.speed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Speed") && dict["Speed"] != nil {
            self.speed = dict["Speed"] as! String
        }
    }
}

public class ListPipelinesResponseBody : Tea.TeaModel {
    public class PipelineList : Tea.TeaModel {
        public var createTime: String?

        public var modifiedTime: String?

        public var name: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var speed: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Speed") && dict["Speed"] != nil {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipelineList: [ListPipelinesResponseBody.PipelineList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineList != nil {
            var tmp : [Any] = []
            for k in self.pipelineList! {
                tmp.append(k.toMap())
            }
            map["PipelineList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineList") && dict["PipelineList"] != nil {
            var tmp : [ListPipelinesResponseBody.PipelineList] = []
            for v in dict["PipelineList"] as! [Any] {
                var model = ListPipelinesResponseBody.PipelineList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.pipelineList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPipelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPublicMediaBasicInfosRequest : Tea.TeaModel {
    public var includeFileBasicInfo: Bool?

    public var maxResults: Int32?

    public var mediaTagId: String?

    public var nextToken: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.includeFileBasicInfo != nil {
            map["IncludeFileBasicInfo"] = self.includeFileBasicInfo!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaTagId != nil {
            map["MediaTagId"] = self.mediaTagId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IncludeFileBasicInfo") && dict["IncludeFileBasicInfo"] != nil {
            self.includeFileBasicInfo = dict["IncludeFileBasicInfo"] as! Bool
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaTagId") && dict["MediaTagId"] != nil {
            self.mediaTagId = dict["MediaTagId"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListPublicMediaBasicInfosResponseBody : Tea.TeaModel {
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") && dict["FileType"] != nil {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") && dict["Region"] != nil {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                    var model = ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") && dict["DeletedTime"] != nil {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") && dict["InputURL"] != nil {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") && dict["MediaTags"] != nil {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") && dict["TranscodeStatus"] != nil {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") && dict["UserData"] != nil {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: ListPublicMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") && dict["FileInfoList"] != nil {
                var tmp : [ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") && dict["MediaBasicInfo"] != nil {
                var model = ListPublicMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var mediaInfos: [ListPublicMediaBasicInfosResponseBody.MediaInfos]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaInfos") && dict["MediaInfos"] != nil {
            var tmp : [ListPublicMediaBasicInfosResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = ListPublicMediaBasicInfosResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListPublicMediaBasicInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPublicMediaBasicInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPublicMediaBasicInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSmartJobsRequest : Tea.TeaModel {
    public var jobState: String?

    public var jobType: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobState != nil {
            map["JobState"] = self.jobState!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobState") && dict["JobState"] != nil {
            self.jobState = dict["JobState"] as! String
        }
        if dict.keys.contains("JobType") && dict["JobType"] != nil {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class ListSmartJobsResponseBody : Tea.TeaModel {
    public class SmartJobList : Tea.TeaModel {
        public class InputConfig : Tea.TeaModel {
            public var inputFile: String?

            public var keyword: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputFile != nil {
                    map["InputFile"] = self.inputFile!
                }
                if self.keyword != nil {
                    map["Keyword"] = self.keyword!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputFile") && dict["InputFile"] != nil {
                    self.inputFile = dict["InputFile"] as! String
                }
                if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
                    self.keyword = dict["Keyword"] as! String
                }
            }
        }
        public class OutputConfig : Tea.TeaModel {
            public var bucket: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Object") && dict["Object"] != nil {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public var createTime: String?

        public var description_: String?

        public var editingConfig: String?

        public var inputConfig: ListSmartJobsResponseBody.SmartJobList.InputConfig?

        public var jobId: String?

        public var jobState: String?

        public var jobType: String?

        public var modifiedTime: String?

        public var outputConfig: ListSmartJobsResponseBody.SmartJobList.OutputConfig?

        public var title: String?

        public var userData: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inputConfig?.validate()
            try self.outputConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.editingConfig != nil {
                map["EditingConfig"] = self.editingConfig!
            }
            if self.inputConfig != nil {
                map["InputConfig"] = self.inputConfig?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobState != nil {
                map["JobState"] = self.jobState!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputConfig != nil {
                map["OutputConfig"] = self.outputConfig?.toMap()
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EditingConfig") && dict["EditingConfig"] != nil {
                self.editingConfig = dict["EditingConfig"] as! String
            }
            if dict.keys.contains("InputConfig") && dict["InputConfig"] != nil {
                var model = ListSmartJobsResponseBody.SmartJobList.InputConfig()
                model.fromMap(dict["InputConfig"] as! [String: Any])
                self.inputConfig = model
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobState") && dict["JobState"] != nil {
                self.jobState = dict["JobState"] as! String
            }
            if dict.keys.contains("JobType") && dict["JobType"] != nil {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputConfig") && dict["OutputConfig"] != nil {
                var model = ListSmartJobsResponseBody.SmartJobList.OutputConfig()
                model.fromMap(dict["OutputConfig"] as! [String: Any])
                self.outputConfig = model
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var maxResults: String?

    public var nextToken: String?

    public var requestId: String?

    public var smartJobList: [ListSmartJobsResponseBody.SmartJobList]?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.smartJobList != nil {
            var tmp : [Any] = []
            for k in self.smartJobList! {
                tmp.append(k.toMap())
            }
            map["SmartJobList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SmartJobList") && dict["SmartJobList"] != nil {
            var tmp : [ListSmartJobsResponseBody.SmartJobList] = []
            for v in dict["SmartJobList"] as! [Any] {
                var model = ListSmartJobsResponseBody.SmartJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.smartJobList = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListSmartJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSmartJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSmartJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSmartSysAvatarModelsRequest : Tea.TeaModel {
    public var pageNo: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class ListSmartSysAvatarModelsResponseBody : Tea.TeaModel {
    public class SmartSysAvatarModelList : Tea.TeaModel {
        public var avatarId: String?

        public var avatarName: String?

        public var coverUrl: String?

        public var videoUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarId != nil {
                map["AvatarId"] = self.avatarId!
            }
            if self.avatarName != nil {
                map["AvatarName"] = self.avatarName!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.videoUrl != nil {
                map["VideoUrl"] = self.videoUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarId") && dict["AvatarId"] != nil {
                self.avatarId = dict["AvatarId"] as! String
            }
            if dict.keys.contains("AvatarName") && dict["AvatarName"] != nil {
                self.avatarName = dict["AvatarName"] as! String
            }
            if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("VideoUrl") && dict["VideoUrl"] != nil {
                self.videoUrl = dict["VideoUrl"] as! String
            }
        }
    }
    public var requestId: String?

    public var smartSysAvatarModelList: [ListSmartSysAvatarModelsResponseBody.SmartSysAvatarModelList]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.smartSysAvatarModelList != nil {
            var tmp : [Any] = []
            for k in self.smartSysAvatarModelList! {
                tmp.append(k.toMap())
            }
            map["SmartSysAvatarModelList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SmartSysAvatarModelList") && dict["SmartSysAvatarModelList"] != nil {
            var tmp : [ListSmartSysAvatarModelsResponseBody.SmartSysAvatarModelList] = []
            for v in dict["SmartSysAvatarModelList"] as! [Any] {
                var model = ListSmartSysAvatarModelsResponseBody.SmartSysAvatarModelList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.smartSysAvatarModelList = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListSmartSysAvatarModelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSmartSysAvatarModelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSmartSysAvatarModelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSnapshotJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") && dict["EndOfCreateTime"] != nil {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") && dict["StartOfCreateTime"] != nil {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListSnapshotJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var async: Bool?

        public var count: Int32?

        public var createTime: String?

        public var finishTime: String?

        public var input: ListSnapshotJobsResponseBody.Jobs.Input?

        public var jobId: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: ListSnapshotJobsResponseBody.Jobs.Output?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateId: String?

        public var triggerSource: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") && dict["Async"] != nil {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") && dict["Input"] != nil {
                var model = ListSnapshotJobsResponseBody.Jobs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") && dict["Output"] != nil {
                var model = ListSnapshotJobsResponseBody.Jobs.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var jobs: [ListSnapshotJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") && dict["Jobs"] != nil {
            var tmp : [ListSnapshotJobsResponseBody.Jobs] = []
            for v in dict["Jobs"] as! [Any] {
                var model = ListSnapshotJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSnapshotJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSnapshotJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSnapshotJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSystemTemplatesRequest : Tea.TeaModel {
    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var subtype: String?

    public var templateId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Subtype") && dict["Subtype"] != nil {
            self.subtype = dict["Subtype"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListSystemTemplatesResponseBody : Tea.TeaModel {
    public class SystemTemplateList : Tea.TeaModel {
        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") && dict["Subtype"] != nil {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") && dict["SubtypeName"] != nil {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var requestId: String?

    public var systemTemplateList: [ListSystemTemplatesResponseBody.SystemTemplateList]?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemTemplateList != nil {
            var tmp : [Any] = []
            for k in self.systemTemplateList! {
                tmp.append(k.toMap())
            }
            map["SystemTemplateList"] = tmp
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemTemplateList") && dict["SystemTemplateList"] != nil {
            var tmp : [ListSystemTemplatesResponseBody.SystemTemplateList] = []
            for v in dict["SystemTemplateList"] as! [Any] {
                var model = ListSystemTemplatesResponseBody.SystemTemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.systemTemplateList = tmp
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListSystemTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSystemTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSystemTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTemplatesRequest : Tea.TeaModel {
    public var createSource: String?

    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortType: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createSource != nil {
            map["CreateSource"] = self.createSource!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateSource") && dict["CreateSource"] != nil {
            self.createSource = dict["CreateSource"] as! String
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortType") && dict["SortType"] != nil {
            self.sortType = dict["SortType"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListTemplatesResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public var clipsParam: String?

        public var config: String?

        public var coverURL: String?

        public var createSource: String?

        public var creationTime: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var name: String?

        public var previewMedia: String?

        public var previewMediaStatus: String?

        public var status: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.previewMedia != nil {
                map["PreviewMedia"] = self.previewMedia!
            }
            if self.previewMediaStatus != nil {
                map["PreviewMediaStatus"] = self.previewMediaStatus!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") && dict["ClipsParam"] != nil {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") && dict["CreateSource"] != nil {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ModifiedSource") && dict["ModifiedSource"] != nil {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PreviewMedia") && dict["PreviewMedia"] != nil {
                self.previewMedia = dict["PreviewMedia"] as! String
            }
            if dict.keys.contains("PreviewMediaStatus") && dict["PreviewMediaStatus"] != nil {
                self.previewMediaStatus = dict["PreviewMediaStatus"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var templates: [ListTemplatesResponseBody.Templates]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templates != nil {
            var tmp : [Any] = []
            for k in self.templates! {
                tmp.append(k.toMap())
            }
            map["Templates"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Templates") && dict["Templates"] != nil {
            var tmp : [ListTemplatesResponseBody.Templates] = []
            for v in dict["Templates"] as! [Any] {
                var model = ListTemplatesResponseBody.Templates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templates = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTranscodeJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var parentJobId: String?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentJobId != nil {
            map["ParentJobId"] = self.parentJobId!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") && dict["EndOfCreateTime"] != nil {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ParentJobId") && dict["ParentJobId"] != nil {
            self.parentJobId = dict["ParentJobId"] as! String
        }
        if dict.keys.contains("StartOfCreateTime") && dict["StartOfCreateTime"] != nil {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListTranscodeJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class InputGroup : Tea.TeaModel {
            public var inputUrl: String?

            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputUrl") && dict["InputUrl"] != nil {
                    self.inputUrl = dict["InputUrl"] as! String
                }
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class OutputGroup : Tea.TeaModel {
            public class Output : Tea.TeaModel {
                public var media: String?

                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") && dict["Media"] != nil {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("OutputUrl") && dict["OutputUrl"] != nil {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") && dict["AudioIndex"] != nil {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") && dict["Start"] != nil {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") && dict["VideoIndex"] != nil {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") && dict["CipherText"] != nil {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") && dict["DecryptKeyUri"] != nil {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") && dict["EncryptType"] != nil {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") && dict["Media"] != nil {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") && dict["Type"] != nil {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") && dict["Start"] != nil {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") && dict["Dx"] != nil {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") && dict["Dy"] != nil {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") && dict["File"] != nil {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") && dict["Height"] != nil {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") && dict["ReferPos"] != nil {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") && dict["Width"] != nil {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") && dict["Media"] != nil {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") && dict["Type"] != nil {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") && dict["CharEnc"] != nil {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") && dict["File"] != nil {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") && dict["Format"] != nil {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") && dict["Adaptive"] != nil {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") && dict["BorderColor"] != nil {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") && dict["BorderWidth"] != nil {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") && dict["Content"] != nil {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") && dict["FontAlpha"] != nil {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") && dict["FontColor"] != nil {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") && dict["FontName"] != nil {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") && dict["FontSize"] != nil {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") && dict["Left"] != nil {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") && dict["Top"] != nil {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") && dict["IntegratedLoudnessTarget"] != nil {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") && dict["LoudnessRangeTarget"] != nil {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") && dict["Method"] != nil {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") && dict["TruePeak"] != nil {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") && dict["Channels"] != nil {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") && dict["Remove"] != nil {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") && dict["Samplerate"] != nil {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") && dict["Volume"] != nil {
                                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") && dict["Format"] != nil {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") && dict["ForceSegTime"] != nil {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") && dict["Segment"] != nil {
                                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") && dict["AbrMax"] != nil {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") && dict["Bufsize"] != nil {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") && dict["Crf"] != nil {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") && dict["Crop"] != nil {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") && dict["Fps"] != nil {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") && dict["Gop"] != nil {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") && dict["Height"] != nil {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") && dict["LongShortMode"] != nil {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") && dict["Maxrate"] != nil {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") && dict["Pad"] != nil {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") && dict["Preset"] != nil {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") && dict["Remove"] != nil {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") && dict["ScanMode"] != nil {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") && dict["Width"] != nil {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var tags: [String: String]?

                        public var video: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.tags != nil {
                                map["Tags"] = self.tags!
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") && dict["Audio"] != nil {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") && dict["Container"] != nil {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") && dict["MuxConfig"] != nil {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                                self.tags = dict["Tags"] as! [String: String]
                            }
                            if dict.keys.contains("Video") && dict["Video"] != nil {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.CombineConfigs]?

                public var encryption: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Encryption?

                public var imageWatermarks: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks]?

                public var isInheritTags: Bool?

                public var subtitles: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles]?

                public var textWatermarks: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks]?

                public var transcode: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.isInheritTags != nil {
                        map["IsInheritTags"] = self.isInheritTags!
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") && dict["CombineConfigs"] != nil {
                        var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") && dict["Encryption"] != nil {
                        var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") && dict["ImageWatermarks"] != nil {
                        var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("IsInheritTags") && dict["IsInheritTags"] != nil {
                        self.isInheritTags = dict["IsInheritTags"] as! Bool
                    }
                    if dict.keys.contains("Subtitles") && dict["Subtitles"] != nil {
                        var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") && dict["TextWatermarks"] != nil {
                        var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") && dict["Transcode"] != nil {
                        var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public var output: ListTranscodeJobsResponseBody.Jobs.OutputGroup.Output?

            public var processConfig: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
                try self.processConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Output") && dict["Output"] != nil {
                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ProcessConfig") && dict["ProcessConfig"] != nil {
                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") && dict["Priority"] != nil {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var inputGroup: [ListTranscodeJobsResponseBody.Jobs.InputGroup]?

        public var jobCount: Int32?

        public var name: String?

        public var outputGroup: [ListTranscodeJobsResponseBody.Jobs.OutputGroup]?

        public var parentJobId: String?

        public var percent: Int32?

        public var requestId: String?

        public var scheduleConfig: ListTranscodeJobsResponseBody.Jobs.ScheduleConfig?

        public var status: String?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputGroup != nil {
                var tmp : [Any] = []
                for k in self.inputGroup! {
                    tmp.append(k.toMap())
                }
                map["InputGroup"] = tmp
            }
            if self.jobCount != nil {
                map["JobCount"] = self.jobCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroup != nil {
                var tmp : [Any] = []
                for k in self.outputGroup! {
                    tmp.append(k.toMap())
                }
                map["OutputGroup"] = tmp
            }
            if self.parentJobId != nil {
                map["ParentJobId"] = self.parentJobId!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("InputGroup") && dict["InputGroup"] != nil {
                var tmp : [ListTranscodeJobsResponseBody.Jobs.InputGroup] = []
                for v in dict["InputGroup"] as! [Any] {
                    var model = ListTranscodeJobsResponseBody.Jobs.InputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputGroup = tmp
            }
            if dict.keys.contains("JobCount") && dict["JobCount"] != nil {
                self.jobCount = dict["JobCount"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroup") && dict["OutputGroup"] != nil {
                var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup] = []
                for v in dict["OutputGroup"] as! [Any] {
                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroup = tmp
            }
            if dict.keys.contains("ParentJobId") && dict["ParentJobId"] != nil {
                self.parentJobId = dict["ParentJobId"] as! String
            }
            if dict.keys.contains("Percent") && dict["Percent"] != nil {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
                var model = ListTranscodeJobsResponseBody.Jobs.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var jobs: [ListTranscodeJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") && dict["Jobs"] != nil {
            var tmp : [ListTranscodeJobsResponseBody.Jobs] = []
            for v in dict["Jobs"] as! [Any] {
                var model = ListTranscodeJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTranscodeJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTranscodeJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTranscodeJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryDNAJobListRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") && dict["JobIds"] != nil {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryDNAJobListResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var code: String?

        public var config: String?

        public var creationTime: String?

        public var DBId: String?

        public var DNAResult: String?

        public var finishTime: String?

        public var id: String?

        public var input: QueryDNAJobListResponseBody.JobList.Input?

        public var message: String?

        public var primaryKey: String?

        public var status: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.DBId != nil {
                map["DBId"] = self.DBId!
            }
            if self.DNAResult != nil {
                map["DNAResult"] = self.DNAResult!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.primaryKey != nil {
                map["PrimaryKey"] = self.primaryKey!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DBId") && dict["DBId"] != nil {
                self.DBId = dict["DBId"] as! String
            }
            if dict.keys.contains("DNAResult") && dict["DNAResult"] != nil {
                self.DNAResult = dict["DNAResult"] as! String
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Input") && dict["Input"] != nil {
                var model = QueryDNAJobListResponseBody.JobList.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PrimaryKey") && dict["PrimaryKey"] != nil {
                self.primaryKey = dict["PrimaryKey"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var jobList: [QueryDNAJobListResponseBody.JobList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            var tmp : [Any] = []
            for k in self.jobList! {
                tmp.append(k.toMap())
            }
            map["JobList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") && dict["JobList"] != nil {
            var tmp : [QueryDNAJobListResponseBody.JobList] = []
            for v in dict["JobList"] as! [Any] {
                var model = QueryDNAJobListResponseBody.JobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryDNAJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDNAJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryDNAJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryIProductionJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class QueryIProductionJobResponseBody : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var createTime: String?

    public var finishTime: String?

    public var functionName: String?

    public var input: QueryIProductionJobResponseBody.Input?

    public var jobId: String?

    public var jobParams: String?

    public var name: String?

    public var output: QueryIProductionJobResponseBody.Output?

    public var outputFiles: [String]?

    public var outputUrls: [String]?

    public var requestId: String?

    public var result: String?

    public var scheduleConfig: QueryIProductionJobResponseBody.ScheduleConfig?

    public var status: String?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.finishTime != nil {
            map["FinishTime"] = self.finishTime!
        }
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.outputFiles != nil {
            map["OutputFiles"] = self.outputFiles!
        }
        if self.outputUrls != nil {
            map["OutputUrls"] = self.outputUrls!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
            self.finishTime = dict["FinishTime"] as! String
        }
        if dict.keys.contains("FunctionName") && dict["FunctionName"] != nil {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") && dict["Input"] != nil {
            var model = QueryIProductionJobResponseBody.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobParams") && dict["JobParams"] != nil {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") && dict["Output"] != nil {
            var model = QueryIProductionJobResponseBody.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("OutputFiles") && dict["OutputFiles"] != nil {
            self.outputFiles = dict["OutputFiles"] as! [String]
        }
        if dict.keys.contains("OutputUrls") && dict["OutputUrls"] != nil {
            self.outputUrls = dict["OutputUrls"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            var model = QueryIProductionJobResponseBody.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class QueryIProductionJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryIProductionJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryIProductionJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaCensorJobDetailRequest : Tea.TeaModel {
    public var jobId: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MaximumPageSize") && dict["MaximumPageSize"] != nil {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaCensorJobDetailResponseBody : Tea.TeaModel {
    public class MediaCensorJobDetail : Tea.TeaModel {
        public class BarrageCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") && dict["Rate"] != nil {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") && dict["Scene"] != nil {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class CoverImageCensorResults : Tea.TeaModel {
            public class CoverImageCensorResult : Tea.TeaModel {
                public class Results : Tea.TeaModel {
                    public class Result : Tea.TeaModel {
                        public var label: String?

                        public var rate: String?

                        public var scene: String?

                        public var suggestion: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.rate != nil {
                                map["Rate"] = self.rate!
                            }
                            if self.scene != nil {
                                map["Scene"] = self.scene!
                            }
                            if self.suggestion != nil {
                                map["Suggestion"] = self.suggestion!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") && dict["Label"] != nil {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Rate") && dict["Rate"] != nil {
                                self.rate = dict["Rate"] as! String
                            }
                            if dict.keys.contains("Scene") && dict["Scene"] != nil {
                                self.scene = dict["Scene"] as! String
                            }
                            if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                                self.suggestion = dict["Suggestion"] as! String
                            }
                        }
                    }
                    public var result: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.result != nil {
                            var tmp : [Any] = []
                            for k in self.result! {
                                tmp.append(k.toMap())
                            }
                            map["Result"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Result") && dict["Result"] != nil {
                            var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result] = []
                            for v in dict["Result"] as! [Any] {
                                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.result = tmp
                        }
                    }
                }
                public var bucket: String?

                public var location: String?

                public var object: String?

                public var results: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.results?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    if self.results != nil {
                        map["Results"] = self.results?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") && dict["Object"] != nil {
                        self.object = dict["Object"] as! String
                    }
                    if dict.keys.contains("Results") && dict["Results"] != nil {
                        var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results()
                        model.fromMap(dict["Results"] as! [String: Any])
                        self.results = model
                    }
                }
            }
            public var coverImageCensorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coverImageCensorResult != nil {
                    var tmp : [Any] = []
                    for k in self.coverImageCensorResult! {
                        tmp.append(k.toMap())
                    }
                    map["CoverImageCensorResult"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CoverImageCensorResult") && dict["CoverImageCensorResult"] != nil {
                    var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult] = []
                    for v in dict["CoverImageCensorResult"] as! [Any] {
                        var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.coverImageCensorResult = tmp
                }
            }
        }
        public class DescCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") && dict["Rate"] != nil {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") && dict["Scene"] != nil {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class Input : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") && dict["Object"] != nil {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public class TitleCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") && dict["Rate"] != nil {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") && dict["Scene"] != nil {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class VensorCensorResult : Tea.TeaModel {
            public class CensorResults : Tea.TeaModel {
                public class CensorResult : Tea.TeaModel {
                    public var label: String?

                    public var rate: String?

                    public var scene: String?

                    public var suggestion: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.rate != nil {
                            map["Rate"] = self.rate!
                        }
                        if self.scene != nil {
                            map["Scene"] = self.scene!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Rate") && dict["Rate"] != nil {
                            self.rate = dict["Rate"] as! String
                        }
                        if dict.keys.contains("Scene") && dict["Scene"] != nil {
                            self.scene = dict["Scene"] as! String
                        }
                        if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                    }
                }
                public var censorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.censorResult != nil {
                        var tmp : [Any] = []
                        for k in self.censorResult! {
                            tmp.append(k.toMap())
                        }
                        map["CensorResult"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CensorResult") && dict["CensorResult"] != nil {
                        var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult] = []
                        for v in dict["CensorResult"] as! [Any] {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.censorResult = tmp
                    }
                }
            }
            public class VideoTimelines : Tea.TeaModel {
                public class VideoTimeline : Tea.TeaModel {
                    public class CensorResults : Tea.TeaModel {
                        public class CensorResult : Tea.TeaModel {
                            public var label: String?

                            public var rate: String?

                            public var scene: String?

                            public var suggestion: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.label != nil {
                                    map["Label"] = self.label!
                                }
                                if self.rate != nil {
                                    map["Rate"] = self.rate!
                                }
                                if self.scene != nil {
                                    map["Scene"] = self.scene!
                                }
                                if self.suggestion != nil {
                                    map["Suggestion"] = self.suggestion!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Label") && dict["Label"] != nil {
                                    self.label = dict["Label"] as! String
                                }
                                if dict.keys.contains("Rate") && dict["Rate"] != nil {
                                    self.rate = dict["Rate"] as! String
                                }
                                if dict.keys.contains("Scene") && dict["Scene"] != nil {
                                    self.scene = dict["Scene"] as! String
                                }
                                if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                                    self.suggestion = dict["Suggestion"] as! String
                                }
                            }
                        }
                        public var censorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.censorResult != nil {
                                var tmp : [Any] = []
                                for k in self.censorResult! {
                                    tmp.append(k.toMap())
                                }
                                map["CensorResult"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CensorResult") && dict["CensorResult"] != nil {
                                var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult] = []
                                for v in dict["CensorResult"] as! [Any] {
                                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.censorResult = tmp
                            }
                        }
                    }
                    public var censorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults?

                    public var object: String?

                    public var timestamp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.censorResults?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.censorResults != nil {
                            map["CensorResults"] = self.censorResults?.toMap()
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CensorResults") && dict["CensorResults"] != nil {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults()
                            model.fromMap(dict["CensorResults"] as! [String: Any])
                            self.censorResults = model
                        }
                        if dict.keys.contains("Object") && dict["Object"] != nil {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                    }
                }
                public var videoTimeline: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.videoTimeline != nil {
                        var tmp : [Any] = []
                        for k in self.videoTimeline! {
                            tmp.append(k.toMap())
                        }
                        map["VideoTimeline"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VideoTimeline") && dict["VideoTimeline"] != nil {
                        var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline] = []
                        for v in dict["VideoTimeline"] as! [Any] {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.videoTimeline = tmp
                    }
                }
            }
            public var censorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults?

            public var nextPageToken: String?

            public var videoTimelines: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.censorResults?.validate()
                try self.videoTimelines?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.censorResults != nil {
                    map["CensorResults"] = self.censorResults?.toMap()
                }
                if self.nextPageToken != nil {
                    map["NextPageToken"] = self.nextPageToken!
                }
                if self.videoTimelines != nil {
                    map["VideoTimelines"] = self.videoTimelines?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CensorResults") && dict["CensorResults"] != nil {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults()
                    model.fromMap(dict["CensorResults"] as! [String: Any])
                    self.censorResults = model
                }
                if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
                    self.nextPageToken = dict["NextPageToken"] as! String
                }
                if dict.keys.contains("VideoTimelines") && dict["VideoTimelines"] != nil {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines()
                    model.fromMap(dict["VideoTimelines"] as! [String: Any])
                    self.videoTimelines = model
                }
            }
        }
        public class VideoCensorConfig : Tea.TeaModel {
            public class OutputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") && dict["Object"] != nil {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var bizType: String?

            public var outputFile: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig.OutputFile?

            public var videoCensor: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.outputFile != nil {
                    map["OutputFile"] = self.outputFile?.toMap()
                }
                if self.videoCensor != nil {
                    map["VideoCensor"] = self.videoCensor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizType") && dict["BizType"] != nil {
                    self.bizType = dict["BizType"] as! String
                }
                if dict.keys.contains("OutputFile") && dict["OutputFile"] != nil {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig.OutputFile()
                    model.fromMap(dict["OutputFile"] as! [String: Any])
                    self.outputFile = model
                }
                if dict.keys.contains("VideoCensor") && dict["VideoCensor"] != nil {
                    self.videoCensor = dict["VideoCensor"] as! String
                }
            }
        }
        public var barrageCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.BarrageCensorResult?

        public var code: String?

        public var coverImageCensorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults?

        public var creationTime: String?

        public var descCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.DescCensorResult?

        public var finishTime: String?

        public var input: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.Input?

        public var jobId: String?

        public var message: String?

        public var pipelineId: String?

        public var state: String?

        public var suggestion: String?

        public var titleCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.TitleCensorResult?

        public var userData: String?

        public var vensorCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult?

        public var videoCensorConfig: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.barrageCensorResult?.validate()
            try self.coverImageCensorResults?.validate()
            try self.descCensorResult?.validate()
            try self.input?.validate()
            try self.titleCensorResult?.validate()
            try self.vensorCensorResult?.validate()
            try self.videoCensorConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.barrageCensorResult != nil {
                map["BarrageCensorResult"] = self.barrageCensorResult?.toMap()
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.coverImageCensorResults != nil {
                map["CoverImageCensorResults"] = self.coverImageCensorResults?.toMap()
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.descCensorResult != nil {
                map["DescCensorResult"] = self.descCensorResult?.toMap()
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.suggestion != nil {
                map["Suggestion"] = self.suggestion!
            }
            if self.titleCensorResult != nil {
                map["TitleCensorResult"] = self.titleCensorResult?.toMap()
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.vensorCensorResult != nil {
                map["VensorCensorResult"] = self.vensorCensorResult?.toMap()
            }
            if self.videoCensorConfig != nil {
                map["VideoCensorConfig"] = self.videoCensorConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BarrageCensorResult") && dict["BarrageCensorResult"] != nil {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.BarrageCensorResult()
                model.fromMap(dict["BarrageCensorResult"] as! [String: Any])
                self.barrageCensorResult = model
            }
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CoverImageCensorResults") && dict["CoverImageCensorResults"] != nil {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults()
                model.fromMap(dict["CoverImageCensorResults"] as! [String: Any])
                self.coverImageCensorResults = model
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DescCensorResult") && dict["DescCensorResult"] != nil {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.DescCensorResult()
                model.fromMap(dict["DescCensorResult"] as! [String: Any])
                self.descCensorResult = model
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") && dict["Input"] != nil {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                self.suggestion = dict["Suggestion"] as! String
            }
            if dict.keys.contains("TitleCensorResult") && dict["TitleCensorResult"] != nil {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.TitleCensorResult()
                model.fromMap(dict["TitleCensorResult"] as! [String: Any])
                self.titleCensorResult = model
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("VensorCensorResult") && dict["VensorCensorResult"] != nil {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult()
                model.fromMap(dict["VensorCensorResult"] as! [String: Any])
                self.vensorCensorResult = model
            }
            if dict.keys.contains("VideoCensorConfig") && dict["VideoCensorConfig"] != nil {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig()
                model.fromMap(dict["VideoCensorConfig"] as! [String: Any])
                self.videoCensorConfig = model
            }
        }
    }
    public var mediaCensorJobDetail: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaCensorJobDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaCensorJobDetail != nil {
            map["MediaCensorJobDetail"] = self.mediaCensorJobDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaCensorJobDetail") && dict["MediaCensorJobDetail"] != nil {
            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail()
            model.fromMap(dict["MediaCensorJobDetail"] as! [String: Any])
            self.mediaCensorJobDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaCensorJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaCensorJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMediaCensorJobDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaCensorJobListRequest : Tea.TeaModel {
    public var endOfJobCreatedTimeRange: String?

    public var jobIds: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startOfJobCreatedTimeRange: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfJobCreatedTimeRange != nil {
            map["EndOfJobCreatedTimeRange"] = self.endOfJobCreatedTimeRange!
        }
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startOfJobCreatedTimeRange != nil {
            map["StartOfJobCreatedTimeRange"] = self.startOfJobCreatedTimeRange!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfJobCreatedTimeRange") && dict["EndOfJobCreatedTimeRange"] != nil {
            self.endOfJobCreatedTimeRange = dict["EndOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("JobIds") && dict["JobIds"] != nil {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("MaximumPageSize") && dict["MaximumPageSize"] != nil {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartOfJobCreatedTimeRange") && dict["StartOfJobCreatedTimeRange"] != nil {
            self.startOfJobCreatedTimeRange = dict["StartOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class QueryMediaCensorJobListResponseBody : Tea.TeaModel {
    public class MediaCensorJobList : Tea.TeaModel {
        public class MediaCensorJob : Tea.TeaModel {
            public class BarrageCensorResult : Tea.TeaModel {
                public var label: String?

                public var rate: String?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") && dict["Rate"] != nil {
                        self.rate = dict["Rate"] as! String
                    }
                    if dict.keys.contains("Scene") && dict["Scene"] != nil {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class CoverImageCensorResults : Tea.TeaModel {
                public class CoverImageCensorResult : Tea.TeaModel {
                    public class Results : Tea.TeaModel {
                        public class Result : Tea.TeaModel {
                            public var label: String?

                            public var rate: String?

                            public var scene: String?

                            public var suggestion: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.label != nil {
                                    map["Label"] = self.label!
                                }
                                if self.rate != nil {
                                    map["Rate"] = self.rate!
                                }
                                if self.scene != nil {
                                    map["Scene"] = self.scene!
                                }
                                if self.suggestion != nil {
                                    map["Suggestion"] = self.suggestion!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Label") && dict["Label"] != nil {
                                    self.label = dict["Label"] as! String
                                }
                                if dict.keys.contains("Rate") && dict["Rate"] != nil {
                                    self.rate = dict["Rate"] as! String
                                }
                                if dict.keys.contains("Scene") && dict["Scene"] != nil {
                                    self.scene = dict["Scene"] as! String
                                }
                                if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                                    self.suggestion = dict["Suggestion"] as! String
                                }
                            }
                        }
                        public var result: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results.Result]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.result != nil {
                                var tmp : [Any] = []
                                for k in self.result! {
                                    tmp.append(k.toMap())
                                }
                                map["Result"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Result") && dict["Result"] != nil {
                                var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results.Result] = []
                                for v in dict["Result"] as! [Any] {
                                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results.Result()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.result = tmp
                            }
                        }
                    }
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var results: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.results?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.results != nil {
                            map["Results"] = self.results?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") && dict["Location"] != nil {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") && dict["Object"] != nil {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("Results") && dict["Results"] != nil {
                            var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results()
                            model.fromMap(dict["Results"] as! [String: Any])
                            self.results = model
                        }
                    }
                }
                public var coverImageCensorResult: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.coverImageCensorResult != nil {
                        var tmp : [Any] = []
                        for k in self.coverImageCensorResult! {
                            tmp.append(k.toMap())
                        }
                        map["CoverImageCensorResult"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CoverImageCensorResult") && dict["CoverImageCensorResult"] != nil {
                        var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult] = []
                        for v in dict["CoverImageCensorResult"] as! [Any] {
                            var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.coverImageCensorResult = tmp
                    }
                }
            }
            public class DescCensorResult : Tea.TeaModel {
                public var label: String?

                public var rate: String?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") && dict["Rate"] != nil {
                        self.rate = dict["Rate"] as! String
                    }
                    if dict.keys.contains("Scene") && dict["Scene"] != nil {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") && dict["Object"] != nil {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public class TitleCensorResult : Tea.TeaModel {
                public var label: String?

                public var rate: String?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") && dict["Rate"] != nil {
                        self.rate = dict["Rate"] as! String
                    }
                    if dict.keys.contains("Scene") && dict["Scene"] != nil {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class VensorCensorResult : Tea.TeaModel {
                public class CensorResults : Tea.TeaModel {
                    public class CensorResult : Tea.TeaModel {
                        public var label: String?

                        public var rate: String?

                        public var scene: String?

                        public var suggestion: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.rate != nil {
                                map["Rate"] = self.rate!
                            }
                            if self.scene != nil {
                                map["Scene"] = self.scene!
                            }
                            if self.suggestion != nil {
                                map["Suggestion"] = self.suggestion!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") && dict["Label"] != nil {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Rate") && dict["Rate"] != nil {
                                self.rate = dict["Rate"] as! String
                            }
                            if dict.keys.contains("Scene") && dict["Scene"] != nil {
                                self.scene = dict["Scene"] as! String
                            }
                            if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                                self.suggestion = dict["Suggestion"] as! String
                            }
                        }
                    }
                    public var censorResult: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults.CensorResult]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.censorResult != nil {
                            var tmp : [Any] = []
                            for k in self.censorResult! {
                                tmp.append(k.toMap())
                            }
                            map["CensorResult"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CensorResult") && dict["CensorResult"] != nil {
                            var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults.CensorResult] = []
                            for v in dict["CensorResult"] as! [Any] {
                                var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults.CensorResult()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.censorResult = tmp
                        }
                    }
                }
                public class VideoTimelines : Tea.TeaModel {
                    public class VideoTimeline : Tea.TeaModel {
                        public class CensorResults : Tea.TeaModel {
                            public class CensorResult : Tea.TeaModel {
                                public var label: String?

                                public var rate: String?

                                public var scene: String?

                                public var suggestion: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.label != nil {
                                        map["Label"] = self.label!
                                    }
                                    if self.rate != nil {
                                        map["Rate"] = self.rate!
                                    }
                                    if self.scene != nil {
                                        map["Scene"] = self.scene!
                                    }
                                    if self.suggestion != nil {
                                        map["Suggestion"] = self.suggestion!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Label") && dict["Label"] != nil {
                                        self.label = dict["Label"] as! String
                                    }
                                    if dict.keys.contains("Rate") && dict["Rate"] != nil {
                                        self.rate = dict["Rate"] as! String
                                    }
                                    if dict.keys.contains("Scene") && dict["Scene"] != nil {
                                        self.scene = dict["Scene"] as! String
                                    }
                                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                                        self.suggestion = dict["Suggestion"] as! String
                                    }
                                }
                            }
                            public var censorResult: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.censorResult != nil {
                                    var tmp : [Any] = []
                                    for k in self.censorResult! {
                                        tmp.append(k.toMap())
                                    }
                                    map["CensorResult"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("CensorResult") && dict["CensorResult"] != nil {
                                    var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult] = []
                                    for v in dict["CensorResult"] as! [Any] {
                                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.censorResult = tmp
                                }
                            }
                        }
                        public var censorResults: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults?

                        public var object: String?

                        public var timestamp: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.censorResults?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.censorResults != nil {
                                map["CensorResults"] = self.censorResults?.toMap()
                            }
                            if self.object != nil {
                                map["Object"] = self.object!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CensorResults") && dict["CensorResults"] != nil {
                                var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults()
                                model.fromMap(dict["CensorResults"] as! [String: Any])
                                self.censorResults = model
                            }
                            if dict.keys.contains("Object") && dict["Object"] != nil {
                                self.object = dict["Object"] as! String
                            }
                            if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                        }
                    }
                    public var videoTimeline: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.videoTimeline != nil {
                            var tmp : [Any] = []
                            for k in self.videoTimeline! {
                                tmp.append(k.toMap())
                            }
                            map["VideoTimeline"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("VideoTimeline") && dict["VideoTimeline"] != nil {
                            var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline] = []
                            for v in dict["VideoTimeline"] as! [Any] {
                                var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.videoTimeline = tmp
                        }
                    }
                }
                public var censorResults: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults?

                public var nextPageToken: String?

                public var videoTimelines: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.censorResults?.validate()
                    try self.videoTimelines?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.censorResults != nil {
                        map["CensorResults"] = self.censorResults?.toMap()
                    }
                    if self.nextPageToken != nil {
                        map["NextPageToken"] = self.nextPageToken!
                    }
                    if self.videoTimelines != nil {
                        map["VideoTimelines"] = self.videoTimelines?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CensorResults") && dict["CensorResults"] != nil {
                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults()
                        model.fromMap(dict["CensorResults"] as! [String: Any])
                        self.censorResults = model
                    }
                    if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
                        self.nextPageToken = dict["NextPageToken"] as! String
                    }
                    if dict.keys.contains("VideoTimelines") && dict["VideoTimelines"] != nil {
                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines()
                        model.fromMap(dict["VideoTimelines"] as! [String: Any])
                        self.videoTimelines = model
                    }
                }
            }
            public class VideoCensorConfig : Tea.TeaModel {
                public class OutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") && dict["Location"] != nil {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") && dict["Object"] != nil {
                            self.object = dict["Object"] as! String
                        }
                    }
                }
                public var bizType: String?

                public var outputFile: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig.OutputFile?

                public var videoCensor: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.outputFile?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizType != nil {
                        map["BizType"] = self.bizType!
                    }
                    if self.outputFile != nil {
                        map["OutputFile"] = self.outputFile?.toMap()
                    }
                    if self.videoCensor != nil {
                        map["VideoCensor"] = self.videoCensor!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizType") && dict["BizType"] != nil {
                        self.bizType = dict["BizType"] as! String
                    }
                    if dict.keys.contains("OutputFile") && dict["OutputFile"] != nil {
                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig.OutputFile()
                        model.fromMap(dict["OutputFile"] as! [String: Any])
                        self.outputFile = model
                    }
                    if dict.keys.contains("VideoCensor") && dict["VideoCensor"] != nil {
                        self.videoCensor = dict["VideoCensor"] as! String
                    }
                }
            }
            public var barrageCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.BarrageCensorResult?

            public var code: String?

            public var coverImageCensorResults: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults?

            public var creationTime: String?

            public var descCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.DescCensorResult?

            public var finishTime: String?

            public var input: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.Input?

            public var jobId: String?

            public var message: String?

            public var pipelineId: String?

            public var state: String?

            public var suggestion: String?

            public var titleCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.TitleCensorResult?

            public var userData: String?

            public var vensorCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult?

            public var videoCensorConfig: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.barrageCensorResult?.validate()
                try self.coverImageCensorResults?.validate()
                try self.descCensorResult?.validate()
                try self.input?.validate()
                try self.titleCensorResult?.validate()
                try self.vensorCensorResult?.validate()
                try self.videoCensorConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.barrageCensorResult != nil {
                    map["BarrageCensorResult"] = self.barrageCensorResult?.toMap()
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.coverImageCensorResults != nil {
                    map["CoverImageCensorResults"] = self.coverImageCensorResults?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.descCensorResult != nil {
                    map["DescCensorResult"] = self.descCensorResult?.toMap()
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.titleCensorResult != nil {
                    map["TitleCensorResult"] = self.titleCensorResult?.toMap()
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                if self.vensorCensorResult != nil {
                    map["VensorCensorResult"] = self.vensorCensorResult?.toMap()
                }
                if self.videoCensorConfig != nil {
                    map["VideoCensorConfig"] = self.videoCensorConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BarrageCensorResult") && dict["BarrageCensorResult"] != nil {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.BarrageCensorResult()
                    model.fromMap(dict["BarrageCensorResult"] as! [String: Any])
                    self.barrageCensorResult = model
                }
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CoverImageCensorResults") && dict["CoverImageCensorResults"] != nil {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults()
                    model.fromMap(dict["CoverImageCensorResults"] as! [String: Any])
                    self.coverImageCensorResults = model
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DescCensorResult") && dict["DescCensorResult"] != nil {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.DescCensorResult()
                    model.fromMap(dict["DescCensorResult"] as! [String: Any])
                    self.descCensorResult = model
                }
                if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Input") && dict["Input"] != nil {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("TitleCensorResult") && dict["TitleCensorResult"] != nil {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.TitleCensorResult()
                    model.fromMap(dict["TitleCensorResult"] as! [String: Any])
                    self.titleCensorResult = model
                }
                if dict.keys.contains("UserData") && dict["UserData"] != nil {
                    self.userData = dict["UserData"] as! String
                }
                if dict.keys.contains("VensorCensorResult") && dict["VensorCensorResult"] != nil {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult()
                    model.fromMap(dict["VensorCensorResult"] as! [String: Any])
                    self.vensorCensorResult = model
                }
                if dict.keys.contains("VideoCensorConfig") && dict["VideoCensorConfig"] != nil {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig()
                    model.fromMap(dict["VideoCensorConfig"] as! [String: Any])
                    self.videoCensorConfig = model
                }
            }
        }
        public var mediaCensorJob: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaCensorJob != nil {
                var tmp : [Any] = []
                for k in self.mediaCensorJob! {
                    tmp.append(k.toMap())
                }
                map["MediaCensorJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaCensorJob") && dict["MediaCensorJob"] != nil {
                var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob] = []
                for v in dict["MediaCensorJob"] as! [Any] {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaCensorJob = tmp
            }
        }
    }
    public class NonExistIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") && dict["String"] != nil {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var mediaCensorJobList: QueryMediaCensorJobListResponseBody.MediaCensorJobList?

    public var nextPageToken: String?

    public var nonExistIds: QueryMediaCensorJobListResponseBody.NonExistIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaCensorJobList?.validate()
        try self.nonExistIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaCensorJobList != nil {
            map["MediaCensorJobList"] = self.mediaCensorJobList?.toMap()
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.nonExistIds != nil {
            map["NonExistIds"] = self.nonExistIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaCensorJobList") && dict["MediaCensorJobList"] != nil {
            var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList()
            model.fromMap(dict["MediaCensorJobList"] as! [String: Any])
            self.mediaCensorJobList = model
        }
        if dict.keys.contains("NextPageToken") && dict["NextPageToken"] != nil {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("NonExistIds") && dict["NonExistIds"] != nil {
            var model = QueryMediaCensorJobListResponseBody.NonExistIds()
            model.fromMap(dict["NonExistIds"] as! [String: Any])
            self.nonExistIds = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaCensorJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaCensorJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMediaCensorJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySmarttagJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var params: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! String
        }
    }
}

public class QuerySmarttagJobResponseBody : Tea.TeaModel {
    public class Results : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var data: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") && dict["Data"] != nil {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var result: [QuerySmarttagJobResponseBody.Results.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [QuerySmarttagJobResponseBody.Results.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = QuerySmarttagJobResponseBody.Results.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
        }
    }
    public var jobStatus: String?

    public var requestId: String?

    public var results: QuerySmarttagJobResponseBody.Results?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.results?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobStatus != nil {
            map["JobStatus"] = self.jobStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.results != nil {
            map["Results"] = self.results?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobStatus") && dict["JobStatus"] != nil {
            self.jobStatus = dict["JobStatus"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Results") && dict["Results"] != nil {
            var model = QuerySmarttagJobResponseBody.Results()
            model.fromMap(dict["Results"] as! [String: Any])
            self.results = model
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class QuerySmarttagJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySmarttagJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QuerySmarttagJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshUploadMediaRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class RefreshUploadMediaResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") && dict["UploadAddress"] != nil {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") && dict["UploadAuth"] != nil {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class RefreshUploadMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshUploadMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefreshUploadMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterMediaInfoRequest : Tea.TeaModel {
    public var businessType: String?

    public var cateId: Int64?

    public var clientToken: String?

    public var coverURL: String?

    public var description_: String?

    public var inputURL: String?

    public var mediaTags: String?

    public var mediaType: String?

    public var overwrite: Bool?

    public var referenceId: String?

    public var registerConfig: String?

    public var title: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaTags != nil {
            map["MediaTags"] = self.mediaTags!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.referenceId != nil {
            map["ReferenceId"] = self.referenceId!
        }
        if self.registerConfig != nil {
            map["RegisterConfig"] = self.registerConfig!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("CateId") && dict["CateId"] != nil {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InputURL") && dict["InputURL"] != nil {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaTags") && dict["MediaTags"] != nil {
            self.mediaTags = dict["MediaTags"] as! String
        }
        if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("Overwrite") && dict["Overwrite"] != nil {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("ReferenceId") && dict["ReferenceId"] != nil {
            self.referenceId = dict["ReferenceId"] as! String
        }
        if dict.keys.contains("RegisterConfig") && dict["RegisterConfig"] != nil {
            self.registerConfig = dict["RegisterConfig"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") && dict["WorkflowId"] != nil {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class RegisterMediaInfoResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RegisterMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterMediaStreamRequest : Tea.TeaModel {
    public var inputURL: String?

    public var mediaId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputURL") && dict["InputURL"] != nil {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class RegisterMediaStreamResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterMediaStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterMediaStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RegisterMediaStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchEditingProjectRequest : Tea.TeaModel {
    public var createSource: String?

    public var endTime: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var projectType: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createSource != nil {
            map["CreateSource"] = self.createSource!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectType != nil {
            map["ProjectType"] = self.projectType!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateSource") && dict["CreateSource"] != nil {
            self.createSource = dict["CreateSource"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ProjectType") && dict["ProjectType"] != nil {
            self.projectType = dict["ProjectType"] as! String
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class SearchEditingProjectResponseBody : Tea.TeaModel {
    public class ProjectList : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var duration: Int64?

        public var errorCode: String?

        public var errorMessage: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: String?

        public var templateType: String?

        public var timeline: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") && dict["BusinessConfig"] != nil {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") && dict["BusinessStatus"] != nil {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") && dict["CreateSource"] != nil {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("ModifiedSource") && dict["ModifiedSource"] != nil {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") && dict["ProjectType"] != nil {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var projectList: [SearchEditingProjectResponseBody.ProjectList]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.projectList != nil {
            var tmp : [Any] = []
            for k in self.projectList! {
                tmp.append(k.toMap())
            }
            map["ProjectList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ProjectList") && dict["ProjectList"] != nil {
            var tmp : [SearchEditingProjectResponseBody.ProjectList] = []
            for v in dict["ProjectList"] as! [Any] {
                var model = SearchEditingProjectResponseBody.ProjectList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.projectList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaRequest : Tea.TeaModel {
    public var entityId: String?

    public var match: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.match != nil {
            map["Match"] = self.match!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") && dict["EntityId"] != nil {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("Match") && dict["Match"] != nil {
            self.match = dict["Match"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class SearchMediaResponseBody : Tea.TeaModel {
    public class MediaInfoList : Tea.TeaModel {
        public class AiData : Tea.TeaModel {
            public class AiLabelInfo : Tea.TeaModel {
                public class Occurrences : Tea.TeaModel {
                    public class Tracks : Tea.TeaModel {
                        public var position: String?

                        public var size: Double?

                        public var timestamp: Double?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.position != nil {
                                map["Position"] = self.position!
                            }
                            if self.size != nil {
                                map["Size"] = self.size!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Position") && dict["Position"] != nil {
                                self.position = dict["Position"] as! String
                            }
                            if dict.keys.contains("Size") && dict["Size"] != nil {
                                self.size = dict["Size"] as! Double
                            }
                            if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                                self.timestamp = dict["Timestamp"] as! Double
                            }
                        }
                    }
                    public var content: String?

                    public var finegrainId: String?

                    public var finegrainName: String?

                    public var from: Double?

                    public var image: String?

                    public var score: Double?

                    public var tableBatchSeqId: String?

                    public var to: Double?

                    public var tracks: [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences.Tracks]?

                    public var clipId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.finegrainId != nil {
                            map["FinegrainId"] = self.finegrainId!
                        }
                        if self.finegrainName != nil {
                            map["FinegrainName"] = self.finegrainName!
                        }
                        if self.from != nil {
                            map["From"] = self.from!
                        }
                        if self.image != nil {
                            map["Image"] = self.image!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.tableBatchSeqId != nil {
                            map["TableBatchSeqId"] = self.tableBatchSeqId!
                        }
                        if self.to != nil {
                            map["To"] = self.to!
                        }
                        if self.tracks != nil {
                            var tmp : [Any] = []
                            for k in self.tracks! {
                                tmp.append(k.toMap())
                            }
                            map["Tracks"] = tmp
                        }
                        if self.clipId != nil {
                            map["clipId"] = self.clipId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Content") && dict["Content"] != nil {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("FinegrainId") && dict["FinegrainId"] != nil {
                            self.finegrainId = dict["FinegrainId"] as! String
                        }
                        if dict.keys.contains("FinegrainName") && dict["FinegrainName"] != nil {
                            self.finegrainName = dict["FinegrainName"] as! String
                        }
                        if dict.keys.contains("From") && dict["From"] != nil {
                            self.from = dict["From"] as! Double
                        }
                        if dict.keys.contains("Image") && dict["Image"] != nil {
                            self.image = dict["Image"] as! String
                        }
                        if dict.keys.contains("Score") && dict["Score"] != nil {
                            self.score = dict["Score"] as! Double
                        }
                        if dict.keys.contains("TableBatchSeqId") && dict["TableBatchSeqId"] != nil {
                            self.tableBatchSeqId = dict["TableBatchSeqId"] as! String
                        }
                        if dict.keys.contains("To") && dict["To"] != nil {
                            self.to = dict["To"] as! Double
                        }
                        if dict.keys.contains("Tracks") && dict["Tracks"] != nil {
                            var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences.Tracks] = []
                            for v in dict["Tracks"] as! [Any] {
                                var model = SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences.Tracks()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.tracks = tmp
                        }
                        if dict.keys.contains("clipId") && dict["clipId"] != nil {
                            self.clipId = dict["clipId"] as! String
                        }
                    }
                }
                public var category: String?

                public var faceId: String?

                public var labelId: String?

                public var labelName: String?

                public var labelType: String?

                public var occurrences: [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences]?

                public var source: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.faceId != nil {
                        map["FaceId"] = self.faceId!
                    }
                    if self.labelId != nil {
                        map["LabelId"] = self.labelId!
                    }
                    if self.labelName != nil {
                        map["LabelName"] = self.labelName!
                    }
                    if self.labelType != nil {
                        map["LabelType"] = self.labelType!
                    }
                    if self.occurrences != nil {
                        var tmp : [Any] = []
                        for k in self.occurrences! {
                            tmp.append(k.toMap())
                        }
                        map["Occurrences"] = tmp
                    }
                    if self.source != nil {
                        map["Source"] = self.source!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") && dict["Category"] != nil {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("FaceId") && dict["FaceId"] != nil {
                        self.faceId = dict["FaceId"] as! String
                    }
                    if dict.keys.contains("LabelId") && dict["LabelId"] != nil {
                        self.labelId = dict["LabelId"] as! String
                    }
                    if dict.keys.contains("LabelName") && dict["LabelName"] != nil {
                        self.labelName = dict["LabelName"] as! String
                    }
                    if dict.keys.contains("LabelType") && dict["LabelType"] != nil {
                        self.labelType = dict["LabelType"] as! String
                    }
                    if dict.keys.contains("Occurrences") && dict["Occurrences"] != nil {
                        var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences] = []
                        for v in dict["Occurrences"] as! [Any] {
                            var model = SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.occurrences = tmp
                    }
                    if dict.keys.contains("Source") && dict["Source"] != nil {
                        self.source = dict["Source"] as! String
                    }
                }
            }
            public class AsrInfo : Tea.TeaModel {
                public var clipId: String?

                public var content: String?

                public var from: Double?

                public var timestamp: Double?

                public var to: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clipId != nil {
                        map["ClipId"] = self.clipId!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.from != nil {
                        map["From"] = self.from!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.to != nil {
                        map["To"] = self.to!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClipId") && dict["ClipId"] != nil {
                        self.clipId = dict["ClipId"] as! String
                    }
                    if dict.keys.contains("Content") && dict["Content"] != nil {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("From") && dict["From"] != nil {
                        self.from = dict["From"] as! Double
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                    if dict.keys.contains("To") && dict["To"] != nil {
                        self.to = dict["To"] as! Double
                    }
                }
            }
            public class OcrInfo : Tea.TeaModel {
                public var clipId: String?

                public var content: String?

                public var from: Double?

                public var timestamp: Double?

                public var to: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clipId != nil {
                        map["ClipId"] = self.clipId!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.from != nil {
                        map["From"] = self.from!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.to != nil {
                        map["To"] = self.to!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClipId") && dict["ClipId"] != nil {
                        self.clipId = dict["ClipId"] as! String
                    }
                    if dict.keys.contains("Content") && dict["Content"] != nil {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("From") && dict["From"] != nil {
                        self.from = dict["From"] as! Double
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                    if dict.keys.contains("To") && dict["To"] != nil {
                        self.to = dict["To"] as! Double
                    }
                }
            }
            public var aiLabelInfo: [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo]?

            public var asrInfo: [SearchMediaResponseBody.MediaInfoList.AiData.AsrInfo]?

            public var ocrInfo: [SearchMediaResponseBody.MediaInfoList.AiData.OcrInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiLabelInfo != nil {
                    var tmp : [Any] = []
                    for k in self.aiLabelInfo! {
                        tmp.append(k.toMap())
                    }
                    map["AiLabelInfo"] = tmp
                }
                if self.asrInfo != nil {
                    var tmp : [Any] = []
                    for k in self.asrInfo! {
                        tmp.append(k.toMap())
                    }
                    map["AsrInfo"] = tmp
                }
                if self.ocrInfo != nil {
                    var tmp : [Any] = []
                    for k in self.ocrInfo! {
                        tmp.append(k.toMap())
                    }
                    map["OcrInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiLabelInfo") && dict["AiLabelInfo"] != nil {
                    var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo] = []
                    for v in dict["AiLabelInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.aiLabelInfo = tmp
                }
                if dict.keys.contains("AsrInfo") && dict["AsrInfo"] != nil {
                    var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.AsrInfo] = []
                    for v in dict["AsrInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaInfoList.AiData.AsrInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.asrInfo = tmp
                }
                if dict.keys.contains("OcrInfo") && dict["OcrInfo"] != nil {
                    var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.OcrInfo] = []
                    for v in dict["OcrInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaInfoList.AiData.OcrInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ocrInfo = tmp
                }
            }
        }
        public class AiRoughData : Tea.TeaModel {
            public var aiCategory: String?

            public var aiJobId: String?

            public var result: String?

            public var saveType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiCategory != nil {
                    map["AiCategory"] = self.aiCategory!
                }
                if self.aiJobId != nil {
                    map["AiJobId"] = self.aiJobId!
                }
                if self.result != nil {
                    map["Result"] = self.result!
                }
                if self.saveType != nil {
                    map["SaveType"] = self.saveType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiCategory") && dict["AiCategory"] != nil {
                    self.aiCategory = dict["AiCategory"] as! String
                }
                if dict.keys.contains("AiJobId") && dict["AiJobId"] != nil {
                    self.aiJobId = dict["AiJobId"] as! String
                }
                if dict.keys.contains("Result") && dict["Result"] != nil {
                    self.result = dict["Result"] as! String
                }
                if dict.keys.contains("SaveType") && dict["SaveType"] != nil {
                    self.saveType = dict["SaveType"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var createTime: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var modifiedTime: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") && dict["FileType"] != nil {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Region") && dict["Region"] != nil {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: SearchMediaResponseBody.MediaInfoList.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                    var model = SearchMediaResponseBody.MediaInfoList.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var cateId: Int64?

            public var cateName: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var referenceId: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var uploadSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.uploadSource != nil {
                    map["UploadSource"] = self.uploadSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") && dict["Biz"] != nil {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("CateId") && dict["CateId"] != nil {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") && dict["CateName"] != nil {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") && dict["DeletedTime"] != nil {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") && dict["InputURL"] != nil {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") && dict["MediaTags"] != nil {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ReferenceId") && dict["ReferenceId"] != nil {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") && dict["SpriteImages"] != nil {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") && dict["TranscodeStatus"] != nil {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UploadSource") && dict["UploadSource"] != nil {
                    self.uploadSource = dict["UploadSource"] as! String
                }
                if dict.keys.contains("UserData") && dict["UserData"] != nil {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var aiData: SearchMediaResponseBody.MediaInfoList.AiData?

        public var aiRoughData: SearchMediaResponseBody.MediaInfoList.AiRoughData?

        public var fileInfoList: [SearchMediaResponseBody.MediaInfoList.FileInfoList]?

        public var mediaBasicInfo: SearchMediaResponseBody.MediaInfoList.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.aiData?.validate()
            try self.aiRoughData?.validate()
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiData != nil {
                map["AiData"] = self.aiData?.toMap()
            }
            if self.aiRoughData != nil {
                map["AiRoughData"] = self.aiRoughData?.toMap()
            }
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiData") && dict["AiData"] != nil {
                var model = SearchMediaResponseBody.MediaInfoList.AiData()
                model.fromMap(dict["AiData"] as! [String: Any])
                self.aiData = model
            }
            if dict.keys.contains("AiRoughData") && dict["AiRoughData"] != nil {
                var model = SearchMediaResponseBody.MediaInfoList.AiRoughData()
                model.fromMap(dict["AiRoughData"] as! [String: Any])
                self.aiRoughData = model
            }
            if dict.keys.contains("FileInfoList") && dict["FileInfoList"] != nil {
                var tmp : [SearchMediaResponseBody.MediaInfoList.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = SearchMediaResponseBody.MediaInfoList.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") && dict["MediaBasicInfo"] != nil {
                var model = SearchMediaResponseBody.MediaInfoList.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var code: String?

    public var mediaInfoList: [SearchMediaResponseBody.MediaInfoList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaInfoList != nil {
            var tmp : [Any] = []
            for k in self.mediaInfoList! {
                tmp.append(k.toMap())
            }
            map["MediaInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaInfoList") && dict["MediaInfoList"] != nil {
            var tmp : [SearchMediaResponseBody.MediaInfoList] = []
            for v in dict["MediaInfoList"] as! [Any] {
                var model = SearchMediaResponseBody.MediaInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfoList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaByFaceRequest : Tea.TeaModel {
    public var entityId: String?

    public var faceSearchToken: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var personImageUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.faceSearchToken != nil {
            map["FaceSearchToken"] = self.faceSearchToken!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.personImageUrl != nil {
            map["PersonImageUrl"] = self.personImageUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") && dict["EntityId"] != nil {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("FaceSearchToken") && dict["FaceSearchToken"] != nil {
            self.faceSearchToken = dict["FaceSearchToken"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PersonImageUrl") && dict["PersonImageUrl"] != nil {
            self.personImageUrl = dict["PersonImageUrl"] as! String
        }
    }
}

public class SearchMediaByFaceResponseBody : Tea.TeaModel {
    public class MediaInfoList : Tea.TeaModel {
        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var code: String?

    public var mediaInfoList: [SearchMediaByFaceResponseBody.MediaInfoList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaInfoList != nil {
            var tmp : [Any] = []
            for k in self.mediaInfoList! {
                tmp.append(k.toMap())
            }
            map["MediaInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaInfoList") && dict["MediaInfoList"] != nil {
            var tmp : [SearchMediaByFaceResponseBody.MediaInfoList] = []
            for v in dict["MediaInfoList"] as! [Any] {
                var model = SearchMediaByFaceResponseBody.MediaInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfoList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaByFaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaByFaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchMediaByFaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaClipByFaceRequest : Tea.TeaModel {
    public var entityId: String?

    public var faceSearchToken: String?

    public var mediaId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.faceSearchToken != nil {
            map["FaceSearchToken"] = self.faceSearchToken!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") && dict["EntityId"] != nil {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("FaceSearchToken") && dict["FaceSearchToken"] != nil {
            self.faceSearchToken = dict["FaceSearchToken"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class SearchMediaClipByFaceResponseBody : Tea.TeaModel {
    public class MediaClipList : Tea.TeaModel {
        public class OccurrencesInfos : Tea.TeaModel {
            public class TrackData : Tea.TeaModel {
                public class BoxPosition : Tea.TeaModel {
                    public var h: Int32?

                    public var w: Int32?

                    public var x: Int32?

                    public var y: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.h != nil {
                            map["H"] = self.h!
                        }
                        if self.w != nil {
                            map["W"] = self.w!
                        }
                        if self.x != nil {
                            map["X"] = self.x!
                        }
                        if self.y != nil {
                            map["Y"] = self.y!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("H") && dict["H"] != nil {
                            self.h = dict["H"] as! Int32
                        }
                        if dict.keys.contains("W") && dict["W"] != nil {
                            self.w = dict["W"] as! Int32
                        }
                        if dict.keys.contains("X") && dict["X"] != nil {
                            self.x = dict["X"] as! Int32
                        }
                        if dict.keys.contains("Y") && dict["Y"] != nil {
                            self.y = dict["Y"] as! Int32
                        }
                    }
                }
                public var boxPosition: SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData.BoxPosition?

                public var timestamp: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.boxPosition?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.boxPosition != nil {
                        map["BoxPosition"] = self.boxPosition?.toMap()
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BoxPosition") && dict["BoxPosition"] != nil {
                        var model = SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData.BoxPosition()
                        model.fromMap(dict["BoxPosition"] as! [String: Any])
                        self.boxPosition = model
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                }
            }
            public var endTime: Double?

            public var startTime: Double?

            public var trackData: [SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.trackData != nil {
                    var tmp : [Any] = []
                    for k in self.trackData! {
                        tmp.append(k.toMap())
                    }
                    map["TrackData"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Double
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Double
                }
                if dict.keys.contains("TrackData") && dict["TrackData"] != nil {
                    var tmp : [SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData] = []
                    for v in dict["TrackData"] as! [Any] {
                        var model = SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.trackData = tmp
                }
            }
        }
        public var category: String?

        public var entityId: String?

        public var labelName: String?

        public var occurrencesInfos: [SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos]?

        public var score: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.entityId != nil {
                map["EntityId"] = self.entityId!
            }
            if self.labelName != nil {
                map["LabelName"] = self.labelName!
            }
            if self.occurrencesInfos != nil {
                var tmp : [Any] = []
                for k in self.occurrencesInfos! {
                    tmp.append(k.toMap())
                }
                map["OccurrencesInfos"] = tmp
            }
            if self.score != nil {
                map["Score"] = self.score!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("EntityId") && dict["EntityId"] != nil {
                self.entityId = dict["EntityId"] as! String
            }
            if dict.keys.contains("LabelName") && dict["LabelName"] != nil {
                self.labelName = dict["LabelName"] as! String
            }
            if dict.keys.contains("OccurrencesInfos") && dict["OccurrencesInfos"] != nil {
                var tmp : [SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos] = []
                for v in dict["OccurrencesInfos"] as! [Any] {
                    var model = SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.occurrencesInfos = tmp
            }
            if dict.keys.contains("Score") && dict["Score"] != nil {
                self.score = dict["Score"] as! Double
            }
        }
    }
    public var code: String?

    public var mediaClipList: [SearchMediaClipByFaceResponseBody.MediaClipList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaClipList != nil {
            var tmp : [Any] = []
            for k in self.mediaClipList! {
                tmp.append(k.toMap())
            }
            map["MediaClipList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaClipList") && dict["MediaClipList"] != nil {
            var tmp : [SearchMediaClipByFaceResponseBody.MediaClipList] = []
            for v in dict["MediaClipList"] as! [Any] {
                var model = SearchMediaClipByFaceResponseBody.MediaClipList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaClipList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaClipByFaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaClipByFaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchMediaClipByFaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchPublicMediaInfoRequest : Tea.TeaModel {
    public var authorized: Bool?

    public var dynamicMetaDataMatchFields: String?

    public var entityId: String?

    public var favorite: Bool?

    public var mediaIds: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorized != nil {
            map["Authorized"] = self.authorized!
        }
        if self.dynamicMetaDataMatchFields != nil {
            map["DynamicMetaDataMatchFields"] = self.dynamicMetaDataMatchFields!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.favorite != nil {
            map["Favorite"] = self.favorite!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Authorized") && dict["Authorized"] != nil {
            self.authorized = dict["Authorized"] as! Bool
        }
        if dict.keys.contains("DynamicMetaDataMatchFields") && dict["DynamicMetaDataMatchFields"] != nil {
            self.dynamicMetaDataMatchFields = dict["DynamicMetaDataMatchFields"] as! String
        }
        if dict.keys.contains("EntityId") && dict["EntityId"] != nil {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("Favorite") && dict["Favorite"] != nil {
            self.favorite = dict["Favorite"] as! Bool
        }
        if dict.keys.contains("MediaIds") && dict["MediaIds"] != nil {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class SearchPublicMediaInfoResponseBody : Tea.TeaModel {
    public class PublicMediaInfos : Tea.TeaModel {
        public class MediaInfo : Tea.TeaModel {
            public class DynamicMetaData : Tea.TeaModel {
                public var data: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.data != nil {
                        map["Data"] = self.data!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Data") && dict["Data"] != nil {
                        self.data = dict["Data"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class MediaBasicInfo : Tea.TeaModel {
                public var businessType: String?

                public var category: String?

                public var coverURL: String?

                public var createTime: String?

                public var deletedTime: String?

                public var description_: String?

                public var mediaId: String?

                public var mediaTags: String?

                public var mediaType: String?

                public var modifiedTime: String?

                public var source: String?

                public var spriteImages: String?

                public var status: String?

                public var title: String?

                public var userData: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.businessType != nil {
                        map["BusinessType"] = self.businessType!
                    }
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.coverURL != nil {
                        map["CoverURL"] = self.coverURL!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.deletedTime != nil {
                        map["DeletedTime"] = self.deletedTime!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.mediaTags != nil {
                        map["MediaTags"] = self.mediaTags!
                    }
                    if self.mediaType != nil {
                        map["MediaType"] = self.mediaType!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.source != nil {
                        map["Source"] = self.source!
                    }
                    if self.spriteImages != nil {
                        map["SpriteImages"] = self.spriteImages!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
                        self.businessType = dict["BusinessType"] as! String
                    }
                    if dict.keys.contains("Category") && dict["Category"] != nil {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                        self.coverURL = dict["CoverURL"] as! String
                    }
                    if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("DeletedTime") && dict["DeletedTime"] != nil {
                        self.deletedTime = dict["DeletedTime"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("MediaTags") && dict["MediaTags"] != nil {
                        self.mediaTags = dict["MediaTags"] as! String
                    }
                    if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
                        self.mediaType = dict["MediaType"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Source") && dict["Source"] != nil {
                        self.source = dict["Source"] as! String
                    }
                    if dict.keys.contains("SpriteImages") && dict["SpriteImages"] != nil {
                        self.spriteImages = dict["SpriteImages"] as! String
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Title") && dict["Title"] != nil {
                        self.title = dict["Title"] as! String
                    }
                    if dict.keys.contains("UserData") && dict["UserData"] != nil {
                        self.userData = dict["UserData"] as! String
                    }
                }
            }
            public var dynamicMetaData: SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.DynamicMetaData?

            public var mediaBasicInfo: SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.MediaBasicInfo?

            public var mediaId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dynamicMetaData?.validate()
                try self.mediaBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dynamicMetaData != nil {
                    map["DynamicMetaData"] = self.dynamicMetaData?.toMap()
                }
                if self.mediaBasicInfo != nil {
                    map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DynamicMetaData") && dict["DynamicMetaData"] != nil {
                    var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.DynamicMetaData()
                    model.fromMap(dict["DynamicMetaData"] as! [String: Any])
                    self.dynamicMetaData = model
                }
                if dict.keys.contains("MediaBasicInfo") && dict["MediaBasicInfo"] != nil {
                    var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.MediaBasicInfo()
                    model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                    self.mediaBasicInfo = model
                }
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
            }
        }
        public var authorized: Bool?

        public var favorite: Bool?

        public var mediaInfo: SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo?

        public var remainingAuthTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorized != nil {
                map["Authorized"] = self.authorized!
            }
            if self.favorite != nil {
                map["Favorite"] = self.favorite!
            }
            if self.mediaInfo != nil {
                map["MediaInfo"] = self.mediaInfo?.toMap()
            }
            if self.remainingAuthTime != nil {
                map["RemainingAuthTime"] = self.remainingAuthTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Authorized") && dict["Authorized"] != nil {
                self.authorized = dict["Authorized"] as! Bool
            }
            if dict.keys.contains("Favorite") && dict["Favorite"] != nil {
                self.favorite = dict["Favorite"] as! Bool
            }
            if dict.keys.contains("MediaInfo") && dict["MediaInfo"] != nil {
                var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo()
                model.fromMap(dict["MediaInfo"] as! [String: Any])
                self.mediaInfo = model
            }
            if dict.keys.contains("RemainingAuthTime") && dict["RemainingAuthTime"] != nil {
                self.remainingAuthTime = dict["RemainingAuthTime"] as! String
            }
        }
    }
    public var publicMediaInfos: [SearchPublicMediaInfoResponseBody.PublicMediaInfos]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.publicMediaInfos != nil {
            var tmp : [Any] = []
            for k in self.publicMediaInfos! {
                tmp.append(k.toMap())
            }
            map["PublicMediaInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PublicMediaInfos") && dict["PublicMediaInfos"] != nil {
            var tmp : [SearchPublicMediaInfoResponseBody.PublicMediaInfos] = []
            for v in dict["PublicMediaInfos"] as! [Any] {
                var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.publicMediaInfos = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchPublicMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchPublicMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchPublicMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendLiveSnapshotJobCommandRequest : Tea.TeaModel {
    public var command: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Command") && dict["Command"] != nil {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class SendLiveSnapshotJobCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendLiveSnapshotJobCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendLiveSnapshotJobCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SendLiveSnapshotJobCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendLiveTranscodeJobCommandRequest : Tea.TeaModel {
    public var command: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Command") && dict["Command"] != nil {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class SendLiveTranscodeJobCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendLiveTranscodeJobCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendLiveTranscodeJobCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SendLiveTranscodeJobCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetContentAnalyzeConfigRequest : Tea.TeaModel {
    public var auto: Bool?

    public var saveType: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.auto != nil {
            map["Auto"] = self.auto!
        }
        if self.saveType != nil {
            map["SaveType"] = self.saveType!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Auto") && dict["Auto"] != nil {
            self.auto = dict["Auto"] as! Bool
        }
        if dict.keys.contains("SaveType") && dict["SaveType"] != nil {
            self.saveType = dict["SaveType"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SetContentAnalyzeConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetContentAnalyzeConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetContentAnalyzeConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetContentAnalyzeConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultCustomTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SetDefaultCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetDefaultCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetDefaultCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultStorageLocationRequest : Tea.TeaModel {
    public var bucket: String?

    public var path: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("StorageType") && dict["StorageType"] != nil {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class SetDefaultStorageLocationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetDefaultStorageLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultStorageLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetDefaultStorageLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetEventCallbackRequest : Tea.TeaModel {
    public var authKey: String?

    public var authSwitch: String?

    public var callbackQueueName: String?

    public var callbackType: String?

    public var callbackURL: String?

    public var eventTypeList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.authSwitch != nil {
            map["AuthSwitch"] = self.authSwitch!
        }
        if self.callbackQueueName != nil {
            map["CallbackQueueName"] = self.callbackQueueName!
        }
        if self.callbackType != nil {
            map["CallbackType"] = self.callbackType!
        }
        if self.callbackURL != nil {
            map["CallbackURL"] = self.callbackURL!
        }
        if self.eventTypeList != nil {
            map["EventTypeList"] = self.eventTypeList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthKey") && dict["AuthKey"] != nil {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("AuthSwitch") && dict["AuthSwitch"] != nil {
            self.authSwitch = dict["AuthSwitch"] as! String
        }
        if dict.keys.contains("CallbackQueueName") && dict["CallbackQueueName"] != nil {
            self.callbackQueueName = dict["CallbackQueueName"] as! String
        }
        if dict.keys.contains("CallbackType") && dict["CallbackType"] != nil {
            self.callbackType = dict["CallbackType"] as! String
        }
        if dict.keys.contains("CallbackURL") && dict["CallbackURL"] != nil {
            self.callbackURL = dict["CallbackURL"] as! String
        }
        if dict.keys.contains("EventTypeList") && dict["EventTypeList"] != nil {
            self.eventTypeList = dict["EventTypeList"] as! String
        }
    }
}

public class SetEventCallbackResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetEventCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetEventCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetEventCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartWorkflowRequest : Tea.TeaModel {
    public var taskInput: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskInput != nil {
            map["TaskInput"] = self.taskInput!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskInput") && dict["TaskInput"] != nil {
            self.taskInput = dict["TaskInput"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") && dict["WorkflowId"] != nil {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class StartWorkflowResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class StartWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitASRJobRequest : Tea.TeaModel {
    public var description_: String?

    public var duration: String?

    public var inputFile: String?

    public var startTime: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.inputFile != nil {
            map["InputFile"] = self.inputFile!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Duration") && dict["Duration"] != nil {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("InputFile") && dict["InputFile"] != nil {
            self.inputFile = dict["InputFile"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitASRJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class SubmitASRJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitASRJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitASRJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAudioProduceJobRequest : Tea.TeaModel {
    public var description_: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var overwrite: Bool?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditingConfig") && dict["EditingConfig"] != nil {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") && dict["InputConfig"] != nil {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") && dict["OutputConfig"] != nil {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Overwrite") && dict["Overwrite"] != nil {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAudioProduceJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class SubmitAudioProduceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAudioProduceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitAudioProduceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAvatarVideoJobRequest : Tea.TeaModel {
    public var description_: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditingConfig") && dict["EditingConfig"] != nil {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") && dict["InputConfig"] != nil {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") && dict["OutputConfig"] != nil {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAvatarVideoJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAvatarVideoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAvatarVideoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitAvatarVideoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDNAJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var config: String?

    public var DBId: String?

    public var input: SubmitDNAJobRequest.Input?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var primaryKey: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.primaryKey != nil {
            map["PrimaryKey"] = self.primaryKey!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("DBId") && dict["DBId"] != nil {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("Input") && dict["Input"] != nil {
            var model = SubmitDNAJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("PrimaryKey") && dict["PrimaryKey"] != nil {
            self.primaryKey = dict["PrimaryKey"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDNAJobShrinkRequest : Tea.TeaModel {
    public var config: String?

    public var DBId: String?

    public var inputShrink: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var primaryKey: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.primaryKey != nil {
            map["PrimaryKey"] = self.primaryKey!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("DBId") && dict["DBId"] != nil {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("Input") && dict["Input"] != nil {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("PrimaryKey") && dict["PrimaryKey"] != nil {
            self.primaryKey = dict["PrimaryKey"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDNAJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDNAJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDNAJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitDNAJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDynamicChartJobRequest : Tea.TeaModel {
    public var axisParams: String?

    public var background: String?

    public var chartConfig: String?

    public var chartTitle: String?

    public var chartType: String?

    public var dataSource: String?

    public var description_: String?

    public var input: String?

    public var outputConfig: String?

    public var subtitle: String?

    public var title: String?

    public var unit: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.axisParams != nil {
            map["AxisParams"] = self.axisParams!
        }
        if self.background != nil {
            map["Background"] = self.background!
        }
        if self.chartConfig != nil {
            map["ChartConfig"] = self.chartConfig!
        }
        if self.chartTitle != nil {
            map["ChartTitle"] = self.chartTitle!
        }
        if self.chartType != nil {
            map["ChartType"] = self.chartType!
        }
        if self.dataSource != nil {
            map["DataSource"] = self.dataSource!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.subtitle != nil {
            map["Subtitle"] = self.subtitle!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.unit != nil {
            map["Unit"] = self.unit!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AxisParams") && dict["AxisParams"] != nil {
            self.axisParams = dict["AxisParams"] as! String
        }
        if dict.keys.contains("Background") && dict["Background"] != nil {
            self.background = dict["Background"] as! String
        }
        if dict.keys.contains("ChartConfig") && dict["ChartConfig"] != nil {
            self.chartConfig = dict["ChartConfig"] as! String
        }
        if dict.keys.contains("ChartTitle") && dict["ChartTitle"] != nil {
            self.chartTitle = dict["ChartTitle"] as! String
        }
        if dict.keys.contains("ChartType") && dict["ChartType"] != nil {
            self.chartType = dict["ChartType"] as! String
        }
        if dict.keys.contains("DataSource") && dict["DataSource"] != nil {
            self.dataSource = dict["DataSource"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") && dict["Input"] != nil {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OutputConfig") && dict["OutputConfig"] != nil {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Subtitle") && dict["Subtitle"] != nil {
            self.subtitle = dict["Subtitle"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("Unit") && dict["Unit"] != nil {
            self.unit = dict["Unit"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDynamicChartJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDynamicChartJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDynamicChartJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitDynamicChartJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDynamicImageJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public class TemplateConfig : Tea.TeaModel {
        public class OverwriteParams : Tea.TeaModel {
            public class TimeSpan : Tea.TeaModel {
                public var duration: String?

                public var end: String?

                public var seek: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.end != nil {
                        map["End"] = self.end!
                    }
                    if self.seek != nil {
                        map["Seek"] = self.seek!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("End") && dict["End"] != nil {
                        self.end = dict["End"] as! String
                    }
                    if dict.keys.contains("Seek") && dict["Seek"] != nil {
                        self.seek = dict["Seek"] as! String
                    }
                }
            }
            public var format: String?

            public var fps: Int32?

            public var height: Int32?

            public var longShortMode: Bool?

            public var scanMode: String?

            public var timeSpan: SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams.TimeSpan?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.timeSpan?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.longShortMode != nil {
                    map["LongShortMode"] = self.longShortMode!
                }
                if self.scanMode != nil {
                    map["ScanMode"] = self.scanMode!
                }
                if self.timeSpan != nil {
                    map["TimeSpan"] = self.timeSpan?.toMap()
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Format") && dict["Format"] != nil {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") && dict["Fps"] != nil {
                    self.fps = dict["Fps"] as! Int32
                }
                if dict.keys.contains("Height") && dict["Height"] != nil {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("LongShortMode") && dict["LongShortMode"] != nil {
                    self.longShortMode = dict["LongShortMode"] as! Bool
                }
                if dict.keys.contains("ScanMode") && dict["ScanMode"] != nil {
                    self.scanMode = dict["ScanMode"] as! String
                }
                if dict.keys.contains("TimeSpan") && dict["TimeSpan"] != nil {
                    var model = SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams.TimeSpan()
                    model.fromMap(dict["TimeSpan"] as! [String: Any])
                    self.timeSpan = model
                }
                if dict.keys.contains("Width") && dict["Width"] != nil {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var overwriteParams: SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.overwriteParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.overwriteParams != nil {
                map["OverwriteParams"] = self.overwriteParams?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                var model = SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams()
                model.fromMap(dict["OverwriteParams"] as! [String: Any])
                self.overwriteParams = model
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var input: SubmitDynamicImageJobRequest.Input?

    public var name: String?

    public var output: SubmitDynamicImageJobRequest.Output?

    public var scheduleConfig: SubmitDynamicImageJobRequest.ScheduleConfig?

    public var templateConfig: SubmitDynamicImageJobRequest.TemplateConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") && dict["Input"] != nil {
            var model = SubmitDynamicImageJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") && dict["Output"] != nil {
            var model = SubmitDynamicImageJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            var model = SubmitDynamicImageJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            var model = SubmitDynamicImageJobRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDynamicImageJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var templateConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") && dict["Input"] != nil {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") && dict["Output"] != nil {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDynamicImageJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDynamicImageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDynamicImageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitDynamicImageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitIProductionJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var functionName: String?

    public var input: SubmitIProductionJobRequest.Input?

    public var jobParams: String?

    public var name: String?

    public var output: SubmitIProductionJobRequest.Output?

    public var scheduleConfig: SubmitIProductionJobRequest.ScheduleConfig?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FunctionName") && dict["FunctionName"] != nil {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") && dict["Input"] != nil {
            var model = SubmitIProductionJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("JobParams") && dict["JobParams"] != nil {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") && dict["Output"] != nil {
            var model = SubmitIProductionJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            var model = SubmitIProductionJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitIProductionJobShrinkRequest : Tea.TeaModel {
    public var functionName: String?

    public var inputShrink: String?

    public var jobParams: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FunctionName") && dict["FunctionName"] != nil {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") && dict["Input"] != nil {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("JobParams") && dict["JobParams"] != nil {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") && dict["Output"] != nil {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitIProductionJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitIProductionJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitIProductionJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitIProductionJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveEditingJobRequest : Tea.TeaModel {
    public var clips: String?

    public var liveStreamConfig: String?

    public var mediaProduceConfig: String?

    public var outputMediaConfig: String?

    public var outputMediaTarget: String?

    public var projectId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clips != nil {
            map["Clips"] = self.clips!
        }
        if self.liveStreamConfig != nil {
            map["LiveStreamConfig"] = self.liveStreamConfig!
        }
        if self.mediaProduceConfig != nil {
            map["MediaProduceConfig"] = self.mediaProduceConfig!
        }
        if self.outputMediaConfig != nil {
            map["OutputMediaConfig"] = self.outputMediaConfig!
        }
        if self.outputMediaTarget != nil {
            map["OutputMediaTarget"] = self.outputMediaTarget!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clips") && dict["Clips"] != nil {
            self.clips = dict["Clips"] as! String
        }
        if dict.keys.contains("LiveStreamConfig") && dict["LiveStreamConfig"] != nil {
            self.liveStreamConfig = dict["LiveStreamConfig"] as! String
        }
        if dict.keys.contains("MediaProduceConfig") && dict["MediaProduceConfig"] != nil {
            self.mediaProduceConfig = dict["MediaProduceConfig"] as! String
        }
        if dict.keys.contains("OutputMediaConfig") && dict["OutputMediaConfig"] != nil {
            self.outputMediaConfig = dict["OutputMediaConfig"] as! String
        }
        if dict.keys.contains("OutputMediaTarget") && dict["OutputMediaTarget"] != nil {
            self.outputMediaTarget = dict["OutputMediaTarget"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitLiveEditingJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var mediaURL: String?

    public var projectId: String?

    public var requestId: String?

    public var vodMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaURL != nil {
            map["MediaURL"] = self.mediaURL!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodMediaId != nil {
            map["VodMediaId"] = self.vodMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaURL") && dict["MediaURL"] != nil {
            self.mediaURL = dict["MediaURL"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodMediaId") && dict["VodMediaId"] != nil {
            self.vodMediaId = dict["VodMediaId"] as! String
        }
    }
}

public class SubmitLiveEditingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveEditingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitLiveEditingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveRecordJobRequest : Tea.TeaModel {
    public class RecordOutput : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class StreamInput : Tea.TeaModel {
        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var name: String?

    public var notifyUrl: String?

    public var recordOutput: SubmitLiveRecordJobRequest.RecordOutput?

    public var streamInput: SubmitLiveRecordJobRequest.StreamInput?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordOutput?.validate()
        try self.streamInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.recordOutput != nil {
            map["RecordOutput"] = self.recordOutput?.toMap()
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyUrl") && dict["NotifyUrl"] != nil {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("RecordOutput") && dict["RecordOutput"] != nil {
            var model = SubmitLiveRecordJobRequest.RecordOutput()
            model.fromMap(dict["RecordOutput"] as! [String: Any])
            self.recordOutput = model
        }
        if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
            var model = SubmitLiveRecordJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveRecordJobShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var notifyUrl: String?

    public var recordOutputShrink: String?

    public var streamInputShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.recordOutputShrink != nil {
            map["RecordOutput"] = self.recordOutputShrink!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyUrl") && dict["NotifyUrl"] != nil {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("RecordOutput") && dict["RecordOutput"] != nil {
            self.recordOutputShrink = dict["RecordOutput"] as! String
        }
        if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveRecordJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitLiveRecordJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveRecordJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitLiveRecordJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveSnapshotJobRequest : Tea.TeaModel {
    public class SnapshotOutput : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("StorageType") && dict["StorageType"] != nil {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public class StreamInput : Tea.TeaModel {
        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var callbackUrl: String?

    public var jobName: String?

    public var snapshotOutput: SubmitLiveSnapshotJobRequest.SnapshotOutput?

    public var streamInput: SubmitLiveSnapshotJobRequest.StreamInput?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotOutput?.validate()
        try self.streamInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.snapshotOutput != nil {
            map["SnapshotOutput"] = self.snapshotOutput?.toMap()
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") && dict["CallbackUrl"] != nil {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("JobName") && dict["JobName"] != nil {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("SnapshotOutput") && dict["SnapshotOutput"] != nil {
            var model = SubmitLiveSnapshotJobRequest.SnapshotOutput()
            model.fromMap(dict["SnapshotOutput"] as! [String: Any])
            self.snapshotOutput = model
        }
        if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
            var model = SubmitLiveSnapshotJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveSnapshotJobShrinkRequest : Tea.TeaModel {
    public var callbackUrl: String?

    public var jobName: String?

    public var snapshotOutputShrink: String?

    public var streamInputShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.snapshotOutputShrink != nil {
            map["SnapshotOutput"] = self.snapshotOutputShrink!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") && dict["CallbackUrl"] != nil {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("JobName") && dict["JobName"] != nil {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("SnapshotOutput") && dict["SnapshotOutput"] != nil {
            self.snapshotOutputShrink = dict["SnapshotOutput"] as! String
        }
        if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveSnapshotJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitLiveSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitLiveSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveTranscodeJobRequest : Tea.TeaModel {
    public class StreamInput : Tea.TeaModel {
        public var inputUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputUrl") && dict["InputUrl"] != nil {
                self.inputUrl = dict["InputUrl"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class TimedConfig : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class TranscodeOutput : Tea.TeaModel {
        public var domainName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var name: String?

    public var startMode: Int32?

    public var streamInput: SubmitLiveTranscodeJobRequest.StreamInput?

    public var templateId: String?

    public var timedConfig: SubmitLiveTranscodeJobRequest.TimedConfig?

    public var transcodeOutput: SubmitLiveTranscodeJobRequest.TranscodeOutput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamInput?.validate()
        try self.timedConfig?.validate()
        try self.transcodeOutput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.startMode != nil {
            map["StartMode"] = self.startMode!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timedConfig != nil {
            map["TimedConfig"] = self.timedConfig?.toMap()
        }
        if self.transcodeOutput != nil {
            map["TranscodeOutput"] = self.transcodeOutput?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StartMode") && dict["StartMode"] != nil {
            self.startMode = dict["StartMode"] as! Int32
        }
        if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
            var model = SubmitLiveTranscodeJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TimedConfig") && dict["TimedConfig"] != nil {
            var model = SubmitLiveTranscodeJobRequest.TimedConfig()
            model.fromMap(dict["TimedConfig"] as! [String: Any])
            self.timedConfig = model
        }
        if dict.keys.contains("TranscodeOutput") && dict["TranscodeOutput"] != nil {
            var model = SubmitLiveTranscodeJobRequest.TranscodeOutput()
            model.fromMap(dict["TranscodeOutput"] as! [String: Any])
            self.transcodeOutput = model
        }
    }
}

public class SubmitLiveTranscodeJobShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var startMode: Int32?

    public var streamInputShrink: String?

    public var templateId: String?

    public var timedConfigShrink: String?

    public var transcodeOutputShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.startMode != nil {
            map["StartMode"] = self.startMode!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timedConfigShrink != nil {
            map["TimedConfig"] = self.timedConfigShrink!
        }
        if self.transcodeOutputShrink != nil {
            map["TranscodeOutput"] = self.transcodeOutputShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StartMode") && dict["StartMode"] != nil {
            self.startMode = dict["StartMode"] as! Int32
        }
        if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TimedConfig") && dict["TimedConfig"] != nil {
            self.timedConfigShrink = dict["TimedConfig"] as! String
        }
        if dict.keys.contains("TranscodeOutput") && dict["TranscodeOutput"] != nil {
            self.transcodeOutputShrink = dict["TranscodeOutput"] as! String
        }
    }
}

public class SubmitLiveTranscodeJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaCensorJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var barrages: String?

    public var coverImages: String?

    public var description_: String?

    public var input: SubmitMediaCensorJobRequest.Input?

    public var notifyUrl: String?

    public var output: String?

    public var scheduleConfig: SubmitMediaCensorJobRequest.ScheduleConfig?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.barrages != nil {
            map["Barrages"] = self.barrages!
        }
        if self.coverImages != nil {
            map["CoverImages"] = self.coverImages!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Barrages") && dict["Barrages"] != nil {
            self.barrages = dict["Barrages"] as! String
        }
        if dict.keys.contains("CoverImages") && dict["CoverImages"] != nil {
            self.coverImages = dict["CoverImages"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") && dict["Input"] != nil {
            var model = SubmitMediaCensorJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("NotifyUrl") && dict["NotifyUrl"] != nil {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Output") && dict["Output"] != nil {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            var model = SubmitMediaCensorJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaCensorJobShrinkRequest : Tea.TeaModel {
    public var barrages: String?

    public var coverImages: String?

    public var description_: String?

    public var inputShrink: String?

    public var notifyUrl: String?

    public var output: String?

    public var scheduleConfigShrink: String?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.barrages != nil {
            map["Barrages"] = self.barrages!
        }
        if self.coverImages != nil {
            map["CoverImages"] = self.coverImages!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Barrages") && dict["Barrages"] != nil {
            self.barrages = dict["Barrages"] as! String
        }
        if dict.keys.contains("CoverImages") && dict["CoverImages"] != nil {
            self.coverImages = dict["CoverImages"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") && dict["Input"] != nil {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("NotifyUrl") && dict["NotifyUrl"] != nil {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Output") && dict["Output"] != nil {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaCensorJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaCensorJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaCensorJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitMediaCensorJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaInfoJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var input: SubmitMediaInfoJobRequest.Input?

    public var name: String?

    public var scheduleConfig: SubmitMediaInfoJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") && dict["Input"] != nil {
            var model = SubmitMediaInfoJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            var model = SubmitMediaInfoJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaInfoJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") && dict["Input"] != nil {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") && dict["ChannelLayout"] != nil {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") && dict["Channels"] != nil {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") && dict["SampleFmt"] != nil {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") && dict["SampleRate"] != nil {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") && dict["FileType"] != nil {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") && dict["Region"] != nil {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") && dict["Avg_fps"] != nil {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") && dict["Bit_rate"] != nil {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") && dict["Codec_long_name"] != nil {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") && dict["Codec_name"] != nil {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") && dict["Codec_tag"] != nil {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") && dict["Codec_tag_string"] != nil {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") && dict["Codec_time_base"] != nil {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") && dict["Dar"] != nil {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") && dict["Fps"] != nil {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") && dict["Has_b_frames"] != nil {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") && dict["NumFrames"] != nil {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") && dict["Profile"] != nil {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") && dict["Rotate"] != nil {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") && dict["Sar"] != nil {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") && dict["Start_time"] != nil {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") && dict["Time_base"] != nil {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") && dict["AudioStreamInfoList"] != nil {
                    var tmp : [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                    var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") && dict["VideoStreamInfoList"] != nil {
                    var tmp : [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") && dict["Priority"] != nil {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: SubmitMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var mediaInfoProperty: SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: SubmitMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") && dict["Async"] != nil {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") && dict["Input"] != nil {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") && dict["MediaInfoProperty"] != nil {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") && dict["SubmitResultJson"] != nil {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: SubmitMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") && dict["MediaInfoJob"] != nil {
            var model = SubmitMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaProducingJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var clipsParam: String?

    public var editingProduceConfig: String?

    public var outputMediaConfig: String?

    public var outputMediaTarget: String?

    public var projectId: String?

    public var projectMetadata: String?

    public var source: String?

    public var templateId: String?

    public var timeline: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clipsParam != nil {
            map["ClipsParam"] = self.clipsParam!
        }
        if self.editingProduceConfig != nil {
            map["EditingProduceConfig"] = self.editingProduceConfig!
        }
        if self.outputMediaConfig != nil {
            map["OutputMediaConfig"] = self.outputMediaConfig!
        }
        if self.outputMediaTarget != nil {
            map["OutputMediaTarget"] = self.outputMediaTarget!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectMetadata != nil {
            map["ProjectMetadata"] = self.projectMetadata!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ClipsParam") && dict["ClipsParam"] != nil {
            self.clipsParam = dict["ClipsParam"] as! String
        }
        if dict.keys.contains("EditingProduceConfig") && dict["EditingProduceConfig"] != nil {
            self.editingProduceConfig = dict["EditingProduceConfig"] as! String
        }
        if dict.keys.contains("OutputMediaConfig") && dict["OutputMediaConfig"] != nil {
            self.outputMediaConfig = dict["OutputMediaConfig"] as! String
        }
        if dict.keys.contains("OutputMediaTarget") && dict["OutputMediaTarget"] != nil {
            self.outputMediaTarget = dict["OutputMediaTarget"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectMetadata") && dict["ProjectMetadata"] != nil {
            self.projectMetadata = dict["ProjectMetadata"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaProducingJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var projectId: String?

    public var requestId: String?

    public var vodMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodMediaId != nil {
            map["VodMediaId"] = self.vodMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodMediaId") && dict["VodMediaId"] != nil {
            self.vodMediaId = dict["VodMediaId"] as! String
        }
    }
}

public class SubmitMediaProducingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaProducingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitMediaProducingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitPackageJobRequest : Tea.TeaModel {
    public class Inputs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var input: SubmitPackageJobRequest.Inputs.Input?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Input") && dict["Input"] != nil {
                var model = SubmitPackageJobRequest.Inputs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var inputs: [SubmitPackageJobRequest.Inputs]?

    public var name: String?

    public var output: SubmitPackageJobRequest.Output?

    public var scheduleConfig: SubmitPackageJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.output?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputs != nil {
            var tmp : [Any] = []
            for k in self.inputs! {
                tmp.append(k.toMap())
            }
            map["Inputs"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Inputs") && dict["Inputs"] != nil {
            var tmp : [SubmitPackageJobRequest.Inputs] = []
            for v in dict["Inputs"] as! [Any] {
                var model = SubmitPackageJobRequest.Inputs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inputs = tmp
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") && dict["Output"] != nil {
            var model = SubmitPackageJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            var model = SubmitPackageJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitPackageJobShrinkRequest : Tea.TeaModel {
    public var inputsShrink: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputsShrink != nil {
            map["Inputs"] = self.inputsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Inputs") && dict["Inputs"] != nil {
            self.inputsShrink = dict["Inputs"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") && dict["Output"] != nil {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitPackageJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitPackageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitPackageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitPackageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSmarttagJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! String
            }
        }
    }
    public var content: String?

    public var contentAddr: String?

    public var contentType: String?

    public var input: SubmitSmarttagJobRequest.Input?

    public var notifyUrl: String?

    public var params: String?

    public var scheduleConfig: SubmitSmarttagJobRequest.ScheduleConfig?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentAddr != nil {
            map["ContentAddr"] = self.contentAddr!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentAddr") && dict["ContentAddr"] != nil {
            self.contentAddr = dict["ContentAddr"] as! String
        }
        if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("Input") && dict["Input"] != nil {
            var model = SubmitSmarttagJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("NotifyUrl") && dict["NotifyUrl"] != nil {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            var model = SubmitSmarttagJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSmarttagJobShrinkRequest : Tea.TeaModel {
    public var content: String?

    public var contentAddr: String?

    public var contentType: String?

    public var inputShrink: String?

    public var notifyUrl: String?

    public var params: String?

    public var scheduleConfigShrink: String?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentAddr != nil {
            map["ContentAddr"] = self.contentAddr!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentAddr") && dict["ContentAddr"] != nil {
            self.contentAddr = dict["ContentAddr"] as! String
        }
        if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("Input") && dict["Input"] != nil {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("NotifyUrl") && dict["NotifyUrl"] != nil {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSmarttagJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSmarttagJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSmarttagJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitSmarttagJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSnapshotJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
        }
    }
    public class TemplateConfig : Tea.TeaModel {
        public class OverwriteParams : Tea.TeaModel {
            public class SpriteSnapshotConfig : Tea.TeaModel {
                public var cellHeight: Int32?

                public var cellWidth: Int32?

                public var color: String?

                public var columns: Int32?

                public var lines: Int32?

                public var margin: Int32?

                public var padding: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cellHeight != nil {
                        map["CellHeight"] = self.cellHeight!
                    }
                    if self.cellWidth != nil {
                        map["CellWidth"] = self.cellWidth!
                    }
                    if self.color != nil {
                        map["Color"] = self.color!
                    }
                    if self.columns != nil {
                        map["Columns"] = self.columns!
                    }
                    if self.lines != nil {
                        map["Lines"] = self.lines!
                    }
                    if self.margin != nil {
                        map["Margin"] = self.margin!
                    }
                    if self.padding != nil {
                        map["Padding"] = self.padding!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CellHeight") && dict["CellHeight"] != nil {
                        self.cellHeight = dict["CellHeight"] as! Int32
                    }
                    if dict.keys.contains("CellWidth") && dict["CellWidth"] != nil {
                        self.cellWidth = dict["CellWidth"] as! Int32
                    }
                    if dict.keys.contains("Color") && dict["Color"] != nil {
                        self.color = dict["Color"] as! String
                    }
                    if dict.keys.contains("Columns") && dict["Columns"] != nil {
                        self.columns = dict["Columns"] as! Int32
                    }
                    if dict.keys.contains("Lines") && dict["Lines"] != nil {
                        self.lines = dict["Lines"] as! Int32
                    }
                    if dict.keys.contains("Margin") && dict["Margin"] != nil {
                        self.margin = dict["Margin"] as! Int32
                    }
                    if dict.keys.contains("Padding") && dict["Padding"] != nil {
                        self.padding = dict["Padding"] as! Int32
                    }
                }
            }
            public var blackLevel: Int32?

            public var count: Int64?

            public var frameType: String?

            public var height: Int32?

            public var interval: Int64?

            public var isSptFrag: Bool?

            public var pixelBlackThreshold: Int32?

            public var spriteSnapshotConfig: SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams.SpriteSnapshotConfig?

            public var time: Int64?

            public var type: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.spriteSnapshotConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blackLevel != nil {
                    map["BlackLevel"] = self.blackLevel!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.frameType != nil {
                    map["FrameType"] = self.frameType!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.isSptFrag != nil {
                    map["IsSptFrag"] = self.isSptFrag!
                }
                if self.pixelBlackThreshold != nil {
                    map["PixelBlackThreshold"] = self.pixelBlackThreshold!
                }
                if self.spriteSnapshotConfig != nil {
                    map["SpriteSnapshotConfig"] = self.spriteSnapshotConfig?.toMap()
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlackLevel") && dict["BlackLevel"] != nil {
                    self.blackLevel = dict["BlackLevel"] as! Int32
                }
                if dict.keys.contains("Count") && dict["Count"] != nil {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("FrameType") && dict["FrameType"] != nil {
                    self.frameType = dict["FrameType"] as! String
                }
                if dict.keys.contains("Height") && dict["Height"] != nil {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("IsSptFrag") && dict["IsSptFrag"] != nil {
                    self.isSptFrag = dict["IsSptFrag"] as! Bool
                }
                if dict.keys.contains("PixelBlackThreshold") && dict["PixelBlackThreshold"] != nil {
                    self.pixelBlackThreshold = dict["PixelBlackThreshold"] as! Int32
                }
                if dict.keys.contains("SpriteSnapshotConfig") && dict["SpriteSnapshotConfig"] != nil {
                    var model = SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams.SpriteSnapshotConfig()
                    model.fromMap(dict["SpriteSnapshotConfig"] as! [String: Any])
                    self.spriteSnapshotConfig = model
                }
                if dict.keys.contains("Time") && dict["Time"] != nil {
                    self.time = dict["Time"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Width") && dict["Width"] != nil {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var overwriteParams: SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.overwriteParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.overwriteParams != nil {
                map["OverwriteParams"] = self.overwriteParams?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                var model = SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams()
                model.fromMap(dict["OverwriteParams"] as! [String: Any])
                self.overwriteParams = model
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var input: SubmitSnapshotJobRequest.Input?

    public var name: String?

    public var output: SubmitSnapshotJobRequest.Output?

    public var scheduleConfig: SubmitSnapshotJobRequest.ScheduleConfig?

    public var templateConfig: SubmitSnapshotJobRequest.TemplateConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") && dict["Input"] != nil {
            var model = SubmitSnapshotJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") && dict["Output"] != nil {
            var model = SubmitSnapshotJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            var model = SubmitSnapshotJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            var model = SubmitSnapshotJobRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSnapshotJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var templateConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") && dict["Input"] != nil {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") && dict["Output"] != nil {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSnapshotJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSubtitleProduceJobRequest : Tea.TeaModel {
    public var description_: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var isAsync: Int64?

    public var outputConfig: String?

    public var title: String?

    public var type: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.isAsync != nil {
            map["IsAsync"] = self.isAsync!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditingConfig") && dict["EditingConfig"] != nil {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") && dict["InputConfig"] != nil {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("IsAsync") && dict["IsAsync"] != nil {
            self.isAsync = dict["IsAsync"] as! Int64
        }
        if dict.keys.contains("OutputConfig") && dict["OutputConfig"] != nil {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSubtitleProduceJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSubtitleProduceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSubtitleProduceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitSubtitleProduceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSyncMediaInfoJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var input: SubmitSyncMediaInfoJobRequest.Input?

    public var name: String?

    public var scheduleConfig: SubmitSyncMediaInfoJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") && dict["Input"] != nil {
            var model = SubmitSyncMediaInfoJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            var model = SubmitSyncMediaInfoJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSyncMediaInfoJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") && dict["Input"] != nil {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSyncMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") && dict["ChannelLayout"] != nil {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") && dict["Channels"] != nil {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") && dict["SampleFmt"] != nil {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") && dict["SampleRate"] != nil {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") && dict["FileType"] != nil {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") && dict["Region"] != nil {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") && dict["Avg_fps"] != nil {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") && dict["Bit_rate"] != nil {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") && dict["Codec_long_name"] != nil {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") && dict["Codec_name"] != nil {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") && dict["Codec_tag"] != nil {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") && dict["Codec_tag_string"] != nil {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") && dict["Codec_time_base"] != nil {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") && dict["Dar"] != nil {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") && dict["Fps"] != nil {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") && dict["Has_b_frames"] != nil {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") && dict["Lang"] != nil {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") && dict["NumFrames"] != nil {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") && dict["Profile"] != nil {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") && dict["Rotate"] != nil {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") && dict["Sar"] != nil {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") && dict["Start_time"] != nil {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") && dict["Time_base"] != nil {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") && dict["AudioStreamInfoList"] != nil {
                    var tmp : [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                    var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") && dict["VideoStreamInfoList"] != nil {
                    var tmp : [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") && dict["Priority"] != nil {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var mediaInfoProperty: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") && dict["Async"] != nil {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") && dict["Input"] != nil {
                var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") && dict["MediaInfoProperty"] != nil {
                var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
                var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") && dict["SubmitResultJson"] != nil {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") && dict["MediaInfoJob"] != nil {
            var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSyncMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSyncMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitSyncMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTranscodeJobRequest : Tea.TeaModel {
    public class InputGroup : Tea.TeaModel {
        public var inputUrl: String?

        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputUrl") && dict["InputUrl"] != nil {
                self.inputUrl = dict["InputUrl"] as! String
            }
            if dict.keys.contains("Media") && dict["Media"] != nil {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class OutputGroup : Tea.TeaModel {
        public class Output : Tea.TeaModel {
            public var media: String?

            public var outputUrl: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.outputUrl != nil {
                    map["OutputUrl"] = self.outputUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OutputUrl") && dict["OutputUrl"] != nil {
                    self.outputUrl = dict["OutputUrl"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class ProcessConfig : Tea.TeaModel {
            public class CombineConfigs : Tea.TeaModel {
                public var audioIndex: String?

                public var duration: Double?

                public var start: Double?

                public var videoIndex: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioIndex != nil {
                        map["AudioIndex"] = self.audioIndex!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.start != nil {
                        map["Start"] = self.start!
                    }
                    if self.videoIndex != nil {
                        map["VideoIndex"] = self.videoIndex!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioIndex") && dict["AudioIndex"] != nil {
                        self.audioIndex = dict["AudioIndex"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! Double
                    }
                    if dict.keys.contains("Start") && dict["Start"] != nil {
                        self.start = dict["Start"] as! Double
                    }
                    if dict.keys.contains("VideoIndex") && dict["VideoIndex"] != nil {
                        self.videoIndex = dict["VideoIndex"] as! String
                    }
                }
            }
            public class Encryption : Tea.TeaModel {
                public var cipherText: String?

                public var decryptKeyUri: String?

                public var encryptType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cipherText != nil {
                        map["CipherText"] = self.cipherText!
                    }
                    if self.decryptKeyUri != nil {
                        map["DecryptKeyUri"] = self.decryptKeyUri!
                    }
                    if self.encryptType != nil {
                        map["EncryptType"] = self.encryptType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CipherText") && dict["CipherText"] != nil {
                        self.cipherText = dict["CipherText"] as! String
                    }
                    if dict.keys.contains("DecryptKeyUri") && dict["DecryptKeyUri"] != nil {
                        self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                    }
                    if dict.keys.contains("EncryptType") && dict["EncryptType"] != nil {
                        self.encryptType = dict["EncryptType"] as! String
                    }
                }
            }
            public class ImageWatermarks : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var media: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.media != nil {
                                map["Media"] = self.media!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Media") && dict["Media"] != nil {
                                self.media = dict["Media"] as! String
                            }
                            if dict.keys.contains("Type") && dict["Type"] != nil {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public class Timeline : Tea.TeaModel {
                        public var duration: String?

                        public var start: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Start") && dict["Start"] != nil {
                                self.start = dict["Start"] as! String
                            }
                        }
                    }
                    public var dx: String?

                    public var dy: String?

                    public var file: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                    public var height: String?

                    public var referPos: String?

                    public var timeline: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                        try self.timeline?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dx != nil {
                            map["Dx"] = self.dx!
                        }
                        if self.dy != nil {
                            map["Dy"] = self.dy!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.referPos != nil {
                            map["ReferPos"] = self.referPos!
                        }
                        if self.timeline != nil {
                            map["Timeline"] = self.timeline?.toMap()
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Dx") && dict["Dx"] != nil {
                            self.dx = dict["Dx"] as! String
                        }
                        if dict.keys.contains("Dy") && dict["Dy"] != nil {
                            self.dy = dict["Dy"] as! String
                        }
                        if dict.keys.contains("File") && dict["File"] != nil {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("Height") && dict["Height"] != nil {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("ReferPos") && dict["ReferPos"] != nil {
                            self.referPos = dict["ReferPos"] as! String
                        }
                        if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                            model.fromMap(dict["Timeline"] as! [String: Any])
                            self.timeline = model
                        }
                        if dict.keys.contains("Width") && dict["Width"] != nil {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public class Subtitles : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var media: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.media != nil {
                                map["Media"] = self.media!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Media") && dict["Media"] != nil {
                                self.media = dict["Media"] as! String
                            }
                            if dict.keys.contains("Type") && dict["Type"] != nil {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public var charEnc: String?

                    public var file: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                    public var format: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.charEnc != nil {
                            map["CharEnc"] = self.charEnc!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CharEnc") && dict["CharEnc"] != nil {
                            self.charEnc = dict["CharEnc"] as! String
                        }
                        if dict.keys.contains("File") && dict["File"] != nil {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("Format") && dict["Format"] != nil {
                            self.format = dict["Format"] as! String
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public class TextWatermarks : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public var adaptive: String?

                    public var borderColor: String?

                    public var borderWidth: Int32?

                    public var content: String?

                    public var fontAlpha: String?

                    public var fontColor: String?

                    public var fontName: String?

                    public var fontSize: Int32?

                    public var left_: String?

                    public var top: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adaptive != nil {
                            map["Adaptive"] = self.adaptive!
                        }
                        if self.borderColor != nil {
                            map["BorderColor"] = self.borderColor!
                        }
                        if self.borderWidth != nil {
                            map["BorderWidth"] = self.borderWidth!
                        }
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.fontAlpha != nil {
                            map["FontAlpha"] = self.fontAlpha!
                        }
                        if self.fontColor != nil {
                            map["FontColor"] = self.fontColor!
                        }
                        if self.fontName != nil {
                            map["FontName"] = self.fontName!
                        }
                        if self.fontSize != nil {
                            map["FontSize"] = self.fontSize!
                        }
                        if self.left_ != nil {
                            map["Left"] = self.left_!
                        }
                        if self.top != nil {
                            map["Top"] = self.top!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Adaptive") && dict["Adaptive"] != nil {
                            self.adaptive = dict["Adaptive"] as! String
                        }
                        if dict.keys.contains("BorderColor") && dict["BorderColor"] != nil {
                            self.borderColor = dict["BorderColor"] as! String
                        }
                        if dict.keys.contains("BorderWidth") && dict["BorderWidth"] != nil {
                            self.borderWidth = dict["BorderWidth"] as! Int32
                        }
                        if dict.keys.contains("Content") && dict["Content"] != nil {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("FontAlpha") && dict["FontAlpha"] != nil {
                            self.fontAlpha = dict["FontAlpha"] as! String
                        }
                        if dict.keys.contains("FontColor") && dict["FontColor"] != nil {
                            self.fontColor = dict["FontColor"] as! String
                        }
                        if dict.keys.contains("FontName") && dict["FontName"] != nil {
                            self.fontName = dict["FontName"] as! String
                        }
                        if dict.keys.contains("FontSize") && dict["FontSize"] != nil {
                            self.fontSize = dict["FontSize"] as! Int32
                        }
                        if dict.keys.contains("Left") && dict["Left"] != nil {
                            self.left_ = dict["Left"] as! String
                        }
                        if dict.keys.contains("Top") && dict["Top"] != nil {
                            self.top = dict["Top"] as! String
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public class Transcode : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public class Audio : Tea.TeaModel {
                        public class Volume : Tea.TeaModel {
                            public var integratedLoudnessTarget: String?

                            public var loudnessRangeTarget: String?

                            public var method: String?

                            public var truePeak: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.integratedLoudnessTarget != nil {
                                    map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                }
                                if self.loudnessRangeTarget != nil {
                                    map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                }
                                if self.method != nil {
                                    map["Method"] = self.method!
                                }
                                if self.truePeak != nil {
                                    map["TruePeak"] = self.truePeak!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("IntegratedLoudnessTarget") && dict["IntegratedLoudnessTarget"] != nil {
                                    self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                }
                                if dict.keys.contains("LoudnessRangeTarget") && dict["LoudnessRangeTarget"] != nil {
                                    self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                }
                                if dict.keys.contains("Method") && dict["Method"] != nil {
                                    self.method = dict["Method"] as! String
                                }
                                if dict.keys.contains("TruePeak") && dict["TruePeak"] != nil {
                                    self.truePeak = dict["TruePeak"] as! String
                                }
                            }
                        }
                        public var bitrate: String?

                        public var channels: String?

                        public var codec: String?

                        public var profile: String?

                        public var remove: String?

                        public var samplerate: String?

                        public var volume: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.volume?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.remove != nil {
                                map["Remove"] = self.remove!
                            }
                            if self.samplerate != nil {
                                map["Samplerate"] = self.samplerate!
                            }
                            if self.volume != nil {
                                map["Volume"] = self.volume?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Channels") && dict["Channels"] != nil {
                                self.channels = dict["Channels"] as! String
                            }
                            if dict.keys.contains("Codec") && dict["Codec"] != nil {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Profile") && dict["Profile"] != nil {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Remove") && dict["Remove"] != nil {
                                self.remove = dict["Remove"] as! String
                            }
                            if dict.keys.contains("Samplerate") && dict["Samplerate"] != nil {
                                self.samplerate = dict["Samplerate"] as! String
                            }
                            if dict.keys.contains("Volume") && dict["Volume"] != nil {
                                var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                model.fromMap(dict["Volume"] as! [String: Any])
                                self.volume = model
                            }
                        }
                    }
                    public class Container : Tea.TeaModel {
                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Format") && dict["Format"] != nil {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public class MuxConfig : Tea.TeaModel {
                        public class Segment : Tea.TeaModel {
                            public var duration: String?

                            public var forceSegTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.forceSegTime != nil {
                                    map["ForceSegTime"] = self.forceSegTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("ForceSegTime") && dict["ForceSegTime"] != nil {
                                    self.forceSegTime = dict["ForceSegTime"] as! String
                                }
                            }
                        }
                        public var segment: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.segment?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.segment != nil {
                                map["Segment"] = self.segment?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Segment") && dict["Segment"] != nil {
                                var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                model.fromMap(dict["Segment"] as! [String: Any])
                                self.segment = model
                            }
                        }
                    }
                    public class Video : Tea.TeaModel {
                        public var abrMax: String?

                        public var bitrate: String?

                        public var bufsize: String?

                        public var codec: String?

                        public var crf: String?

                        public var crop: String?

                        public var fps: String?

                        public var gop: String?

                        public var height: String?

                        public var longShortMode: String?

                        public var maxrate: String?

                        public var pad: String?

                        public var pixFmt: String?

                        public var preset: String?

                        public var profile: String?

                        public var remove: String?

                        public var scanMode: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.abrMax != nil {
                                map["AbrMax"] = self.abrMax!
                            }
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.bufsize != nil {
                                map["Bufsize"] = self.bufsize!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.crf != nil {
                                map["Crf"] = self.crf!
                            }
                            if self.crop != nil {
                                map["Crop"] = self.crop!
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.gop != nil {
                                map["Gop"] = self.gop!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.longShortMode != nil {
                                map["LongShortMode"] = self.longShortMode!
                            }
                            if self.maxrate != nil {
                                map["Maxrate"] = self.maxrate!
                            }
                            if self.pad != nil {
                                map["Pad"] = self.pad!
                            }
                            if self.pixFmt != nil {
                                map["PixFmt"] = self.pixFmt!
                            }
                            if self.preset != nil {
                                map["Preset"] = self.preset!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.remove != nil {
                                map["Remove"] = self.remove!
                            }
                            if self.scanMode != nil {
                                map["ScanMode"] = self.scanMode!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AbrMax") && dict["AbrMax"] != nil {
                                self.abrMax = dict["AbrMax"] as! String
                            }
                            if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Bufsize") && dict["Bufsize"] != nil {
                                self.bufsize = dict["Bufsize"] as! String
                            }
                            if dict.keys.contains("Codec") && dict["Codec"] != nil {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Crf") && dict["Crf"] != nil {
                                self.crf = dict["Crf"] as! String
                            }
                            if dict.keys.contains("Crop") && dict["Crop"] != nil {
                                self.crop = dict["Crop"] as! String
                            }
                            if dict.keys.contains("Fps") && dict["Fps"] != nil {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("Gop") && dict["Gop"] != nil {
                                self.gop = dict["Gop"] as! String
                            }
                            if dict.keys.contains("Height") && dict["Height"] != nil {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("LongShortMode") && dict["LongShortMode"] != nil {
                                self.longShortMode = dict["LongShortMode"] as! String
                            }
                            if dict.keys.contains("Maxrate") && dict["Maxrate"] != nil {
                                self.maxrate = dict["Maxrate"] as! String
                            }
                            if dict.keys.contains("Pad") && dict["Pad"] != nil {
                                self.pad = dict["Pad"] as! String
                            }
                            if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                                self.pixFmt = dict["PixFmt"] as! String
                            }
                            if dict.keys.contains("Preset") && dict["Preset"] != nil {
                                self.preset = dict["Preset"] as! String
                            }
                            if dict.keys.contains("Profile") && dict["Profile"] != nil {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Remove") && dict["Remove"] != nil {
                                self.remove = dict["Remove"] as! String
                            }
                            if dict.keys.contains("ScanMode") && dict["ScanMode"] != nil {
                                self.scanMode = dict["ScanMode"] as! String
                            }
                            if dict.keys.contains("Width") && dict["Width"] != nil {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var audio: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                    public var container: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                    public var muxConfig: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                    public var tags: [String: String]?

                    public var video: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audio?.validate()
                        try self.container?.validate()
                        try self.muxConfig?.validate()
                        try self.video?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audio != nil {
                            map["Audio"] = self.audio?.toMap()
                        }
                        if self.container != nil {
                            map["Container"] = self.container?.toMap()
                        }
                        if self.muxConfig != nil {
                            map["MuxConfig"] = self.muxConfig?.toMap()
                        }
                        if self.tags != nil {
                            map["Tags"] = self.tags!
                        }
                        if self.video != nil {
                            map["Video"] = self.video?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Audio") && dict["Audio"] != nil {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                            model.fromMap(dict["Audio"] as! [String: Any])
                            self.audio = model
                        }
                        if dict.keys.contains("Container") && dict["Container"] != nil {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                            model.fromMap(dict["Container"] as! [String: Any])
                            self.container = model
                        }
                        if dict.keys.contains("MuxConfig") && dict["MuxConfig"] != nil {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                            model.fromMap(dict["MuxConfig"] as! [String: Any])
                            self.muxConfig = model
                        }
                        if dict.keys.contains("Tags") && dict["Tags"] != nil {
                            self.tags = dict["Tags"] as! [String: String]
                        }
                        if dict.keys.contains("Video") && dict["Video"] != nil {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                            model.fromMap(dict["Video"] as! [String: Any])
                            self.video = model
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public var combineConfigs: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.CombineConfigs]?

            public var encryption: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Encryption?

            public var imageWatermarks: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks]?

            public var isInheritTags: Bool?

            public var subtitles: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles]?

            public var textWatermarks: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks]?

            public var transcode: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.encryption?.validate()
                try self.transcode?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.combineConfigs != nil {
                    var tmp : [Any] = []
                    for k in self.combineConfigs! {
                        tmp.append(k.toMap())
                    }
                    map["CombineConfigs"] = tmp
                }
                if self.encryption != nil {
                    map["Encryption"] = self.encryption?.toMap()
                }
                if self.imageWatermarks != nil {
                    var tmp : [Any] = []
                    for k in self.imageWatermarks! {
                        tmp.append(k.toMap())
                    }
                    map["ImageWatermarks"] = tmp
                }
                if self.isInheritTags != nil {
                    map["IsInheritTags"] = self.isInheritTags!
                }
                if self.subtitles != nil {
                    var tmp : [Any] = []
                    for k in self.subtitles! {
                        tmp.append(k.toMap())
                    }
                    map["Subtitles"] = tmp
                }
                if self.textWatermarks != nil {
                    var tmp : [Any] = []
                    for k in self.textWatermarks! {
                        tmp.append(k.toMap())
                    }
                    map["TextWatermarks"] = tmp
                }
                if self.transcode != nil {
                    map["Transcode"] = self.transcode?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CombineConfigs") && dict["CombineConfigs"] != nil {
                    var tmp : [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.CombineConfigs] = []
                    for v in dict["CombineConfigs"] as! [Any] {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.CombineConfigs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.combineConfigs = tmp
                }
                if dict.keys.contains("Encryption") && dict["Encryption"] != nil {
                    var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Encryption()
                    model.fromMap(dict["Encryption"] as! [String: Any])
                    self.encryption = model
                }
                if dict.keys.contains("ImageWatermarks") && dict["ImageWatermarks"] != nil {
                    var tmp : [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks] = []
                    for v in dict["ImageWatermarks"] as! [Any] {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.imageWatermarks = tmp
                }
                if dict.keys.contains("IsInheritTags") && dict["IsInheritTags"] != nil {
                    self.isInheritTags = dict["IsInheritTags"] as! Bool
                }
                if dict.keys.contains("Subtitles") && dict["Subtitles"] != nil {
                    var tmp : [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles] = []
                    for v in dict["Subtitles"] as! [Any] {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subtitles = tmp
                }
                if dict.keys.contains("TextWatermarks") && dict["TextWatermarks"] != nil {
                    var tmp : [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks] = []
                    for v in dict["TextWatermarks"] as! [Any] {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.textWatermarks = tmp
                }
                if dict.keys.contains("Transcode") && dict["Transcode"] != nil {
                    var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode()
                    model.fromMap(dict["Transcode"] as! [String: Any])
                    self.transcode = model
                }
            }
        }
        public var output: SubmitTranscodeJobRequest.OutputGroup.Output?

        public var processConfig: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.output?.validate()
            try self.processConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.processConfig != nil {
                map["ProcessConfig"] = self.processConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Output") && dict["Output"] != nil {
                var model = SubmitTranscodeJobRequest.OutputGroup.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("ProcessConfig") && dict["ProcessConfig"] != nil {
                var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig()
                model.fromMap(dict["ProcessConfig"] as! [String: Any])
                self.processConfig = model
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var inputGroup: [SubmitTranscodeJobRequest.InputGroup]?

    public var name: String?

    public var outputGroup: [SubmitTranscodeJobRequest.OutputGroup]?

    public var scheduleConfig: SubmitTranscodeJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputGroup != nil {
            var tmp : [Any] = []
            for k in self.inputGroup! {
                tmp.append(k.toMap())
            }
            map["InputGroup"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputGroup != nil {
            var tmp : [Any] = []
            for k in self.outputGroup! {
                tmp.append(k.toMap())
            }
            map["OutputGroup"] = tmp
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputGroup") && dict["InputGroup"] != nil {
            var tmp : [SubmitTranscodeJobRequest.InputGroup] = []
            for v in dict["InputGroup"] as! [Any] {
                var model = SubmitTranscodeJobRequest.InputGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inputGroup = tmp
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputGroup") && dict["OutputGroup"] != nil {
            var tmp : [SubmitTranscodeJobRequest.OutputGroup] = []
            for v in dict["OutputGroup"] as! [Any] {
                var model = SubmitTranscodeJobRequest.OutputGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outputGroup = tmp
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            var model = SubmitTranscodeJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTranscodeJobShrinkRequest : Tea.TeaModel {
    public var inputGroupShrink: String?

    public var name: String?

    public var outputGroupShrink: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputGroupShrink != nil {
            map["InputGroup"] = self.inputGroupShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputGroupShrink != nil {
            map["OutputGroup"] = self.outputGroupShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputGroup") && dict["InputGroup"] != nil {
            self.inputGroupShrink = dict["InputGroup"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputGroup") && dict["OutputGroup"] != nil {
            self.outputGroupShrink = dict["OutputGroup"] as! String
        }
        if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTranscodeJobResponseBody : Tea.TeaModel {
    public class TranscodeParentJob : Tea.TeaModel {
        public class InputGroup : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") && dict["Media"] != nil {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class OutputGroup : Tea.TeaModel {
            public class Output : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") && dict["Media"] != nil {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") && dict["AudioIndex"] != nil {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") && dict["Start"] != nil {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") && dict["VideoIndex"] != nil {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") && dict["CipherText"] != nil {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") && dict["DecryptKeyUri"] != nil {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") && dict["EncryptType"] != nil {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") && dict["Media"] != nil {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") && dict["Type"] != nil {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") && dict["Start"] != nil {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") && dict["Dx"] != nil {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") && dict["Dy"] != nil {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") && dict["File"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") && dict["Height"] != nil {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") && dict["ReferPos"] != nil {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") && dict["Width"] != nil {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") && dict["Media"] != nil {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") && dict["Type"] != nil {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") && dict["CharEnc"] != nil {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") && dict["File"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") && dict["Format"] != nil {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") && dict["Adaptive"] != nil {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") && dict["BorderColor"] != nil {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") && dict["BorderWidth"] != nil {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") && dict["Content"] != nil {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") && dict["FontAlpha"] != nil {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") && dict["FontColor"] != nil {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") && dict["FontName"] != nil {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") && dict["FontSize"] != nil {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") && dict["Left"] != nil {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") && dict["Top"] != nil {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") && dict["IntegratedLoudnessTarget"] != nil {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") && dict["LoudnessRangeTarget"] != nil {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") && dict["Method"] != nil {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") && dict["TruePeak"] != nil {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") && dict["Channels"] != nil {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") && dict["Remove"] != nil {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") && dict["Samplerate"] != nil {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") && dict["Volume"] != nil {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") && dict["Format"] != nil {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") && dict["ForceSegTime"] != nil {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") && dict["Segment"] != nil {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") && dict["AbrMax"] != nil {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") && dict["Bufsize"] != nil {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") && dict["Crf"] != nil {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") && dict["Crop"] != nil {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") && dict["Fps"] != nil {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") && dict["Gop"] != nil {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") && dict["Height"] != nil {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") && dict["LongShortMode"] != nil {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") && dict["Maxrate"] != nil {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") && dict["Pad"] != nil {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") && dict["Preset"] != nil {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") && dict["Remove"] != nil {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") && dict["ScanMode"] != nil {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") && dict["Width"] != nil {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var video: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") && dict["Audio"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") && dict["Container"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") && dict["MuxConfig"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Video") && dict["Video"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs]?

                public var encryption: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption?

                public var imageWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks]?

                public var subtitles: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles]?

                public var textWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks]?

                public var transcode: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") && dict["CombineConfigs"] != nil {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") && dict["Encryption"] != nil {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") && dict["ImageWatermarks"] != nil {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("Subtitles") && dict["Subtitles"] != nil {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") && dict["TextWatermarks"] != nil {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") && dict["Transcode"] != nil {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public var output: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output?

            public var processConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
                try self.processConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Output") && dict["Output"] != nil {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ProcessConfig") && dict["ProcessConfig"] != nil {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") && dict["Priority"] != nil {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public class TranscodeJobList : Tea.TeaModel {
            public class InputGroup : Tea.TeaModel {
                public var inputUrl: String?

                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inputUrl != nil {
                        map["InputUrl"] = self.inputUrl!
                    }
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InputUrl") && dict["InputUrl"] != nil {
                        self.inputUrl = dict["InputUrl"] as! String
                    }
                    if dict.keys.contains("Media") && dict["Media"] != nil {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class OutFileMeta : Tea.TeaModel {
                public class AudioStreamInfoList : Tea.TeaModel {
                    public var bitrate: String?

                    public var channelLayout: String?

                    public var channels: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var duration: String?

                    public var index: String?

                    public var lang: String?

                    public var sampleFmt: String?

                    public var sampleRate: String?

                    public var startTime: String?

                    public var timebase: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channelLayout != nil {
                            map["ChannelLayout"] = self.channelLayout!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codecLongName != nil {
                            map["CodecLongName"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["CodecName"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["CodecTag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["CodecTagString"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["CodecTimeBase"] = self.codecTimeBase!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.sampleFmt != nil {
                            map["SampleFmt"] = self.sampleFmt!
                        }
                        if self.sampleRate != nil {
                            map["SampleRate"] = self.sampleRate!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.timebase != nil {
                            map["Timebase"] = self.timebase!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("ChannelLayout") && dict["ChannelLayout"] != nil {
                            self.channelLayout = dict["ChannelLayout"] as! String
                        }
                        if dict.keys.contains("Channels") && dict["Channels"] != nil {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                            self.codecLongName = dict["CodecLongName"] as! String
                        }
                        if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                            self.codecName = dict["CodecName"] as! String
                        }
                        if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                            self.codecTag = dict["CodecTag"] as! String
                        }
                        if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                            self.codecTagString = dict["CodecTagString"] as! String
                        }
                        if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                        }
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Index") && dict["Index"] != nil {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") && dict["Lang"] != nil {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("SampleFmt") && dict["SampleFmt"] != nil {
                            self.sampleFmt = dict["SampleFmt"] as! String
                        }
                        if dict.keys.contains("SampleRate") && dict["SampleRate"] != nil {
                            self.sampleRate = dict["SampleRate"] as! String
                        }
                        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                            self.timebase = dict["Timebase"] as! String
                        }
                    }
                }
                public class FileBasicInfo : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var fileName: String?

                    public var fileSize: String?

                    public var fileStatus: String?

                    public var fileType: String?

                    public var fileUrl: String?

                    public var formatName: String?

                    public var height: String?

                    public var mediaId: String?

                    public var region: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileName != nil {
                            map["FileName"] = self.fileName!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.fileStatus != nil {
                            map["FileStatus"] = self.fileStatus!
                        }
                        if self.fileType != nil {
                            map["FileType"] = self.fileType!
                        }
                        if self.fileUrl != nil {
                            map["FileUrl"] = self.fileUrl!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.mediaId != nil {
                            map["MediaId"] = self.mediaId!
                        }
                        if self.region != nil {
                            map["Region"] = self.region!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileName") && dict["FileName"] != nil {
                            self.fileName = dict["FileName"] as! String
                        }
                        if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("FileStatus") && dict["FileStatus"] != nil {
                            self.fileStatus = dict["FileStatus"] as! String
                        }
                        if dict.keys.contains("FileType") && dict["FileType"] != nil {
                            self.fileType = dict["FileType"] as! String
                        }
                        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                            self.fileUrl = dict["FileUrl"] as! String
                        }
                        if dict.keys.contains("FormatName") && dict["FormatName"] != nil {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("Height") && dict["Height"] != nil {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                            self.mediaId = dict["MediaId"] as! String
                        }
                        if dict.keys.contains("Region") && dict["Region"] != nil {
                            self.region = dict["Region"] as! String
                        }
                        if dict.keys.contains("Width") && dict["Width"] != nil {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class VideoStreamInfoList : Tea.TeaModel {
                    public var avgFps: String?

                    public var bitRate: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var dar: String?

                    public var duration: String?

                    public var fps: String?

                    public var hasBFrames: String?

                    public var height: String?

                    public var index: String?

                    public var lang: String?

                    public var level: String?

                    public var numFrames: String?

                    public var pixFmt: String?

                    public var profile: String?

                    public var rotate: String?

                    public var sar: String?

                    public var startTime: String?

                    public var timeBase: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgFps != nil {
                            map["Avg_fps"] = self.avgFps!
                        }
                        if self.bitRate != nil {
                            map["Bit_rate"] = self.bitRate!
                        }
                        if self.codecLongName != nil {
                            map["Codec_long_name"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["Codec_name"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["Codec_tag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["Codec_tag_string"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["Codec_time_base"] = self.codecTimeBase!
                        }
                        if self.dar != nil {
                            map["Dar"] = self.dar!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.hasBFrames != nil {
                            map["Has_b_frames"] = self.hasBFrames!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.numFrames != nil {
                            map["NumFrames"] = self.numFrames!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.rotate != nil {
                            map["Rotate"] = self.rotate!
                        }
                        if self.sar != nil {
                            map["Sar"] = self.sar!
                        }
                        if self.startTime != nil {
                            map["Start_time"] = self.startTime!
                        }
                        if self.timeBase != nil {
                            map["Time_base"] = self.timeBase!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Avg_fps") && dict["Avg_fps"] != nil {
                            self.avgFps = dict["Avg_fps"] as! String
                        }
                        if dict.keys.contains("Bit_rate") && dict["Bit_rate"] != nil {
                            self.bitRate = dict["Bit_rate"] as! String
                        }
                        if dict.keys.contains("Codec_long_name") && dict["Codec_long_name"] != nil {
                            self.codecLongName = dict["Codec_long_name"] as! String
                        }
                        if dict.keys.contains("Codec_name") && dict["Codec_name"] != nil {
                            self.codecName = dict["Codec_name"] as! String
                        }
                        if dict.keys.contains("Codec_tag") && dict["Codec_tag"] != nil {
                            self.codecTag = dict["Codec_tag"] as! String
                        }
                        if dict.keys.contains("Codec_tag_string") && dict["Codec_tag_string"] != nil {
                            self.codecTagString = dict["Codec_tag_string"] as! String
                        }
                        if dict.keys.contains("Codec_time_base") && dict["Codec_time_base"] != nil {
                            self.codecTimeBase = dict["Codec_time_base"] as! String
                        }
                        if dict.keys.contains("Dar") && dict["Dar"] != nil {
                            self.dar = dict["Dar"] as! String
                        }
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Fps") && dict["Fps"] != nil {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Has_b_frames") && dict["Has_b_frames"] != nil {
                            self.hasBFrames = dict["Has_b_frames"] as! String
                        }
                        if dict.keys.contains("Height") && dict["Height"] != nil {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Index") && dict["Index"] != nil {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") && dict["Lang"] != nil {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("Level") && dict["Level"] != nil {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("NumFrames") && dict["NumFrames"] != nil {
                            self.numFrames = dict["NumFrames"] as! String
                        }
                        if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Profile") && dict["Profile"] != nil {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Rotate") && dict["Rotate"] != nil {
                            self.rotate = dict["Rotate"] as! String
                        }
                        if dict.keys.contains("Sar") && dict["Sar"] != nil {
                            self.sar = dict["Sar"] as! String
                        }
                        if dict.keys.contains("Start_time") && dict["Start_time"] != nil {
                            self.startTime = dict["Start_time"] as! String
                        }
                        if dict.keys.contains("Time_base") && dict["Time_base"] != nil {
                            self.timeBase = dict["Time_base"] as! String
                        }
                        if dict.keys.contains("Width") && dict["Width"] != nil {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var audioStreamInfoList: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList]?

                public var fileBasicInfo: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo?

                public var videoStreamInfoList: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.fileBasicInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.audioStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["AudioStreamInfoList"] = tmp
                    }
                    if self.fileBasicInfo != nil {
                        map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                    }
                    if self.videoStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.videoStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["VideoStreamInfoList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioStreamInfoList") && dict["AudioStreamInfoList"] != nil {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList] = []
                        for v in dict["AudioStreamInfoList"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.audioStreamInfoList = tmp
                    }
                    if dict.keys.contains("FileBasicInfo") && dict["FileBasicInfo"] != nil {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo()
                        model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                        self.fileBasicInfo = model
                    }
                    if dict.keys.contains("VideoStreamInfoList") && dict["VideoStreamInfoList"] != nil {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList] = []
                        for v in dict["VideoStreamInfoList"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.videoStreamInfoList = tmp
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public var media: String?

                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") && dict["Media"] != nil {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("OutputUrl") && dict["OutputUrl"] != nil {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") && dict["AudioIndex"] != nil {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") && dict["Start"] != nil {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") && dict["VideoIndex"] != nil {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") && dict["CipherText"] != nil {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") && dict["DecryptKeyUri"] != nil {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") && dict["EncryptType"] != nil {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") && dict["Media"] != nil {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") && dict["Type"] != nil {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") && dict["Start"] != nil {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") && dict["Dx"] != nil {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") && dict["Dy"] != nil {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") && dict["File"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") && dict["Height"] != nil {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") && dict["ReferPos"] != nil {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") && dict["Width"] != nil {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") && dict["Media"] != nil {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") && dict["Type"] != nil {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") && dict["CharEnc"] != nil {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") && dict["File"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") && dict["Format"] != nil {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") && dict["Adaptive"] != nil {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") && dict["BorderColor"] != nil {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") && dict["BorderWidth"] != nil {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") && dict["Content"] != nil {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") && dict["FontAlpha"] != nil {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") && dict["FontColor"] != nil {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") && dict["FontName"] != nil {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") && dict["FontSize"] != nil {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") && dict["Left"] != nil {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") && dict["Top"] != nil {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") && dict["IntegratedLoudnessTarget"] != nil {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") && dict["LoudnessRangeTarget"] != nil {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") && dict["Method"] != nil {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") && dict["TruePeak"] != nil {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") && dict["Channels"] != nil {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") && dict["Remove"] != nil {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") && dict["Samplerate"] != nil {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") && dict["Volume"] != nil {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") && dict["Format"] != nil {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") && dict["ForceSegTime"] != nil {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") && dict["Segment"] != nil {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") && dict["AbrMax"] != nil {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") && dict["Bufsize"] != nil {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") && dict["Crf"] != nil {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") && dict["Crop"] != nil {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") && dict["Fps"] != nil {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") && dict["Gop"] != nil {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") && dict["Height"] != nil {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") && dict["LongShortMode"] != nil {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") && dict["Maxrate"] != nil {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") && dict["Pad"] != nil {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") && dict["Preset"] != nil {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") && dict["Remove"] != nil {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") && dict["ScanMode"] != nil {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") && dict["Width"] != nil {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var tags: [String: Any]?

                        public var video: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.tags != nil {
                                map["Tags"] = self.tags!
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") && dict["Audio"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") && dict["Container"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") && dict["MuxConfig"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                                self.tags = dict["Tags"] as! [String: Any]
                            }
                            if dict.keys.contains("Video") && dict["Video"] != nil {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") && dict["OverwriteParams"] != nil {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs]?

                public var encryption: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption?

                public var imageWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks]?

                public var isInheritTags: String?

                public var subtitles: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles]?

                public var textWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks]?

                public var transcode: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.isInheritTags != nil {
                        map["IsInheritTags"] = self.isInheritTags!
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") && dict["CombineConfigs"] != nil {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") && dict["Encryption"] != nil {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") && dict["ImageWatermarks"] != nil {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("IsInheritTags") && dict["IsInheritTags"] != nil {
                        self.isInheritTags = dict["IsInheritTags"] as! String
                    }
                    if dict.keys.contains("Subtitles") && dict["Subtitles"] != nil {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") && dict["TextWatermarks"] != nil {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") && dict["Transcode"] != nil {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public class ScheduleConfig : Tea.TeaModel {
                public var pipelineId: String?

                public var priority: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                        self.pipelineId = dict["PipelineId"] as! String
                    }
                    if dict.keys.contains("Priority") && dict["Priority"] != nil {
                        self.priority = dict["Priority"] as! Int32
                    }
                }
            }
            public var createTime: String?

            public var finishTime: String?

            public var inputGroup: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup]?

            public var jobId: String?

            public var jobIndex: Int32?

            public var name: String?

            public var outFileMeta: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta?

            public var output: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output?

            public var parentJobId: String?

            public var processConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig?

            public var requestId: String?

            public var scheduleConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig?

            public var status: String?

            public var submitResultJson: [String: Any]?

            public var submitTime: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outFileMeta?.validate()
                try self.output?.validate()
                try self.processConfig?.validate()
                try self.scheduleConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inputGroup != nil {
                    var tmp : [Any] = []
                    for k in self.inputGroup! {
                        tmp.append(k.toMap())
                    }
                    map["InputGroup"] = tmp
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobIndex != nil {
                    map["JobIndex"] = self.jobIndex!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outFileMeta != nil {
                    map["OutFileMeta"] = self.outFileMeta?.toMap()
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.parentJobId != nil {
                    map["ParentJobId"] = self.parentJobId!
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.scheduleConfig != nil {
                    map["ScheduleConfig"] = self.scheduleConfig?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitResultJson != nil {
                    map["SubmitResultJson"] = self.submitResultJson!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("InputGroup") && dict["InputGroup"] != nil {
                    var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup] = []
                    for v in dict["InputGroup"] as! [Any] {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputGroup = tmp
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobIndex") && dict["JobIndex"] != nil {
                    self.jobIndex = dict["JobIndex"] as! Int32
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OutFileMeta") && dict["OutFileMeta"] != nil {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta()
                    model.fromMap(dict["OutFileMeta"] as! [String: Any])
                    self.outFileMeta = model
                }
                if dict.keys.contains("Output") && dict["Output"] != nil {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ParentJobId") && dict["ParentJobId"] != nil {
                    self.parentJobId = dict["ParentJobId"] as! String
                }
                if dict.keys.contains("ProcessConfig") && dict["ProcessConfig"] != nil {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
                if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig()
                    model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                    self.scheduleConfig = model
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitResultJson") && dict["SubmitResultJson"] != nil {
                    self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
                }
                if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("UserData") && dict["UserData"] != nil {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var inputGroup: [SubmitTranscodeJobResponseBody.TranscodeParentJob.InputGroup]?

        public var jobCount: Int32?

        public var name: String?

        public var outputGroup: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup]?

        public var parentJobId: String?

        public var percent: Int32?

        public var requestId: String?

        public var scheduleConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig?

        public var status: String?

        public var submitTime: String?

        public var transcodeJobList: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList]?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputGroup != nil {
                var tmp : [Any] = []
                for k in self.inputGroup! {
                    tmp.append(k.toMap())
                }
                map["InputGroup"] = tmp
            }
            if self.jobCount != nil {
                map["JobCount"] = self.jobCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroup != nil {
                var tmp : [Any] = []
                for k in self.outputGroup! {
                    tmp.append(k.toMap())
                }
                map["OutputGroup"] = tmp
            }
            if self.parentJobId != nil {
                map["ParentJobId"] = self.parentJobId!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.transcodeJobList != nil {
                var tmp : [Any] = []
                for k in self.transcodeJobList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJobList"] = tmp
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("InputGroup") && dict["InputGroup"] != nil {
                var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.InputGroup] = []
                for v in dict["InputGroup"] as! [Any] {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.InputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputGroup = tmp
            }
            if dict.keys.contains("JobCount") && dict["JobCount"] != nil {
                self.jobCount = dict["JobCount"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroup") && dict["OutputGroup"] != nil {
                var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup] = []
                for v in dict["OutputGroup"] as! [Any] {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroup = tmp
            }
            if dict.keys.contains("ParentJobId") && dict["ParentJobId"] != nil {
                self.parentJobId = dict["ParentJobId"] as! String
            }
            if dict.keys.contains("Percent") && dict["Percent"] != nil {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") && dict["ScheduleConfig"] != nil {
                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TranscodeJobList") && dict["TranscodeJobList"] != nil {
                var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList] = []
                for v in dict["TranscodeJobList"] as! [Any] {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeJobList = tmp
            }
            if dict.keys.contains("TriggerSource") && dict["TriggerSource"] != nil {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeParentJob: SubmitTranscodeJobResponseBody.TranscodeParentJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeParentJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeParentJob != nil {
            map["TranscodeParentJob"] = self.transcodeParentJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeParentJob") && dict["TranscodeParentJob"] != nil {
            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob()
            model.fromMap(dict["TranscodeParentJob"] as! [String: Any])
            self.transcodeParentJob = model
        }
    }
}

public class SubmitTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var cateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") && dict["CateId"] != nil {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CateName") && dict["CateName"] != nil {
            self.cateName = dict["CateName"] as! String
        }
    }
}

public class UpdateCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCustomTemplateRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfig: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEditingProjectRequest : Tea.TeaModel {
    public var businessStatus: String?

    public var clipsParam: String?

    public var coverURL: String?

    public var description_: String?

    public var projectId: String?

    public var templateId: String?

    public var timeline: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.clipsParam != nil {
            map["ClipsParam"] = self.clipsParam!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessStatus") && dict["BusinessStatus"] != nil {
            self.businessStatus = dict["BusinessStatus"] as! String
        }
        if dict.keys.contains("ClipsParam") && dict["ClipsParam"] != nil {
            self.clipsParam = dict["ClipsParam"] as! String
        }
        if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateEditingProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveRecordTemplateRequest : Tea.TeaModel {
    public class RecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var ossObjectPrefix: String?

        public var sliceDuration: Int32?

        public var sliceOssObjectPrefix: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.ossObjectPrefix != nil {
                map["OssObjectPrefix"] = self.ossObjectPrefix!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            if self.sliceOssObjectPrefix != nil {
                map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CycleDuration") && dict["CycleDuration"] != nil {
                self.cycleDuration = dict["CycleDuration"] as! Int32
            }
            if dict.keys.contains("Format") && dict["Format"] != nil {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("OssObjectPrefix") && dict["OssObjectPrefix"] != nil {
                self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
            }
            if dict.keys.contains("SliceDuration") && dict["SliceDuration"] != nil {
                self.sliceDuration = dict["SliceDuration"] as! Int32
            }
            if dict.keys.contains("SliceOssObjectPrefix") && dict["SliceOssObjectPrefix"] != nil {
                self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
            }
        }
    }
    public var name: String?

    public var recordFormat: [UpdateLiveRecordTemplateRequest.RecordFormat]?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormat != nil {
            var tmp : [Any] = []
            for k in self.recordFormat! {
                tmp.append(k.toMap())
            }
            map["RecordFormat"] = tmp
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") && dict["RecordFormat"] != nil {
            var tmp : [UpdateLiveRecordTemplateRequest.RecordFormat] = []
            for v in dict["RecordFormat"] as! [Any] {
                var model = UpdateLiveRecordTemplateRequest.RecordFormat()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordFormat = tmp
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveRecordTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var recordFormatShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormatShrink != nil {
            map["RecordFormat"] = self.recordFormatShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") && dict["RecordFormat"] != nil {
            self.recordFormatShrink = dict["RecordFormat"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveRecordTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var overwriteFormat: String?

    public var sequenceFormat: String?

    public var templateId: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OverwriteFormat") && dict["OverwriteFormat"] != nil {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("SequenceFormat") && dict["SequenceFormat"] != nil {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") && dict["TimeInterval"] != nil {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class UpdateLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveTranscodeJobRequest : Tea.TeaModel {
    public class StreamInput : Tea.TeaModel {
        public var inputUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputUrl") && dict["InputUrl"] != nil {
                self.inputUrl = dict["InputUrl"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class TimedConfig : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class TranscodeOutput : Tea.TeaModel {
        public var domainName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var jobId: String?

    public var name: String?

    public var streamInput: UpdateLiveTranscodeJobRequest.StreamInput?

    public var timedConfig: UpdateLiveTranscodeJobRequest.TimedConfig?

    public var transcodeOutput: UpdateLiveTranscodeJobRequest.TranscodeOutput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamInput?.validate()
        try self.timedConfig?.validate()
        try self.transcodeOutput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.timedConfig != nil {
            map["TimedConfig"] = self.timedConfig?.toMap()
        }
        if self.transcodeOutput != nil {
            map["TranscodeOutput"] = self.transcodeOutput?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
            var model = UpdateLiveTranscodeJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TimedConfig") && dict["TimedConfig"] != nil {
            var model = UpdateLiveTranscodeJobRequest.TimedConfig()
            model.fromMap(dict["TimedConfig"] as! [String: Any])
            self.timedConfig = model
        }
        if dict.keys.contains("TranscodeOutput") && dict["TranscodeOutput"] != nil {
            var model = UpdateLiveTranscodeJobRequest.TranscodeOutput()
            model.fromMap(dict["TranscodeOutput"] as! [String: Any])
            self.transcodeOutput = model
        }
    }
}

public class UpdateLiveTranscodeJobShrinkRequest : Tea.TeaModel {
    public var jobId: String?

    public var name: String?

    public var streamInputShrink: String?

    public var timedConfigShrink: String?

    public var transcodeOutputShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.timedConfigShrink != nil {
            map["TimedConfig"] = self.timedConfigShrink!
        }
        if self.transcodeOutputShrink != nil {
            map["TranscodeOutput"] = self.transcodeOutputShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StreamInput") && dict["StreamInput"] != nil {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TimedConfig") && dict["TimedConfig"] != nil {
            self.timedConfigShrink = dict["TimedConfig"] as! String
        }
        if dict.keys.contains("TranscodeOutput") && dict["TranscodeOutput"] != nil {
            self.transcodeOutputShrink = dict["TranscodeOutput"] as! String
        }
    }
}

public class UpdateLiveTranscodeJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveTranscodeTemplateRequest : Tea.TeaModel {
    public class TemplateConfig : Tea.TeaModel {
        public class AudioParams : Tea.TeaModel {
            public var bitrate: String?

            public var channels: String?

            public var codec: String?

            public var profile: String?

            public var samplerate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.samplerate != nil {
                    map["Samplerate"] = self.samplerate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Channels") && dict["Channels"] != nil {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Samplerate") && dict["Samplerate"] != nil {
                    self.samplerate = dict["Samplerate"] as! String
                }
            }
        }
        public class VideoParams : Tea.TeaModel {
            public var bitrate: String?

            public var codec: String?

            public var fps: String?

            public var gop: String?

            public var height: String?

            public var profile: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Codec") && dict["Codec"] != nil {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Fps") && dict["Fps"] != nil {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Gop") && dict["Gop"] != nil {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Height") && dict["Height"] != nil {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Width") && dict["Width"] != nil {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audioParams: UpdateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams?

        public var videoParams: UpdateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audioParams?.validate()
            try self.videoParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioParams != nil {
                map["AudioParams"] = self.audioParams?.toMap()
            }
            if self.videoParams != nil {
                map["VideoParams"] = self.videoParams?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioParams") && dict["AudioParams"] != nil {
                var model = UpdateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams()
                model.fromMap(dict["AudioParams"] as! [String: Any])
                self.audioParams = model
            }
            if dict.keys.contains("VideoParams") && dict["VideoParams"] != nil {
                var model = UpdateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams()
                model.fromMap(dict["VideoParams"] as! [String: Any])
                self.videoParams = model
            }
        }
    }
    public var name: String?

    public var templateConfig: UpdateLiveTranscodeTemplateRequest.TemplateConfig?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            var model = UpdateLiveTranscodeTemplateRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveTranscodeTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfigShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaInfoRequest : Tea.TeaModel {
    public var appendTags: Bool?

    public var businessType: String?

    public var cateId: Int64?

    public var category: String?

    public var coverURL: String?

    public var description_: String?

    public var inputURL: String?

    public var mediaId: String?

    public var mediaTags: String?

    public var referenceId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appendTags != nil {
            map["AppendTags"] = self.appendTags!
        }
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaTags != nil {
            map["MediaTags"] = self.mediaTags!
        }
        if self.referenceId != nil {
            map["ReferenceId"] = self.referenceId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppendTags") && dict["AppendTags"] != nil {
            self.appendTags = dict["AppendTags"] as! Bool
        }
        if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("CateId") && dict["CateId"] != nil {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InputURL") && dict["InputURL"] != nil {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaTags") && dict["MediaTags"] != nil {
            self.mediaTags = dict["MediaTags"] as! String
        }
        if dict.keys.contains("ReferenceId") && dict["ReferenceId"] != nil {
            self.referenceId = dict["ReferenceId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UpdateMediaInfoResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") && dict["MediaMarks"] != nil {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
    }
}

public class UpdateMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") && dict["MediaMarkIds"] != nil {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePipelineRequest : Tea.TeaModel {
    public var name: String?

    public var pipelineId: String?

    public var priority: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("Priority") && dict["Priority"] != nil {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdatePipelineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdatePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSmartJobRequest : Tea.TeaModel {
    public var FEExtend: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.FEExtend != nil {
            map["FEExtend"] = self.FEExtend!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FEExtend") && dict["FEExtend"] != nil {
            self.FEExtend = dict["FEExtend"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class UpdateSmartJobResponseBody : Tea.TeaModel {
    public var FEExtend: String?

    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.FEExtend != nil {
            map["FEExtend"] = self.FEExtend!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FEExtend") && dict["FEExtend"] != nil {
            self.FEExtend = dict["FEExtend"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateSmartJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSmartJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateSmartJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTemplateRequest : Tea.TeaModel {
    public var config: String?

    public var coverUrl: String?

    public var name: String?

    public var previewMedia: String?

    public var relatedMediaids: String?

    public var source: String?

    public var status: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.previewMedia != nil {
            map["PreviewMedia"] = self.previewMedia!
        }
        if self.relatedMediaids != nil {
            map["RelatedMediaids"] = self.relatedMediaids!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PreviewMedia") && dict["PreviewMedia"] != nil {
            self.previewMedia = dict["PreviewMedia"] as! String
        }
        if dict.keys.contains("RelatedMediaids") && dict["RelatedMediaids"] != nil {
            self.relatedMediaids = dict["RelatedMediaids"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadMediaByURLRequest : Tea.TeaModel {
    public var appId: String?

    public var entityId: String?

    public var mediaMetaData: String?

    public var postProcessConfig: String?

    public var uploadTargetConfig: String?

    public var uploadURLs: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.mediaMetaData != nil {
            map["MediaMetaData"] = self.mediaMetaData!
        }
        if self.postProcessConfig != nil {
            map["PostProcessConfig"] = self.postProcessConfig!
        }
        if self.uploadTargetConfig != nil {
            map["UploadTargetConfig"] = self.uploadTargetConfig!
        }
        if self.uploadURLs != nil {
            map["UploadURLs"] = self.uploadURLs!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EntityId") && dict["EntityId"] != nil {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("MediaMetaData") && dict["MediaMetaData"] != nil {
            self.mediaMetaData = dict["MediaMetaData"] as! String
        }
        if dict.keys.contains("PostProcessConfig") && dict["PostProcessConfig"] != nil {
            self.postProcessConfig = dict["PostProcessConfig"] as! String
        }
        if dict.keys.contains("UploadTargetConfig") && dict["UploadTargetConfig"] != nil {
            self.uploadTargetConfig = dict["UploadTargetConfig"] as! String
        }
        if dict.keys.contains("UploadURLs") && dict["UploadURLs"] != nil {
            self.uploadURLs = dict["UploadURLs"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UploadMediaByURLResponseBody : Tea.TeaModel {
    public class UploadJobs : Tea.TeaModel {
        public var jobId: String?

        public var mediaId: String?

        public var sourceURL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.sourceURL != nil {
                map["SourceURL"] = self.sourceURL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("SourceURL") && dict["SourceURL"] != nil {
                self.sourceURL = dict["SourceURL"] as! String
            }
        }
    }
    public var requestId: String?

    public var uploadJobs: [UploadMediaByURLResponseBody.UploadJobs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadJobs != nil {
            var tmp : [Any] = []
            for k in self.uploadJobs! {
                tmp.append(k.toMap())
            }
            map["UploadJobs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadJobs") && dict["UploadJobs"] != nil {
            var tmp : [UploadMediaByURLResponseBody.UploadJobs] = []
            for v in dict["UploadJobs"] as! [Any] {
                var model = UploadMediaByURLResponseBody.UploadJobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uploadJobs = tmp
        }
    }
}

public class UploadMediaByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadMediaByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadMediaByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadStreamByURLRequest : Tea.TeaModel {
    public var definition: String?

    public var fileExtension: String?

    public var HDRType: String?

    public var mediaId: String?

    public var streamURL: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.fileExtension != nil {
            map["FileExtension"] = self.fileExtension!
        }
        if self.HDRType != nil {
            map["HDRType"] = self.HDRType!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.streamURL != nil {
            map["StreamURL"] = self.streamURL!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definition") && dict["Definition"] != nil {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("FileExtension") && dict["FileExtension"] != nil {
            self.fileExtension = dict["FileExtension"] as! String
        }
        if dict.keys.contains("HDRType") && dict["HDRType"] != nil {
            self.HDRType = dict["HDRType"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("StreamURL") && dict["StreamURL"] != nil {
            self.streamURL = dict["StreamURL"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UploadStreamByURLResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var jobId: String?

    public var mediaId: String?

    public var requestId: String?

    public var sourceURL: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceURL != nil {
            map["SourceURL"] = self.sourceURL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceURL") && dict["SourceURL"] != nil {
            self.sourceURL = dict["SourceURL"] as! String
        }
    }
}

public class UploadStreamByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadStreamByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadStreamByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
