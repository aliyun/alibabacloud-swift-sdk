import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddCategoryRequest : Tea.TeaModel {
    public var cateName: String?

    public var parentId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateName") {
            self.cateName = dict["CateName"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddCategoryResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: Int64?

        public var cateName: String?

        public var level: Int64?

        public var parentId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var category: AddCategoryResponseBody.Category?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            var model = AddCategoryResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialMaps: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialMaps != nil {
            map["MaterialMaps"] = self.materialMaps!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialMaps") {
            self.materialMaps = dict["MaterialMaps"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class AddEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public class LiveMaterials : Tea.TeaModel {
        public var appName: String?

        public var domainName: String?

        public var liveUrl: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.liveUrl != nil {
                map["LiveUrl"] = self.liveUrl!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("LiveUrl") {
                self.liveUrl = dict["LiveUrl"] as! String
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
        }
    }
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: AddEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                var tmp : [AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = AddEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var liveMaterials: [AddEditingProjectMaterialsResponseBody.LiveMaterials]?

    public var mediaInfos: [AddEditingProjectMaterialsResponseBody.MediaInfos]?

    public var projectId: String?

    public var projectMaterials: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveMaterials != nil {
            var tmp : [Any] = []
            for k in self.liveMaterials! {
                tmp.append(k.toMap())
            }
            map["LiveMaterials"] = tmp
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectMaterials != nil {
            map["ProjectMaterials"] = self.projectMaterials!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveMaterials") {
            var tmp : [AddEditingProjectMaterialsResponseBody.LiveMaterials] = []
            for v in dict["LiveMaterials"] as! [Any] {
                var model = AddEditingProjectMaterialsResponseBody.LiveMaterials()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.liveMaterials = tmp
        }
        if dict.keys.contains("MediaInfos") {
            var tmp : [AddEditingProjectMaterialsResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = AddEditingProjectMaterialsResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectMaterials") {
            self.projectMaterials = dict["ProjectMaterials"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddFavoritePublicMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class AddFavoritePublicMediaResponseBody : Tea.TeaModel {
    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IgnoredList") {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddFavoritePublicMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddFavoritePublicMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddFavoritePublicMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
    }
}

public class AddMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTemplateRequest : Tea.TeaModel {
    public var config: String?

    public var coverUrl: String?

    public var name: String?

    public var previewMedia: String?

    public var relatedMediaids: String?

    public var source: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.previewMedia != nil {
            map["PreviewMedia"] = self.previewMedia!
        }
        if self.relatedMediaids != nil {
            map["RelatedMediaids"] = self.relatedMediaids!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("CoverUrl") {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PreviewMedia") {
            self.previewMedia = dict["PreviewMedia"] as! String
        }
        if dict.keys.contains("RelatedMediaids") {
            self.relatedMediaids = dict["RelatedMediaids"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var config: String?

        public var coverUrl: String?

        public var createSource: String?

        public var modifiedSource: String?

        public var name: String?

        public var previewMedia: String?

        public var status: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.previewMedia != nil {
                map["PreviewMedia"] = self.previewMedia!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CoverUrl") {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PreviewMedia") {
                self.previewMedia = dict["PreviewMedia"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var template: AddTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") {
            var model = AddTemplateResponseBody.Template()
            model.fromMap(dict["Template"] as! [String: Any])
            self.template = model
        }
    }
}

public class AddTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AlterSearchIndexRequest : Tea.TeaModel {
    public var indexConfig: String?

    public var indexStatus: String?

    public var indexType: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexConfig != nil {
            map["IndexConfig"] = self.indexConfig!
        }
        if self.indexStatus != nil {
            map["IndexStatus"] = self.indexStatus!
        }
        if self.indexType != nil {
            map["IndexType"] = self.indexType!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndexConfig") {
            self.indexConfig = dict["IndexConfig"] as! String
        }
        if dict.keys.contains("IndexStatus") {
            self.indexStatus = dict["IndexStatus"] as! String
        }
        if dict.keys.contains("IndexType") {
            self.indexType = dict["IndexType"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class AlterSearchIndexResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class AlterSearchIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AlterSearchIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AlterSearchIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchGetMediaInfosRequest : Tea.TeaModel {
    public var additionType: String?

    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionType != nil {
            map["AdditionType"] = self.additionType!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionType") {
            self.additionType = dict["AdditionType"] as! String
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class BatchGetMediaInfosResponseBody : Tea.TeaModel {
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: BatchGetMediaInfosResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                var tmp : [BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = BatchGetMediaInfosResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var mediaInfos: [BatchGetMediaInfosResponseBody.MediaInfos]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfos") {
            var tmp : [BatchGetMediaInfosResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = BatchGetMediaInfosResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchGetMediaInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchGetMediaInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchGetMediaInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelDNAJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CancelDNAJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelDNAJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelDNAJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelDNAJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelFavoritePublicMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class CancelFavoritePublicMediaResponseBody : Tea.TeaModel {
    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IgnoredList") {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelFavoritePublicMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelFavoritePublicMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelFavoritePublicMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAuditRequest : Tea.TeaModel {
    public var auditContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.auditContent != nil {
            map["AuditContent"] = self.auditContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuditContent") {
            self.auditContent = dict["AuditContent"] as! String
        }
    }
}

public class CreateAuditResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAuditResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAuditResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAuditResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAvatarTrainingJobRequest : Tea.TeaModel {
    public var avatarDescription: String?

    public var avatarName: String?

    public var avatarType: String?

    public var portrait: String?

    public var thumbnail: String?

    public var transparent: Bool?

    public var video: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarDescription != nil {
            map["AvatarDescription"] = self.avatarDescription!
        }
        if self.avatarName != nil {
            map["AvatarName"] = self.avatarName!
        }
        if self.avatarType != nil {
            map["AvatarType"] = self.avatarType!
        }
        if self.portrait != nil {
            map["Portrait"] = self.portrait!
        }
        if self.thumbnail != nil {
            map["Thumbnail"] = self.thumbnail!
        }
        if self.transparent != nil {
            map["Transparent"] = self.transparent!
        }
        if self.video != nil {
            map["Video"] = self.video!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarDescription") {
            self.avatarDescription = dict["AvatarDescription"] as! String
        }
        if dict.keys.contains("AvatarName") {
            self.avatarName = dict["AvatarName"] as! String
        }
        if dict.keys.contains("AvatarType") {
            self.avatarType = dict["AvatarType"] as! String
        }
        if dict.keys.contains("Portrait") {
            self.portrait = dict["Portrait"] as! String
        }
        if dict.keys.contains("Thumbnail") {
            self.thumbnail = dict["Thumbnail"] as! String
        }
        if dict.keys.contains("Transparent") {
            self.transparent = dict["Transparent"] as! Bool
        }
        if dict.keys.contains("Video") {
            self.video = dict["Video"] as! String
        }
    }
}

public class CreateAvatarTrainingJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: CreateAvatarTrainingJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateAvatarTrainingJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateAvatarTrainingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAvatarTrainingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAvatarTrainingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomTemplateRequest : Tea.TeaModel {
    public var name: String?

    public var subtype: Int32?

    public var templateConfig: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Subtype") {
            self.subtype = dict["Subtype"] as! Int32
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class CreateCustomTemplateResponseBody : Tea.TeaModel {
    public class CustomTemplate : Tea.TeaModel {
        public var createTime: String?

        public var isDefault: Bool?

        public var modifiedTime: String?

        public var status: String?

        public var subtype: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var customTemplate: CreateCustomTemplateResponseBody.CustomTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplate != nil {
            map["CustomTemplate"] = self.customTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplate") {
            var model = CreateCustomTemplateResponseBody.CustomTemplate()
            model.fromMap(dict["CustomTemplate"] as! [String: Any])
            self.customTemplate = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomizedVoiceJobRequest : Tea.TeaModel {
    public var gender: String?

    public var scenario: String?

    public var voiceDesc: String?

    public var voiceId: String?

    public var voiceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gender != nil {
            map["Gender"] = self.gender!
        }
        if self.scenario != nil {
            map["Scenario"] = self.scenario!
        }
        if self.voiceDesc != nil {
            map["VoiceDesc"] = self.voiceDesc!
        }
        if self.voiceId != nil {
            map["VoiceId"] = self.voiceId!
        }
        if self.voiceName != nil {
            map["VoiceName"] = self.voiceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Gender") {
            self.gender = dict["Gender"] as! String
        }
        if dict.keys.contains("Scenario") {
            self.scenario = dict["Scenario"] as! String
        }
        if dict.keys.contains("VoiceDesc") {
            self.voiceDesc = dict["VoiceDesc"] as! String
        }
        if dict.keys.contains("VoiceId") {
            self.voiceId = dict["VoiceId"] as! String
        }
        if dict.keys.contains("VoiceName") {
            self.voiceName = dict["VoiceName"] as! String
        }
    }
}

public class CreateCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public var voiceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.voiceId != nil {
                map["VoiceId"] = self.voiceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("VoiceId") {
                self.voiceId = dict["VoiceId"] as! String
            }
        }
    }
    public var data: CreateCustomizedVoiceJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateCustomizedVoiceJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDNADBRequest : Tea.TeaModel {
    public var description_: String?

    public var model: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Model") {
            self.model = dict["Model"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateDNADBResponseBody : Tea.TeaModel {
    public class DBInfo : Tea.TeaModel {
        public var DBId: String?

        public var description_: String?

        public var model: String?

        public var name: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBId != nil {
                map["DBId"] = self.DBId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.model != nil {
                map["Model"] = self.model!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DBId") {
                self.DBId = dict["DBId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Model") {
                self.model = dict["Model"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var DBInfo: CreateDNADBResponseBody.DBInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DBInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInfo != nil {
            map["DBInfo"] = self.DBInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBInfo") {
            var model = CreateDNADBResponseBody.DBInfo()
            model.fromMap(dict["DBInfo"] as! [String: Any])
            self.DBInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDNADBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDNADBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDNADBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEditingProjectRequest : Tea.TeaModel {
    public var businessConfig: String?

    public var clipsParam: String?

    public var coverURL: String?

    public var description_: String?

    public var materialMaps: String?

    public var projectType: String?

    public var templateId: String?

    public var templateType: String?

    public var timeline: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessConfig != nil {
            map["BusinessConfig"] = self.businessConfig!
        }
        if self.clipsParam != nil {
            map["ClipsParam"] = self.clipsParam!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.materialMaps != nil {
            map["MaterialMaps"] = self.materialMaps!
        }
        if self.projectType != nil {
            map["ProjectType"] = self.projectType!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessConfig") {
            self.businessConfig = dict["BusinessConfig"] as! String
        }
        if dict.keys.contains("ClipsParam") {
            self.clipsParam = dict["ClipsParam"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MaterialMaps") {
            self.materialMaps = dict["MaterialMaps"] as! String
        }
        if dict.keys.contains("ProjectType") {
            self.projectType = dict["ProjectType"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateEditingProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var clipsParam: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var duration: Double?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: Int64?

        public var statusName: String?

        public var templateId: String?

        public var templateType: String?

        public var timeline: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusName != nil {
                map["StatusName"] = self.statusName!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("StatusName") {
                self.statusName = dict["StatusName"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var project: CreateEditingProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") {
            var model = CreateEditingProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveRecordTemplateRequest : Tea.TeaModel {
    public class RecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var ossObjectPrefix: String?

        public var sliceDuration: Int32?

        public var sliceOssObjectPrefix: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.ossObjectPrefix != nil {
                map["OssObjectPrefix"] = self.ossObjectPrefix!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            if self.sliceOssObjectPrefix != nil {
                map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CycleDuration") {
                self.cycleDuration = dict["CycleDuration"] as! Int32
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("OssObjectPrefix") {
                self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
            }
            if dict.keys.contains("SliceDuration") {
                self.sliceDuration = dict["SliceDuration"] as! Int32
            }
            if dict.keys.contains("SliceOssObjectPrefix") {
                self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
            }
        }
    }
    public var name: String?

    public var recordFormat: [CreateLiveRecordTemplateRequest.RecordFormat]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormat != nil {
            var tmp : [Any] = []
            for k in self.recordFormat! {
                tmp.append(k.toMap())
            }
            map["RecordFormat"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") {
            var tmp : [CreateLiveRecordTemplateRequest.RecordFormat] = []
            for v in dict["RecordFormat"] as! [Any] {
                var model = CreateLiveRecordTemplateRequest.RecordFormat()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordFormat = tmp
        }
    }
}

public class CreateLiveRecordTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var recordFormatShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormatShrink != nil {
            map["RecordFormat"] = self.recordFormatShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") {
            self.recordFormatShrink = dict["RecordFormat"] as! String
        }
    }
}

public class CreateLiveRecordTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var overwriteFormat: String?

    public var sequenceFormat: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OverwriteFormat") {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("SequenceFormat") {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class CreateLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveTranscodeTemplateRequest : Tea.TeaModel {
    public class TemplateConfig : Tea.TeaModel {
        public class AudioParams : Tea.TeaModel {
            public var bitrate: String?

            public var channels: String?

            public var codec: String?

            public var profile: String?

            public var samplerate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.samplerate != nil {
                    map["Samplerate"] = self.samplerate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Samplerate") {
                    self.samplerate = dict["Samplerate"] as! String
                }
            }
        }
        public class VideoParams : Tea.TeaModel {
            public var bitrate: String?

            public var codec: String?

            public var fps: String?

            public var gop: String?

            public var height: String?

            public var profile: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Gop") {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audioParams: CreateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams?

        public var videoParams: CreateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audioParams?.validate()
            try self.videoParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioParams != nil {
                map["AudioParams"] = self.audioParams?.toMap()
            }
            if self.videoParams != nil {
                map["VideoParams"] = self.videoParams?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioParams") {
                var model = CreateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams()
                model.fromMap(dict["AudioParams"] as! [String: Any])
                self.audioParams = model
            }
            if dict.keys.contains("VideoParams") {
                var model = CreateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams()
                model.fromMap(dict["VideoParams"] as! [String: Any])
                self.videoParams = model
            }
        }
    }
    public var name: String?

    public var templateConfig: CreateLiveTranscodeTemplateRequest.TemplateConfig?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            var model = CreateLiveTranscodeTemplateRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfigShrink: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePipelineRequest : Tea.TeaModel {
    public var name: String?

    public var priority: Int32?

    public var speed: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.speed != nil {
            map["Speed"] = self.speed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Speed") {
            self.speed = dict["Speed"] as! String
        }
    }
}

public class CreatePipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public var createTime: String?

        public var modifiedTime: String?

        public var name: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var speed: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipeline: CreatePipelineResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") {
            var model = CreatePipelineResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSearchIndexRequest : Tea.TeaModel {
    public var indexConfig: String?

    public var indexStatus: String?

    public var indexType: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexConfig != nil {
            map["IndexConfig"] = self.indexConfig!
        }
        if self.indexStatus != nil {
            map["IndexStatus"] = self.indexStatus!
        }
        if self.indexType != nil {
            map["IndexType"] = self.indexType!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndexConfig") {
            self.indexConfig = dict["IndexConfig"] as! String
        }
        if dict.keys.contains("IndexStatus") {
            self.indexStatus = dict["IndexStatus"] as! String
        }
        if dict.keys.contains("IndexType") {
            self.indexType = dict["IndexType"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class CreateSearchIndexResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateSearchIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSearchIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSearchIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSearchLibRequest : Tea.TeaModel {
    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class CreateSearchLibResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var searchLibName: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateSearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadMediaRequest : Tea.TeaModel {
    public var appId: String?

    public var entityId: String?

    public var fileInfo: String?

    public var mediaMetaData: String?

    public var postProcessConfig: String?

    public var uploadTargetConfig: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.fileInfo != nil {
            map["FileInfo"] = self.fileInfo!
        }
        if self.mediaMetaData != nil {
            map["MediaMetaData"] = self.mediaMetaData!
        }
        if self.postProcessConfig != nil {
            map["PostProcessConfig"] = self.postProcessConfig!
        }
        if self.uploadTargetConfig != nil {
            map["UploadTargetConfig"] = self.uploadTargetConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("FileInfo") {
            self.fileInfo = dict["FileInfo"] as! String
        }
        if dict.keys.contains("MediaMetaData") {
            self.mediaMetaData = dict["MediaMetaData"] as! String
        }
        if dict.keys.contains("PostProcessConfig") {
            self.postProcessConfig = dict["PostProcessConfig"] as! String
        }
        if dict.keys.contains("UploadTargetConfig") {
            self.uploadTargetConfig = dict["UploadTargetConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class CreateUploadMediaResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var mediaId: String?

    public var mediaURL: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaURL != nil {
            map["MediaURL"] = self.mediaURL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaURL") {
            self.mediaURL = dict["MediaURL"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class CreateUploadMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUploadMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadStreamRequest : Tea.TeaModel {
    public var definition: String?

    public var fileExtension: String?

    public var HDRType: String?

    public var mediaId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.fileExtension != nil {
            map["FileExtension"] = self.fileExtension!
        }
        if self.HDRType != nil {
            map["HDRType"] = self.HDRType!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("FileExtension") {
            self.fileExtension = dict["FileExtension"] as! String
        }
        if dict.keys.contains("HDRType") {
            self.HDRType = dict["HDRType"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class CreateUploadStreamResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var mediaId: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class CreateUploadStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUploadStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DecryptKMSDataKeyRequest : Tea.TeaModel {
    public var ciphertextBlob: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ciphertextBlob != nil {
            map["CiphertextBlob"] = self.ciphertextBlob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CiphertextBlob") {
            self.ciphertextBlob = dict["CiphertextBlob"] as! String
        }
    }
}

public class DecryptKMSDataKeyResponseBody : Tea.TeaModel {
    public class DataKey : Tea.TeaModel {
        public var keyId: String?

        public var plaintext: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.keyId != nil {
                map["KeyId"] = self.keyId!
            }
            if self.plaintext != nil {
                map["Plaintext"] = self.plaintext!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("KeyId") {
                self.keyId = dict["KeyId"] as! String
            }
            if dict.keys.contains("Plaintext") {
                self.plaintext = dict["Plaintext"] as! String
            }
        }
    }
    public var dataKey: DecryptKMSDataKeyResponseBody.DataKey?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataKey?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataKey != nil {
            map["DataKey"] = self.dataKey?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataKey") {
            var model = DecryptKMSDataKeyResponseBody.DataKey()
            model.fromMap(dict["DataKey"] as! [String: Any])
            self.dataKey = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DecryptKMSDataKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DecryptKMSDataKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DecryptKMSDataKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAvatarTrainingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteAvatarTrainingJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: DeleteAvatarTrainingJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DeleteAvatarTrainingJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAvatarTrainingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAvatarTrainingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAvatarTrainingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
    }
}

public class DeleteCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomizedVoiceJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDNADBRequest : Tea.TeaModel {
    public var DBId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBId") {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteDNADBResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDNADBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDNADBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDNADBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDNAFilesRequest : Tea.TeaModel {
    public var DBId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var primaryKeys: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.primaryKeys != nil {
            map["PrimaryKeys"] = self.primaryKeys!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBId") {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrimaryKeys") {
            self.primaryKeys = dict["PrimaryKeys"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteDNAFilesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDNAFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDNAFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDNAFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialIds: String?

    public var materialType: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialIds != nil {
            map["MaterialIds"] = self.materialIds!
        }
        if self.materialType != nil {
            map["MaterialType"] = self.materialType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialIds") {
            self.materialIds = dict["MaterialIds"] as! String
        }
        if dict.keys.contains("MaterialType") {
            self.materialType = dict["MaterialType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DeleteEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEditingProjectsRequest : Tea.TeaModel {
    public var projectIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectIds != nil {
            map["ProjectIds"] = self.projectIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectIds") {
            self.projectIds = dict["ProjectIds"] as! String
        }
    }
}

public class DeleteEditingProjectsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEditingProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEditingProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEditingProjectsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveRecordFilesRequest : Tea.TeaModel {
    public var recordIds: [String]?

    public var removeFile: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordIds != nil {
            map["RecordIds"] = self.recordIds!
        }
        if self.removeFile != nil {
            map["RemoveFile"] = self.removeFile!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordIds") {
            self.recordIds = dict["RecordIds"] as! [String]
        }
        if dict.keys.contains("RemoveFile") {
            self.removeFile = dict["RemoveFile"] as! Bool
        }
    }
}

public class DeleteLiveRecordFilesResponseBody : Tea.TeaModel {
    public class DeleteFileInfoList : Tea.TeaModel {
        public var code: String?

        public var message: String?

        public var recordId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! String
            }
        }
    }
    public var deleteFileInfoList: [DeleteLiveRecordFilesResponseBody.DeleteFileInfoList]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFileInfoList != nil {
            var tmp : [Any] = []
            for k in self.deleteFileInfoList! {
                tmp.append(k.toMap())
            }
            map["DeleteFileInfoList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteFileInfoList") {
            var tmp : [DeleteLiveRecordFilesResponseBody.DeleteFileInfoList] = []
            for v in dict["DeleteFileInfoList"] as! [Any] {
                var model = DeleteLiveRecordFilesResponseBody.DeleteFileInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deleteFileInfoList = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveRecordFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRecordFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveRecordFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveRecordTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveRecordTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveSnapshotFilesRequest : Tea.TeaModel {
    public var createTimestampList: [Int64]?

    public var deleteOriginalFile: Bool?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimestampList != nil {
            map["CreateTimestampList"] = self.createTimestampList!
        }
        if self.deleteOriginalFile != nil {
            map["DeleteOriginalFile"] = self.deleteOriginalFile!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimestampList") {
            self.createTimestampList = dict["CreateTimestampList"] as! [Int64]
        }
        if dict.keys.contains("DeleteOriginalFile") {
            self.deleteOriginalFile = dict["DeleteOriginalFile"] as! Bool
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteLiveSnapshotFilesShrinkRequest : Tea.TeaModel {
    public var createTimestampListShrink: String?

    public var deleteOriginalFile: Bool?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimestampListShrink != nil {
            map["CreateTimestampList"] = self.createTimestampListShrink!
        }
        if self.deleteOriginalFile != nil {
            map["DeleteOriginalFile"] = self.deleteOriginalFile!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimestampList") {
            self.createTimestampListShrink = dict["CreateTimestampList"] as! String
        }
        if dict.keys.contains("DeleteOriginalFile") {
            self.deleteOriginalFile = dict["DeleteOriginalFile"] as! Bool
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteLiveSnapshotFilesResponseBody : Tea.TeaModel {
    public class DeleteFileResultList : Tea.TeaModel {
        public var createTimestamp: Int64?

        public var result: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! String
            }
        }
    }
    public var deleteFileResultList: [DeleteLiveSnapshotFilesResponseBody.DeleteFileResultList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFileResultList != nil {
            var tmp : [Any] = []
            for k in self.deleteFileResultList! {
                tmp.append(k.toMap())
            }
            map["DeleteFileResultList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteFileResultList") {
            var tmp : [DeleteLiveSnapshotFilesResponseBody.DeleteFileResultList] = []
            for v in dict["DeleteFileResultList"] as! [Any] {
                var model = DeleteLiveSnapshotFilesResponseBody.DeleteFileResultList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deleteFileResultList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveSnapshotFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSnapshotFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveSnapshotFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveTranscodeJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteLiveTranscodeJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveTranscodeTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaFromSearchLibRequest : Tea.TeaModel {
    public var mediaId: String?

    public var msgBody: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.msgBody != nil {
            map["MsgBody"] = self.msgBody!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MsgBody") {
            self.msgBody = dict["MsgBody"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class DeleteMediaFromSearchLibResponseBody : Tea.TeaModel {
    public var code: String?

    public var mediaId: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteMediaFromSearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaFromSearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaFromSearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaInfosRequest : Tea.TeaModel {
    public var deletePhysicalFiles: Bool?

    public var inputURLs: String?

    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deletePhysicalFiles != nil {
            map["DeletePhysicalFiles"] = self.deletePhysicalFiles!
        }
        if self.inputURLs != nil {
            map["InputURLs"] = self.inputURLs!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeletePhysicalFiles") {
            self.deletePhysicalFiles = dict["DeletePhysicalFiles"] as! Bool
        }
        if dict.keys.contains("InputURLs") {
            self.inputURLs = dict["InputURLs"] as! String
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class DeleteMediaInfosResponseBody : Tea.TeaModel {
    public var forbiddenList: [String]?

    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenList != nil {
            map["ForbiddenList"] = self.forbiddenList!
        }
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenList") {
            self.forbiddenList = dict["ForbiddenList"] as! [String]
        }
        if dict.keys.contains("IgnoredList") {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
    }
}

public class DeleteMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePipelineRequest : Tea.TeaModel {
    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
    }
}

public class DeletePipelineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeletePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePlayInfoRequest : Tea.TeaModel {
    public var deletePhysicalFiles: Bool?

    public var fileURLs: String?

    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deletePhysicalFiles != nil {
            map["DeletePhysicalFiles"] = self.deletePhysicalFiles!
        }
        if self.fileURLs != nil {
            map["FileURLs"] = self.fileURLs!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeletePhysicalFiles") {
            self.deletePhysicalFiles = dict["DeletePhysicalFiles"] as! Bool
        }
        if dict.keys.contains("FileURLs") {
            self.fileURLs = dict["FileURLs"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class DeletePlayInfoResponseBody : Tea.TeaModel {
    public var forbiddenList: [String]?

    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenList != nil {
            map["ForbiddenList"] = self.forbiddenList!
        }
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenList") {
            self.forbiddenList = dict["ForbiddenList"] as! [String]
        }
        if dict.keys.contains("IgnoredList") {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSmartJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteSmartJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSmartJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSmartJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSmartJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTemplateRequest : Tea.TeaModel {
    public var templateIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateIds") {
            self.templateIds = dict["TemplateIds"] as! String
        }
    }
}

public class DeleteTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsEditUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsEditUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var profile: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.profile != nil {
                map["Profile"] = self.profile!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Profile") {
                self.profile = dict["Profile"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsEditUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeMeterImsEditUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsEditUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsEditUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsEditUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsEditUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsMediaConvertUHDUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: String?

    public var regionId: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsMediaConvertUHDUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsMediaConvertUHDUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeMeterImsMediaConvertUHDUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsMediaConvertUHDUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsMediaConvertUHDUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsMediaConvertUHDUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsMediaConvertUHDUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsMediaConvertUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsMediaConvertUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsMediaConvertUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeMeterImsMediaConvertUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsMediaConvertUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsMediaConvertUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsMediaConvertUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsMediaConvertUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsMpsAiUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsMpsAiUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var time: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [DescribeMeterImsMpsAiUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeMeterImsMpsAiUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsMpsAiUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsMpsAiUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsMpsAiUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsMpsAiUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsSummaryRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var editingDuration: String?

        public var liveEditDuration: String?

        public var liveRecordDuration: String?

        public var liveSnapshotCount: String?

        public var liveTranscodeDuration: Int64?

        public var mpsAiDuration: Int64?

        public var mpsTranscodeDuration: Int64?

        public var mpsTranscodeUHDDuration: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.editingDuration != nil {
                map["EditingDuration"] = self.editingDuration!
            }
            if self.liveEditDuration != nil {
                map["LiveEditDuration"] = self.liveEditDuration!
            }
            if self.liveRecordDuration != nil {
                map["LiveRecordDuration"] = self.liveRecordDuration!
            }
            if self.liveSnapshotCount != nil {
                map["LiveSnapshotCount"] = self.liveSnapshotCount!
            }
            if self.liveTranscodeDuration != nil {
                map["LiveTranscodeDuration"] = self.liveTranscodeDuration!
            }
            if self.mpsAiDuration != nil {
                map["MpsAiDuration"] = self.mpsAiDuration!
            }
            if self.mpsTranscodeDuration != nil {
                map["MpsTranscodeDuration"] = self.mpsTranscodeDuration!
            }
            if self.mpsTranscodeUHDDuration != nil {
                map["MpsTranscodeUHDDuration"] = self.mpsTranscodeUHDDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EditingDuration") {
                self.editingDuration = dict["EditingDuration"] as! String
            }
            if dict.keys.contains("LiveEditDuration") {
                self.liveEditDuration = dict["LiveEditDuration"] as! String
            }
            if dict.keys.contains("LiveRecordDuration") {
                self.liveRecordDuration = dict["LiveRecordDuration"] as! String
            }
            if dict.keys.contains("LiveSnapshotCount") {
                self.liveSnapshotCount = dict["LiveSnapshotCount"] as! String
            }
            if dict.keys.contains("LiveTranscodeDuration") {
                self.liveTranscodeDuration = dict["LiveTranscodeDuration"] as! Int64
            }
            if dict.keys.contains("MpsAiDuration") {
                self.mpsAiDuration = dict["MpsAiDuration"] as! Int64
            }
            if dict.keys.contains("MpsTranscodeDuration") {
                self.mpsTranscodeDuration = dict["MpsTranscodeDuration"] as! Int64
            }
            if dict.keys.contains("MpsTranscodeUHDDuration") {
                self.mpsTranscodeUHDDuration = dict["MpsTranscodeUHDDuration"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsSummaryResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeMeterImsSummaryResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsSummaryResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayListRequest : Tea.TeaModel {
    public var beginTs: String?

    public var endTs: String?

    public var orderName: String?

    public var orderType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var playType: String?

    public var status: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playType != nil {
            map["PlayType"] = self.playType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTs") {
            self.beginTs = dict["BeginTs"] as! String
        }
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! String
        }
        if dict.keys.contains("OrderName") {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PlayType") {
            self.playType = dict["PlayType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribePlayListResponseBody : Tea.TeaModel {
    public class PlayList : Tea.TeaModel {
        public var firstFrameDuration: String?

        public var playDuration: String?

        public var playTs: String?

        public var playType: String?

        public var sessionId: String?

        public var status: String?

        public var stuckDuration: String?

        public var traceId: String?

        public var videoDuration: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.firstFrameDuration != nil {
                map["FirstFrameDuration"] = self.firstFrameDuration!
            }
            if self.playDuration != nil {
                map["PlayDuration"] = self.playDuration!
            }
            if self.playTs != nil {
                map["PlayTs"] = self.playTs!
            }
            if self.playType != nil {
                map["PlayType"] = self.playType!
            }
            if self.sessionId != nil {
                map["SessionId"] = self.sessionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stuckDuration != nil {
                map["StuckDuration"] = self.stuckDuration!
            }
            if self.traceId != nil {
                map["TraceId"] = self.traceId!
            }
            if self.videoDuration != nil {
                map["VideoDuration"] = self.videoDuration!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FirstFrameDuration") {
                self.firstFrameDuration = dict["FirstFrameDuration"] as! String
            }
            if dict.keys.contains("PlayDuration") {
                self.playDuration = dict["PlayDuration"] as! String
            }
            if dict.keys.contains("PlayTs") {
                self.playTs = dict["PlayTs"] as! String
            }
            if dict.keys.contains("PlayType") {
                self.playType = dict["PlayType"] as! String
            }
            if dict.keys.contains("SessionId") {
                self.sessionId = dict["SessionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StuckDuration") {
                self.stuckDuration = dict["StuckDuration"] as! String
            }
            if dict.keys.contains("TraceId") {
                self.traceId = dict["TraceId"] as! String
            }
            if dict.keys.contains("VideoDuration") {
                self.videoDuration = dict["VideoDuration"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var pageNum: Int64?

    public var pageSize: Int64?

    public var playList: [DescribePlayListResponseBody.PlayList]?

    public var requestId: String?

    public var totalNum: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playList != nil {
            var tmp : [Any] = []
            for k in self.playList! {
                tmp.append(k.toMap())
            }
            map["PlayList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PlayList") {
            var tmp : [DescribePlayListResponseBody.PlayList] = []
            for v in dict["PlayList"] as! [Any] {
                var model = DescribePlayListResponseBody.PlayList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.playList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int64
        }
    }
}

public class DescribePlayListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetectAudioForCustomizedVoiceJobRequest : Tea.TeaModel {
    public var audioRecordId: Int32?

    public var recordUrl: String?

    public var voiceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioRecordId != nil {
            map["AudioRecordId"] = self.audioRecordId!
        }
        if self.recordUrl != nil {
            map["RecordUrl"] = self.recordUrl!
        }
        if self.voiceId != nil {
            map["VoiceId"] = self.voiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioRecordId") {
            self.audioRecordId = dict["AudioRecordId"] as! Int32
        }
        if dict.keys.contains("RecordUrl") {
            self.recordUrl = dict["RecordUrl"] as! String
        }
        if dict.keys.contains("VoiceId") {
            self.voiceId = dict["VoiceId"] as! String
        }
    }
}

public class DetectAudioForCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var pass: Bool?

        public var reason: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pass != nil {
                map["Pass"] = self.pass!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pass") {
                self.pass = dict["Pass"] as! Bool
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
        }
    }
    public var data: DetectAudioForCustomizedVoiceJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DetectAudioForCustomizedVoiceJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DetectAudioForCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetectAudioForCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetectAudioForCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DropSearchIndexRequest : Tea.TeaModel {
    public var indexType: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexType != nil {
            map["IndexType"] = self.indexType!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndexType") {
            self.indexType = dict["IndexType"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class DropSearchIndexResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DropSearchIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DropSearchIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DropSearchIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DropSearchLibRequest : Tea.TeaModel {
    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class DropSearchLibResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DropSearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DropSearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DropSearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateKMSDataKeyResponseBody : Tea.TeaModel {
    public class DataKey : Tea.TeaModel {
        public var ciphertextBlob: String?

        public var keyId: String?

        public var plaintext: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ciphertextBlob != nil {
                map["CiphertextBlob"] = self.ciphertextBlob!
            }
            if self.keyId != nil {
                map["KeyId"] = self.keyId!
            }
            if self.plaintext != nil {
                map["Plaintext"] = self.plaintext!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CiphertextBlob") {
                self.ciphertextBlob = dict["CiphertextBlob"] as! String
            }
            if dict.keys.contains("KeyId") {
                self.keyId = dict["KeyId"] as! String
            }
            if dict.keys.contains("Plaintext") {
                self.plaintext = dict["Plaintext"] as! String
            }
        }
    }
    public var dataKey: GenerateKMSDataKeyResponseBody.DataKey?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataKey?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataKey != nil {
            map["DataKey"] = self.dataKey?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataKey") {
            var model = GenerateKMSDataKeyResponseBody.DataKey()
            model.fromMap(dict["DataKey"] as! [String: Any])
            self.dataKey = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GenerateKMSDataKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateKMSDataKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GenerateKMSDataKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAvatarRequest : Tea.TeaModel {
    public var avatarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarId != nil {
            map["AvatarId"] = self.avatarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarId") {
            self.avatarId = dict["AvatarId"] as! String
        }
    }
}

public class GetAvatarResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Avatar : Tea.TeaModel {
            public var avatarDescription: String?

            public var avatarId: String?

            public var avatarName: String?

            public var avatarType: String?

            public var height: Int32?

            public var portrait: String?

            public var thumbnail: String?

            public var transparent: Bool?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarDescription != nil {
                    map["AvatarDescription"] = self.avatarDescription!
                }
                if self.avatarId != nil {
                    map["AvatarId"] = self.avatarId!
                }
                if self.avatarName != nil {
                    map["AvatarName"] = self.avatarName!
                }
                if self.avatarType != nil {
                    map["AvatarType"] = self.avatarType!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.portrait != nil {
                    map["Portrait"] = self.portrait!
                }
                if self.thumbnail != nil {
                    map["Thumbnail"] = self.thumbnail!
                }
                if self.transparent != nil {
                    map["Transparent"] = self.transparent!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvatarDescription") {
                    self.avatarDescription = dict["AvatarDescription"] as! String
                }
                if dict.keys.contains("AvatarId") {
                    self.avatarId = dict["AvatarId"] as! String
                }
                if dict.keys.contains("AvatarName") {
                    self.avatarName = dict["AvatarName"] as! String
                }
                if dict.keys.contains("AvatarType") {
                    self.avatarType = dict["AvatarType"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Portrait") {
                    self.portrait = dict["Portrait"] as! String
                }
                if dict.keys.contains("Thumbnail") {
                    self.thumbnail = dict["Thumbnail"] as! String
                }
                if dict.keys.contains("Transparent") {
                    self.transparent = dict["Transparent"] as! Bool
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var avatar: GetAvatarResponseBody.Data.Avatar?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.avatar?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatar != nil {
                map["Avatar"] = self.avatar?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Avatar") {
                var model = GetAvatarResponseBody.Data.Avatar()
                model.fromMap(dict["Avatar"] as! [String: Any])
                self.avatar = model
            }
        }
    }
    public var data: GetAvatarResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetAvatarResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAvatarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAvatarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAvatarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAvatarTrainingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetAvatarTrainingJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AvatarTrainingJob : Tea.TeaModel {
            public var avatarDescription: String?

            public var avatarId: String?

            public var avatarName: String?

            public var avatarType: String?

            public var firstTrainingTime: String?

            public var jobId: String?

            public var lastTrainingTime: String?

            public var message: String?

            public var portrait: String?

            public var status: String?

            public var thumbnail: String?

            public var transparent: Bool?

            public var video: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarDescription != nil {
                    map["AvatarDescription"] = self.avatarDescription!
                }
                if self.avatarId != nil {
                    map["AvatarId"] = self.avatarId!
                }
                if self.avatarName != nil {
                    map["AvatarName"] = self.avatarName!
                }
                if self.avatarType != nil {
                    map["AvatarType"] = self.avatarType!
                }
                if self.firstTrainingTime != nil {
                    map["FirstTrainingTime"] = self.firstTrainingTime!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.lastTrainingTime != nil {
                    map["LastTrainingTime"] = self.lastTrainingTime!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.portrait != nil {
                    map["Portrait"] = self.portrait!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.thumbnail != nil {
                    map["Thumbnail"] = self.thumbnail!
                }
                if self.transparent != nil {
                    map["Transparent"] = self.transparent!
                }
                if self.video != nil {
                    map["Video"] = self.video!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvatarDescription") {
                    self.avatarDescription = dict["AvatarDescription"] as! String
                }
                if dict.keys.contains("AvatarId") {
                    self.avatarId = dict["AvatarId"] as! String
                }
                if dict.keys.contains("AvatarName") {
                    self.avatarName = dict["AvatarName"] as! String
                }
                if dict.keys.contains("AvatarType") {
                    self.avatarType = dict["AvatarType"] as! String
                }
                if dict.keys.contains("FirstTrainingTime") {
                    self.firstTrainingTime = dict["FirstTrainingTime"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("LastTrainingTime") {
                    self.lastTrainingTime = dict["LastTrainingTime"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Portrait") {
                    self.portrait = dict["Portrait"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Thumbnail") {
                    self.thumbnail = dict["Thumbnail"] as! String
                }
                if dict.keys.contains("Transparent") {
                    self.transparent = dict["Transparent"] as! Bool
                }
                if dict.keys.contains("Video") {
                    self.video = dict["Video"] as! String
                }
            }
        }
        public var avatarTrainingJob: GetAvatarTrainingJobResponseBody.Data.AvatarTrainingJob?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.avatarTrainingJob?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarTrainingJob != nil {
                map["AvatarTrainingJob"] = self.avatarTrainingJob?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarTrainingJob") {
                var model = GetAvatarTrainingJobResponseBody.Data.AvatarTrainingJob()
                model.fromMap(dict["AvatarTrainingJob"] as! [String: Any])
                self.avatarTrainingJob = model
            }
        }
    }
    public var data: GetAvatarTrainingJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetAvatarTrainingJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAvatarTrainingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAvatarTrainingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAvatarTrainingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBatchMediaProducingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var signature: String?

    public var signatureMehtod: String?

    public var signatureNonce: String?

    public var signatureType: String?

    public var signatureVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.signature != nil {
            map["Signature"] = self.signature!
        }
        if self.signatureMehtod != nil {
            map["SignatureMehtod"] = self.signatureMehtod!
        }
        if self.signatureNonce != nil {
            map["SignatureNonce"] = self.signatureNonce!
        }
        if self.signatureType != nil {
            map["SignatureType"] = self.signatureType!
        }
        if self.signatureVersion != nil {
            map["SignatureVersion"] = self.signatureVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Signature") {
            self.signature = dict["Signature"] as! String
        }
        if dict.keys.contains("SignatureMehtod") {
            self.signatureMehtod = dict["SignatureMehtod"] as! String
        }
        if dict.keys.contains("SignatureNonce") {
            self.signatureNonce = dict["SignatureNonce"] as! String
        }
        if dict.keys.contains("SignatureType") {
            self.signatureType = dict["SignatureType"] as! String
        }
        if dict.keys.contains("SignatureVersion") {
            self.signatureVersion = dict["SignatureVersion"] as! String
        }
    }
}

public class GetBatchMediaProducingJobResponseBody : Tea.TeaModel {
    public class EditingBatchJob : Tea.TeaModel {
        public class SubJobList : Tea.TeaModel {
            public var errorCode: String?

            public var errorMessage: String?

            public var jobId: String?

            public var mediaId: String?

            public var mediaURL: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaURL != nil {
                    map["MediaURL"] = self.mediaURL!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaURL") {
                    self.mediaURL = dict["MediaURL"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var completeTime: String?

        public var createTime: String?

        public var editingConfig: String?

        public var extend: String?

        public var inputConfig: String?

        public var jobId: String?

        public var jobType: String?

        public var modifiedTime: String?

        public var outputConfig: String?

        public var status: String?

        public var subJobList: [GetBatchMediaProducingJobResponseBody.EditingBatchJob.SubJobList]?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.editingConfig != nil {
                map["EditingConfig"] = self.editingConfig!
            }
            if self.extend != nil {
                map["Extend"] = self.extend!
            }
            if self.inputConfig != nil {
                map["InputConfig"] = self.inputConfig!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputConfig != nil {
                map["OutputConfig"] = self.outputConfig!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subJobList != nil {
                var tmp : [Any] = []
                for k in self.subJobList! {
                    tmp.append(k.toMap())
                }
                map["SubJobList"] = tmp
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EditingConfig") {
                self.editingConfig = dict["EditingConfig"] as! String
            }
            if dict.keys.contains("Extend") {
                self.extend = dict["Extend"] as! String
            }
            if dict.keys.contains("InputConfig") {
                self.inputConfig = dict["InputConfig"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputConfig") {
                self.outputConfig = dict["OutputConfig"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubJobList") {
                var tmp : [GetBatchMediaProducingJobResponseBody.EditingBatchJob.SubJobList] = []
                for v in dict["SubJobList"] as! [Any] {
                    var model = GetBatchMediaProducingJobResponseBody.EditingBatchJob.SubJobList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.subJobList = tmp
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var editingBatchJob: GetBatchMediaProducingJobResponseBody.EditingBatchJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.editingBatchJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.editingBatchJob != nil {
            map["EditingBatchJob"] = self.editingBatchJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EditingBatchJob") {
            var model = GetBatchMediaProducingJobResponseBody.EditingBatchJob()
            model.fromMap(dict["EditingBatchJob"] as! [String: Any])
            self.editingBatchJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetBatchMediaProducingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBatchMediaProducingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBatchMediaProducingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCategoriesRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetCategoriesResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: Int64?

        public var cateName: String?

        public var level: Int64?

        public var parentId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SubCategories : Tea.TeaModel {
        public class Category : Tea.TeaModel {
            public var cateId: Int64?

            public var cateName: String?

            public var level: Int64?

            public var parentId: Int64?

            public var subTotal: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.subTotal != nil {
                    map["SubTotal"] = self.subTotal!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! Int64
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! Int64
                }
                if dict.keys.contains("SubTotal") {
                    self.subTotal = dict["SubTotal"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var category: [GetCategoriesResponseBody.SubCategories.Category]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                var tmp : [Any] = []
                for k in self.category! {
                    tmp.append(k.toMap())
                }
                map["Category"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                var tmp : [GetCategoriesResponseBody.SubCategories.Category] = []
                for v in dict["Category"] as! [Any] {
                    var model = GetCategoriesResponseBody.SubCategories.Category()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.category = tmp
            }
        }
    }
    public var category: GetCategoriesResponseBody.Category?

    public var requestId: String?

    public var subCategories: GetCategoriesResponseBody.SubCategories?

    public var subTotal: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
        try self.subCategories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCategories != nil {
            map["SubCategories"] = self.subCategories?.toMap()
        }
        if self.subTotal != nil {
            map["SubTotal"] = self.subTotal!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            var model = GetCategoriesResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCategories") {
            var model = GetCategoriesResponseBody.SubCategories()
            model.fromMap(dict["SubCategories"] as! [String: Any])
            self.subCategories = model
        }
        if dict.keys.contains("SubTotal") {
            self.subTotal = dict["SubTotal"] as! Int64
        }
    }
}

public class GetCategoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCategoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCategoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetContentAnalyzeConfigResponseBody : Tea.TeaModel {
    public class ContentAnalyzeConfig : Tea.TeaModel {
        public var auto: Bool?

        public var saveType: String?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auto != nil {
                map["Auto"] = self.auto!
            }
            if self.saveType != nil {
                map["SaveType"] = self.saveType!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Auto") {
                self.auto = dict["Auto"] as! Bool
            }
            if dict.keys.contains("SaveType") {
                self.saveType = dict["SaveType"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var contentAnalyzeConfig: GetContentAnalyzeConfigResponseBody.ContentAnalyzeConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.contentAnalyzeConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentAnalyzeConfig != nil {
            map["ContentAnalyzeConfig"] = self.contentAnalyzeConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContentAnalyzeConfig") {
            var model = GetContentAnalyzeConfigResponseBody.ContentAnalyzeConfig()
            model.fromMap(dict["ContentAnalyzeConfig"] as! [String: Any])
            self.contentAnalyzeConfig = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetContentAnalyzeConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetContentAnalyzeConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetContentAnalyzeConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCustomTemplateRequest : Tea.TeaModel {
    public var subtype: Int32?

    public var templateId: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Subtype") {
            self.subtype = dict["Subtype"] as! Int32
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class GetCustomTemplateResponseBody : Tea.TeaModel {
    public class CustomTemplate : Tea.TeaModel {
        public var createTime: String?

        public var isDefault: Bool?

        public var modifiedTime: String?

        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var customTemplate: GetCustomTemplateResponseBody.CustomTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplate != nil {
            map["CustomTemplate"] = self.customTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplate") {
            var model = GetCustomTemplateResponseBody.CustomTemplate()
            model.fromMap(dict["CustomTemplate"] as! [String: Any])
            self.customTemplate = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCustomizedVoiceRequest : Tea.TeaModel {
    public var voiceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.voiceId != nil {
            map["VoiceId"] = self.voiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VoiceId") {
            self.voiceId = dict["VoiceId"] as! String
        }
    }
}

public class GetCustomizedVoiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CustomizedVoice : Tea.TeaModel {
            public var demoAudioMediaId: String?

            public var gender: String?

            public var scenario: String?

            public var voiceDesc: String?

            public var voiceId: String?

            public var voiceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoAudioMediaId != nil {
                    map["DemoAudioMediaId"] = self.demoAudioMediaId!
                }
                if self.gender != nil {
                    map["Gender"] = self.gender!
                }
                if self.scenario != nil {
                    map["Scenario"] = self.scenario!
                }
                if self.voiceDesc != nil {
                    map["VoiceDesc"] = self.voiceDesc!
                }
                if self.voiceId != nil {
                    map["VoiceId"] = self.voiceId!
                }
                if self.voiceName != nil {
                    map["VoiceName"] = self.voiceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoAudioMediaId") {
                    self.demoAudioMediaId = dict["DemoAudioMediaId"] as! String
                }
                if dict.keys.contains("Gender") {
                    self.gender = dict["Gender"] as! String
                }
                if dict.keys.contains("Scenario") {
                    self.scenario = dict["Scenario"] as! String
                }
                if dict.keys.contains("VoiceDesc") {
                    self.voiceDesc = dict["VoiceDesc"] as! String
                }
                if dict.keys.contains("VoiceId") {
                    self.voiceId = dict["VoiceId"] as! String
                }
                if dict.keys.contains("VoiceName") {
                    self.voiceName = dict["VoiceName"] as! String
                }
            }
        }
        public var customizedVoice: GetCustomizedVoiceResponseBody.Data.CustomizedVoice?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.customizedVoice?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customizedVoice != nil {
                map["CustomizedVoice"] = self.customizedVoice?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomizedVoice") {
                var model = GetCustomizedVoiceResponseBody.Data.CustomizedVoice()
                model.fromMap(dict["CustomizedVoice"] as! [String: Any])
                self.customizedVoice = model
            }
        }
    }
    public var data: GetCustomizedVoiceResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetCustomizedVoiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetCustomizedVoiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomizedVoiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCustomizedVoiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCustomizedVoiceJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CustomizedVoiceJob : Tea.TeaModel {
            public var createTime: String?

            public var gender: String?

            public var jobId: String?

            public var message: String?

            public var scenario: String?

            public var status: String?

            public var type: String?

            public var voiceDesc: String?

            public var voiceId: String?

            public var voiceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.gender != nil {
                    map["Gender"] = self.gender!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.scenario != nil {
                    map["Scenario"] = self.scenario!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.voiceDesc != nil {
                    map["VoiceDesc"] = self.voiceDesc!
                }
                if self.voiceId != nil {
                    map["VoiceId"] = self.voiceId!
                }
                if self.voiceName != nil {
                    map["VoiceName"] = self.voiceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Gender") {
                    self.gender = dict["Gender"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Scenario") {
                    self.scenario = dict["Scenario"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VoiceDesc") {
                    self.voiceDesc = dict["VoiceDesc"] as! String
                }
                if dict.keys.contains("VoiceId") {
                    self.voiceId = dict["VoiceId"] as! String
                }
                if dict.keys.contains("VoiceName") {
                    self.voiceName = dict["VoiceName"] as! String
                }
            }
        }
        public var customizedVoiceJob: GetCustomizedVoiceJobResponseBody.Data.CustomizedVoiceJob?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.customizedVoiceJob?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customizedVoiceJob != nil {
                map["CustomizedVoiceJob"] = self.customizedVoiceJob?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomizedVoiceJob") {
                var model = GetCustomizedVoiceJobResponseBody.Data.CustomizedVoiceJob()
                model.fromMap(dict["CustomizedVoiceJob"] as! [String: Any])
                self.customizedVoiceJob = model
            }
        }
    }
    public var data: GetCustomizedVoiceJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetCustomizedVoiceJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDefaultStorageLocationResponseBody : Tea.TeaModel {
    public var bucket: String?

    public var path: String?

    public var requestId: String?

    public var status: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class GetDefaultStorageLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDefaultStorageLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDefaultStorageLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDemonstrationForCustomizedVoiceJobRequest : Tea.TeaModel {
    public var scenario: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scenario != nil {
            map["Scenario"] = self.scenario!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Scenario") {
            self.scenario = dict["Scenario"] as! String
        }
    }
}

public class GetDemonstrationForCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DemonstrationList : Tea.TeaModel {
            public var audioId: Int32?

            public var demoAudio: String?

            public var text: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioId != nil {
                    map["AudioId"] = self.audioId!
                }
                if self.demoAudio != nil {
                    map["DemoAudio"] = self.demoAudio!
                }
                if self.text != nil {
                    map["Text"] = self.text!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioId") {
                    self.audioId = dict["AudioId"] as! Int32
                }
                if dict.keys.contains("DemoAudio") {
                    self.demoAudio = dict["DemoAudio"] as! String
                }
                if dict.keys.contains("Text") {
                    self.text = dict["Text"] as! String
                }
            }
        }
        public var demonstrationList: [GetDemonstrationForCustomizedVoiceJobResponseBody.Data.DemonstrationList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.demonstrationList != nil {
                var tmp : [Any] = []
                for k in self.demonstrationList! {
                    tmp.append(k.toMap())
                }
                map["DemonstrationList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DemonstrationList") {
                var tmp : [GetDemonstrationForCustomizedVoiceJobResponseBody.Data.DemonstrationList] = []
                for v in dict["DemonstrationList"] as! [Any] {
                    var model = GetDemonstrationForCustomizedVoiceJobResponseBody.Data.DemonstrationList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.demonstrationList = tmp
            }
        }
    }
    public var data: GetDemonstrationForCustomizedVoiceJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDemonstrationForCustomizedVoiceJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDemonstrationForCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDemonstrationForCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDemonstrationForCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDynamicImageJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetDynamicImageJobResponseBody : Tea.TeaModel {
    public class DynamicImageJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetDynamicImageJobResponseBody.DynamicImageJob.Input.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") {
                    var model = GetDynamicImageJobResponseBody.DynamicImageJob.Input.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetDynamicImageJobResponseBody.DynamicImageJob.Output.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") {
                    var model = GetDynamicImageJobResponseBody.DynamicImageJob.Output.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var code: String?

        public var createTime: String?

        public var finishTime: String?

        public var input: GetDynamicImageJobResponseBody.DynamicImageJob.Input?

        public var jobId: String?

        public var message: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: GetDynamicImageJobResponseBody.DynamicImageJob.Output?

        public var outputUrl: String?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateConfig: String?

        public var templateId: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.outputUrl != nil {
                map["OutputUrl"] = self.outputUrl!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = GetDynamicImageJobResponseBody.DynamicImageJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = GetDynamicImageJobResponseBody.DynamicImageJob.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("OutputUrl") {
                self.outputUrl = dict["OutputUrl"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var dynamicImageJob: GetDynamicImageJobResponseBody.DynamicImageJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dynamicImageJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicImageJob != nil {
            map["DynamicImageJob"] = self.dynamicImageJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicImageJob") {
            var model = GetDynamicImageJobResponseBody.DynamicImageJob()
            model.fromMap(dict["DynamicImageJob"] as! [String: Any])
            self.dynamicImageJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDynamicImageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDynamicImageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDynamicImageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingProjectRequest : Tea.TeaModel {
    public var projectId: String?

    public var requestSource: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestSource != nil {
            map["RequestSource"] = self.requestSource!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestSource") {
            self.requestSource = dict["RequestSource"] as! String
        }
    }
}

public class GetEditingProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var clipsParam: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var duration: Int64?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: String?

        public var templateId: String?

        public var templateType: String?

        public var timeline: String?

        public var timelineConvertErrorMessage: String?

        public var timelineConvertStatus: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.timelineConvertErrorMessage != nil {
                map["TimelineConvertErrorMessage"] = self.timelineConvertErrorMessage!
            }
            if self.timelineConvertStatus != nil {
                map["TimelineConvertStatus"] = self.timelineConvertStatus!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("TimelineConvertErrorMessage") {
                self.timelineConvertErrorMessage = dict["TimelineConvertErrorMessage"] as! String
            }
            if dict.keys.contains("TimelineConvertStatus") {
                self.timelineConvertStatus = dict["TimelineConvertStatus"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var project: GetEditingProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") {
            var model = GetEditingProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingProjectMaterialsRequest : Tea.TeaModel {
    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class GetEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public class LiveMaterials : Tea.TeaModel {
        public var appName: String?

        public var domainName: String?

        public var liveUrl: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.liveUrl != nil {
                map["LiveUrl"] = self.liveUrl!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("LiveUrl") {
                self.liveUrl = dict["LiveUrl"] as! String
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
        }
    }
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: GetEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                var tmp : [GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = GetEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var liveMaterials: [GetEditingProjectMaterialsResponseBody.LiveMaterials]?

    public var mediaInfos: [GetEditingProjectMaterialsResponseBody.MediaInfos]?

    public var projectId: String?

    public var projectMaterials: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveMaterials != nil {
            var tmp : [Any] = []
            for k in self.liveMaterials! {
                tmp.append(k.toMap())
            }
            map["LiveMaterials"] = tmp
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectMaterials != nil {
            map["ProjectMaterials"] = self.projectMaterials!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveMaterials") {
            var tmp : [GetEditingProjectMaterialsResponseBody.LiveMaterials] = []
            for v in dict["LiveMaterials"] as! [Any] {
                var model = GetEditingProjectMaterialsResponseBody.LiveMaterials()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.liveMaterials = tmp
        }
        if dict.keys.contains("MediaInfos") {
            var tmp : [GetEditingProjectMaterialsResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = GetEditingProjectMaterialsResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectMaterials") {
            self.projectMaterials = dict["ProjectMaterials"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEventCallbackResponseBody : Tea.TeaModel {
    public var authKey: String?

    public var authSwitch: String?

    public var callbackQueueName: String?

    public var callbackType: String?

    public var callbackURL: String?

    public var eventTypeList: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.authSwitch != nil {
            map["AuthSwitch"] = self.authSwitch!
        }
        if self.callbackQueueName != nil {
            map["CallbackQueueName"] = self.callbackQueueName!
        }
        if self.callbackType != nil {
            map["CallbackType"] = self.callbackType!
        }
        if self.callbackURL != nil {
            map["CallbackURL"] = self.callbackURL!
        }
        if self.eventTypeList != nil {
            map["EventTypeList"] = self.eventTypeList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthKey") {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("AuthSwitch") {
            self.authSwitch = dict["AuthSwitch"] as! String
        }
        if dict.keys.contains("CallbackQueueName") {
            self.callbackQueueName = dict["CallbackQueueName"] as! String
        }
        if dict.keys.contains("CallbackType") {
            self.callbackType = dict["CallbackType"] as! String
        }
        if dict.keys.contains("CallbackURL") {
            self.callbackURL = dict["CallbackURL"] as! String
        }
        if dict.keys.contains("EventTypeList") {
            self.eventTypeList = dict["EventTypeList"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEventCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEventCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEventCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveEditingIndexFileRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var projectId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class GetLiveEditingIndexFileResponseBody : Tea.TeaModel {
    public var indexFile: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexFile != nil {
            map["IndexFile"] = self.indexFile!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndexFile") {
            self.indexFile = dict["IndexFile"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveEditingIndexFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveEditingIndexFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveEditingIndexFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveEditingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveEditingJobResponseBody : Tea.TeaModel {
    public class LiveEditingJob : Tea.TeaModel {
        public class LiveStreamConfig : Tea.TeaModel {
            public var appName: String?

            public var domainName: String?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
            }
        }
        public class MediaProduceConfig : Tea.TeaModel {
            public var mode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! String
                }
            }
        }
        public class OutputMediaConfig : Tea.TeaModel {
            public var bitrate: Int64?

            public var fileName: String?

            public var height: Int32?

            public var mediaURL: String?

            public var storageLocation: String?

            public var vodTemplateGroupId: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.mediaURL != nil {
                    map["MediaURL"] = self.mediaURL!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.vodTemplateGroupId != nil {
                    map["VodTemplateGroupId"] = self.vodTemplateGroupId!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! Int64
                }
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("MediaURL") {
                    self.mediaURL = dict["MediaURL"] as! String
                }
                if dict.keys.contains("StorageLocation") {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("VodTemplateGroupId") {
                    self.vodTemplateGroupId = dict["VodTemplateGroupId"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var clips: String?

        public var code: String?

        public var completeTime: String?

        public var creationTime: String?

        public var jobId: String?

        public var liveStreamConfig: GetLiveEditingJobResponseBody.LiveEditingJob.LiveStreamConfig?

        public var mediaId: String?

        public var mediaProduceConfig: GetLiveEditingJobResponseBody.LiveEditingJob.MediaProduceConfig?

        public var mediaURL: String?

        public var message: String?

        public var modifiedTime: String?

        public var outputMediaConfig: GetLiveEditingJobResponseBody.LiveEditingJob.OutputMediaConfig?

        public var projectId: String?

        public var status: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.liveStreamConfig?.validate()
            try self.mediaProduceConfig?.validate()
            try self.outputMediaConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clips != nil {
                map["Clips"] = self.clips!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.liveStreamConfig != nil {
                map["LiveStreamConfig"] = self.liveStreamConfig?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaProduceConfig != nil {
                map["MediaProduceConfig"] = self.mediaProduceConfig?.toMap()
            }
            if self.mediaURL != nil {
                map["MediaURL"] = self.mediaURL!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputMediaConfig != nil {
                map["OutputMediaConfig"] = self.outputMediaConfig?.toMap()
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Clips") {
                self.clips = dict["Clips"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("LiveStreamConfig") {
                var model = GetLiveEditingJobResponseBody.LiveEditingJob.LiveStreamConfig()
                model.fromMap(dict["LiveStreamConfig"] as! [String: Any])
                self.liveStreamConfig = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaProduceConfig") {
                var model = GetLiveEditingJobResponseBody.LiveEditingJob.MediaProduceConfig()
                model.fromMap(dict["MediaProduceConfig"] as! [String: Any])
                self.mediaProduceConfig = model
            }
            if dict.keys.contains("MediaURL") {
                self.mediaURL = dict["MediaURL"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputMediaConfig") {
                var model = GetLiveEditingJobResponseBody.LiveEditingJob.OutputMediaConfig()
                model.fromMap(dict["OutputMediaConfig"] as! [String: Any])
                self.outputMediaConfig = model
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var liveEditingJob: GetLiveEditingJobResponseBody.LiveEditingJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveEditingJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveEditingJob != nil {
            map["LiveEditingJob"] = self.liveEditingJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveEditingJob") {
            var model = GetLiveEditingJobResponseBody.LiveEditingJob()
            model.fromMap(dict["LiveEditingJob"] as! [String: Any])
            self.liveEditingJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveEditingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveEditingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveEditingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveRecordJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveRecordJobResponseBody : Tea.TeaModel {
    public class RecordJob : Tea.TeaModel {
        public class RecordOutput : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var notifyUrl: String?

        public var recordOutput: GetLiveRecordJobResponseBody.RecordJob.RecordOutput?

        public var status: String?

        public var streamInput: GetLiveRecordJobResponseBody.RecordJob.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordOutput?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            if self.recordOutput != nil {
                map["RecordOutput"] = self.recordOutput?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyUrl") {
                self.notifyUrl = dict["NotifyUrl"] as! String
            }
            if dict.keys.contains("RecordOutput") {
                var model = GetLiveRecordJobResponseBody.RecordJob.RecordOutput()
                model.fromMap(dict["RecordOutput"] as! [String: Any])
                self.recordOutput = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StreamInput") {
                var model = GetLiveRecordJobResponseBody.RecordJob.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var recordJob: GetLiveRecordJobResponseBody.RecordJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordJob != nil {
            map["RecordJob"] = self.recordJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordJob") {
            var model = GetLiveRecordJobResponseBody.RecordJob()
            model.fromMap(dict["RecordJob"] as! [String: Any])
            self.recordJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveRecordJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveRecordJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveRecordJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveRecordTemplateRequest : Tea.TeaModel {
    public var jobId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetLiveRecordTemplateResponseBody : Tea.TeaModel {
    public class RecordTemplate : Tea.TeaModel {
        public class RecordFormatList : Tea.TeaModel {
            public var cycleDuration: Int32?

            public var format: String?

            public var ossObjectPrefix: String?

            public var sliceDuration: Int32?

            public var sliceOssObjectPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleDuration != nil {
                    map["CycleDuration"] = self.cycleDuration!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.ossObjectPrefix != nil {
                    map["OssObjectPrefix"] = self.ossObjectPrefix!
                }
                if self.sliceDuration != nil {
                    map["SliceDuration"] = self.sliceDuration!
                }
                if self.sliceOssObjectPrefix != nil {
                    map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CycleDuration") {
                    self.cycleDuration = dict["CycleDuration"] as! Int32
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("OssObjectPrefix") {
                    self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
                }
                if dict.keys.contains("SliceDuration") {
                    self.sliceDuration = dict["SliceDuration"] as! Int32
                }
                if dict.keys.contains("SliceOssObjectPrefix") {
                    self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
                }
            }
        }
        public var createTime: String?

        public var lastModified: String?

        public var name: String?

        public var recordFormatList: [GetLiveRecordTemplateResponseBody.RecordTemplate.RecordFormatList]?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordFormatList != nil {
                var tmp : [Any] = []
                for k in self.recordFormatList! {
                    tmp.append(k.toMap())
                }
                map["RecordFormatList"] = tmp
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordFormatList") {
                var tmp : [GetLiveRecordTemplateResponseBody.RecordTemplate.RecordFormatList] = []
                for v in dict["RecordFormatList"] as! [Any] {
                    var model = GetLiveRecordTemplateResponseBody.RecordTemplate.RecordFormatList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recordFormatList = tmp
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var recordTemplate: GetLiveRecordTemplateResponseBody.RecordTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordTemplate != nil {
            map["RecordTemplate"] = self.recordTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordTemplate") {
            var model = GetLiveRecordTemplateResponseBody.RecordTemplate()
            model.fromMap(dict["RecordTemplate"] as! [String: Any])
            self.recordTemplate = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveSnapshotJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveSnapshotJobResponseBody : Tea.TeaModel {
    public class SnapshotOutput : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("StorageType") {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public class StreamInput : Tea.TeaModel {
        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var callbackUrl: String?

    public var createTime: String?

    public var jobId: String?

    public var jobName: String?

    public var lastModified: String?

    public var overwriteFormat: String?

    public var requestId: String?

    public var sequenceFormat: String?

    public var snapshotOutput: GetLiveSnapshotJobResponseBody.SnapshotOutput?

    public var status: String?

    public var streamInput: GetLiveSnapshotJobResponseBody.StreamInput?

    public var templateId: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotOutput?.validate()
        try self.streamInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.lastModified != nil {
            map["LastModified"] = self.lastModified!
        }
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.snapshotOutput != nil {
            map["SnapshotOutput"] = self.snapshotOutput?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("LastModified") {
            self.lastModified = dict["LastModified"] as! String
        }
        if dict.keys.contains("OverwriteFormat") {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SequenceFormat") {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("SnapshotOutput") {
            var model = GetLiveSnapshotJobResponseBody.SnapshotOutput()
            model.fromMap(dict["SnapshotOutput"] as! [String: Any])
            self.snapshotOutput = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StreamInput") {
            var model = GetLiveSnapshotJobResponseBody.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class GetLiveSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var createTime: String?

    public var lastModified: String?

    public var overwriteFormat: String?

    public var requestId: String?

    public var sequenceFormat: String?

    public var templateId: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.lastModified != nil {
            map["LastModified"] = self.lastModified!
        }
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("LastModified") {
            self.lastModified = dict["LastModified"] as! String
        }
        if dict.keys.contains("OverwriteFormat") {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SequenceFormat") {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveTranscodeJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveTranscodeJobResponseBody : Tea.TeaModel {
    public class Job : Tea.TeaModel {
        public class OutputStream : Tea.TeaModel {
            public class StreamInfos : Tea.TeaModel {
                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var streamInfos: [GetLiveTranscodeJobResponseBody.Job.OutputStream.StreamInfos]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.streamInfos != nil {
                    var tmp : [Any] = []
                    for k in self.streamInfos! {
                        tmp.append(k.toMap())
                    }
                    map["StreamInfos"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("StreamInfos") {
                    var tmp : [GetLiveTranscodeJobResponseBody.Job.OutputStream.StreamInfos] = []
                    for v in dict["StreamInfos"] as! [Any] {
                        var model = GetLiveTranscodeJobResponseBody.Job.OutputStream.StreamInfos()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.streamInfos = tmp
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var inputUrl: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputUrl") {
                    self.inputUrl = dict["InputUrl"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var outputStream: GetLiveTranscodeJobResponseBody.Job.OutputStream?

        public var startMode: Int32?

        public var status: Int32?

        public var streamInput: GetLiveTranscodeJobResponseBody.Job.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.outputStream?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputStream != nil {
                map["OutputStream"] = self.outputStream?.toMap()
            }
            if self.startMode != nil {
                map["StartMode"] = self.startMode!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputStream") {
                var model = GetLiveTranscodeJobResponseBody.Job.OutputStream()
                model.fromMap(dict["OutputStream"] as! [String: Any])
                self.outputStream = model
            }
            if dict.keys.contains("StartMode") {
                self.startMode = dict["StartMode"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StreamInput") {
                var model = GetLiveTranscodeJobResponseBody.Job.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var job: GetLiveTranscodeJobResponseBody.Job?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.job?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.job != nil {
            map["Job"] = self.job?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Job") {
            var model = GetLiveTranscodeJobResponseBody.Job()
            model.fromMap(dict["Job"] as! [String: Any])
            self.job = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveTranscodeTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public class TemplateContent : Tea.TeaModel {
        public class TemplateConfig : Tea.TeaModel {
            public class AudioParams : Tea.TeaModel {
                public var bitrate: String?

                public var channels: String?

                public var codec: String?

                public var profile: String?

                public var samplerate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.samplerate != nil {
                        map["Samplerate"] = self.samplerate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Samplerate") {
                        self.samplerate = dict["Samplerate"] as! String
                    }
                }
            }
            public class VideoParams : Tea.TeaModel {
                public var bitrate: String?

                public var codec: String?

                public var fps: String?

                public var gop: String?

                public var height: String?

                public var profile: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Gop") {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioParams: GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.AudioParams?

            public var videoParams: GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.VideoParams?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioParams?.validate()
                try self.videoParams?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioParams != nil {
                    map["AudioParams"] = self.audioParams?.toMap()
                }
                if self.videoParams != nil {
                    map["VideoParams"] = self.videoParams?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioParams") {
                    var model = GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.AudioParams()
                    model.fromMap(dict["AudioParams"] as! [String: Any])
                    self.audioParams = model
                }
                if dict.keys.contains("VideoParams") {
                    var model = GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.VideoParams()
                    model.fromMap(dict["VideoParams"] as! [String: Any])
                    self.videoParams = model
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var name: String?

        public var templateConfig: GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.templateConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                var model = GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig()
                model.fromMap(dict["TemplateConfig"] as! [String: Any])
                self.templateConfig = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateContent: GetLiveTranscodeTemplateResponseBody.TemplateContent?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateContent != nil {
            map["TemplateContent"] = self.templateContent?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateContent") {
            var model = GetLiveTranscodeTemplateResponseBody.TemplateContent()
            model.fromMap(dict["TemplateContent"] as! [String: Any])
            self.templateContent = model
        }
    }
}

public class GetLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaInfoRequest : Tea.TeaModel {
    public var inputURL: String?

    public var mediaId: String?

    public var outputType: String?

    public var returnDetailedInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        if self.returnDetailedInfo != nil {
            map["ReturnDetailedInfo"] = self.returnDetailedInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OutputType") {
            self.outputType = dict["OutputType"] as! String
        }
        if dict.keys.contains("ReturnDetailedInfo") {
            self.returnDetailedInfo = dict["ReturnDetailedInfo"] as! String
        }
    }
}

public class GetMediaInfoResponseBody : Tea.TeaModel {
    public class MediaInfo : Tea.TeaModel {
        public class AiRoughData : Tea.TeaModel {
            public class StandardSmartTagJob : Tea.TeaModel {
                public class Results : Tea.TeaModel {
                    public var data: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.data != nil {
                            map["Data"] = self.data!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Data") {
                            self.data = dict["Data"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var aiJobId: String?

                public var resultUrl: String?

                public var results: [GetMediaInfoResponseBody.MediaInfo.AiRoughData.StandardSmartTagJob.Results]?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aiJobId != nil {
                        map["AiJobId"] = self.aiJobId!
                    }
                    if self.resultUrl != nil {
                        map["ResultUrl"] = self.resultUrl!
                    }
                    if self.results != nil {
                        var tmp : [Any] = []
                        for k in self.results! {
                            tmp.append(k.toMap())
                        }
                        map["Results"] = tmp
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AiJobId") {
                        self.aiJobId = dict["AiJobId"] as! String
                    }
                    if dict.keys.contains("ResultUrl") {
                        self.resultUrl = dict["ResultUrl"] as! String
                    }
                    if dict.keys.contains("Results") {
                        var tmp : [GetMediaInfoResponseBody.MediaInfo.AiRoughData.StandardSmartTagJob.Results] = []
                        for v in dict["Results"] as! [Any] {
                            var model = GetMediaInfoResponseBody.MediaInfo.AiRoughData.StandardSmartTagJob.Results()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.results = tmp
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public var aiCategory: String?

            public var aiJobId: String?

            public var result: String?

            public var saveType: String?

            public var standardSmartTagJob: GetMediaInfoResponseBody.MediaInfo.AiRoughData.StandardSmartTagJob?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.standardSmartTagJob?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiCategory != nil {
                    map["AiCategory"] = self.aiCategory!
                }
                if self.aiJobId != nil {
                    map["AiJobId"] = self.aiJobId!
                }
                if self.result != nil {
                    map["Result"] = self.result!
                }
                if self.saveType != nil {
                    map["SaveType"] = self.saveType!
                }
                if self.standardSmartTagJob != nil {
                    map["StandardSmartTagJob"] = self.standardSmartTagJob?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiCategory") {
                    self.aiCategory = dict["AiCategory"] as! String
                }
                if dict.keys.contains("AiJobId") {
                    self.aiJobId = dict["AiJobId"] as! String
                }
                if dict.keys.contains("Result") {
                    self.result = dict["Result"] as! String
                }
                if dict.keys.contains("SaveType") {
                    self.saveType = dict["SaveType"] as! String
                }
                if dict.keys.contains("StandardSmartTagJob") {
                    var model = GetMediaInfoResponseBody.MediaInfo.AiRoughData.StandardSmartTagJob()
                    model.fromMap(dict["StandardSmartTagJob"] as! [String: Any])
                    self.standardSmartTagJob = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class FileInfoList : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var fps: String?

                public var index: String?

                public var lang: String?

                public var numFrames: String?

                public var profile: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var createTime: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var modifiedTime: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class SubtitleStreamInfoList : Tea.TeaModel {
                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFPS: String?

                public var bitrate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var nbFrames: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timebase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFPS != nil {
                        map["AvgFPS"] = self.avgFPS!
                    }
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["HasBFrames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.nbFrames != nil {
                        map["Nb_frames"] = self.nbFrames!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvgFPS") {
                        self.avgFPS = dict["AvgFPS"] as! String
                    }
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("HasBFrames") {
                        self.hasBFrames = dict["HasBFrames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Nb_frames") {
                        self.nbFrames = dict["Nb_frames"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList]?

            public var fileBasicInfo: GetMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo?

            public var subtitleStreamInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList]?

            public var videoStreamInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.subtitleStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.subtitleStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["SubtitleStreamInfoList"] = tmp
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    var tmp : [GetMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("SubtitleStreamInfoList") {
                    var tmp : [GetMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList] = []
                    for v in dict["SubtitleStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subtitleStreamInfoList = tmp
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    var tmp : [GetMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var cateId: Int64?

            public var cateName: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var referenceId: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var uploadSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.uploadSource != nil {
                    map["UploadSource"] = self.uploadSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UploadSource") {
                    self.uploadSource = dict["UploadSource"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var aiRoughData: GetMediaInfoResponseBody.MediaInfo.AiRoughData?

        public var fileInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList]?

        public var mediaBasicInfo: GetMediaInfoResponseBody.MediaInfo.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.aiRoughData?.validate()
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiRoughData != nil {
                map["AiRoughData"] = self.aiRoughData?.toMap()
            }
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiRoughData") {
                var model = GetMediaInfoResponseBody.MediaInfo.AiRoughData()
                model.fromMap(dict["AiRoughData"] as! [String: Any])
                self.aiRoughData = model
            }
            if dict.keys.contains("FileInfoList") {
                var tmp : [GetMediaInfoResponseBody.MediaInfo.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = GetMediaInfoResponseBody.MediaInfo.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var mediaInfo: GetMediaInfoResponseBody.MediaInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfo != nil {
            map["MediaInfo"] = self.mediaInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfo") {
            var model = GetMediaInfoResponseBody.MediaInfo()
            model.fromMap(dict["MediaInfo"] as! [String: Any])
            self.mediaInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaInfoJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    var tmp : [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    var tmp : [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: GetMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var mediaInfoProperty: GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: GetMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = GetMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") {
                var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = GetMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: GetMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") {
            var model = GetMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
    }
}

public class GetMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaProducingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetMediaProducingJobResponseBody : Tea.TeaModel {
    public class MediaProducingJob : Tea.TeaModel {
        public var clipsParam: String?

        public var code: String?

        public var completeTime: String?

        public var createTime: String?

        public var duration: Double?

        public var jobId: String?

        public var mediaId: String?

        public var mediaURL: String?

        public var message: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var status: String?

        public var subJobMaterials: String?

        public var templateId: String?

        public var timeline: String?

        public var userData: String?

        public var vodMediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaURL != nil {
                map["MediaURL"] = self.mediaURL!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subJobMaterials != nil {
                map["SubJobMaterials"] = self.subJobMaterials!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.vodMediaId != nil {
                map["VodMediaId"] = self.vodMediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaURL") {
                self.mediaURL = dict["MediaURL"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubJobMaterials") {
                self.subJobMaterials = dict["SubJobMaterials"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("VodMediaId") {
                self.vodMediaId = dict["VodMediaId"] as! String
            }
        }
    }
    public var mediaProducingJob: GetMediaProducingJobResponseBody.MediaProducingJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaProducingJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaProducingJob != nil {
            map["MediaProducingJob"] = self.mediaProducingJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaProducingJob") {
            var model = GetMediaProducingJobResponseBody.MediaProducingJob()
            model.fromMap(dict["MediaProducingJob"] as! [String: Any])
            self.mediaProducingJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaProducingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaProducingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaProducingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPackageJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetPackageJobResponseBody : Tea.TeaModel {
    public class PackageJob : Tea.TeaModel {
        public class Inputs : Tea.TeaModel {
            public class Input : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var input: GetPackageJobResponseBody.PackageJob.Inputs.Input?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.input?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Input") {
                    var model = GetPackageJobResponseBody.PackageJob.Inputs.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var code: String?

        public var createTime: String?

        public var finishTime: String?

        public var inputs: [GetPackageJobResponseBody.PackageJob.Inputs]?

        public var jobId: String?

        public var message: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: GetPackageJobResponseBody.PackageJob.Output?

        public var outputUrl: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var status: String?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputs != nil {
                var tmp : [Any] = []
                for k in self.inputs! {
                    tmp.append(k.toMap())
                }
                map["Inputs"] = tmp
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.outputUrl != nil {
                map["OutputUrl"] = self.outputUrl!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Inputs") {
                var tmp : [GetPackageJobResponseBody.PackageJob.Inputs] = []
                for v in dict["Inputs"] as! [Any] {
                    var model = GetPackageJobResponseBody.PackageJob.Inputs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputs = tmp
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = GetPackageJobResponseBody.PackageJob.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("OutputUrl") {
                self.outputUrl = dict["OutputUrl"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var packageJob: GetPackageJobResponseBody.PackageJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packageJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packageJob != nil {
            map["PackageJob"] = self.packageJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackageJob") {
            var model = GetPackageJobResponseBody.PackageJob()
            model.fromMap(dict["PackageJob"] as! [String: Any])
            self.packageJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPackageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPackageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPackageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPipelineRequest : Tea.TeaModel {
    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
    }
}

public class GetPipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public var createTime: String?

        public var modifiedTime: String?

        public var name: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var speed: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipeline: GetPipelineResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") {
            var model = GetPipelineResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPlayInfoRequest : Tea.TeaModel {
    public var inputURL: String?

    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class GetPlayInfoResponseBody : Tea.TeaModel {
    public class MediaBase : Tea.TeaModel {
        public var cateId: Int64?

        public var coverURL: String?

        public var creationTime: String?

        public var description_: String?

        public var mediaId: String?

        public var mediaTags: String?

        public var mediaType: String?

        public var status: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaTags != nil {
                map["MediaTags"] = self.mediaTags!
            }
            if self.mediaType != nil {
                map["MediaType"] = self.mediaType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaTags") {
                self.mediaTags = dict["MediaTags"] as! String
            }
            if dict.keys.contains("MediaType") {
                self.mediaType = dict["MediaType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class PlayInfoList : Tea.TeaModel {
        public var bitDepth: Int32?

        public var bitrate: String?

        public var creationTime: String?

        public var definition: String?

        public var duration: String?

        public var encrypt: Int64?

        public var encryptType: String?

        public var fileURL: String?

        public var format: String?

        public var fps: String?

        public var HDRType: String?

        public var height: Int64?

        public var jobId: String?

        public var modificationTime: String?

        public var narrowBandType: String?

        public var playURL: String?

        public var size: Int64?

        public var status: String?

        public var streamTags: String?

        public var streamType: String?

        public var transTemplateType: String?

        public var watermarkId: String?

        public var width: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitDepth != nil {
                map["BitDepth"] = self.bitDepth!
            }
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.definition != nil {
                map["Definition"] = self.definition!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.encrypt != nil {
                map["Encrypt"] = self.encrypt!
            }
            if self.encryptType != nil {
                map["EncryptType"] = self.encryptType!
            }
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.HDRType != nil {
                map["HDRType"] = self.HDRType!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.narrowBandType != nil {
                map["NarrowBandType"] = self.narrowBandType!
            }
            if self.playURL != nil {
                map["PlayURL"] = self.playURL!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamTags != nil {
                map["StreamTags"] = self.streamTags!
            }
            if self.streamType != nil {
                map["StreamType"] = self.streamType!
            }
            if self.transTemplateType != nil {
                map["TransTemplateType"] = self.transTemplateType!
            }
            if self.watermarkId != nil {
                map["WatermarkId"] = self.watermarkId!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BitDepth") {
                self.bitDepth = dict["BitDepth"] as! Int32
            }
            if dict.keys.contains("Bitrate") {
                self.bitrate = dict["Bitrate"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Definition") {
                self.definition = dict["Definition"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Encrypt") {
                self.encrypt = dict["Encrypt"] as! Int64
            }
            if dict.keys.contains("EncryptType") {
                self.encryptType = dict["EncryptType"] as! String
            }
            if dict.keys.contains("FileURL") {
                self.fileURL = dict["FileURL"] as! String
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Fps") {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("HDRType") {
                self.HDRType = dict["HDRType"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int64
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("NarrowBandType") {
                self.narrowBandType = dict["NarrowBandType"] as! String
            }
            if dict.keys.contains("PlayURL") {
                self.playURL = dict["PlayURL"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StreamTags") {
                self.streamTags = dict["StreamTags"] as! String
            }
            if dict.keys.contains("StreamType") {
                self.streamType = dict["StreamType"] as! String
            }
            if dict.keys.contains("TransTemplateType") {
                self.transTemplateType = dict["TransTemplateType"] as! String
            }
            if dict.keys.contains("WatermarkId") {
                self.watermarkId = dict["WatermarkId"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int64
            }
        }
    }
    public var mediaBase: GetPlayInfoResponseBody.MediaBase?

    public var playInfoList: [GetPlayInfoResponseBody.PlayInfoList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaBase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaBase != nil {
            map["MediaBase"] = self.mediaBase?.toMap()
        }
        if self.playInfoList != nil {
            var tmp : [Any] = []
            for k in self.playInfoList! {
                tmp.append(k.toMap())
            }
            map["PlayInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaBase") {
            var model = GetPlayInfoResponseBody.MediaBase()
            model.fromMap(dict["MediaBase"] as! [String: Any])
            self.mediaBase = model
        }
        if dict.keys.contains("PlayInfoList") {
            var tmp : [GetPlayInfoResponseBody.PlayInfoList] = []
            for v in dict["PlayInfoList"] as! [Any] {
                var model = GetPlayInfoResponseBody.PlayInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.playInfoList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPublicMediaInfoRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class GetPublicMediaInfoResponseBody : Tea.TeaModel {
    public class MediaInfo : Tea.TeaModel {
        public class DynamicMetaData : Tea.TeaModel {
            public var data: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class FileInfoList : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var fps: String?

                public var index: String?

                public var lang: String?

                public var numFrames: String?

                public var profile: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class SubtitleStreamInfoList : Tea.TeaModel {
                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFPS: String?

                public var bitrate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var nbFrames: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timebase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFPS != nil {
                        map["AvgFPS"] = self.avgFPS!
                    }
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["HasBFrames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.nbFrames != nil {
                        map["Nb_frames"] = self.nbFrames!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvgFPS") {
                        self.avgFPS = dict["AvgFPS"] as! String
                    }
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("HasBFrames") {
                        self.hasBFrames = dict["HasBFrames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Nb_frames") {
                        self.nbFrames = dict["Nb_frames"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList]?

            public var fileBasicInfo: GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo?

            public var subtitleStreamInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList]?

            public var videoStreamInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.subtitleStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.subtitleStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["SubtitleStreamInfoList"] = tmp
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    var tmp : [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("SubtitleStreamInfoList") {
                    var tmp : [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList] = []
                    for v in dict["SubtitleStreamInfoList"] as! [Any] {
                        var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subtitleStreamInfoList = tmp
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    var tmp : [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var dynamicMetaData: GetPublicMediaInfoResponseBody.MediaInfo.DynamicMetaData?

        public var fileInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList]?

        public var mediaBasicInfo: GetPublicMediaInfoResponseBody.MediaInfo.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dynamicMetaData?.validate()
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dynamicMetaData != nil {
                map["DynamicMetaData"] = self.dynamicMetaData?.toMap()
            }
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DynamicMetaData") {
                var model = GetPublicMediaInfoResponseBody.MediaInfo.DynamicMetaData()
                model.fromMap(dict["DynamicMetaData"] as! [String: Any])
                self.dynamicMetaData = model
            }
            if dict.keys.contains("FileInfoList") {
                var tmp : [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = GetPublicMediaInfoResponseBody.MediaInfo.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var mediaInfo: GetPublicMediaInfoResponseBody.MediaInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfo != nil {
            map["MediaInfo"] = self.mediaInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfo") {
            var model = GetPublicMediaInfoResponseBody.MediaInfo()
            model.fromMap(dict["MediaInfo"] as! [String: Any])
            self.mediaInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPublicMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPublicMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPublicMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSmartHandleJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetSmartHandleJobResponseBody : Tea.TeaModel {
    public class JobResult : Tea.TeaModel {
        public var aiResult: String?

        public var mediaId: String?

        public var usage: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiResult != nil {
                map["AiResult"] = self.aiResult!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.usage != nil {
                map["Usage"] = self.usage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiResult") {
                self.aiResult = dict["AiResult"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("Usage") {
                self.usage = dict["Usage"] as! String
            }
        }
    }
    public class SmartJobInfo : Tea.TeaModel {
        public class InputConfig : Tea.TeaModel {
            public var inputFile: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputFile != nil {
                    map["InputFile"] = self.inputFile!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputFile") {
                    self.inputFile = dict["InputFile"] as! String
                }
            }
        }
        public class OutputConfig : Tea.TeaModel {
            public var bucket: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public var createTime: String?

        public var description_: String?

        public var inputConfig: GetSmartHandleJobResponseBody.SmartJobInfo.InputConfig?

        public var jobType: String?

        public var modifiedTime: String?

        public var outputConfig: GetSmartHandleJobResponseBody.SmartJobInfo.OutputConfig?

        public var title: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inputConfig?.validate()
            try self.outputConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.inputConfig != nil {
                map["InputConfig"] = self.inputConfig?.toMap()
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputConfig != nil {
                map["OutputConfig"] = self.outputConfig?.toMap()
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InputConfig") {
                var model = GetSmartHandleJobResponseBody.SmartJobInfo.InputConfig()
                model.fromMap(dict["InputConfig"] as! [String: Any])
                self.inputConfig = model
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputConfig") {
                var model = GetSmartHandleJobResponseBody.SmartJobInfo.OutputConfig()
                model.fromMap(dict["OutputConfig"] as! [String: Any])
                self.outputConfig = model
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var jobId: String?

    public var jobResult: GetSmartHandleJobResponseBody.JobResult?

    public var output: String?

    public var requestId: String?

    public var smartJobInfo: GetSmartHandleJobResponseBody.SmartJobInfo?

    public var state: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobResult?.validate()
        try self.smartJobInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobResult != nil {
            map["JobResult"] = self.jobResult?.toMap()
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.smartJobInfo != nil {
            map["SmartJobInfo"] = self.smartJobInfo?.toMap()
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobResult") {
            var model = GetSmartHandleJobResponseBody.JobResult()
            model.fromMap(dict["JobResult"] as! [String: Any])
            self.jobResult = model
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SmartJobInfo") {
            var model = GetSmartHandleJobResponseBody.SmartJobInfo()
            model.fromMap(dict["SmartJobInfo"] as! [String: Any])
            self.smartJobInfo = model
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class GetSmartHandleJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSmartHandleJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSmartHandleJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSnapshotJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetSnapshotJobResponseBody : Tea.TeaModel {
    public class SnapshotJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetSnapshotJobResponseBody.SnapshotJob.Input.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") {
                    var model = GetSnapshotJobResponseBody.SnapshotJob.Input.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetSnapshotJobResponseBody.SnapshotJob.Output.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") {
                    var model = GetSnapshotJobResponseBody.SnapshotJob.Output.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var async: Bool?

        public var code: String?

        public var count: Int32?

        public var createTime: String?

        public var finishTime: String?

        public var input: GetSnapshotJobResponseBody.SnapshotJob.Input?

        public var jobId: String?

        public var message: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: GetSnapshotJobResponseBody.SnapshotJob.Output?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateConfig: String?

        public var templateId: String?

        public var triggerSource: String?

        public var type: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = GetSnapshotJobResponseBody.SnapshotJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = GetSnapshotJobResponseBody.SnapshotJob.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var snapshotJob: GetSnapshotJobResponseBody.SnapshotJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotJob != nil {
            map["SnapshotJob"] = self.snapshotJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotJob") {
            var model = GetSnapshotJobResponseBody.SnapshotJob()
            model.fromMap(dict["SnapshotJob"] as! [String: Any])
            self.snapshotJob = model
        }
    }
}

public class GetSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSnapshotUrlsRequest : Tea.TeaModel {
    public var jobId: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
    }
}

public class GetSnapshotUrlsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotUrls: [String]?

    public var total: Int32?

    public var webVTTUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotUrls != nil {
            map["SnapshotUrls"] = self.snapshotUrls!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.webVTTUrl != nil {
            map["WebVTTUrl"] = self.webVTTUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotUrls") {
            self.snapshotUrls = dict["SnapshotUrls"] as! [String]
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
        if dict.keys.contains("WebVTTUrl") {
            self.webVTTUrl = dict["WebVTTUrl"] as! String
        }
    }
}

public class GetSnapshotUrlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSnapshotUrlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSnapshotUrlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSystemTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetSystemTemplateResponseBody : Tea.TeaModel {
    public class SystemTemplate : Tea.TeaModel {
        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var requestId: String?

    public var systemTemplate: GetSystemTemplateResponseBody.SystemTemplate?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemTemplate != nil {
            map["SystemTemplate"] = self.systemTemplate?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemTemplate") {
            var model = GetSystemTemplateResponseBody.SystemTemplate()
            model.fromMap(dict["SystemTemplate"] as! [String: Any])
            self.systemTemplate = model
        }
    }
}

public class GetSystemTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSystemTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSystemTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateRequest : Tea.TeaModel {
    public var relatedMediaidFlag: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.relatedMediaidFlag != nil {
            map["RelatedMediaidFlag"] = self.relatedMediaidFlag!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RelatedMediaidFlag") {
            self.relatedMediaidFlag = dict["RelatedMediaidFlag"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var clipsParam: String?

        public var config: String?

        public var coverURL: String?

        public var createSource: String?

        public var creationTime: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var name: String?

        public var previewMedia: String?

        public var previewMediaStatus: String?

        public var relatedMediaids: String?

        public var status: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.previewMedia != nil {
                map["PreviewMedia"] = self.previewMedia!
            }
            if self.previewMediaStatus != nil {
                map["PreviewMediaStatus"] = self.previewMediaStatus!
            }
            if self.relatedMediaids != nil {
                map["RelatedMediaids"] = self.relatedMediaids!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PreviewMedia") {
                self.previewMedia = dict["PreviewMedia"] as! String
            }
            if dict.keys.contains("PreviewMediaStatus") {
                self.previewMediaStatus = dict["PreviewMediaStatus"] as! String
            }
            if dict.keys.contains("RelatedMediaids") {
                self.relatedMediaids = dict["RelatedMediaids"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var template: GetTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") {
            var model = GetTemplateResponseBody.Template()
            model.fromMap(dict["Template"] as! [String: Any])
            self.template = model
        }
    }
}

public class GetTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateMaterialsRequest : Tea.TeaModel {
    public var fileList: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileList != nil {
            map["FileList"] = self.fileList!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileList") {
            self.fileList = dict["FileList"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateMaterialsResponseBody : Tea.TeaModel {
    public var materialUrls: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialUrls != nil {
            map["MaterialUrls"] = self.materialUrls!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialUrls") {
            self.materialUrls = dict["MaterialUrls"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTemplateMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTemplateMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateParamsRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateParamsResponseBody : Tea.TeaModel {
    public class ParamList : Tea.TeaModel {
        public var content: String?

        public var coverUrl: String?

        public var key: String?

        public var mediaUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.mediaUrl != nil {
                map["MediaUrl"] = self.mediaUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("CoverUrl") {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("MediaUrl") {
                self.mediaUrl = dict["MediaUrl"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var paramList: [GetTemplateParamsResponseBody.ParamList]?

    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.paramList != nil {
            var tmp : [Any] = []
            for k in self.paramList! {
                tmp.append(k.toMap())
            }
            map["ParamList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ParamList") {
            var tmp : [GetTemplateParamsResponseBody.ParamList] = []
            for v in dict["ParamList"] as! [Any] {
                var model = GetTemplateParamsResponseBody.ParamList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.paramList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateParamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateParamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTemplateParamsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTranscodeJobRequest : Tea.TeaModel {
    public var parentJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.parentJobId != nil {
            map["ParentJobId"] = self.parentJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ParentJobId") {
            self.parentJobId = dict["ParentJobId"] as! String
        }
    }
}

public class GetTranscodeJobResponseBody : Tea.TeaModel {
    public class TranscodeParentJob : Tea.TeaModel {
        public class InputGroup : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class OutputGroup : Tea.TeaModel {
            public class Output : Tea.TeaModel {
                public var media: String?

                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public var keyServiceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        if self.keyServiceType != nil {
                            map["KeyServiceType"] = self.keyServiceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                        if dict.keys.contains("KeyServiceType") {
                            self.keyServiceType = dict["KeyServiceType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class TransConfig : Tea.TeaModel {
                            public var adjDarMethod: String?

                            public var isCheckAudioBitrate: String?

                            public var isCheckAudioBitrateFail: String?

                            public var isCheckReso: String?

                            public var isCheckResoFail: String?

                            public var isCheckVideoBitrate: String?

                            public var isCheckVideoBitrateFail: String?

                            public var transMode: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.adjDarMethod != nil {
                                    map["AdjDarMethod"] = self.adjDarMethod!
                                }
                                if self.isCheckAudioBitrate != nil {
                                    map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                                }
                                if self.isCheckAudioBitrateFail != nil {
                                    map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                                }
                                if self.isCheckReso != nil {
                                    map["IsCheckReso"] = self.isCheckReso!
                                }
                                if self.isCheckResoFail != nil {
                                    map["IsCheckResoFail"] = self.isCheckResoFail!
                                }
                                if self.isCheckVideoBitrate != nil {
                                    map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                                }
                                if self.isCheckVideoBitrateFail != nil {
                                    map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                                }
                                if self.transMode != nil {
                                    map["TransMode"] = self.transMode!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AdjDarMethod") {
                                    self.adjDarMethod = dict["AdjDarMethod"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrate") {
                                    self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrateFail") {
                                    self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                                }
                                if dict.keys.contains("IsCheckReso") {
                                    self.isCheckReso = dict["IsCheckReso"] as! String
                                }
                                if dict.keys.contains("IsCheckResoFail") {
                                    self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrate") {
                                    self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrateFail") {
                                    self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                                }
                                if dict.keys.contains("TransMode") {
                                    self.transMode = dict["TransMode"] as! String
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var transConfig: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.TransConfig?

                        public var video: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.transConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.transConfig != nil {
                                map["TransConfig"] = self.transConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("TransConfig") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.TransConfig()
                                model.fromMap(dict["TransConfig"] as! [String: Any])
                                self.transConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs]?

                public var encryption: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption?

                public var imageWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks]?

                public var subtitles: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles]?

                public var textWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks]?

                public var transcode: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("Subtitles") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public var output: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output?

            public var processConfig: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
                try self.processConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Output") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public class TranscodeJobList : Tea.TeaModel {
            public class InputGroup : Tea.TeaModel {
                public var inputUrl: String?

                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inputUrl != nil {
                        map["InputUrl"] = self.inputUrl!
                    }
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InputUrl") {
                        self.inputUrl = dict["InputUrl"] as! String
                    }
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class OutFileMeta : Tea.TeaModel {
                public class AudioStreamInfoList : Tea.TeaModel {
                    public var bitrate: String?

                    public var channelLayout: String?

                    public var channels: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var duration: String?

                    public var index: String?

                    public var lang: String?

                    public var sampleFmt: String?

                    public var sampleRate: String?

                    public var startTime: String?

                    public var timebase: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channelLayout != nil {
                            map["ChannelLayout"] = self.channelLayout!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codecLongName != nil {
                            map["CodecLongName"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["CodecName"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["CodecTag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["CodecTagString"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["CodecTimeBase"] = self.codecTimeBase!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.sampleFmt != nil {
                            map["SampleFmt"] = self.sampleFmt!
                        }
                        if self.sampleRate != nil {
                            map["SampleRate"] = self.sampleRate!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.timebase != nil {
                            map["Timebase"] = self.timebase!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("ChannelLayout") {
                            self.channelLayout = dict["ChannelLayout"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("CodecLongName") {
                            self.codecLongName = dict["CodecLongName"] as! String
                        }
                        if dict.keys.contains("CodecName") {
                            self.codecName = dict["CodecName"] as! String
                        }
                        if dict.keys.contains("CodecTag") {
                            self.codecTag = dict["CodecTag"] as! String
                        }
                        if dict.keys.contains("CodecTagString") {
                            self.codecTagString = dict["CodecTagString"] as! String
                        }
                        if dict.keys.contains("CodecTimeBase") {
                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Index") {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("SampleFmt") {
                            self.sampleFmt = dict["SampleFmt"] as! String
                        }
                        if dict.keys.contains("SampleRate") {
                            self.sampleRate = dict["SampleRate"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("Timebase") {
                            self.timebase = dict["Timebase"] as! String
                        }
                    }
                }
                public class FileBasicInfo : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var fileName: String?

                    public var fileSize: String?

                    public var fileStatus: String?

                    public var fileType: String?

                    public var fileUrl: String?

                    public var formatName: String?

                    public var height: String?

                    public var mediaId: String?

                    public var region: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileName != nil {
                            map["FileName"] = self.fileName!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.fileStatus != nil {
                            map["FileStatus"] = self.fileStatus!
                        }
                        if self.fileType != nil {
                            map["FileType"] = self.fileType!
                        }
                        if self.fileUrl != nil {
                            map["FileUrl"] = self.fileUrl!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.mediaId != nil {
                            map["MediaId"] = self.mediaId!
                        }
                        if self.region != nil {
                            map["Region"] = self.region!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileName") {
                            self.fileName = dict["FileName"] as! String
                        }
                        if dict.keys.contains("FileSize") {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("FileStatus") {
                            self.fileStatus = dict["FileStatus"] as! String
                        }
                        if dict.keys.contains("FileType") {
                            self.fileType = dict["FileType"] as! String
                        }
                        if dict.keys.contains("FileUrl") {
                            self.fileUrl = dict["FileUrl"] as! String
                        }
                        if dict.keys.contains("FormatName") {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MediaId") {
                            self.mediaId = dict["MediaId"] as! String
                        }
                        if dict.keys.contains("Region") {
                            self.region = dict["Region"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class VideoStreamInfoList : Tea.TeaModel {
                    public var avgFps: String?

                    public var bitRate: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var dar: String?

                    public var duration: String?

                    public var fps: String?

                    public var hasBFrames: String?

                    public var height: String?

                    public var index: String?

                    public var lang: String?

                    public var level: String?

                    public var numFrames: String?

                    public var pixFmt: String?

                    public var profile: String?

                    public var rotate: String?

                    public var sar: String?

                    public var startTime: String?

                    public var timeBase: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgFps != nil {
                            map["Avg_fps"] = self.avgFps!
                        }
                        if self.bitRate != nil {
                            map["Bit_rate"] = self.bitRate!
                        }
                        if self.codecLongName != nil {
                            map["Codec_long_name"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["Codec_name"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["Codec_tag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["Codec_tag_string"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["Codec_time_base"] = self.codecTimeBase!
                        }
                        if self.dar != nil {
                            map["Dar"] = self.dar!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.hasBFrames != nil {
                            map["Has_b_frames"] = self.hasBFrames!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.numFrames != nil {
                            map["NumFrames"] = self.numFrames!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.rotate != nil {
                            map["Rotate"] = self.rotate!
                        }
                        if self.sar != nil {
                            map["Sar"] = self.sar!
                        }
                        if self.startTime != nil {
                            map["Start_time"] = self.startTime!
                        }
                        if self.timeBase != nil {
                            map["Time_base"] = self.timeBase!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Avg_fps") {
                            self.avgFps = dict["Avg_fps"] as! String
                        }
                        if dict.keys.contains("Bit_rate") {
                            self.bitRate = dict["Bit_rate"] as! String
                        }
                        if dict.keys.contains("Codec_long_name") {
                            self.codecLongName = dict["Codec_long_name"] as! String
                        }
                        if dict.keys.contains("Codec_name") {
                            self.codecName = dict["Codec_name"] as! String
                        }
                        if dict.keys.contains("Codec_tag") {
                            self.codecTag = dict["Codec_tag"] as! String
                        }
                        if dict.keys.contains("Codec_tag_string") {
                            self.codecTagString = dict["Codec_tag_string"] as! String
                        }
                        if dict.keys.contains("Codec_time_base") {
                            self.codecTimeBase = dict["Codec_time_base"] as! String
                        }
                        if dict.keys.contains("Dar") {
                            self.dar = dict["Dar"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Has_b_frames") {
                            self.hasBFrames = dict["Has_b_frames"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Index") {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("Level") {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("NumFrames") {
                            self.numFrames = dict["NumFrames"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Rotate") {
                            self.rotate = dict["Rotate"] as! String
                        }
                        if dict.keys.contains("Sar") {
                            self.sar = dict["Sar"] as! String
                        }
                        if dict.keys.contains("Start_time") {
                            self.startTime = dict["Start_time"] as! String
                        }
                        if dict.keys.contains("Time_base") {
                            self.timeBase = dict["Time_base"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var audioStreamInfoList: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList]?

                public var fileBasicInfo: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo?

                public var videoStreamInfoList: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.fileBasicInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.audioStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["AudioStreamInfoList"] = tmp
                    }
                    if self.fileBasicInfo != nil {
                        map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                    }
                    if self.videoStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.videoStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["VideoStreamInfoList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioStreamInfoList") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList] = []
                        for v in dict["AudioStreamInfoList"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.audioStreamInfoList = tmp
                    }
                    if dict.keys.contains("FileBasicInfo") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo()
                        model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                        self.fileBasicInfo = model
                    }
                    if dict.keys.contains("VideoStreamInfoList") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList] = []
                        for v in dict["VideoStreamInfoList"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.videoStreamInfoList = tmp
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public var media: String?

                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public var keyServiceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        if self.keyServiceType != nil {
                            map["KeyServiceType"] = self.keyServiceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                        if dict.keys.contains("KeyServiceType") {
                            self.keyServiceType = dict["KeyServiceType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class TransConfig : Tea.TeaModel {
                            public var adjDarMethod: String?

                            public var isCheckAudioBitrate: String?

                            public var isCheckAudioBitrateFail: String?

                            public var isCheckReso: String?

                            public var isCheckResoFail: String?

                            public var isCheckVideoBitrate: String?

                            public var isCheckVideoBitrateFail: String?

                            public var transMode: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.adjDarMethod != nil {
                                    map["AdjDarMethod"] = self.adjDarMethod!
                                }
                                if self.isCheckAudioBitrate != nil {
                                    map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                                }
                                if self.isCheckAudioBitrateFail != nil {
                                    map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                                }
                                if self.isCheckReso != nil {
                                    map["IsCheckReso"] = self.isCheckReso!
                                }
                                if self.isCheckResoFail != nil {
                                    map["IsCheckResoFail"] = self.isCheckResoFail!
                                }
                                if self.isCheckVideoBitrate != nil {
                                    map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                                }
                                if self.isCheckVideoBitrateFail != nil {
                                    map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                                }
                                if self.transMode != nil {
                                    map["TransMode"] = self.transMode!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AdjDarMethod") {
                                    self.adjDarMethod = dict["AdjDarMethod"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrate") {
                                    self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrateFail") {
                                    self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                                }
                                if dict.keys.contains("IsCheckReso") {
                                    self.isCheckReso = dict["IsCheckReso"] as! String
                                }
                                if dict.keys.contains("IsCheckResoFail") {
                                    self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrate") {
                                    self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrateFail") {
                                    self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                                }
                                if dict.keys.contains("TransMode") {
                                    self.transMode = dict["TransMode"] as! String
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var tags: [String: String]?

                        public var transConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.TransConfig?

                        public var video: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.transConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.tags != nil {
                                map["Tags"] = self.tags!
                            }
                            if self.transConfig != nil {
                                map["TransConfig"] = self.transConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Tags") {
                                self.tags = dict["Tags"] as! [String: String]
                            }
                            if dict.keys.contains("TransConfig") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.TransConfig()
                                model.fromMap(dict["TransConfig"] as! [String: Any])
                                self.transConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs]?

                public var encryption: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption?

                public var imageWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks]?

                public var isInheritTags: Bool?

                public var subtitles: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles]?

                public var textWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks]?

                public var transcode: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.isInheritTags != nil {
                        map["IsInheritTags"] = self.isInheritTags!
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("IsInheritTags") {
                        self.isInheritTags = dict["IsInheritTags"] as! Bool
                    }
                    if dict.keys.contains("Subtitles") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public class ScheduleConfig : Tea.TeaModel {
                public var pipelineId: String?

                public var priority: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PipelineId") {
                        self.pipelineId = dict["PipelineId"] as! String
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! Int32
                    }
                }
            }
            public var createTime: String?

            public var finishTime: String?

            public var inputGroup: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup]?

            public var jobId: String?

            public var jobIndex: Int32?

            public var name: String?

            public var outFileMeta: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta?

            public var output: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output?

            public var parentJobId: String?

            public var processConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig?

            public var requestId: String?

            public var scheduleConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig?

            public var status: String?

            public var submitResultJson: [String: Any]?

            public var submitTime: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outFileMeta?.validate()
                try self.output?.validate()
                try self.processConfig?.validate()
                try self.scheduleConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inputGroup != nil {
                    var tmp : [Any] = []
                    for k in self.inputGroup! {
                        tmp.append(k.toMap())
                    }
                    map["InputGroup"] = tmp
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobIndex != nil {
                    map["JobIndex"] = self.jobIndex!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outFileMeta != nil {
                    map["OutFileMeta"] = self.outFileMeta?.toMap()
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.parentJobId != nil {
                    map["ParentJobId"] = self.parentJobId!
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.scheduleConfig != nil {
                    map["ScheduleConfig"] = self.scheduleConfig?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitResultJson != nil {
                    map["SubmitResultJson"] = self.submitResultJson!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("InputGroup") {
                    var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup] = []
                    for v in dict["InputGroup"] as! [Any] {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputGroup = tmp
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobIndex") {
                    self.jobIndex = dict["JobIndex"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OutFileMeta") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta()
                    model.fromMap(dict["OutFileMeta"] as! [String: Any])
                    self.outFileMeta = model
                }
                if dict.keys.contains("Output") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ParentJobId") {
                    self.parentJobId = dict["ParentJobId"] as! String
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
                if dict.keys.contains("RequestId") {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ScheduleConfig") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig()
                    model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                    self.scheduleConfig = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitResultJson") {
                    self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
                }
                if dict.keys.contains("SubmitTime") {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var inputGroup: [GetTranscodeJobResponseBody.TranscodeParentJob.InputGroup]?

        public var jobCount: Int32?

        public var name: String?

        public var outputGroup: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup]?

        public var parentJobId: String?

        public var percent: Int32?

        public var requestId: String?

        public var scheduleConfig: GetTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig?

        public var status: String?

        public var submitTime: String?

        public var transcodeJobList: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList]?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputGroup != nil {
                var tmp : [Any] = []
                for k in self.inputGroup! {
                    tmp.append(k.toMap())
                }
                map["InputGroup"] = tmp
            }
            if self.jobCount != nil {
                map["JobCount"] = self.jobCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroup != nil {
                var tmp : [Any] = []
                for k in self.outputGroup! {
                    tmp.append(k.toMap())
                }
                map["OutputGroup"] = tmp
            }
            if self.parentJobId != nil {
                map["ParentJobId"] = self.parentJobId!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.transcodeJobList != nil {
                var tmp : [Any] = []
                for k in self.transcodeJobList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJobList"] = tmp
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("InputGroup") {
                var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.InputGroup] = []
                for v in dict["InputGroup"] as! [Any] {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.InputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputGroup = tmp
            }
            if dict.keys.contains("JobCount") {
                self.jobCount = dict["JobCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroup") {
                var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup] = []
                for v in dict["OutputGroup"] as! [Any] {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroup = tmp
            }
            if dict.keys.contains("ParentJobId") {
                self.parentJobId = dict["ParentJobId"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = GetTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TranscodeJobList") {
                var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList] = []
                for v in dict["TranscodeJobList"] as! [Any] {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeJobList = tmp
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeParentJob: GetTranscodeJobResponseBody.TranscodeParentJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeParentJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeParentJob != nil {
            map["TranscodeParentJob"] = self.transcodeParentJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeParentJob") {
            var model = GetTranscodeJobResponseBody.TranscodeParentJob()
            model.fromMap(dict["TranscodeParentJob"] as! [String: Any])
            self.transcodeParentJob = model
        }
    }
}

public class GetTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUrlUploadInfosRequest : Tea.TeaModel {
    public var jobIds: String?

    public var uploadURLs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.uploadURLs != nil {
            map["UploadURLs"] = self.uploadURLs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("UploadURLs") {
            self.uploadURLs = dict["UploadURLs"] as! String
        }
    }
}

public class GetUrlUploadInfosResponseBody : Tea.TeaModel {
    public class URLUploadInfoList : Tea.TeaModel {
        public var completeTime: String?

        public var creationTime: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var fileSize: String?

        public var jobId: String?

        public var mediaId: String?

        public var status: String?

        public var uploadURL: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uploadURL != nil {
                map["UploadURL"] = self.uploadURL!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("FileSize") {
                self.fileSize = dict["FileSize"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UploadURL") {
                self.uploadURL = dict["UploadURL"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var nonExists: [String]?

    public var requestId: String?

    public var URLUploadInfoList: [GetUrlUploadInfosResponseBody.URLUploadInfoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExists != nil {
            map["NonExists"] = self.nonExists!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.URLUploadInfoList != nil {
            var tmp : [Any] = []
            for k in self.URLUploadInfoList! {
                tmp.append(k.toMap())
            }
            map["URLUploadInfoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExists") {
            self.nonExists = dict["NonExists"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("URLUploadInfoList") {
            var tmp : [GetUrlUploadInfosResponseBody.URLUploadInfoList] = []
            for v in dict["URLUploadInfoList"] as! [Any] {
                var model = GetUrlUploadInfosResponseBody.URLUploadInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.URLUploadInfoList = tmp
        }
    }
}

public class GetUrlUploadInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUrlUploadInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUrlUploadInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoListRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class GetVideoListResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public var appId: String?

        public var cateId: Int64?

        public var cateName: String?

        public var coverUrl: String?

        public var creationTime: String?

        public var description_: String?

        public var duration: Double?

        public var mediaId: String?

        public var modificationTime: String?

        public var size: Int64?

        public var snapshots: [String]?

        public var status: String?

        public var storageLocation: String?

        public var tags: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshots != nil {
                map["Snapshots"] = self.snapshots!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("CoverUrl") {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Snapshots") {
                self.snapshots = dict["Snapshots"] as! [String]
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var code: String?

    public var mediaList: [GetVideoListResponseBody.MediaList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaList != nil {
            var tmp : [Any] = []
            for k in self.mediaList! {
                tmp.append(k.toMap())
            }
            map["MediaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaList") {
            var tmp : [GetVideoListResponseBody.MediaList] = []
            for v in dict["MediaList"] as! [Any] {
                var model = GetVideoListResponseBody.MediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class GetVideoListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVideoListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkflowTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetWorkflowTaskResponseBody : Tea.TeaModel {
    public class WorkflowTask : Tea.TeaModel {
        public class Workflow : Tea.TeaModel {
            public var createTime: String?

            public var modifiedTime: String?

            public var name: String?

            public var status: String?

            public var type: String?

            public var workflowId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("WorkflowId") {
                    self.workflowId = dict["WorkflowId"] as! String
                }
            }
        }
        public var activityResults: String?

        public var createTime: String?

        public var finishTime: String?

        public var status: String?

        public var taskId: String?

        public var taskInput: String?

        public var userData: String?

        public var workflow: GetWorkflowTaskResponseBody.WorkflowTask.Workflow?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.workflow?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityResults != nil {
                map["ActivityResults"] = self.activityResults!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskInput != nil {
                map["TaskInput"] = self.taskInput!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.workflow != nil {
                map["Workflow"] = self.workflow?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityResults") {
                self.activityResults = dict["ActivityResults"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskInput") {
                self.taskInput = dict["TaskInput"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("Workflow") {
                var model = GetWorkflowTaskResponseBody.WorkflowTask.Workflow()
                model.fromMap(dict["Workflow"] as! [String: Any])
                self.workflow = model
            }
        }
    }
    public var requestId: String?

    public var workflowTask: GetWorkflowTaskResponseBody.WorkflowTask?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workflowTask?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.workflowTask != nil {
            map["WorkflowTask"] = self.workflowTask?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WorkflowTask") {
            var model = GetWorkflowTaskResponseBody.WorkflowTask()
            model.fromMap(dict["WorkflowTask"] as! [String: Any])
            self.workflowTask = model
        }
    }
}

public class GetWorkflowTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkflowTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkflowTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertMediaToSearchLibRequest : Tea.TeaModel {
    public var input: String?

    public var mediaId: String?

    public var mediaType: String?

    public var msgBody: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.msgBody != nil {
            map["MsgBody"] = self.msgBody!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("MsgBody") {
            self.msgBody = dict["MsgBody"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class InsertMediaToSearchLibResponseBody : Tea.TeaModel {
    public var code: String?

    public var mediaId: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class InsertMediaToSearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertMediaToSearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InsertMediaToSearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAllPublicMediaTagsRequest : Tea.TeaModel {
    public var businessType: String?

    public var entityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
    }
}

public class ListAllPublicMediaTagsResponseBody : Tea.TeaModel {
    public class MediaTagList : Tea.TeaModel {
        public class Options : Tea.TeaModel {
            public var optionChineseName: String?

            public var optionEnglishName: String?

            public var optionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.optionChineseName != nil {
                    map["OptionChineseName"] = self.optionChineseName!
                }
                if self.optionEnglishName != nil {
                    map["OptionEnglishName"] = self.optionEnglishName!
                }
                if self.optionId != nil {
                    map["OptionId"] = self.optionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OptionChineseName") {
                    self.optionChineseName = dict["OptionChineseName"] as! String
                }
                if dict.keys.contains("OptionEnglishName") {
                    self.optionEnglishName = dict["OptionEnglishName"] as! String
                }
                if dict.keys.contains("OptionId") {
                    self.optionId = dict["OptionId"] as! String
                }
            }
        }
        public var mediaTagId: String?

        public var mediaTagNameChinese: String?

        public var mediaTagNameEnglish: String?

        public var options: [ListAllPublicMediaTagsResponseBody.MediaTagList.Options]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaTagId != nil {
                map["MediaTagId"] = self.mediaTagId!
            }
            if self.mediaTagNameChinese != nil {
                map["MediaTagNameChinese"] = self.mediaTagNameChinese!
            }
            if self.mediaTagNameEnglish != nil {
                map["MediaTagNameEnglish"] = self.mediaTagNameEnglish!
            }
            if self.options != nil {
                var tmp : [Any] = []
                for k in self.options! {
                    tmp.append(k.toMap())
                }
                map["Options"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaTagId") {
                self.mediaTagId = dict["MediaTagId"] as! String
            }
            if dict.keys.contains("MediaTagNameChinese") {
                self.mediaTagNameChinese = dict["MediaTagNameChinese"] as! String
            }
            if dict.keys.contains("MediaTagNameEnglish") {
                self.mediaTagNameEnglish = dict["MediaTagNameEnglish"] as! String
            }
            if dict.keys.contains("Options") {
                var tmp : [ListAllPublicMediaTagsResponseBody.MediaTagList.Options] = []
                for v in dict["Options"] as! [Any] {
                    var model = ListAllPublicMediaTagsResponseBody.MediaTagList.Options()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.options = tmp
            }
        }
    }
    public var mediaTagList: [ListAllPublicMediaTagsResponseBody.MediaTagList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaTagList != nil {
            var tmp : [Any] = []
            for k in self.mediaTagList! {
                tmp.append(k.toMap())
            }
            map["MediaTagList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaTagList") {
            var tmp : [ListAllPublicMediaTagsResponseBody.MediaTagList] = []
            for v in dict["MediaTagList"] as! [Any] {
                var model = ListAllPublicMediaTagsResponseBody.MediaTagList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaTagList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAllPublicMediaTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllPublicMediaTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAllPublicMediaTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAvatarTrainingJobsRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListAvatarTrainingJobsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AvatarTrainingJobList : Tea.TeaModel {
            public var avatarDescription: String?

            public var avatarId: String?

            public var avatarName: String?

            public var avatarType: String?

            public var createTime: String?

            public var firstTrainingTime: String?

            public var jobId: String?

            public var lastTrainingTime: String?

            public var message: String?

            public var portrait: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarDescription != nil {
                    map["AvatarDescription"] = self.avatarDescription!
                }
                if self.avatarId != nil {
                    map["AvatarId"] = self.avatarId!
                }
                if self.avatarName != nil {
                    map["AvatarName"] = self.avatarName!
                }
                if self.avatarType != nil {
                    map["AvatarType"] = self.avatarType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.firstTrainingTime != nil {
                    map["FirstTrainingTime"] = self.firstTrainingTime!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.lastTrainingTime != nil {
                    map["LastTrainingTime"] = self.lastTrainingTime!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.portrait != nil {
                    map["Portrait"] = self.portrait!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvatarDescription") {
                    self.avatarDescription = dict["AvatarDescription"] as! String
                }
                if dict.keys.contains("AvatarId") {
                    self.avatarId = dict["AvatarId"] as! String
                }
                if dict.keys.contains("AvatarName") {
                    self.avatarName = dict["AvatarName"] as! String
                }
                if dict.keys.contains("AvatarType") {
                    self.avatarType = dict["AvatarType"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FirstTrainingTime") {
                    self.firstTrainingTime = dict["FirstTrainingTime"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("LastTrainingTime") {
                    self.lastTrainingTime = dict["LastTrainingTime"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Portrait") {
                    self.portrait = dict["Portrait"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var avatarTrainingJobList: [ListAvatarTrainingJobsResponseBody.Data.AvatarTrainingJobList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarTrainingJobList != nil {
                var tmp : [Any] = []
                for k in self.avatarTrainingJobList! {
                    tmp.append(k.toMap())
                }
                map["AvatarTrainingJobList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarTrainingJobList") {
                var tmp : [ListAvatarTrainingJobsResponseBody.Data.AvatarTrainingJobList] = []
                for v in dict["AvatarTrainingJobList"] as! [Any] {
                    var model = ListAvatarTrainingJobsResponseBody.Data.AvatarTrainingJobList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.avatarTrainingJobList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: ListAvatarTrainingJobsResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListAvatarTrainingJobsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAvatarTrainingJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAvatarTrainingJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAvatarTrainingJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAvatarsRequest : Tea.TeaModel {
    public var avatarType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarType != nil {
            map["AvatarType"] = self.avatarType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarType") {
            self.avatarType = dict["AvatarType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListAvatarsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AvatarList : Tea.TeaModel {
            public var avatarDescription: String?

            public var avatarId: String?

            public var avatarName: String?

            public var avatarType: String?

            public var portrait: String?

            public var thumbnail: String?

            public var transparent: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarDescription != nil {
                    map["AvatarDescription"] = self.avatarDescription!
                }
                if self.avatarId != nil {
                    map["AvatarId"] = self.avatarId!
                }
                if self.avatarName != nil {
                    map["AvatarName"] = self.avatarName!
                }
                if self.avatarType != nil {
                    map["AvatarType"] = self.avatarType!
                }
                if self.portrait != nil {
                    map["Portrait"] = self.portrait!
                }
                if self.thumbnail != nil {
                    map["Thumbnail"] = self.thumbnail!
                }
                if self.transparent != nil {
                    map["Transparent"] = self.transparent!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvatarDescription") {
                    self.avatarDescription = dict["AvatarDescription"] as! String
                }
                if dict.keys.contains("AvatarId") {
                    self.avatarId = dict["AvatarId"] as! String
                }
                if dict.keys.contains("AvatarName") {
                    self.avatarName = dict["AvatarName"] as! String
                }
                if dict.keys.contains("AvatarType") {
                    self.avatarType = dict["AvatarType"] as! String
                }
                if dict.keys.contains("Portrait") {
                    self.portrait = dict["Portrait"] as! String
                }
                if dict.keys.contains("Thumbnail") {
                    self.thumbnail = dict["Thumbnail"] as! String
                }
                if dict.keys.contains("Transparent") {
                    self.transparent = dict["Transparent"] as! Bool
                }
            }
        }
        public var avatarList: [ListAvatarsResponseBody.Data.AvatarList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarList != nil {
                var tmp : [Any] = []
                for k in self.avatarList! {
                    tmp.append(k.toMap())
                }
                map["AvatarList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarList") {
                var tmp : [ListAvatarsResponseBody.Data.AvatarList] = []
                for v in dict["AvatarList"] as! [Any] {
                    var model = ListAvatarsResponseBody.Data.AvatarList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.avatarList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: ListAvatarsResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListAvatarsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAvatarsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAvatarsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAvatarsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBatchMediaProducingJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var jobId: String?

    public var jobType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListBatchMediaProducingJobsResponseBody : Tea.TeaModel {
    public class EditingBatchJobList : Tea.TeaModel {
        public var completeTime: String?

        public var createTime: String?

        public var editingConfig: String?

        public var extend: String?

        public var inputConfig: String?

        public var jobId: String?

        public var jobType: String?

        public var modifiedTime: String?

        public var outputConfig: String?

        public var status: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.editingConfig != nil {
                map["EditingConfig"] = self.editingConfig!
            }
            if self.extend != nil {
                map["Extend"] = self.extend!
            }
            if self.inputConfig != nil {
                map["InputConfig"] = self.inputConfig!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputConfig != nil {
                map["OutputConfig"] = self.outputConfig!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EditingConfig") {
                self.editingConfig = dict["EditingConfig"] as! String
            }
            if dict.keys.contains("Extend") {
                self.extend = dict["Extend"] as! String
            }
            if dict.keys.contains("InputConfig") {
                self.inputConfig = dict["InputConfig"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputConfig") {
                self.outputConfig = dict["OutputConfig"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var editingBatchJobList: [ListBatchMediaProducingJobsResponseBody.EditingBatchJobList]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.editingBatchJobList != nil {
            var tmp : [Any] = []
            for k in self.editingBatchJobList! {
                tmp.append(k.toMap())
            }
            map["EditingBatchJobList"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EditingBatchJobList") {
            var tmp : [ListBatchMediaProducingJobsResponseBody.EditingBatchJobList] = []
            for v in dict["EditingBatchJobList"] as! [Any] {
                var model = ListBatchMediaProducingJobsResponseBody.EditingBatchJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.editingBatchJobList = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListBatchMediaProducingJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBatchMediaProducingJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListBatchMediaProducingJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomTemplatesRequest : Tea.TeaModel {
    public var name: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var subtype: String?

    public var templateId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Subtype") {
            self.subtype = dict["Subtype"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListCustomTemplatesResponseBody : Tea.TeaModel {
    public class CustomTemplateList : Tea.TeaModel {
        public var createTime: String?

        public var isDefault: Bool?

        public var modifiedTime: String?

        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var customTemplateList: [ListCustomTemplatesResponseBody.CustomTemplateList]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplateList != nil {
            var tmp : [Any] = []
            for k in self.customTemplateList! {
                tmp.append(k.toMap())
            }
            map["CustomTemplateList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplateList") {
            var tmp : [ListCustomTemplatesResponseBody.CustomTemplateList] = []
            for v in dict["CustomTemplateList"] as! [Any] {
                var model = ListCustomTemplatesResponseBody.CustomTemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customTemplateList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListCustomTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCustomTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomizedVoiceJobsRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListCustomizedVoiceJobsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CustomizedVoiceJobList : Tea.TeaModel {
            public var createTime: String?

            public var gender: String?

            public var gmtCreate: String?

            public var jobId: String?

            public var message: String?

            public var scenario: String?

            public var status: String?

            public var type: String?

            public var voiceDesc: String?

            public var voiceId: String?

            public var voiceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.gender != nil {
                    map["Gender"] = self.gender!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.scenario != nil {
                    map["Scenario"] = self.scenario!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.voiceDesc != nil {
                    map["VoiceDesc"] = self.voiceDesc!
                }
                if self.voiceId != nil {
                    map["VoiceId"] = self.voiceId!
                }
                if self.voiceName != nil {
                    map["VoiceName"] = self.voiceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Gender") {
                    self.gender = dict["Gender"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Scenario") {
                    self.scenario = dict["Scenario"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VoiceDesc") {
                    self.voiceDesc = dict["VoiceDesc"] as! String
                }
                if dict.keys.contains("VoiceId") {
                    self.voiceId = dict["VoiceId"] as! String
                }
                if dict.keys.contains("VoiceName") {
                    self.voiceName = dict["VoiceName"] as! String
                }
            }
        }
        public var customizedVoiceJobList: [ListCustomizedVoiceJobsResponseBody.Data.CustomizedVoiceJobList]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customizedVoiceJobList != nil {
                var tmp : [Any] = []
                for k in self.customizedVoiceJobList! {
                    tmp.append(k.toMap())
                }
                map["CustomizedVoiceJobList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomizedVoiceJobList") {
                var tmp : [ListCustomizedVoiceJobsResponseBody.Data.CustomizedVoiceJobList] = []
                for v in dict["CustomizedVoiceJobList"] as! [Any] {
                    var model = ListCustomizedVoiceJobsResponseBody.Data.CustomizedVoiceJobList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customizedVoiceJobList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListCustomizedVoiceJobsResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListCustomizedVoiceJobsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCustomizedVoiceJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomizedVoiceJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCustomizedVoiceJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomizedVoicesRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListCustomizedVoicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CustomizedVoiceList : Tea.TeaModel {
            public var demoAudioMediaId: String?

            public var gender: String?

            public var scenario: String?

            public var type: String?

            public var voiceDesc: String?

            public var voiceId: String?

            public var voiceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoAudioMediaId != nil {
                    map["DemoAudioMediaId"] = self.demoAudioMediaId!
                }
                if self.gender != nil {
                    map["Gender"] = self.gender!
                }
                if self.scenario != nil {
                    map["Scenario"] = self.scenario!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.voiceDesc != nil {
                    map["VoiceDesc"] = self.voiceDesc!
                }
                if self.voiceId != nil {
                    map["VoiceId"] = self.voiceId!
                }
                if self.voiceName != nil {
                    map["VoiceName"] = self.voiceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoAudioMediaId") {
                    self.demoAudioMediaId = dict["DemoAudioMediaId"] as! String
                }
                if dict.keys.contains("Gender") {
                    self.gender = dict["Gender"] as! String
                }
                if dict.keys.contains("Scenario") {
                    self.scenario = dict["Scenario"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VoiceDesc") {
                    self.voiceDesc = dict["VoiceDesc"] as! String
                }
                if dict.keys.contains("VoiceId") {
                    self.voiceId = dict["VoiceId"] as! String
                }
                if dict.keys.contains("VoiceName") {
                    self.voiceName = dict["VoiceName"] as! String
                }
            }
        }
        public var customizedVoiceList: [ListCustomizedVoicesResponseBody.Data.CustomizedVoiceList]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customizedVoiceList != nil {
                var tmp : [Any] = []
                for k in self.customizedVoiceList! {
                    tmp.append(k.toMap())
                }
                map["CustomizedVoiceList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomizedVoiceList") {
                var tmp : [ListCustomizedVoicesResponseBody.Data.CustomizedVoiceList] = []
                for v in dict["CustomizedVoiceList"] as! [Any] {
                    var model = ListCustomizedVoicesResponseBody.Data.CustomizedVoiceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customizedVoiceList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListCustomizedVoicesResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListCustomizedVoicesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCustomizedVoicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomizedVoicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCustomizedVoicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDNADBRequest : Tea.TeaModel {
    public var DBIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBIds != nil {
            map["DBIds"] = self.DBIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBIds") {
            self.DBIds = dict["DBIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListDNADBResponseBody : Tea.TeaModel {
    public class DBList : Tea.TeaModel {
        public var DBId: String?

        public var description_: String?

        public var model: Int32?

        public var name: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBId != nil {
                map["DBId"] = self.DBId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.model != nil {
                map["Model"] = self.model!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DBId") {
                self.DBId = dict["DBId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Model") {
                self.model = dict["Model"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var DBList: [ListDNADBResponseBody.DBList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBList != nil {
            var tmp : [Any] = []
            for k in self.DBList! {
                tmp.append(k.toMap())
            }
            map["DBList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBList") {
            var tmp : [ListDNADBResponseBody.DBList] = []
            for v in dict["DBList"] as! [Any] {
                var model = ListDNADBResponseBody.DBList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.DBList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDNADBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDNADBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDNADBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDNAFilesRequest : Tea.TeaModel {
    public var DBId: String?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBId") {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListDNAFilesResponseBody : Tea.TeaModel {
    public class FileList : Tea.TeaModel {
        public class InputFile : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public var inputFile: ListDNAFilesResponseBody.FileList.InputFile?

        public var primaryKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inputFile?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputFile != nil {
                map["InputFile"] = self.inputFile?.toMap()
            }
            if self.primaryKey != nil {
                map["PrimaryKey"] = self.primaryKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputFile") {
                var model = ListDNAFilesResponseBody.FileList.InputFile()
                model.fromMap(dict["InputFile"] as! [String: Any])
                self.inputFile = model
            }
            if dict.keys.contains("PrimaryKey") {
                self.primaryKey = dict["PrimaryKey"] as! String
            }
        }
    }
    public var fileList: [ListDNAFilesResponseBody.FileList]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileList != nil {
            var tmp : [Any] = []
            for k in self.fileList! {
                tmp.append(k.toMap())
            }
            map["FileList"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileList") {
            var tmp : [ListDNAFilesResponseBody.FileList] = []
            for v in dict["FileList"] as! [Any] {
                var model = ListDNAFilesResponseBody.FileList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fileList = tmp
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDNAFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDNAFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDNAFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDynamicImageJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListDynamicImageJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var input: ListDynamicImageJobsResponseBody.Jobs.Input?

        public var jobId: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: ListDynamicImageJobsResponseBody.Jobs.Output?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateId: String?

        public var triggerSource: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = ListDynamicImageJobsResponseBody.Jobs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = ListDynamicImageJobsResponseBody.Jobs.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
        }
    }
    public var jobs: [ListDynamicImageJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            var tmp : [ListDynamicImageJobsResponseBody.Jobs] = []
            for v in dict["Jobs"] as! [Any] {
                var model = ListDynamicImageJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDynamicImageJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDynamicImageJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDynamicImageJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordFilesRequest : Tea.TeaModel {
    public var endTime: String?

    public var jobIds: [String]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var recordFormat: String?

    public var sortBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordFormat != nil {
            map["RecordFormat"] = self.recordFormat!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! [String]
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecordFormat") {
            self.recordFormat = dict["RecordFormat"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListLiveRecordFilesResponseBody : Tea.TeaModel {
    public class Files : Tea.TeaModel {
        public var createTime: String?

        public var duration: Double?

        public var endTime: String?

        public var format: String?

        public var height: Int32?

        public var jobId: String?

        public var jobName: String?

        public var recordId: String?

        public var recordOutput: String?

        public var recordUrl: String?

        public var startTime: String?

        public var streamUrl: String?

        public var width: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.recordOutput != nil {
                map["RecordOutput"] = self.recordOutput!
            }
            if self.recordUrl != nil {
                map["RecordUrl"] = self.recordUrl!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.streamUrl != nil {
                map["StreamUrl"] = self.streamUrl!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobName") {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("RecordOutput") {
                self.recordOutput = dict["RecordOutput"] as! String
            }
            if dict.keys.contains("RecordUrl") {
                self.recordUrl = dict["RecordUrl"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("StreamUrl") {
                self.streamUrl = dict["StreamUrl"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int32
            }
        }
    }
    public var files: [ListLiveRecordFilesResponseBody.Files]?

    public var pageNo: Int64?

    public var pageSize: String?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.files != nil {
            var tmp : [Any] = []
            for k in self.files! {
                tmp.append(k.toMap())
            }
            map["Files"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Files") {
            var tmp : [ListLiveRecordFilesResponseBody.Files] = []
            for v in dict["Files"] as! [Any] {
                var model = ListLiveRecordFilesResponseBody.Files()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.files = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListLiveRecordFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRecordFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListLiveRecordJobsResponseBody : Tea.TeaModel {
    public class LiveRecordJobs : Tea.TeaModel {
        public class RecordOutput : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var notifyUrl: String?

        public var recordOutput: ListLiveRecordJobsResponseBody.LiveRecordJobs.RecordOutput?

        public var status: String?

        public var streamInput: ListLiveRecordJobsResponseBody.LiveRecordJobs.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordOutput?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            if self.recordOutput != nil {
                map["RecordOutput"] = self.recordOutput?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyUrl") {
                self.notifyUrl = dict["NotifyUrl"] as! String
            }
            if dict.keys.contains("RecordOutput") {
                var model = ListLiveRecordJobsResponseBody.LiveRecordJobs.RecordOutput()
                model.fromMap(dict["RecordOutput"] as! [String: Any])
                self.recordOutput = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StreamInput") {
                var model = ListLiveRecordJobsResponseBody.LiveRecordJobs.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var liveRecordJobs: [ListLiveRecordJobsResponseBody.LiveRecordJobs]?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveRecordJobs != nil {
            var tmp : [Any] = []
            for k in self.liveRecordJobs! {
                tmp.append(k.toMap())
            }
            map["LiveRecordJobs"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveRecordJobs") {
            var tmp : [ListLiveRecordJobsResponseBody.LiveRecordJobs] = []
            for v in dict["LiveRecordJobs"] as! [Any] {
                var model = ListLiveRecordJobsResponseBody.LiveRecordJobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.liveRecordJobs = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveRecordJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRecordJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordTemplatesRequest : Tea.TeaModel {
    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var templateIds: [String]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TemplateIds") {
            self.templateIds = dict["TemplateIds"] as! [String]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListLiveRecordTemplatesResponseBody : Tea.TeaModel {
    public class RecordTemplateList : Tea.TeaModel {
        public class RecordFormatList : Tea.TeaModel {
            public var cycleDuration: Int32?

            public var format: String?

            public var ossObjectPrefix: String?

            public var sliceDuration: Int32?

            public var sliceOssObjectPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleDuration != nil {
                    map["CycleDuration"] = self.cycleDuration!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.ossObjectPrefix != nil {
                    map["OssObjectPrefix"] = self.ossObjectPrefix!
                }
                if self.sliceDuration != nil {
                    map["SliceDuration"] = self.sliceDuration!
                }
                if self.sliceOssObjectPrefix != nil {
                    map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CycleDuration") {
                    self.cycleDuration = dict["CycleDuration"] as! Int32
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("OssObjectPrefix") {
                    self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
                }
                if dict.keys.contains("SliceDuration") {
                    self.sliceDuration = dict["SliceDuration"] as! Int32
                }
                if dict.keys.contains("SliceOssObjectPrefix") {
                    self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
                }
            }
        }
        public var createTime: String?

        public var lastModified: String?

        public var name: String?

        public var recordFormatList: [ListLiveRecordTemplatesResponseBody.RecordTemplateList.RecordFormatList]?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordFormatList != nil {
                var tmp : [Any] = []
                for k in self.recordFormatList! {
                    tmp.append(k.toMap())
                }
                map["RecordFormatList"] = tmp
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordFormatList") {
                var tmp : [ListLiveRecordTemplatesResponseBody.RecordTemplateList.RecordFormatList] = []
                for v in dict["RecordFormatList"] as! [Any] {
                    var model = ListLiveRecordTemplatesResponseBody.RecordTemplateList.RecordFormatList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recordFormatList = tmp
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var recordTemplateList: [ListLiveRecordTemplatesResponseBody.RecordTemplateList]?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordTemplateList != nil {
            var tmp : [Any] = []
            for k in self.recordTemplateList! {
                tmp.append(k.toMap())
            }
            map["RecordTemplateList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RecordTemplateList") {
            var tmp : [ListLiveRecordTemplatesResponseBody.RecordTemplateList] = []
            for v in dict["RecordTemplateList"] as! [Any] {
                var model = ListLiveRecordTemplatesResponseBody.RecordTemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordTemplateList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveRecordTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRecordTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveSnapshotFilesRequest : Tea.TeaModel {
    public var endTime: String?

    public var jobId: String?

    public var limit: Int32?

    public var sortBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListLiveSnapshotFilesResponseBody : Tea.TeaModel {
    public class FileList : Tea.TeaModel {
        public var createTime: String?

        public var createTimestamp: Int64?

        public var isOverlay: Bool?

        public var ossBucket: String?

        public var ossEndpoint: String?

        public var ossObject: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.isOverlay != nil {
                map["IsOverlay"] = self.isOverlay!
            }
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossEndpoint != nil {
                map["OssEndpoint"] = self.ossEndpoint!
            }
            if self.ossObject != nil {
                map["OssObject"] = self.ossObject!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("IsOverlay") {
                self.isOverlay = dict["IsOverlay"] as! Bool
            }
            if dict.keys.contains("OssBucket") {
                self.ossBucket = dict["OssBucket"] as! String
            }
            if dict.keys.contains("OssEndpoint") {
                self.ossEndpoint = dict["OssEndpoint"] as! String
            }
            if dict.keys.contains("OssObject") {
                self.ossObject = dict["OssObject"] as! String
            }
        }
    }
    public var fileList: [ListLiveSnapshotFilesResponseBody.FileList]?

    public var nextStartTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileList != nil {
            var tmp : [Any] = []
            for k in self.fileList! {
                tmp.append(k.toMap())
            }
            map["FileList"] = tmp
        }
        if self.nextStartTime != nil {
            map["NextStartTime"] = self.nextStartTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileList") {
            var tmp : [ListLiveSnapshotFilesResponseBody.FileList] = []
            for v in dict["FileList"] as! [Any] {
                var model = ListLiveSnapshotFilesResponseBody.FileList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fileList = tmp
        }
        if dict.keys.contains("NextStartTime") {
            self.nextStartTime = dict["NextStartTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListLiveSnapshotFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveSnapshotFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveSnapshotFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveSnapshotJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchKeyWord: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListLiveSnapshotJobsResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class SnapshotOutput : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var storageType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.storageType != nil {
                    map["StorageType"] = self.storageType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("StorageType") {
                    self.storageType = dict["StorageType"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var jobName: String?

        public var snapshotOutput: ListLiveSnapshotJobsResponseBody.JobList.SnapshotOutput?

        public var status: String?

        public var templateId: String?

        public var templateName: String?

        public var timeInterval: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.snapshotOutput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.snapshotOutput != nil {
                map["SnapshotOutput"] = self.snapshotOutput?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.timeInterval != nil {
                map["TimeInterval"] = self.timeInterval!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobName") {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("SnapshotOutput") {
                var model = ListLiveSnapshotJobsResponseBody.JobList.SnapshotOutput()
                model.fromMap(dict["SnapshotOutput"] as! [String: Any])
                self.snapshotOutput = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TimeInterval") {
                self.timeInterval = dict["TimeInterval"] as! Int32
            }
        }
    }
    public var jobList: [ListLiveSnapshotJobsResponseBody.JobList]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            var tmp : [Any] = []
            for k in self.jobList! {
                tmp.append(k.toMap())
            }
            map["JobList"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            var tmp : [ListLiveSnapshotJobsResponseBody.JobList] = []
            for v in dict["JobList"] as! [Any] {
                var model = ListLiveSnapshotJobsResponseBody.JobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobList = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveSnapshotJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveSnapshotJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveSnapshotJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveSnapshotTemplatesRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchKeyWord: String?

    public var sortBy: String?

    public var templateIds: [String]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TemplateIds") {
            self.templateIds = dict["TemplateIds"] as! [String]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListLiveSnapshotTemplatesResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public var createTime: String?

        public var templateId: String?

        public var templateName: String?

        public var timeInterval: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.timeInterval != nil {
                map["TimeInterval"] = self.timeInterval!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TimeInterval") {
                self.timeInterval = dict["TimeInterval"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sortBy: String?

    public var templateList: [ListLiveSnapshotTemplatesResponseBody.TemplateList]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.templateList != nil {
            var tmp : [Any] = []
            for k in self.templateList! {
                tmp.append(k.toMap())
            }
            map["TemplateList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TemplateList") {
            var tmp : [ListLiveSnapshotTemplatesResponseBody.TemplateList] = []
            for v in dict["TemplateList"] as! [Any] {
                var model = ListLiveSnapshotTemplatesResponseBody.TemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveSnapshotTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveSnapshotTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveSnapshotTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveTranscodeJobsRequest : Tea.TeaModel {
    public var keyWord: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var startMode: Int32?

    public var status: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startMode != nil {
            map["StartMode"] = self.startMode!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartMode") {
            self.startMode = dict["StartMode"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListLiveTranscodeJobsResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class OutputStream : Tea.TeaModel {
            public class StreamInfos : Tea.TeaModel {
                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var streamInfos: [ListLiveTranscodeJobsResponseBody.JobList.OutputStream.StreamInfos]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.streamInfos != nil {
                    var tmp : [Any] = []
                    for k in self.streamInfos! {
                        tmp.append(k.toMap())
                    }
                    map["StreamInfos"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("StreamInfos") {
                    var tmp : [ListLiveTranscodeJobsResponseBody.JobList.OutputStream.StreamInfos] = []
                    for v in dict["StreamInfos"] as! [Any] {
                        var model = ListLiveTranscodeJobsResponseBody.JobList.OutputStream.StreamInfos()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.streamInfos = tmp
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var inputUrl: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputUrl") {
                    self.inputUrl = dict["InputUrl"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var outputStream: ListLiveTranscodeJobsResponseBody.JobList.OutputStream?

        public var startMode: Int32?

        public var status: Int32?

        public var streamInput: ListLiveTranscodeJobsResponseBody.JobList.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.outputStream?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputStream != nil {
                map["OutputStream"] = self.outputStream?.toMap()
            }
            if self.startMode != nil {
                map["StartMode"] = self.startMode!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputStream") {
                var model = ListLiveTranscodeJobsResponseBody.JobList.OutputStream()
                model.fromMap(dict["OutputStream"] as! [String: Any])
                self.outputStream = model
            }
            if dict.keys.contains("StartMode") {
                self.startMode = dict["StartMode"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StreamInput") {
                var model = ListLiveTranscodeJobsResponseBody.JobList.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var jobList: [ListLiveTranscodeJobsResponseBody.JobList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            var tmp : [Any] = []
            for k in self.jobList! {
                tmp.append(k.toMap())
            }
            map["JobList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            var tmp : [ListLiveTranscodeJobsResponseBody.JobList] = []
            for v in dict["JobList"] as! [Any] {
                var model = ListLiveTranscodeJobsResponseBody.JobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListLiveTranscodeJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveTranscodeJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveTranscodeJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveTranscodeTemplatesRequest : Tea.TeaModel {
    public var category: String?

    public var keyWord: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var type: String?

    public var videoCodec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.videoCodec != nil {
            map["VideoCodec"] = self.videoCodec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VideoCodec") {
            self.videoCodec = dict["VideoCodec"] as! String
        }
    }
}

public class ListLiveTranscodeTemplatesResponseBody : Tea.TeaModel {
    public class TemplateContentList : Tea.TeaModel {
        public class TemplateConfig : Tea.TeaModel {
            public class AudioParams : Tea.TeaModel {
                public var bitrate: String?

                public var channels: String?

                public var codec: String?

                public var profile: String?

                public var samplerate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.samplerate != nil {
                        map["Samplerate"] = self.samplerate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Samplerate") {
                        self.samplerate = dict["Samplerate"] as! String
                    }
                }
            }
            public class VideoParams : Tea.TeaModel {
                public var bitrate: String?

                public var codec: String?

                public var fps: String?

                public var gop: String?

                public var height: String?

                public var profile: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Gop") {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioParams: ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.AudioParams?

            public var videoParams: ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.VideoParams?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioParams?.validate()
                try self.videoParams?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioParams != nil {
                    map["AudioParams"] = self.audioParams?.toMap()
                }
                if self.videoParams != nil {
                    map["VideoParams"] = self.videoParams?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioParams") {
                    var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.AudioParams()
                    model.fromMap(dict["AudioParams"] as! [String: Any])
                    self.audioParams = model
                }
                if dict.keys.contains("VideoParams") {
                    var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.VideoParams()
                    model.fromMap(dict["VideoParams"] as! [String: Any])
                    self.videoParams = model
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var name: String?

        public var templateConfig: ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.templateConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig()
                model.fromMap(dict["TemplateConfig"] as! [String: Any])
                self.templateConfig = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateContentList: [ListLiveTranscodeTemplatesResponseBody.TemplateContentList]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateContentList != nil {
            var tmp : [Any] = []
            for k in self.templateContentList! {
                tmp.append(k.toMap())
            }
            map["TemplateContentList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateContentList") {
            var tmp : [ListLiveTranscodeTemplatesResponseBody.TemplateContentList] = []
            for v in dict["TemplateContentList"] as! [Any] {
                var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateContentList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListLiveTranscodeTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveTranscodeTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveTranscodeTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaBasicInfosRequest : Tea.TeaModel {
    public var businessType: String?

    public var endTime: String?

    public var includeFileBasicInfo: Bool?

    public var maxResults: Int32?

    public var mediaId: String?

    public var mediaType: String?

    public var nextToken: String?

    public var sortBy: String?

    public var source: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.includeFileBasicInfo != nil {
            map["IncludeFileBasicInfo"] = self.includeFileBasicInfo!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IncludeFileBasicInfo") {
            self.includeFileBasicInfo = dict["IncludeFileBasicInfo"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListMediaBasicInfosResponseBody : Tea.TeaModel {
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var createTime: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var modifiedTime: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var cateId: Int64?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var referenceId: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var uploadSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.uploadSource != nil {
                    map["UploadSource"] = self.uploadSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UploadSource") {
                    self.uploadSource = dict["UploadSource"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: ListMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                var tmp : [ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = ListMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var mediaInfos: [ListMediaBasicInfosResponseBody.MediaInfos]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaInfos") {
            var tmp : [ListMediaBasicInfosResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = ListMediaBasicInfosResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListMediaBasicInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaBasicInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaBasicInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaInfoJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListMediaInfoJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    var tmp : [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    var tmp : [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: ListMediaInfoJobsResponseBody.Jobs.Input?

        public var jobId: String?

        public var mediaInfoProperty: ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: ListMediaInfoJobsResponseBody.Jobs.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = ListMediaInfoJobsResponseBody.Jobs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") {
                var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = ListMediaInfoJobsResponseBody.Jobs.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var jobs: [ListMediaInfoJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            var tmp : [ListMediaInfoJobsResponseBody.Jobs] = []
            for v in dict["Jobs"] as! [Any] {
                var model = ListMediaInfoJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaInfoJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaInfoJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaInfoJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
    }
}

public class ListMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaProducingJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var jobType: String?

    public var keyword: String?

    public var masterJobId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.masterJobId != nil {
            map["MasterJobId"] = self.masterJobId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("MasterJobId") {
            self.masterJobId = dict["MasterJobId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListMediaProducingJobsResponseBody : Tea.TeaModel {
    public class MediaProducingJobList : Tea.TeaModel {
        public var clipsParam: String?

        public var code: String?

        public var completeTime: String?

        public var createTime: String?

        public var duration: Double?

        public var jobId: String?

        public var mediaId: String?

        public var mediaURL: String?

        public var message: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var status: String?

        public var templateId: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaURL != nil {
                map["MediaURL"] = self.mediaURL!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaURL") {
                self.mediaURL = dict["MediaURL"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var maxResults: String?

    public var mediaProducingJobList: [ListMediaProducingJobsResponseBody.MediaProducingJobList]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaProducingJobList != nil {
            var tmp : [Any] = []
            for k in self.mediaProducingJobList! {
                tmp.append(k.toMap())
            }
            map["MediaProducingJobList"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! String
        }
        if dict.keys.contains("MediaProducingJobList") {
            var tmp : [ListMediaProducingJobsResponseBody.MediaProducingJobList] = []
            for v in dict["MediaProducingJobList"] as! [Any] {
                var model = ListMediaProducingJobsResponseBody.MediaProducingJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaProducingJobList = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaProducingJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaProducingJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaProducingJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPackageJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListPackageJobsResponseBody : Tea.TeaModel {
    public class PackageJobList : Tea.TeaModel {
        public class PackageJobs : Tea.TeaModel {
            public class Inputs : Tea.TeaModel {
                public class Input : Tea.TeaModel {
                    public var media: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.media != nil {
                            map["Media"] = self.media!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Media") {
                            self.media = dict["Media"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var input: ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs.Input?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.input?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.input != nil {
                        map["Input"] = self.input?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Input") {
                        var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs.Input()
                        model.fromMap(dict["Input"] as! [String: Any])
                        self.input = model
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var code: String?

            public var createTime: String?

            public var finishTime: String?

            public var inputs: [ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs]?

            public var jobId: String?

            public var message: String?

            public var modifiedTime: String?

            public var name: String?

            public var output: ListPackageJobsResponseBody.PackageJobList.PackageJobs.Output?

            public var pipelineId: String?

            public var priority: Int32?

            public var status: String?

            public var submitTime: String?

            public var triggerSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inputs != nil {
                    var tmp : [Any] = []
                    for k in self.inputs! {
                        tmp.append(k.toMap())
                    }
                    map["Inputs"] = tmp
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.triggerSource != nil {
                    map["TriggerSource"] = self.triggerSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Inputs") {
                    var tmp : [ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs] = []
                    for v in dict["Inputs"] as! [Any] {
                        var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputs = tmp
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Output") {
                    var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitTime") {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("TriggerSource") {
                    self.triggerSource = dict["TriggerSource"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var nextPageToken: String?

        public var packageJobs: [ListPackageJobsResponseBody.PackageJobList.PackageJobs]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextPageToken != nil {
                map["NextPageToken"] = self.nextPageToken!
            }
            if self.packageJobs != nil {
                var tmp : [Any] = []
                for k in self.packageJobs! {
                    tmp.append(k.toMap())
                }
                map["PackageJobs"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextPageToken") {
                self.nextPageToken = dict["NextPageToken"] as! String
            }
            if dict.keys.contains("PackageJobs") {
                var tmp : [ListPackageJobsResponseBody.PackageJobList.PackageJobs] = []
                for v in dict["PackageJobs"] as! [Any] {
                    var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.packageJobs = tmp
            }
        }
    }
    public var packageJobList: ListPackageJobsResponseBody.PackageJobList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packageJobList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packageJobList != nil {
            map["PackageJobList"] = self.packageJobList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackageJobList") {
            var model = ListPackageJobsResponseBody.PackageJobList()
            model.fromMap(dict["PackageJobList"] as! [String: Any])
            self.packageJobList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPackageJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPackageJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPackageJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelinesRequest : Tea.TeaModel {
    public var speed: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.speed != nil {
            map["Speed"] = self.speed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Speed") {
            self.speed = dict["Speed"] as! String
        }
    }
}

public class ListPipelinesResponseBody : Tea.TeaModel {
    public class PipelineList : Tea.TeaModel {
        public var createTime: String?

        public var modifiedTime: String?

        public var name: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var speed: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipelineList: [ListPipelinesResponseBody.PipelineList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineList != nil {
            var tmp : [Any] = []
            for k in self.pipelineList! {
                tmp.append(k.toMap())
            }
            map["PipelineList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineList") {
            var tmp : [ListPipelinesResponseBody.PipelineList] = []
            for v in dict["PipelineList"] as! [Any] {
                var model = ListPipelinesResponseBody.PipelineList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.pipelineList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPipelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPublicMediaBasicInfosRequest : Tea.TeaModel {
    public var businessType: String?

    public var includeFileBasicInfo: Bool?

    public var maxResults: Int32?

    public var mediaTagId: String?

    public var nextToken: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.includeFileBasicInfo != nil {
            map["IncludeFileBasicInfo"] = self.includeFileBasicInfo!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaTagId != nil {
            map["MediaTagId"] = self.mediaTagId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("IncludeFileBasicInfo") {
            self.includeFileBasicInfo = dict["IncludeFileBasicInfo"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaTagId") {
            self.mediaTagId = dict["MediaTagId"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListPublicMediaBasicInfosResponseBody : Tea.TeaModel {
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: ListPublicMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                var tmp : [ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = ListPublicMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var mediaInfos: [ListPublicMediaBasicInfosResponseBody.MediaInfos]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaInfos") {
            var tmp : [ListPublicMediaBasicInfosResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = ListPublicMediaBasicInfosResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListPublicMediaBasicInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPublicMediaBasicInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPublicMediaBasicInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSmartJobsRequest : Tea.TeaModel {
    public var jobState: String?

    public var jobType: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobState != nil {
            map["JobState"] = self.jobState!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobState") {
            self.jobState = dict["JobState"] as! String
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class ListSmartJobsResponseBody : Tea.TeaModel {
    public class SmartJobList : Tea.TeaModel {
        public class InputConfig : Tea.TeaModel {
            public var inputFile: String?

            public var keyword: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputFile != nil {
                    map["InputFile"] = self.inputFile!
                }
                if self.keyword != nil {
                    map["Keyword"] = self.keyword!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputFile") {
                    self.inputFile = dict["InputFile"] as! String
                }
                if dict.keys.contains("Keyword") {
                    self.keyword = dict["Keyword"] as! String
                }
            }
        }
        public class OutputConfig : Tea.TeaModel {
            public var bucket: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public var createTime: String?

        public var description_: String?

        public var editingConfig: String?

        public var inputConfig: ListSmartJobsResponseBody.SmartJobList.InputConfig?

        public var jobId: String?

        public var jobState: String?

        public var jobType: String?

        public var modifiedTime: String?

        public var outputConfig: ListSmartJobsResponseBody.SmartJobList.OutputConfig?

        public var title: String?

        public var userData: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inputConfig?.validate()
            try self.outputConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.editingConfig != nil {
                map["EditingConfig"] = self.editingConfig!
            }
            if self.inputConfig != nil {
                map["InputConfig"] = self.inputConfig?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobState != nil {
                map["JobState"] = self.jobState!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputConfig != nil {
                map["OutputConfig"] = self.outputConfig?.toMap()
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EditingConfig") {
                self.editingConfig = dict["EditingConfig"] as! String
            }
            if dict.keys.contains("InputConfig") {
                var model = ListSmartJobsResponseBody.SmartJobList.InputConfig()
                model.fromMap(dict["InputConfig"] as! [String: Any])
                self.inputConfig = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobState") {
                self.jobState = dict["JobState"] as! String
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputConfig") {
                var model = ListSmartJobsResponseBody.SmartJobList.OutputConfig()
                model.fromMap(dict["OutputConfig"] as! [String: Any])
                self.outputConfig = model
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var maxResults: String?

    public var nextToken: String?

    public var requestId: String?

    public var smartJobList: [ListSmartJobsResponseBody.SmartJobList]?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.smartJobList != nil {
            var tmp : [Any] = []
            for k in self.smartJobList! {
                tmp.append(k.toMap())
            }
            map["SmartJobList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SmartJobList") {
            var tmp : [ListSmartJobsResponseBody.SmartJobList] = []
            for v in dict["SmartJobList"] as! [Any] {
                var model = ListSmartJobsResponseBody.SmartJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.smartJobList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListSmartJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSmartJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSmartJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSmartSysAvatarModelsRequest : Tea.TeaModel {
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sdkVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sdkVersion != nil {
            map["SdkVersion"] = self.sdkVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SdkVersion") {
            self.sdkVersion = dict["SdkVersion"] as! String
        }
    }
}

public class ListSmartSysAvatarModelsResponseBody : Tea.TeaModel {
    public class SmartSysAvatarModelList : Tea.TeaModel {
        public var avatarId: String?

        public var avatarName: String?

        public var bitrate: Int32?

        public var coverUrl: String?

        public var height: Int32?

        public var outputMask: Bool?

        public var videoUrl: String?

        public var width: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarId != nil {
                map["AvatarId"] = self.avatarId!
            }
            if self.avatarName != nil {
                map["AvatarName"] = self.avatarName!
            }
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.outputMask != nil {
                map["OutputMask"] = self.outputMask!
            }
            if self.videoUrl != nil {
                map["VideoUrl"] = self.videoUrl!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarId") {
                self.avatarId = dict["AvatarId"] as! String
            }
            if dict.keys.contains("AvatarName") {
                self.avatarName = dict["AvatarName"] as! String
            }
            if dict.keys.contains("Bitrate") {
                self.bitrate = dict["Bitrate"] as! Int32
            }
            if dict.keys.contains("CoverUrl") {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("OutputMask") {
                self.outputMask = dict["OutputMask"] as! Bool
            }
            if dict.keys.contains("VideoUrl") {
                self.videoUrl = dict["VideoUrl"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var smartSysAvatarModelList: [ListSmartSysAvatarModelsResponseBody.SmartSysAvatarModelList]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.smartSysAvatarModelList != nil {
            var tmp : [Any] = []
            for k in self.smartSysAvatarModelList! {
                tmp.append(k.toMap())
            }
            map["SmartSysAvatarModelList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SmartSysAvatarModelList") {
            var tmp : [ListSmartSysAvatarModelsResponseBody.SmartSysAvatarModelList] = []
            for v in dict["SmartSysAvatarModelList"] as! [Any] {
                var model = ListSmartSysAvatarModelsResponseBody.SmartSysAvatarModelList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.smartSysAvatarModelList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListSmartSysAvatarModelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSmartSysAvatarModelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSmartSysAvatarModelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSmartVoiceGroupsResponseBody : Tea.TeaModel {
    public class VoiceGroups : Tea.TeaModel {
        public class VoiceList : Tea.TeaModel {
            public var desc: String?

            public var name: String?

            public var remark: String?

            public var tag: String?

            public var voice: String?

            public var voiceType: String?

            public var voiceUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.voice != nil {
                    map["Voice"] = self.voice!
                }
                if self.voiceType != nil {
                    map["VoiceType"] = self.voiceType!
                }
                if self.voiceUrl != nil {
                    map["VoiceUrl"] = self.voiceUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Desc") {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Voice") {
                    self.voice = dict["Voice"] as! String
                }
                if dict.keys.contains("VoiceType") {
                    self.voiceType = dict["VoiceType"] as! String
                }
                if dict.keys.contains("VoiceUrl") {
                    self.voiceUrl = dict["VoiceUrl"] as! String
                }
            }
        }
        public var type: String?

        public var voiceList: [ListSmartVoiceGroupsResponseBody.VoiceGroups.VoiceList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.voiceList != nil {
                var tmp : [Any] = []
                for k in self.voiceList! {
                    tmp.append(k.toMap())
                }
                map["VoiceList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("VoiceList") {
                var tmp : [ListSmartVoiceGroupsResponseBody.VoiceGroups.VoiceList] = []
                for v in dict["VoiceList"] as! [Any] {
                    var model = ListSmartVoiceGroupsResponseBody.VoiceGroups.VoiceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.voiceList = tmp
            }
        }
    }
    public var requestId: String?

    public var voiceGroups: [ListSmartVoiceGroupsResponseBody.VoiceGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.voiceGroups != nil {
            var tmp : [Any] = []
            for k in self.voiceGroups! {
                tmp.append(k.toMap())
            }
            map["VoiceGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VoiceGroups") {
            var tmp : [ListSmartVoiceGroupsResponseBody.VoiceGroups] = []
            for v in dict["VoiceGroups"] as! [Any] {
                var model = ListSmartVoiceGroupsResponseBody.VoiceGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.voiceGroups = tmp
        }
    }
}

public class ListSmartVoiceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSmartVoiceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSmartVoiceGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSnapshotJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListSnapshotJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var async: Bool?

        public var count: Int32?

        public var createTime: String?

        public var finishTime: String?

        public var input: ListSnapshotJobsResponseBody.Jobs.Input?

        public var jobId: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: ListSnapshotJobsResponseBody.Jobs.Output?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateId: String?

        public var triggerSource: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = ListSnapshotJobsResponseBody.Jobs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = ListSnapshotJobsResponseBody.Jobs.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var jobs: [ListSnapshotJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            var tmp : [ListSnapshotJobsResponseBody.Jobs] = []
            for v in dict["Jobs"] as! [Any] {
                var model = ListSnapshotJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSnapshotJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSnapshotJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSnapshotJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSystemTemplatesRequest : Tea.TeaModel {
    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var subtype: String?

    public var templateId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Subtype") {
            self.subtype = dict["Subtype"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListSystemTemplatesResponseBody : Tea.TeaModel {
    public class SystemTemplateList : Tea.TeaModel {
        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var requestId: String?

    public var systemTemplateList: [ListSystemTemplatesResponseBody.SystemTemplateList]?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemTemplateList != nil {
            var tmp : [Any] = []
            for k in self.systemTemplateList! {
                tmp.append(k.toMap())
            }
            map["SystemTemplateList"] = tmp
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemTemplateList") {
            var tmp : [ListSystemTemplatesResponseBody.SystemTemplateList] = []
            for v in dict["SystemTemplateList"] as! [Any] {
                var model = ListSystemTemplatesResponseBody.SystemTemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.systemTemplateList = tmp
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListSystemTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSystemTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSystemTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTemplatesRequest : Tea.TeaModel {
    public var createSource: String?

    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortType: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createSource != nil {
            map["CreateSource"] = self.createSource!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateSource") {
            self.createSource = dict["CreateSource"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortType") {
            self.sortType = dict["SortType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListTemplatesResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public var clipsParam: String?

        public var config: String?

        public var coverURL: String?

        public var createSource: String?

        public var creationTime: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var name: String?

        public var previewMedia: String?

        public var previewMediaStatus: String?

        public var status: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.previewMedia != nil {
                map["PreviewMedia"] = self.previewMedia!
            }
            if self.previewMediaStatus != nil {
                map["PreviewMediaStatus"] = self.previewMediaStatus!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PreviewMedia") {
                self.previewMedia = dict["PreviewMedia"] as! String
            }
            if dict.keys.contains("PreviewMediaStatus") {
                self.previewMediaStatus = dict["PreviewMediaStatus"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var templates: [ListTemplatesResponseBody.Templates]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templates != nil {
            var tmp : [Any] = []
            for k in self.templates! {
                tmp.append(k.toMap())
            }
            map["Templates"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Templates") {
            var tmp : [ListTemplatesResponseBody.Templates] = []
            for v in dict["Templates"] as! [Any] {
                var model = ListTemplatesResponseBody.Templates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templates = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTranscodeJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var parentJobId: String?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentJobId != nil {
            map["ParentJobId"] = self.parentJobId!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ParentJobId") {
            self.parentJobId = dict["ParentJobId"] as! String
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListTranscodeJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class InputGroup : Tea.TeaModel {
            public var inputUrl: String?

            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputUrl") {
                    self.inputUrl = dict["InputUrl"] as! String
                }
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class OutputGroup : Tea.TeaModel {
            public class Output : Tea.TeaModel {
                public var media: String?

                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var tags: [String: String]?

                        public var video: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.tags != nil {
                                map["Tags"] = self.tags!
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Tags") {
                                self.tags = dict["Tags"] as! [String: String]
                            }
                            if dict.keys.contains("Video") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.CombineConfigs]?

                public var encryption: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Encryption?

                public var imageWatermarks: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks]?

                public var isInheritTags: Bool?

                public var subtitles: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles]?

                public var textWatermarks: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks]?

                public var transcode: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.isInheritTags != nil {
                        map["IsInheritTags"] = self.isInheritTags!
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") {
                        var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("IsInheritTags") {
                        self.isInheritTags = dict["IsInheritTags"] as! Bool
                    }
                    if dict.keys.contains("Subtitles") {
                        var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") {
                        var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") {
                        var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public var output: ListTranscodeJobsResponseBody.Jobs.OutputGroup.Output?

            public var processConfig: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
                try self.processConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Output") {
                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var inputGroup: [ListTranscodeJobsResponseBody.Jobs.InputGroup]?

        public var jobCount: Int32?

        public var name: String?

        public var outputGroup: [ListTranscodeJobsResponseBody.Jobs.OutputGroup]?

        public var parentJobId: String?

        public var percent: Int32?

        public var requestId: String?

        public var scheduleConfig: ListTranscodeJobsResponseBody.Jobs.ScheduleConfig?

        public var status: String?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputGroup != nil {
                var tmp : [Any] = []
                for k in self.inputGroup! {
                    tmp.append(k.toMap())
                }
                map["InputGroup"] = tmp
            }
            if self.jobCount != nil {
                map["JobCount"] = self.jobCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroup != nil {
                var tmp : [Any] = []
                for k in self.outputGroup! {
                    tmp.append(k.toMap())
                }
                map["OutputGroup"] = tmp
            }
            if self.parentJobId != nil {
                map["ParentJobId"] = self.parentJobId!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("InputGroup") {
                var tmp : [ListTranscodeJobsResponseBody.Jobs.InputGroup] = []
                for v in dict["InputGroup"] as! [Any] {
                    var model = ListTranscodeJobsResponseBody.Jobs.InputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputGroup = tmp
            }
            if dict.keys.contains("JobCount") {
                self.jobCount = dict["JobCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroup") {
                var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup] = []
                for v in dict["OutputGroup"] as! [Any] {
                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroup = tmp
            }
            if dict.keys.contains("ParentJobId") {
                self.parentJobId = dict["ParentJobId"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = ListTranscodeJobsResponseBody.Jobs.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var jobs: [ListTranscodeJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            var tmp : [ListTranscodeJobsResponseBody.Jobs] = []
            for v in dict["Jobs"] as! [Any] {
                var model = ListTranscodeJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTranscodeJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTranscodeJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTranscodeJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryDNAJobListRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryDNAJobListResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var code: String?

        public var config: String?

        public var creationTime: String?

        public var DBId: String?

        public var DNAResult: String?

        public var finishTime: String?

        public var id: String?

        public var input: QueryDNAJobListResponseBody.JobList.Input?

        public var message: String?

        public var primaryKey: String?

        public var status: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.DBId != nil {
                map["DBId"] = self.DBId!
            }
            if self.DNAResult != nil {
                map["DNAResult"] = self.DNAResult!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.primaryKey != nil {
                map["PrimaryKey"] = self.primaryKey!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DBId") {
                self.DBId = dict["DBId"] as! String
            }
            if dict.keys.contains("DNAResult") {
                self.DNAResult = dict["DNAResult"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Input") {
                var model = QueryDNAJobListResponseBody.JobList.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PrimaryKey") {
                self.primaryKey = dict["PrimaryKey"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var jobList: [QueryDNAJobListResponseBody.JobList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            var tmp : [Any] = []
            for k in self.jobList! {
                tmp.append(k.toMap())
            }
            map["JobList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            var tmp : [QueryDNAJobListResponseBody.JobList] = []
            for v in dict["JobList"] as! [Any] {
                var model = QueryDNAJobListResponseBody.JobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryDNAJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDNAJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryDNAJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryIProductionJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class QueryIProductionJobResponseBody : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var createTime: String?

    public var finishTime: String?

    public var functionName: String?

    public var input: QueryIProductionJobResponseBody.Input?

    public var jobId: String?

    public var jobParams: String?

    public var name: String?

    public var output: QueryIProductionJobResponseBody.Output?

    public var outputFiles: [String]?

    public var outputUrls: [String]?

    public var requestId: String?

    public var result: String?

    public var scheduleConfig: QueryIProductionJobResponseBody.ScheduleConfig?

    public var status: String?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.finishTime != nil {
            map["FinishTime"] = self.finishTime!
        }
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.outputFiles != nil {
            map["OutputFiles"] = self.outputFiles!
        }
        if self.outputUrls != nil {
            map["OutputUrls"] = self.outputUrls!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("FinishTime") {
            self.finishTime = dict["FinishTime"] as! String
        }
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") {
            var model = QueryIProductionJobResponseBody.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobParams") {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = QueryIProductionJobResponseBody.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("OutputFiles") {
            self.outputFiles = dict["OutputFiles"] as! [String]
        }
        if dict.keys.contains("OutputUrls") {
            self.outputUrls = dict["OutputUrls"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = QueryIProductionJobResponseBody.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class QueryIProductionJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryIProductionJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryIProductionJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaCensorJobDetailRequest : Tea.TeaModel {
    public var jobId: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaCensorJobDetailResponseBody : Tea.TeaModel {
    public class MediaCensorJobDetail : Tea.TeaModel {
        public class BarrageCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class CoverImageCensorResults : Tea.TeaModel {
            public class CoverImageCensorResult : Tea.TeaModel {
                public class Results : Tea.TeaModel {
                    public class Result : Tea.TeaModel {
                        public var label: String?

                        public var rate: String?

                        public var scene: String?

                        public var suggestion: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.rate != nil {
                                map["Rate"] = self.rate!
                            }
                            if self.scene != nil {
                                map["Scene"] = self.scene!
                            }
                            if self.suggestion != nil {
                                map["Suggestion"] = self.suggestion!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Rate") {
                                self.rate = dict["Rate"] as! String
                            }
                            if dict.keys.contains("Scene") {
                                self.scene = dict["Scene"] as! String
                            }
                            if dict.keys.contains("Suggestion") {
                                self.suggestion = dict["Suggestion"] as! String
                            }
                        }
                    }
                    public var result: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.result != nil {
                            var tmp : [Any] = []
                            for k in self.result! {
                                tmp.append(k.toMap())
                            }
                            map["Result"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Result") {
                            var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result] = []
                            for v in dict["Result"] as! [Any] {
                                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.result = tmp
                        }
                    }
                }
                public var bucket: String?

                public var location: String?

                public var object: String?

                public var results: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.results?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    if self.results != nil {
                        map["Results"] = self.results?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                    if dict.keys.contains("Results") {
                        var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results()
                        model.fromMap(dict["Results"] as! [String: Any])
                        self.results = model
                    }
                }
            }
            public var coverImageCensorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coverImageCensorResult != nil {
                    var tmp : [Any] = []
                    for k in self.coverImageCensorResult! {
                        tmp.append(k.toMap())
                    }
                    map["CoverImageCensorResult"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CoverImageCensorResult") {
                    var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult] = []
                    for v in dict["CoverImageCensorResult"] as! [Any] {
                        var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.coverImageCensorResult = tmp
                }
            }
        }
        public class DescCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class Input : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public class TitleCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class VensorCensorResult : Tea.TeaModel {
            public class CensorResults : Tea.TeaModel {
                public class CensorResult : Tea.TeaModel {
                    public var label: String?

                    public var rate: String?

                    public var scene: String?

                    public var suggestion: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.rate != nil {
                            map["Rate"] = self.rate!
                        }
                        if self.scene != nil {
                            map["Scene"] = self.scene!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Rate") {
                            self.rate = dict["Rate"] as! String
                        }
                        if dict.keys.contains("Scene") {
                            self.scene = dict["Scene"] as! String
                        }
                        if dict.keys.contains("Suggestion") {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                    }
                }
                public var censorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.censorResult != nil {
                        var tmp : [Any] = []
                        for k in self.censorResult! {
                            tmp.append(k.toMap())
                        }
                        map["CensorResult"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CensorResult") {
                        var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult] = []
                        for v in dict["CensorResult"] as! [Any] {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.censorResult = tmp
                    }
                }
            }
            public class VideoTimelines : Tea.TeaModel {
                public class VideoTimeline : Tea.TeaModel {
                    public class CensorResults : Tea.TeaModel {
                        public class CensorResult : Tea.TeaModel {
                            public var label: String?

                            public var rate: String?

                            public var scene: String?

                            public var suggestion: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.label != nil {
                                    map["Label"] = self.label!
                                }
                                if self.rate != nil {
                                    map["Rate"] = self.rate!
                                }
                                if self.scene != nil {
                                    map["Scene"] = self.scene!
                                }
                                if self.suggestion != nil {
                                    map["Suggestion"] = self.suggestion!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Label") {
                                    self.label = dict["Label"] as! String
                                }
                                if dict.keys.contains("Rate") {
                                    self.rate = dict["Rate"] as! String
                                }
                                if dict.keys.contains("Scene") {
                                    self.scene = dict["Scene"] as! String
                                }
                                if dict.keys.contains("Suggestion") {
                                    self.suggestion = dict["Suggestion"] as! String
                                }
                            }
                        }
                        public var censorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.censorResult != nil {
                                var tmp : [Any] = []
                                for k in self.censorResult! {
                                    tmp.append(k.toMap())
                                }
                                map["CensorResult"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CensorResult") {
                                var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult] = []
                                for v in dict["CensorResult"] as! [Any] {
                                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.censorResult = tmp
                            }
                        }
                    }
                    public var censorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults?

                    public var object: String?

                    public var timestamp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.censorResults?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.censorResults != nil {
                            map["CensorResults"] = self.censorResults?.toMap()
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CensorResults") {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults()
                            model.fromMap(dict["CensorResults"] as! [String: Any])
                            self.censorResults = model
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("Timestamp") {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                    }
                }
                public var videoTimeline: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.videoTimeline != nil {
                        var tmp : [Any] = []
                        for k in self.videoTimeline! {
                            tmp.append(k.toMap())
                        }
                        map["VideoTimeline"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VideoTimeline") {
                        var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline] = []
                        for v in dict["VideoTimeline"] as! [Any] {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.videoTimeline = tmp
                    }
                }
            }
            public var censorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults?

            public var nextPageToken: String?

            public var videoTimelines: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.censorResults?.validate()
                try self.videoTimelines?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.censorResults != nil {
                    map["CensorResults"] = self.censorResults?.toMap()
                }
                if self.nextPageToken != nil {
                    map["NextPageToken"] = self.nextPageToken!
                }
                if self.videoTimelines != nil {
                    map["VideoTimelines"] = self.videoTimelines?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CensorResults") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults()
                    model.fromMap(dict["CensorResults"] as! [String: Any])
                    self.censorResults = model
                }
                if dict.keys.contains("NextPageToken") {
                    self.nextPageToken = dict["NextPageToken"] as! String
                }
                if dict.keys.contains("VideoTimelines") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines()
                    model.fromMap(dict["VideoTimelines"] as! [String: Any])
                    self.videoTimelines = model
                }
            }
        }
        public class VideoCensorConfig : Tea.TeaModel {
            public class OutputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var bizType: String?

            public var outputFile: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig.OutputFile?

            public var videoCensor: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.outputFile != nil {
                    map["OutputFile"] = self.outputFile?.toMap()
                }
                if self.videoCensor != nil {
                    map["VideoCensor"] = self.videoCensor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizType") {
                    self.bizType = dict["BizType"] as! String
                }
                if dict.keys.contains("OutputFile") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig.OutputFile()
                    model.fromMap(dict["OutputFile"] as! [String: Any])
                    self.outputFile = model
                }
                if dict.keys.contains("VideoCensor") {
                    self.videoCensor = dict["VideoCensor"] as! String
                }
            }
        }
        public var barrageCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.BarrageCensorResult?

        public var code: String?

        public var coverImageCensorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults?

        public var creationTime: String?

        public var descCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.DescCensorResult?

        public var finishTime: String?

        public var input: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.Input?

        public var jobId: String?

        public var message: String?

        public var pipelineId: String?

        public var state: String?

        public var suggestion: String?

        public var titleCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.TitleCensorResult?

        public var userData: String?

        public var vensorCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult?

        public var videoCensorConfig: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.barrageCensorResult?.validate()
            try self.coverImageCensorResults?.validate()
            try self.descCensorResult?.validate()
            try self.input?.validate()
            try self.titleCensorResult?.validate()
            try self.vensorCensorResult?.validate()
            try self.videoCensorConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.barrageCensorResult != nil {
                map["BarrageCensorResult"] = self.barrageCensorResult?.toMap()
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.coverImageCensorResults != nil {
                map["CoverImageCensorResults"] = self.coverImageCensorResults?.toMap()
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.descCensorResult != nil {
                map["DescCensorResult"] = self.descCensorResult?.toMap()
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.suggestion != nil {
                map["Suggestion"] = self.suggestion!
            }
            if self.titleCensorResult != nil {
                map["TitleCensorResult"] = self.titleCensorResult?.toMap()
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.vensorCensorResult != nil {
                map["VensorCensorResult"] = self.vensorCensorResult?.toMap()
            }
            if self.videoCensorConfig != nil {
                map["VideoCensorConfig"] = self.videoCensorConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BarrageCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.BarrageCensorResult()
                model.fromMap(dict["BarrageCensorResult"] as! [String: Any])
                self.barrageCensorResult = model
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CoverImageCensorResults") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults()
                model.fromMap(dict["CoverImageCensorResults"] as! [String: Any])
                self.coverImageCensorResults = model
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DescCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.DescCensorResult()
                model.fromMap(dict["DescCensorResult"] as! [String: Any])
                self.descCensorResult = model
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Suggestion") {
                self.suggestion = dict["Suggestion"] as! String
            }
            if dict.keys.contains("TitleCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.TitleCensorResult()
                model.fromMap(dict["TitleCensorResult"] as! [String: Any])
                self.titleCensorResult = model
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("VensorCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult()
                model.fromMap(dict["VensorCensorResult"] as! [String: Any])
                self.vensorCensorResult = model
            }
            if dict.keys.contains("VideoCensorConfig") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig()
                model.fromMap(dict["VideoCensorConfig"] as! [String: Any])
                self.videoCensorConfig = model
            }
        }
    }
    public var mediaCensorJobDetail: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaCensorJobDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaCensorJobDetail != nil {
            map["MediaCensorJobDetail"] = self.mediaCensorJobDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaCensorJobDetail") {
            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail()
            model.fromMap(dict["MediaCensorJobDetail"] as! [String: Any])
            self.mediaCensorJobDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaCensorJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaCensorJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaCensorJobDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaCensorJobListRequest : Tea.TeaModel {
    public var endOfJobCreatedTimeRange: String?

    public var jobIds: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startOfJobCreatedTimeRange: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfJobCreatedTimeRange != nil {
            map["EndOfJobCreatedTimeRange"] = self.endOfJobCreatedTimeRange!
        }
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startOfJobCreatedTimeRange != nil {
            map["StartOfJobCreatedTimeRange"] = self.startOfJobCreatedTimeRange!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfJobCreatedTimeRange") {
            self.endOfJobCreatedTimeRange = dict["EndOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartOfJobCreatedTimeRange") {
            self.startOfJobCreatedTimeRange = dict["StartOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class QueryMediaCensorJobListResponseBody : Tea.TeaModel {
    public class MediaCensorJobList : Tea.TeaModel {
        public class MediaCensorJob : Tea.TeaModel {
            public class BarrageCensorResult : Tea.TeaModel {
                public var label: String?

                public var rate: String?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! String
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class CoverImageCensorResults : Tea.TeaModel {
                public class CoverImageCensorResult : Tea.TeaModel {
                    public class Results : Tea.TeaModel {
                        public class Result : Tea.TeaModel {
                            public var label: String?

                            public var rate: String?

                            public var scene: String?

                            public var suggestion: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.label != nil {
                                    map["Label"] = self.label!
                                }
                                if self.rate != nil {
                                    map["Rate"] = self.rate!
                                }
                                if self.scene != nil {
                                    map["Scene"] = self.scene!
                                }
                                if self.suggestion != nil {
                                    map["Suggestion"] = self.suggestion!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Label") {
                                    self.label = dict["Label"] as! String
                                }
                                if dict.keys.contains("Rate") {
                                    self.rate = dict["Rate"] as! String
                                }
                                if dict.keys.contains("Scene") {
                                    self.scene = dict["Scene"] as! String
                                }
                                if dict.keys.contains("Suggestion") {
                                    self.suggestion = dict["Suggestion"] as! String
                                }
                            }
                        }
                        public var result: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results.Result]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.result != nil {
                                var tmp : [Any] = []
                                for k in self.result! {
                                    tmp.append(k.toMap())
                                }
                                map["Result"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Result") {
                                var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results.Result] = []
                                for v in dict["Result"] as! [Any] {
                                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results.Result()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.result = tmp
                            }
                        }
                    }
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var results: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.results?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.results != nil {
                            map["Results"] = self.results?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("Results") {
                            var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results()
                            model.fromMap(dict["Results"] as! [String: Any])
                            self.results = model
                        }
                    }
                }
                public var coverImageCensorResult: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.coverImageCensorResult != nil {
                        var tmp : [Any] = []
                        for k in self.coverImageCensorResult! {
                            tmp.append(k.toMap())
                        }
                        map["CoverImageCensorResult"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CoverImageCensorResult") {
                        var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult] = []
                        for v in dict["CoverImageCensorResult"] as! [Any] {
                            var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.coverImageCensorResult = tmp
                    }
                }
            }
            public class DescCensorResult : Tea.TeaModel {
                public var label: String?

                public var rate: String?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! String
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public class TitleCensorResult : Tea.TeaModel {
                public var label: String?

                public var rate: String?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! String
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class VensorCensorResult : Tea.TeaModel {
                public class CensorResults : Tea.TeaModel {
                    public class CensorResult : Tea.TeaModel {
                        public var label: String?

                        public var rate: String?

                        public var scene: String?

                        public var suggestion: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.rate != nil {
                                map["Rate"] = self.rate!
                            }
                            if self.scene != nil {
                                map["Scene"] = self.scene!
                            }
                            if self.suggestion != nil {
                                map["Suggestion"] = self.suggestion!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Rate") {
                                self.rate = dict["Rate"] as! String
                            }
                            if dict.keys.contains("Scene") {
                                self.scene = dict["Scene"] as! String
                            }
                            if dict.keys.contains("Suggestion") {
                                self.suggestion = dict["Suggestion"] as! String
                            }
                        }
                    }
                    public var censorResult: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults.CensorResult]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.censorResult != nil {
                            var tmp : [Any] = []
                            for k in self.censorResult! {
                                tmp.append(k.toMap())
                            }
                            map["CensorResult"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CensorResult") {
                            var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults.CensorResult] = []
                            for v in dict["CensorResult"] as! [Any] {
                                var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults.CensorResult()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.censorResult = tmp
                        }
                    }
                }
                public class VideoTimelines : Tea.TeaModel {
                    public class VideoTimeline : Tea.TeaModel {
                        public class CensorResults : Tea.TeaModel {
                            public class CensorResult : Tea.TeaModel {
                                public var label: String?

                                public var rate: String?

                                public var scene: String?

                                public var suggestion: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.label != nil {
                                        map["Label"] = self.label!
                                    }
                                    if self.rate != nil {
                                        map["Rate"] = self.rate!
                                    }
                                    if self.scene != nil {
                                        map["Scene"] = self.scene!
                                    }
                                    if self.suggestion != nil {
                                        map["Suggestion"] = self.suggestion!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Label") {
                                        self.label = dict["Label"] as! String
                                    }
                                    if dict.keys.contains("Rate") {
                                        self.rate = dict["Rate"] as! String
                                    }
                                    if dict.keys.contains("Scene") {
                                        self.scene = dict["Scene"] as! String
                                    }
                                    if dict.keys.contains("Suggestion") {
                                        self.suggestion = dict["Suggestion"] as! String
                                    }
                                }
                            }
                            public var censorResult: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.censorResult != nil {
                                    var tmp : [Any] = []
                                    for k in self.censorResult! {
                                        tmp.append(k.toMap())
                                    }
                                    map["CensorResult"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("CensorResult") {
                                    var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult] = []
                                    for v in dict["CensorResult"] as! [Any] {
                                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.censorResult = tmp
                                }
                            }
                        }
                        public var censorResults: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults?

                        public var object: String?

                        public var timestamp: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.censorResults?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.censorResults != nil {
                                map["CensorResults"] = self.censorResults?.toMap()
                            }
                            if self.object != nil {
                                map["Object"] = self.object!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CensorResults") {
                                var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults()
                                model.fromMap(dict["CensorResults"] as! [String: Any])
                                self.censorResults = model
                            }
                            if dict.keys.contains("Object") {
                                self.object = dict["Object"] as! String
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                        }
                    }
                    public var videoTimeline: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.videoTimeline != nil {
                            var tmp : [Any] = []
                            for k in self.videoTimeline! {
                                tmp.append(k.toMap())
                            }
                            map["VideoTimeline"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("VideoTimeline") {
                            var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline] = []
                            for v in dict["VideoTimeline"] as! [Any] {
                                var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.videoTimeline = tmp
                        }
                    }
                }
                public var censorResults: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults?

                public var nextPageToken: String?

                public var videoTimelines: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.censorResults?.validate()
                    try self.videoTimelines?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.censorResults != nil {
                        map["CensorResults"] = self.censorResults?.toMap()
                    }
                    if self.nextPageToken != nil {
                        map["NextPageToken"] = self.nextPageToken!
                    }
                    if self.videoTimelines != nil {
                        map["VideoTimelines"] = self.videoTimelines?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CensorResults") {
                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults()
                        model.fromMap(dict["CensorResults"] as! [String: Any])
                        self.censorResults = model
                    }
                    if dict.keys.contains("NextPageToken") {
                        self.nextPageToken = dict["NextPageToken"] as! String
                    }
                    if dict.keys.contains("VideoTimelines") {
                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines()
                        model.fromMap(dict["VideoTimelines"] as! [String: Any])
                        self.videoTimelines = model
                    }
                }
            }
            public class VideoCensorConfig : Tea.TeaModel {
                public class OutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                    }
                }
                public var bizType: String?

                public var outputFile: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig.OutputFile?

                public var videoCensor: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.outputFile?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizType != nil {
                        map["BizType"] = self.bizType!
                    }
                    if self.outputFile != nil {
                        map["OutputFile"] = self.outputFile?.toMap()
                    }
                    if self.videoCensor != nil {
                        map["VideoCensor"] = self.videoCensor!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizType") {
                        self.bizType = dict["BizType"] as! String
                    }
                    if dict.keys.contains("OutputFile") {
                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig.OutputFile()
                        model.fromMap(dict["OutputFile"] as! [String: Any])
                        self.outputFile = model
                    }
                    if dict.keys.contains("VideoCensor") {
                        self.videoCensor = dict["VideoCensor"] as! String
                    }
                }
            }
            public var barrageCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.BarrageCensorResult?

            public var code: String?

            public var coverImageCensorResults: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults?

            public var creationTime: String?

            public var descCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.DescCensorResult?

            public var finishTime: String?

            public var input: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.Input?

            public var jobId: String?

            public var message: String?

            public var pipelineId: String?

            public var state: String?

            public var suggestion: String?

            public var titleCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.TitleCensorResult?

            public var userData: String?

            public var vensorCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult?

            public var videoCensorConfig: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.barrageCensorResult?.validate()
                try self.coverImageCensorResults?.validate()
                try self.descCensorResult?.validate()
                try self.input?.validate()
                try self.titleCensorResult?.validate()
                try self.vensorCensorResult?.validate()
                try self.videoCensorConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.barrageCensorResult != nil {
                    map["BarrageCensorResult"] = self.barrageCensorResult?.toMap()
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.coverImageCensorResults != nil {
                    map["CoverImageCensorResults"] = self.coverImageCensorResults?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.descCensorResult != nil {
                    map["DescCensorResult"] = self.descCensorResult?.toMap()
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.titleCensorResult != nil {
                    map["TitleCensorResult"] = self.titleCensorResult?.toMap()
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                if self.vensorCensorResult != nil {
                    map["VensorCensorResult"] = self.vensorCensorResult?.toMap()
                }
                if self.videoCensorConfig != nil {
                    map["VideoCensorConfig"] = self.videoCensorConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BarrageCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.BarrageCensorResult()
                    model.fromMap(dict["BarrageCensorResult"] as! [String: Any])
                    self.barrageCensorResult = model
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CoverImageCensorResults") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults()
                    model.fromMap(dict["CoverImageCensorResults"] as! [String: Any])
                    self.coverImageCensorResults = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DescCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.DescCensorResult()
                    model.fromMap(dict["DescCensorResult"] as! [String: Any])
                    self.descCensorResult = model
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("TitleCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.TitleCensorResult()
                    model.fromMap(dict["TitleCensorResult"] as! [String: Any])
                    self.titleCensorResult = model
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
                if dict.keys.contains("VensorCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult()
                    model.fromMap(dict["VensorCensorResult"] as! [String: Any])
                    self.vensorCensorResult = model
                }
                if dict.keys.contains("VideoCensorConfig") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig()
                    model.fromMap(dict["VideoCensorConfig"] as! [String: Any])
                    self.videoCensorConfig = model
                }
            }
        }
        public var mediaCensorJob: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaCensorJob != nil {
                var tmp : [Any] = []
                for k in self.mediaCensorJob! {
                    tmp.append(k.toMap())
                }
                map["MediaCensorJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaCensorJob") {
                var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob] = []
                for v in dict["MediaCensorJob"] as! [Any] {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaCensorJob = tmp
            }
        }
    }
    public class NonExistIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var mediaCensorJobList: QueryMediaCensorJobListResponseBody.MediaCensorJobList?

    public var nextPageToken: String?

    public var nonExistIds: QueryMediaCensorJobListResponseBody.NonExistIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaCensorJobList?.validate()
        try self.nonExistIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaCensorJobList != nil {
            map["MediaCensorJobList"] = self.mediaCensorJobList?.toMap()
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.nonExistIds != nil {
            map["NonExistIds"] = self.nonExistIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaCensorJobList") {
            var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList()
            model.fromMap(dict["MediaCensorJobList"] as! [String: Any])
            self.mediaCensorJobList = model
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("NonExistIds") {
            var model = QueryMediaCensorJobListResponseBody.NonExistIds()
            model.fromMap(dict["NonExistIds"] as! [String: Any])
            self.nonExistIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaCensorJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaCensorJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaCensorJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaIndexJobRequest : Tea.TeaModel {
    public var mediaId: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class QueryMediaIndexJobResponseBody : Tea.TeaModel {
    public class IndexJobInfoList : Tea.TeaModel {
        public var gmtFinish: String?

        public var gmtSubmit: String?

        public var indexType: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtFinish != nil {
                map["GmtFinish"] = self.gmtFinish!
            }
            if self.gmtSubmit != nil {
                map["GmtSubmit"] = self.gmtSubmit!
            }
            if self.indexType != nil {
                map["IndexType"] = self.indexType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GmtFinish") {
                self.gmtFinish = dict["GmtFinish"] as! String
            }
            if dict.keys.contains("GmtSubmit") {
                self.gmtSubmit = dict["GmtSubmit"] as! String
            }
            if dict.keys.contains("IndexType") {
                self.indexType = dict["IndexType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var indexJobInfoList: [QueryMediaIndexJobResponseBody.IndexJobInfoList]?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.indexJobInfoList != nil {
            var tmp : [Any] = []
            for k in self.indexJobInfoList! {
                tmp.append(k.toMap())
            }
            map["IndexJobInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("IndexJobInfoList") {
            var tmp : [QueryMediaIndexJobResponseBody.IndexJobInfoList] = []
            for v in dict["IndexJobInfoList"] as! [Any] {
                var model = QueryMediaIndexJobResponseBody.IndexJobInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.indexJobInfoList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class QueryMediaIndexJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaIndexJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaIndexJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySearchIndexRequest : Tea.TeaModel {
    public var indexType: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexType != nil {
            map["IndexType"] = self.indexType!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndexType") {
            self.indexType = dict["IndexType"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class QuerySearchIndexResponseBody : Tea.TeaModel {
    public var code: String?

    public var indexStatus: String?

    public var indexType: String?

    public var mediaTotal: String?

    public var requestId: String?

    public var searchLibName: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.indexStatus != nil {
            map["IndexStatus"] = self.indexStatus!
        }
        if self.indexType != nil {
            map["IndexType"] = self.indexType!
        }
        if self.mediaTotal != nil {
            map["MediaTotal"] = self.mediaTotal!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("IndexStatus") {
            self.indexStatus = dict["IndexStatus"] as! String
        }
        if dict.keys.contains("IndexType") {
            self.indexType = dict["IndexType"] as! String
        }
        if dict.keys.contains("MediaTotal") {
            self.mediaTotal = dict["MediaTotal"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class QuerySearchIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySearchIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySearchIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySearchLibRequest : Tea.TeaModel {
    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class QuerySearchLibResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var searchLibName: String?

    public var status: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class QuerySearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySmarttagJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var params: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
    }
}

public class QuerySmarttagJobResponseBody : Tea.TeaModel {
    public class Results : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var data: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var result: [QuerySmarttagJobResponseBody.Results.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Result") {
                var tmp : [QuerySmarttagJobResponseBody.Results.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = QuerySmarttagJobResponseBody.Results.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
        }
    }
    public var jobStatus: String?

    public var requestId: String?

    public var results: QuerySmarttagJobResponseBody.Results?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.results?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobStatus != nil {
            map["JobStatus"] = self.jobStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.results != nil {
            map["Results"] = self.results?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobStatus") {
            self.jobStatus = dict["JobStatus"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Results") {
            var model = QuerySmarttagJobResponseBody.Results()
            model.fromMap(dict["Results"] as! [String: Any])
            self.results = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class QuerySmarttagJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySmarttagJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySmarttagJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshUploadMediaRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class RefreshUploadMediaResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class RefreshUploadMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshUploadMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RefreshUploadMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterMediaInfoRequest : Tea.TeaModel {
    public var businessType: String?

    public var cateId: Int64?

    public var clientToken: String?

    public var coverURL: String?

    public var description_: String?

    public var inputURL: String?

    public var mediaTags: String?

    public var mediaType: String?

    public var overwrite: Bool?

    public var referenceId: String?

    public var registerConfig: String?

    public var smartTagTemplateId: String?

    public var title: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaTags != nil {
            map["MediaTags"] = self.mediaTags!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.referenceId != nil {
            map["ReferenceId"] = self.referenceId!
        }
        if self.registerConfig != nil {
            map["RegisterConfig"] = self.registerConfig!
        }
        if self.smartTagTemplateId != nil {
            map["SmartTagTemplateId"] = self.smartTagTemplateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaTags") {
            self.mediaTags = dict["MediaTags"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("Overwrite") {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("ReferenceId") {
            self.referenceId = dict["ReferenceId"] as! String
        }
        if dict.keys.contains("RegisterConfig") {
            self.registerConfig = dict["RegisterConfig"] as! String
        }
        if dict.keys.contains("SmartTagTemplateId") {
            self.smartTagTemplateId = dict["SmartTagTemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class RegisterMediaInfoResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterMediaStreamRequest : Tea.TeaModel {
    public var inputURL: String?

    public var mediaId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class RegisterMediaStreamResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterMediaStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterMediaStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterMediaStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchEditingProjectRequest : Tea.TeaModel {
    public var createSource: String?

    public var endTime: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var projectType: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createSource != nil {
            map["CreateSource"] = self.createSource!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectType != nil {
            map["ProjectType"] = self.projectType!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateSource") {
            self.createSource = dict["CreateSource"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ProjectType") {
            self.projectType = dict["ProjectType"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class SearchEditingProjectResponseBody : Tea.TeaModel {
    public class ProjectList : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var duration: Int64?

        public var errorCode: String?

        public var errorMessage: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: String?

        public var templateType: String?

        public var timeline: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var projectList: [SearchEditingProjectResponseBody.ProjectList]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.projectList != nil {
            var tmp : [Any] = []
            for k in self.projectList! {
                tmp.append(k.toMap())
            }
            map["ProjectList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ProjectList") {
            var tmp : [SearchEditingProjectResponseBody.ProjectList] = []
            for v in dict["ProjectList"] as! [Any] {
                var model = SearchEditingProjectResponseBody.ProjectList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.projectList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaRequest : Tea.TeaModel {
    public var entityId: String?

    public var match: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var scrollToken: String?

    public var searchLibName: String?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.match != nil {
            map["Match"] = self.match!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scrollToken != nil {
            map["ScrollToken"] = self.scrollToken!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("Match") {
            self.match = dict["Match"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScrollToken") {
            self.scrollToken = dict["ScrollToken"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class SearchMediaResponseBody : Tea.TeaModel {
    public class MediaInfoList : Tea.TeaModel {
        public class AiData : Tea.TeaModel {
            public class AiLabelInfo : Tea.TeaModel {
                public class Occurrences : Tea.TeaModel {
                    public class Tracks : Tea.TeaModel {
                        public var position: String?

                        public var size: Double?

                        public var timestamp: Double?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.position != nil {
                                map["Position"] = self.position!
                            }
                            if self.size != nil {
                                map["Size"] = self.size!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Position") {
                                self.position = dict["Position"] as! String
                            }
                            if dict.keys.contains("Size") {
                                self.size = dict["Size"] as! Double
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! Double
                            }
                        }
                    }
                    public var content: String?

                    public var finegrainId: String?

                    public var finegrainName: String?

                    public var from: Double?

                    public var image: String?

                    public var score: Double?

                    public var tableBatchSeqId: String?

                    public var to: Double?

                    public var tracks: [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences.Tracks]?

                    public var clipId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.finegrainId != nil {
                            map["FinegrainId"] = self.finegrainId!
                        }
                        if self.finegrainName != nil {
                            map["FinegrainName"] = self.finegrainName!
                        }
                        if self.from != nil {
                            map["From"] = self.from!
                        }
                        if self.image != nil {
                            map["Image"] = self.image!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.tableBatchSeqId != nil {
                            map["TableBatchSeqId"] = self.tableBatchSeqId!
                        }
                        if self.to != nil {
                            map["To"] = self.to!
                        }
                        if self.tracks != nil {
                            var tmp : [Any] = []
                            for k in self.tracks! {
                                tmp.append(k.toMap())
                            }
                            map["Tracks"] = tmp
                        }
                        if self.clipId != nil {
                            map["clipId"] = self.clipId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("FinegrainId") {
                            self.finegrainId = dict["FinegrainId"] as! String
                        }
                        if dict.keys.contains("FinegrainName") {
                            self.finegrainName = dict["FinegrainName"] as! String
                        }
                        if dict.keys.contains("From") {
                            self.from = dict["From"] as! Double
                        }
                        if dict.keys.contains("Image") {
                            self.image = dict["Image"] as! String
                        }
                        if dict.keys.contains("Score") {
                            self.score = dict["Score"] as! Double
                        }
                        if dict.keys.contains("TableBatchSeqId") {
                            self.tableBatchSeqId = dict["TableBatchSeqId"] as! String
                        }
                        if dict.keys.contains("To") {
                            self.to = dict["To"] as! Double
                        }
                        if dict.keys.contains("Tracks") {
                            var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences.Tracks] = []
                            for v in dict["Tracks"] as! [Any] {
                                var model = SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences.Tracks()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.tracks = tmp
                        }
                        if dict.keys.contains("clipId") {
                            self.clipId = dict["clipId"] as! String
                        }
                    }
                }
                public var category: String?

                public var faceId: String?

                public var labelId: String?

                public var labelName: String?

                public var labelType: String?

                public var occurrences: [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences]?

                public var source: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.faceId != nil {
                        map["FaceId"] = self.faceId!
                    }
                    if self.labelId != nil {
                        map["LabelId"] = self.labelId!
                    }
                    if self.labelName != nil {
                        map["LabelName"] = self.labelName!
                    }
                    if self.labelType != nil {
                        map["LabelType"] = self.labelType!
                    }
                    if self.occurrences != nil {
                        var tmp : [Any] = []
                        for k in self.occurrences! {
                            tmp.append(k.toMap())
                        }
                        map["Occurrences"] = tmp
                    }
                    if self.source != nil {
                        map["Source"] = self.source!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("FaceId") {
                        self.faceId = dict["FaceId"] as! String
                    }
                    if dict.keys.contains("LabelId") {
                        self.labelId = dict["LabelId"] as! String
                    }
                    if dict.keys.contains("LabelName") {
                        self.labelName = dict["LabelName"] as! String
                    }
                    if dict.keys.contains("LabelType") {
                        self.labelType = dict["LabelType"] as! String
                    }
                    if dict.keys.contains("Occurrences") {
                        var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences] = []
                        for v in dict["Occurrences"] as! [Any] {
                            var model = SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.occurrences = tmp
                    }
                    if dict.keys.contains("Source") {
                        self.source = dict["Source"] as! String
                    }
                }
            }
            public class AsrInfo : Tea.TeaModel {
                public var clipId: String?

                public var content: String?

                public var from: Double?

                public var timestamp: Double?

                public var to: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clipId != nil {
                        map["ClipId"] = self.clipId!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.from != nil {
                        map["From"] = self.from!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.to != nil {
                        map["To"] = self.to!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClipId") {
                        self.clipId = dict["ClipId"] as! String
                    }
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("From") {
                        self.from = dict["From"] as! Double
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                    if dict.keys.contains("To") {
                        self.to = dict["To"] as! Double
                    }
                }
            }
            public class OcrInfo : Tea.TeaModel {
                public var clipId: String?

                public var content: String?

                public var from: Double?

                public var timestamp: Double?

                public var to: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clipId != nil {
                        map["ClipId"] = self.clipId!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.from != nil {
                        map["From"] = self.from!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.to != nil {
                        map["To"] = self.to!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClipId") {
                        self.clipId = dict["ClipId"] as! String
                    }
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("From") {
                        self.from = dict["From"] as! Double
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                    if dict.keys.contains("To") {
                        self.to = dict["To"] as! Double
                    }
                }
            }
            public var aiLabelInfo: [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo]?

            public var asrInfo: [SearchMediaResponseBody.MediaInfoList.AiData.AsrInfo]?

            public var ocrInfo: [SearchMediaResponseBody.MediaInfoList.AiData.OcrInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiLabelInfo != nil {
                    var tmp : [Any] = []
                    for k in self.aiLabelInfo! {
                        tmp.append(k.toMap())
                    }
                    map["AiLabelInfo"] = tmp
                }
                if self.asrInfo != nil {
                    var tmp : [Any] = []
                    for k in self.asrInfo! {
                        tmp.append(k.toMap())
                    }
                    map["AsrInfo"] = tmp
                }
                if self.ocrInfo != nil {
                    var tmp : [Any] = []
                    for k in self.ocrInfo! {
                        tmp.append(k.toMap())
                    }
                    map["OcrInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiLabelInfo") {
                    var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo] = []
                    for v in dict["AiLabelInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.aiLabelInfo = tmp
                }
                if dict.keys.contains("AsrInfo") {
                    var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.AsrInfo] = []
                    for v in dict["AsrInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaInfoList.AiData.AsrInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.asrInfo = tmp
                }
                if dict.keys.contains("OcrInfo") {
                    var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.OcrInfo] = []
                    for v in dict["OcrInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaInfoList.AiData.OcrInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ocrInfo = tmp
                }
            }
        }
        public class AiRoughData : Tea.TeaModel {
            public var aiCategory: String?

            public var aiJobId: String?

            public var result: String?

            public var saveType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiCategory != nil {
                    map["AiCategory"] = self.aiCategory!
                }
                if self.aiJobId != nil {
                    map["AiJobId"] = self.aiJobId!
                }
                if self.result != nil {
                    map["Result"] = self.result!
                }
                if self.saveType != nil {
                    map["SaveType"] = self.saveType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiCategory") {
                    self.aiCategory = dict["AiCategory"] as! String
                }
                if dict.keys.contains("AiJobId") {
                    self.aiJobId = dict["AiJobId"] as! String
                }
                if dict.keys.contains("Result") {
                    self.result = dict["Result"] as! String
                }
                if dict.keys.contains("SaveType") {
                    self.saveType = dict["SaveType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var createTime: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var modifiedTime: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: SearchMediaResponseBody.MediaInfoList.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = SearchMediaResponseBody.MediaInfoList.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var cateId: Int64?

            public var cateName: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var referenceId: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var uploadSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.uploadSource != nil {
                    map["UploadSource"] = self.uploadSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UploadSource") {
                    self.uploadSource = dict["UploadSource"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var aiData: SearchMediaResponseBody.MediaInfoList.AiData?

        public var aiRoughData: SearchMediaResponseBody.MediaInfoList.AiRoughData?

        public var fileInfoList: [SearchMediaResponseBody.MediaInfoList.FileInfoList]?

        public var mediaBasicInfo: SearchMediaResponseBody.MediaInfoList.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.aiData?.validate()
            try self.aiRoughData?.validate()
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiData != nil {
                map["AiData"] = self.aiData?.toMap()
            }
            if self.aiRoughData != nil {
                map["AiRoughData"] = self.aiRoughData?.toMap()
            }
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiData") {
                var model = SearchMediaResponseBody.MediaInfoList.AiData()
                model.fromMap(dict["AiData"] as! [String: Any])
                self.aiData = model
            }
            if dict.keys.contains("AiRoughData") {
                var model = SearchMediaResponseBody.MediaInfoList.AiRoughData()
                model.fromMap(dict["AiRoughData"] as! [String: Any])
                self.aiRoughData = model
            }
            if dict.keys.contains("FileInfoList") {
                var tmp : [SearchMediaResponseBody.MediaInfoList.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = SearchMediaResponseBody.MediaInfoList.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = SearchMediaResponseBody.MediaInfoList.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var code: String?

    public var mediaInfoList: [SearchMediaResponseBody.MediaInfoList]?

    public var requestId: String?

    public var scrollToken: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaInfoList != nil {
            var tmp : [Any] = []
            for k in self.mediaInfoList! {
                tmp.append(k.toMap())
            }
            map["MediaInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scrollToken != nil {
            map["ScrollToken"] = self.scrollToken!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaInfoList") {
            var tmp : [SearchMediaResponseBody.MediaInfoList] = []
            for v in dict["MediaInfoList"] as! [Any] {
                var model = SearchMediaResponseBody.MediaInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfoList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScrollToken") {
            self.scrollToken = dict["ScrollToken"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaByAILabelRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaType: String?

    public var multimodalSearchType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchLibName: String?

    public var sortBy: String?

    public var specificSearch: Bool?

    public var text: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.multimodalSearchType != nil {
            map["MultimodalSearchType"] = self.multimodalSearchType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.specificSearch != nil {
            map["SpecificSearch"] = self.specificSearch!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("MultimodalSearchType") {
            self.multimodalSearchType = dict["MultimodalSearchType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("SpecificSearch") {
            self.specificSearch = dict["SpecificSearch"] as! Bool
        }
        if dict.keys.contains("Text") {
            self.text = dict["Text"] as! String
        }
    }
}

public class SearchMediaByAILabelResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class AiData : Tea.TeaModel {
            public class AiLabelInfo : Tea.TeaModel {
                public class Occurrences : Tea.TeaModel {
                    public class Tracks : Tea.TeaModel {
                        public var position: String?

                        public var size: Double?

                        public var timestamp: Double?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.position != nil {
                                map["Position"] = self.position!
                            }
                            if self.size != nil {
                                map["Size"] = self.size!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Position") {
                                self.position = dict["Position"] as! String
                            }
                            if dict.keys.contains("Size") {
                                self.size = dict["Size"] as! Double
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! Double
                            }
                        }
                    }
                    public var clipId: String?

                    public var content: String?

                    public var finegrainId: String?

                    public var finegrainName: String?

                    public var from: Double?

                    public var image: String?

                    public var score: Double?

                    public var tableBatchSeqId: String?

                    public var to: Double?

                    public var tracks: [SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo.Occurrences.Tracks]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.clipId != nil {
                            map["ClipId"] = self.clipId!
                        }
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.finegrainId != nil {
                            map["FinegrainId"] = self.finegrainId!
                        }
                        if self.finegrainName != nil {
                            map["FinegrainName"] = self.finegrainName!
                        }
                        if self.from != nil {
                            map["From"] = self.from!
                        }
                        if self.image != nil {
                            map["Image"] = self.image!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.tableBatchSeqId != nil {
                            map["TableBatchSeqId"] = self.tableBatchSeqId!
                        }
                        if self.to != nil {
                            map["To"] = self.to!
                        }
                        if self.tracks != nil {
                            var tmp : [Any] = []
                            for k in self.tracks! {
                                tmp.append(k.toMap())
                            }
                            map["Tracks"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClipId") {
                            self.clipId = dict["ClipId"] as! String
                        }
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("FinegrainId") {
                            self.finegrainId = dict["FinegrainId"] as! String
                        }
                        if dict.keys.contains("FinegrainName") {
                            self.finegrainName = dict["FinegrainName"] as! String
                        }
                        if dict.keys.contains("From") {
                            self.from = dict["From"] as! Double
                        }
                        if dict.keys.contains("Image") {
                            self.image = dict["Image"] as! String
                        }
                        if dict.keys.contains("Score") {
                            self.score = dict["Score"] as! Double
                        }
                        if dict.keys.contains("TableBatchSeqId") {
                            self.tableBatchSeqId = dict["TableBatchSeqId"] as! String
                        }
                        if dict.keys.contains("To") {
                            self.to = dict["To"] as! Double
                        }
                        if dict.keys.contains("Tracks") {
                            var tmp : [SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo.Occurrences.Tracks] = []
                            for v in dict["Tracks"] as! [Any] {
                                var model = SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo.Occurrences.Tracks()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.tracks = tmp
                        }
                    }
                }
                public var category: String?

                public var faceId: String?

                public var labelId: String?

                public var labelName: String?

                public var labelType: String?

                public var occurrences: [SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo.Occurrences]?

                public var source: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.faceId != nil {
                        map["FaceId"] = self.faceId!
                    }
                    if self.labelId != nil {
                        map["LabelId"] = self.labelId!
                    }
                    if self.labelName != nil {
                        map["LabelName"] = self.labelName!
                    }
                    if self.labelType != nil {
                        map["LabelType"] = self.labelType!
                    }
                    if self.occurrences != nil {
                        var tmp : [Any] = []
                        for k in self.occurrences! {
                            tmp.append(k.toMap())
                        }
                        map["Occurrences"] = tmp
                    }
                    if self.source != nil {
                        map["Source"] = self.source!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("FaceId") {
                        self.faceId = dict["FaceId"] as! String
                    }
                    if dict.keys.contains("LabelId") {
                        self.labelId = dict["LabelId"] as! String
                    }
                    if dict.keys.contains("LabelName") {
                        self.labelName = dict["LabelName"] as! String
                    }
                    if dict.keys.contains("LabelType") {
                        self.labelType = dict["LabelType"] as! String
                    }
                    if dict.keys.contains("Occurrences") {
                        var tmp : [SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo.Occurrences] = []
                        for v in dict["Occurrences"] as! [Any] {
                            var model = SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo.Occurrences()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.occurrences = tmp
                    }
                    if dict.keys.contains("Source") {
                        self.source = dict["Source"] as! String
                    }
                }
            }
            public class AsrInfo : Tea.TeaModel {
                public var clipId: String?

                public var content: String?

                public var from: Double?

                public var timestamp: Double?

                public var to: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clipId != nil {
                        map["ClipId"] = self.clipId!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.from != nil {
                        map["From"] = self.from!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.to != nil {
                        map["To"] = self.to!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClipId") {
                        self.clipId = dict["ClipId"] as! String
                    }
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("From") {
                        self.from = dict["From"] as! Double
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                    if dict.keys.contains("To") {
                        self.to = dict["To"] as! Double
                    }
                }
            }
            public class OcrInfo : Tea.TeaModel {
                public var clipId: String?

                public var content: String?

                public var from: Double?

                public var timestamp: Double?

                public var to: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clipId != nil {
                        map["ClipId"] = self.clipId!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.from != nil {
                        map["From"] = self.from!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.to != nil {
                        map["To"] = self.to!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClipId") {
                        self.clipId = dict["ClipId"] as! String
                    }
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("From") {
                        self.from = dict["From"] as! Double
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                    if dict.keys.contains("To") {
                        self.to = dict["To"] as! Double
                    }
                }
            }
            public var aiLabelInfo: [SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo]?

            public var asrInfo: [SearchMediaByAILabelResponseBody.MediaList.AiData.AsrInfo]?

            public var ocrInfo: [SearchMediaByAILabelResponseBody.MediaList.AiData.OcrInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiLabelInfo != nil {
                    var tmp : [Any] = []
                    for k in self.aiLabelInfo! {
                        tmp.append(k.toMap())
                    }
                    map["AiLabelInfo"] = tmp
                }
                if self.asrInfo != nil {
                    var tmp : [Any] = []
                    for k in self.asrInfo! {
                        tmp.append(k.toMap())
                    }
                    map["AsrInfo"] = tmp
                }
                if self.ocrInfo != nil {
                    var tmp : [Any] = []
                    for k in self.ocrInfo! {
                        tmp.append(k.toMap())
                    }
                    map["OcrInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiLabelInfo") {
                    var tmp : [SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo] = []
                    for v in dict["AiLabelInfo"] as! [Any] {
                        var model = SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.aiLabelInfo = tmp
                }
                if dict.keys.contains("AsrInfo") {
                    var tmp : [SearchMediaByAILabelResponseBody.MediaList.AiData.AsrInfo] = []
                    for v in dict["AsrInfo"] as! [Any] {
                        var model = SearchMediaByAILabelResponseBody.MediaList.AiData.AsrInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.asrInfo = tmp
                }
                if dict.keys.contains("OcrInfo") {
                    var tmp : [SearchMediaByAILabelResponseBody.MediaList.AiData.OcrInfo] = []
                    for v in dict["OcrInfo"] as! [Any] {
                        var model = SearchMediaByAILabelResponseBody.MediaList.AiData.OcrInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ocrInfo = tmp
                }
            }
        }
        public var aiData: SearchMediaByAILabelResponseBody.MediaList.AiData?

        public var appId: String?

        public var coverUrl: String?

        public var creationTime: String?

        public var description_: String?

        public var duration: Double?

        public var mediaId: String?

        public var modificationTime: String?

        public var size: Int64?

        public var snapshots: [String]?

        public var status: String?

        public var storageLocation: String?

        public var tags: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.aiData?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiData != nil {
                map["AiData"] = self.aiData?.toMap()
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshots != nil {
                map["Snapshots"] = self.snapshots!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiData") {
                var model = SearchMediaByAILabelResponseBody.MediaList.AiData()
                model.fromMap(dict["AiData"] as! [String: Any])
                self.aiData = model
            }
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CoverUrl") {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Snapshots") {
                self.snapshots = dict["Snapshots"] as! [String]
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var code: String?

    public var mediaList: [SearchMediaByAILabelResponseBody.MediaList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaList != nil {
            var tmp : [Any] = []
            for k in self.mediaList! {
                tmp.append(k.toMap())
            }
            map["MediaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaList") {
            var tmp : [SearchMediaByAILabelResponseBody.MediaList] = []
            for v in dict["MediaList"] as! [Any] {
                var model = SearchMediaByAILabelResponseBody.MediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaByAILabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaByAILabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaByAILabelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaByFaceRequest : Tea.TeaModel {
    public var entityId: String?

    public var faceSearchToken: String?

    public var mediaType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var personImageUrl: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.faceSearchToken != nil {
            map["FaceSearchToken"] = self.faceSearchToken!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.personImageUrl != nil {
            map["PersonImageUrl"] = self.personImageUrl!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("FaceSearchToken") {
            self.faceSearchToken = dict["FaceSearchToken"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PersonImageUrl") {
            self.personImageUrl = dict["PersonImageUrl"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class SearchMediaByFaceResponseBody : Tea.TeaModel {
    public class MediaInfoList : Tea.TeaModel {
        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var code: String?

    public var mediaInfoList: [SearchMediaByFaceResponseBody.MediaInfoList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaInfoList != nil {
            var tmp : [Any] = []
            for k in self.mediaInfoList! {
                tmp.append(k.toMap())
            }
            map["MediaInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaInfoList") {
            var tmp : [SearchMediaByFaceResponseBody.MediaInfoList] = []
            for v in dict["MediaInfoList"] as! [Any] {
                var model = SearchMediaByFaceResponseBody.MediaInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfoList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaByFaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaByFaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaByFaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaByHybridRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchLibName: String?

    public var text: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("Text") {
            self.text = dict["Text"] as! String
        }
    }
}

public class SearchMediaByHybridResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class ClipInfo : Tea.TeaModel {
            public var from: Double?

            public var score: Double?

            public var to: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.from != nil {
                    map["From"] = self.from!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.to != nil {
                    map["To"] = self.to!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("From") {
                    self.from = dict["From"] as! Double
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Double
                }
                if dict.keys.contains("To") {
                    self.to = dict["To"] as! Double
                }
            }
        }
        public var clipInfo: [SearchMediaByHybridResponseBody.MediaList.ClipInfo]?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipInfo != nil {
                var tmp : [Any] = []
                for k in self.clipInfo! {
                    tmp.append(k.toMap())
                }
                map["ClipInfo"] = tmp
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipInfo") {
                var tmp : [SearchMediaByHybridResponseBody.MediaList.ClipInfo] = []
                for v in dict["ClipInfo"] as! [Any] {
                    var model = SearchMediaByHybridResponseBody.MediaList.ClipInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clipInfo = tmp
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var code: String?

    public var mediaList: [SearchMediaByHybridResponseBody.MediaList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaList != nil {
            var tmp : [Any] = []
            for k in self.mediaList! {
                tmp.append(k.toMap())
            }
            map["MediaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaList") {
            var tmp : [SearchMediaByHybridResponseBody.MediaList] = []
            for v in dict["MediaList"] as! [Any] {
                var model = SearchMediaByHybridResponseBody.MediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaByHybridResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaByHybridResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaByHybridResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaByMultimodalRequest : Tea.TeaModel {
    public var mediaType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchLibName: String?

    public var text: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("Text") {
            self.text = dict["Text"] as! String
        }
    }
}

public class SearchMediaByMultimodalResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class ClipInfo : Tea.TeaModel {
            public var from: Double?

            public var score: Double?

            public var to: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.from != nil {
                    map["From"] = self.from!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.to != nil {
                    map["To"] = self.to!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("From") {
                    self.from = dict["From"] as! Double
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Double
                }
                if dict.keys.contains("To") {
                    self.to = dict["To"] as! Double
                }
            }
        }
        public var clipInfo: [SearchMediaByMultimodalResponseBody.MediaList.ClipInfo]?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipInfo != nil {
                var tmp : [Any] = []
                for k in self.clipInfo! {
                    tmp.append(k.toMap())
                }
                map["ClipInfo"] = tmp
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipInfo") {
                var tmp : [SearchMediaByMultimodalResponseBody.MediaList.ClipInfo] = []
                for v in dict["ClipInfo"] as! [Any] {
                    var model = SearchMediaByMultimodalResponseBody.MediaList.ClipInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clipInfo = tmp
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var code: String?

    public var mediaList: [SearchMediaByMultimodalResponseBody.MediaList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaList != nil {
            var tmp : [Any] = []
            for k in self.mediaList! {
                tmp.append(k.toMap())
            }
            map["MediaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaList") {
            var tmp : [SearchMediaByMultimodalResponseBody.MediaList] = []
            for v in dict["MediaList"] as! [Any] {
                var model = SearchMediaByMultimodalResponseBody.MediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaByMultimodalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaByMultimodalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaByMultimodalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaClipByFaceRequest : Tea.TeaModel {
    public var entityId: String?

    public var faceSearchToken: String?

    public var mediaId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.faceSearchToken != nil {
            map["FaceSearchToken"] = self.faceSearchToken!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("FaceSearchToken") {
            self.faceSearchToken = dict["FaceSearchToken"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class SearchMediaClipByFaceResponseBody : Tea.TeaModel {
    public class MediaClipList : Tea.TeaModel {
        public class OccurrencesInfos : Tea.TeaModel {
            public class TrackData : Tea.TeaModel {
                public class BoxPosition : Tea.TeaModel {
                    public var h: Int32?

                    public var w: Int32?

                    public var x: Int32?

                    public var y: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.h != nil {
                            map["H"] = self.h!
                        }
                        if self.w != nil {
                            map["W"] = self.w!
                        }
                        if self.x != nil {
                            map["X"] = self.x!
                        }
                        if self.y != nil {
                            map["Y"] = self.y!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("H") {
                            self.h = dict["H"] as! Int32
                        }
                        if dict.keys.contains("W") {
                            self.w = dict["W"] as! Int32
                        }
                        if dict.keys.contains("X") {
                            self.x = dict["X"] as! Int32
                        }
                        if dict.keys.contains("Y") {
                            self.y = dict["Y"] as! Int32
                        }
                    }
                }
                public var boxPosition: SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData.BoxPosition?

                public var timestamp: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.boxPosition?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.boxPosition != nil {
                        map["BoxPosition"] = self.boxPosition?.toMap()
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BoxPosition") {
                        var model = SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData.BoxPosition()
                        model.fromMap(dict["BoxPosition"] as! [String: Any])
                        self.boxPosition = model
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                }
            }
            public var endTime: Double?

            public var startTime: Double?

            public var trackData: [SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.trackData != nil {
                    var tmp : [Any] = []
                    for k in self.trackData! {
                        tmp.append(k.toMap())
                    }
                    map["TrackData"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Double
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Double
                }
                if dict.keys.contains("TrackData") {
                    var tmp : [SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData] = []
                    for v in dict["TrackData"] as! [Any] {
                        var model = SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.trackData = tmp
                }
            }
        }
        public var category: String?

        public var entityId: String?

        public var labelName: String?

        public var occurrencesInfos: [SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos]?

        public var score: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.entityId != nil {
                map["EntityId"] = self.entityId!
            }
            if self.labelName != nil {
                map["LabelName"] = self.labelName!
            }
            if self.occurrencesInfos != nil {
                var tmp : [Any] = []
                for k in self.occurrencesInfos! {
                    tmp.append(k.toMap())
                }
                map["OccurrencesInfos"] = tmp
            }
            if self.score != nil {
                map["Score"] = self.score!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("EntityId") {
                self.entityId = dict["EntityId"] as! String
            }
            if dict.keys.contains("LabelName") {
                self.labelName = dict["LabelName"] as! String
            }
            if dict.keys.contains("OccurrencesInfos") {
                var tmp : [SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos] = []
                for v in dict["OccurrencesInfos"] as! [Any] {
                    var model = SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.occurrencesInfos = tmp
            }
            if dict.keys.contains("Score") {
                self.score = dict["Score"] as! Double
            }
        }
    }
    public var code: String?

    public var mediaClipList: [SearchMediaClipByFaceResponseBody.MediaClipList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaClipList != nil {
            var tmp : [Any] = []
            for k in self.mediaClipList! {
                tmp.append(k.toMap())
            }
            map["MediaClipList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaClipList") {
            var tmp : [SearchMediaClipByFaceResponseBody.MediaClipList] = []
            for v in dict["MediaClipList"] as! [Any] {
                var model = SearchMediaClipByFaceResponseBody.MediaClipList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaClipList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaClipByFaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaClipByFaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaClipByFaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchPublicMediaInfoRequest : Tea.TeaModel {
    public var authorized: Bool?

    public var dynamicMetaDataMatchFields: String?

    public var entityId: String?

    public var favorite: Bool?

    public var mediaIds: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorized != nil {
            map["Authorized"] = self.authorized!
        }
        if self.dynamicMetaDataMatchFields != nil {
            map["DynamicMetaDataMatchFields"] = self.dynamicMetaDataMatchFields!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.favorite != nil {
            map["Favorite"] = self.favorite!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Authorized") {
            self.authorized = dict["Authorized"] as! Bool
        }
        if dict.keys.contains("DynamicMetaDataMatchFields") {
            self.dynamicMetaDataMatchFields = dict["DynamicMetaDataMatchFields"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("Favorite") {
            self.favorite = dict["Favorite"] as! Bool
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class SearchPublicMediaInfoResponseBody : Tea.TeaModel {
    public class PublicMediaInfos : Tea.TeaModel {
        public class MediaInfo : Tea.TeaModel {
            public class DynamicMetaData : Tea.TeaModel {
                public var data: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.data != nil {
                        map["Data"] = self.data!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Data") {
                        self.data = dict["Data"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class MediaBasicInfo : Tea.TeaModel {
                public var businessType: String?

                public var category: String?

                public var coverURL: String?

                public var createTime: String?

                public var deletedTime: String?

                public var description_: String?

                public var mediaId: String?

                public var mediaTags: String?

                public var mediaType: String?

                public var modifiedTime: String?

                public var source: String?

                public var spriteImages: String?

                public var status: String?

                public var title: String?

                public var userData: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.businessType != nil {
                        map["BusinessType"] = self.businessType!
                    }
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.coverURL != nil {
                        map["CoverURL"] = self.coverURL!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.deletedTime != nil {
                        map["DeletedTime"] = self.deletedTime!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.mediaTags != nil {
                        map["MediaTags"] = self.mediaTags!
                    }
                    if self.mediaType != nil {
                        map["MediaType"] = self.mediaType!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.source != nil {
                        map["Source"] = self.source!
                    }
                    if self.spriteImages != nil {
                        map["SpriteImages"] = self.spriteImages!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BusinessType") {
                        self.businessType = dict["BusinessType"] as! String
                    }
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("CoverURL") {
                        self.coverURL = dict["CoverURL"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("DeletedTime") {
                        self.deletedTime = dict["DeletedTime"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("MediaTags") {
                        self.mediaTags = dict["MediaTags"] as! String
                    }
                    if dict.keys.contains("MediaType") {
                        self.mediaType = dict["MediaType"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Source") {
                        self.source = dict["Source"] as! String
                    }
                    if dict.keys.contains("SpriteImages") {
                        self.spriteImages = dict["SpriteImages"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Title") {
                        self.title = dict["Title"] as! String
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                }
            }
            public var dynamicMetaData: SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.DynamicMetaData?

            public var mediaBasicInfo: SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.MediaBasicInfo?

            public var mediaId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dynamicMetaData?.validate()
                try self.mediaBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dynamicMetaData != nil {
                    map["DynamicMetaData"] = self.dynamicMetaData?.toMap()
                }
                if self.mediaBasicInfo != nil {
                    map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DynamicMetaData") {
                    var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.DynamicMetaData()
                    model.fromMap(dict["DynamicMetaData"] as! [String: Any])
                    self.dynamicMetaData = model
                }
                if dict.keys.contains("MediaBasicInfo") {
                    var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.MediaBasicInfo()
                    model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                    self.mediaBasicInfo = model
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
            }
        }
        public var authorized: Bool?

        public var favorite: Bool?

        public var mediaInfo: SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo?

        public var remainingAuthTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorized != nil {
                map["Authorized"] = self.authorized!
            }
            if self.favorite != nil {
                map["Favorite"] = self.favorite!
            }
            if self.mediaInfo != nil {
                map["MediaInfo"] = self.mediaInfo?.toMap()
            }
            if self.remainingAuthTime != nil {
                map["RemainingAuthTime"] = self.remainingAuthTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Authorized") {
                self.authorized = dict["Authorized"] as! Bool
            }
            if dict.keys.contains("Favorite") {
                self.favorite = dict["Favorite"] as! Bool
            }
            if dict.keys.contains("MediaInfo") {
                var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo()
                model.fromMap(dict["MediaInfo"] as! [String: Any])
                self.mediaInfo = model
            }
            if dict.keys.contains("RemainingAuthTime") {
                self.remainingAuthTime = dict["RemainingAuthTime"] as! String
            }
        }
    }
    public var publicMediaInfos: [SearchPublicMediaInfoResponseBody.PublicMediaInfos]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.publicMediaInfos != nil {
            var tmp : [Any] = []
            for k in self.publicMediaInfos! {
                tmp.append(k.toMap())
            }
            map["PublicMediaInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PublicMediaInfos") {
            var tmp : [SearchPublicMediaInfoResponseBody.PublicMediaInfos] = []
            for v in dict["PublicMediaInfos"] as! [Any] {
                var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.publicMediaInfos = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchPublicMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchPublicMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchPublicMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendLiveSnapshotJobCommandRequest : Tea.TeaModel {
    public var command: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class SendLiveSnapshotJobCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendLiveSnapshotJobCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendLiveSnapshotJobCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendLiveSnapshotJobCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendLiveTranscodeJobCommandRequest : Tea.TeaModel {
    public var command: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class SendLiveTranscodeJobCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendLiveTranscodeJobCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendLiveTranscodeJobCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendLiveTranscodeJobCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetContentAnalyzeConfigRequest : Tea.TeaModel {
    public var auto: Bool?

    public var saveType: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.auto != nil {
            map["Auto"] = self.auto!
        }
        if self.saveType != nil {
            map["SaveType"] = self.saveType!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Auto") {
            self.auto = dict["Auto"] as! Bool
        }
        if dict.keys.contains("SaveType") {
            self.saveType = dict["SaveType"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SetContentAnalyzeConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetContentAnalyzeConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetContentAnalyzeConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetContentAnalyzeConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultCustomTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SetDefaultCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetDefaultCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDefaultCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultStorageLocationRequest : Tea.TeaModel {
    public var bucket: String?

    public var path: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class SetDefaultStorageLocationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetDefaultStorageLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultStorageLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDefaultStorageLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetEventCallbackRequest : Tea.TeaModel {
    public var authKey: String?

    public var authSwitch: String?

    public var callbackQueueName: String?

    public var callbackType: String?

    public var callbackURL: String?

    public var eventTypeList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.authSwitch != nil {
            map["AuthSwitch"] = self.authSwitch!
        }
        if self.callbackQueueName != nil {
            map["CallbackQueueName"] = self.callbackQueueName!
        }
        if self.callbackType != nil {
            map["CallbackType"] = self.callbackType!
        }
        if self.callbackURL != nil {
            map["CallbackURL"] = self.callbackURL!
        }
        if self.eventTypeList != nil {
            map["EventTypeList"] = self.eventTypeList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthKey") {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("AuthSwitch") {
            self.authSwitch = dict["AuthSwitch"] as! String
        }
        if dict.keys.contains("CallbackQueueName") {
            self.callbackQueueName = dict["CallbackQueueName"] as! String
        }
        if dict.keys.contains("CallbackType") {
            self.callbackType = dict["CallbackType"] as! String
        }
        if dict.keys.contains("CallbackURL") {
            self.callbackURL = dict["CallbackURL"] as! String
        }
        if dict.keys.contains("EventTypeList") {
            self.eventTypeList = dict["EventTypeList"] as! String
        }
    }
}

public class SetEventCallbackResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetEventCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetEventCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetEventCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartWorkflowRequest : Tea.TeaModel {
    public var taskInput: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskInput != nil {
            map["TaskInput"] = self.taskInput!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskInput") {
            self.taskInput = dict["TaskInput"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class StartWorkflowResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class StartWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitASRJobRequest : Tea.TeaModel {
    public var description_: String?

    public var duration: String?

    public var inputFile: String?

    public var startTime: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.inputFile != nil {
            map["InputFile"] = self.inputFile!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("InputFile") {
            self.inputFile = dict["InputFile"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitASRJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class SubmitASRJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitASRJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitASRJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAudioProduceJobRequest : Tea.TeaModel {
    public var description_: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var overwrite: Bool?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditingConfig") {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Overwrite") {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAudioProduceJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class SubmitAudioProduceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAudioProduceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAudioProduceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAvatarTrainingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class SubmitAvatarTrainingJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitAvatarTrainingJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitAvatarTrainingJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitAvatarTrainingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAvatarTrainingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAvatarTrainingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAvatarVideoJobRequest : Tea.TeaModel {
    public var description_: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditingConfig") {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAvatarVideoJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAvatarVideoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAvatarVideoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAvatarVideoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitBatchMediaProducingJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EditingConfig") {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitBatchMediaProducingJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitBatchMediaProducingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitBatchMediaProducingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitBatchMediaProducingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitCustomizedVoiceJobRequest : Tea.TeaModel {
    public var demoAudioMediaURL: String?

    public var voiceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.demoAudioMediaURL != nil {
            map["DemoAudioMediaURL"] = self.demoAudioMediaURL!
        }
        if self.voiceId != nil {
            map["VoiceId"] = self.voiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DemoAudioMediaURL") {
            self.demoAudioMediaURL = dict["DemoAudioMediaURL"] as! String
        }
        if dict.keys.contains("VoiceId") {
            self.voiceId = dict["VoiceId"] as! String
        }
    }
}

public class SubmitCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public var voiceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.voiceId != nil {
                map["VoiceId"] = self.voiceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("VoiceId") {
                self.voiceId = dict["VoiceId"] as! String
            }
        }
    }
    public var data: SubmitCustomizedVoiceJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitCustomizedVoiceJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDNAJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var config: String?

    public var DBId: String?

    public var input: SubmitDNAJobRequest.Input?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var primaryKey: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.primaryKey != nil {
            map["PrimaryKey"] = self.primaryKey!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("DBId") {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitDNAJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("PrimaryKey") {
            self.primaryKey = dict["PrimaryKey"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDNAJobShrinkRequest : Tea.TeaModel {
    public var config: String?

    public var DBId: String?

    public var inputShrink: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var primaryKey: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.primaryKey != nil {
            map["PrimaryKey"] = self.primaryKey!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("DBId") {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("PrimaryKey") {
            self.primaryKey = dict["PrimaryKey"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDNAJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDNAJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDNAJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitDNAJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDynamicChartJobRequest : Tea.TeaModel {
    public var axisParams: String?

    public var background: String?

    public var chartConfig: String?

    public var chartTitle: String?

    public var chartType: String?

    public var dataSource: String?

    public var description_: String?

    public var input: String?

    public var outputConfig: String?

    public var subtitle: String?

    public var title: String?

    public var unit: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.axisParams != nil {
            map["AxisParams"] = self.axisParams!
        }
        if self.background != nil {
            map["Background"] = self.background!
        }
        if self.chartConfig != nil {
            map["ChartConfig"] = self.chartConfig!
        }
        if self.chartTitle != nil {
            map["ChartTitle"] = self.chartTitle!
        }
        if self.chartType != nil {
            map["ChartType"] = self.chartType!
        }
        if self.dataSource != nil {
            map["DataSource"] = self.dataSource!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.subtitle != nil {
            map["Subtitle"] = self.subtitle!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.unit != nil {
            map["Unit"] = self.unit!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AxisParams") {
            self.axisParams = dict["AxisParams"] as! String
        }
        if dict.keys.contains("Background") {
            self.background = dict["Background"] as! String
        }
        if dict.keys.contains("ChartConfig") {
            self.chartConfig = dict["ChartConfig"] as! String
        }
        if dict.keys.contains("ChartTitle") {
            self.chartTitle = dict["ChartTitle"] as! String
        }
        if dict.keys.contains("ChartType") {
            self.chartType = dict["ChartType"] as! String
        }
        if dict.keys.contains("DataSource") {
            self.dataSource = dict["DataSource"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Subtitle") {
            self.subtitle = dict["Subtitle"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("Unit") {
            self.unit = dict["Unit"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDynamicChartJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDynamicChartJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDynamicChartJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitDynamicChartJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDynamicImageJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public class TemplateConfig : Tea.TeaModel {
        public class OverwriteParams : Tea.TeaModel {
            public class TimeSpan : Tea.TeaModel {
                public var duration: String?

                public var end: String?

                public var seek: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.end != nil {
                        map["End"] = self.end!
                    }
                    if self.seek != nil {
                        map["Seek"] = self.seek!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("End") {
                        self.end = dict["End"] as! String
                    }
                    if dict.keys.contains("Seek") {
                        self.seek = dict["Seek"] as! String
                    }
                }
            }
            public var format: String?

            public var fps: Int32?

            public var height: Int32?

            public var longShortMode: Bool?

            public var scanMode: String?

            public var timeSpan: SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams.TimeSpan?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.timeSpan?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.longShortMode != nil {
                    map["LongShortMode"] = self.longShortMode!
                }
                if self.scanMode != nil {
                    map["ScanMode"] = self.scanMode!
                }
                if self.timeSpan != nil {
                    map["TimeSpan"] = self.timeSpan?.toMap()
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! Int32
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("LongShortMode") {
                    self.longShortMode = dict["LongShortMode"] as! Bool
                }
                if dict.keys.contains("ScanMode") {
                    self.scanMode = dict["ScanMode"] as! String
                }
                if dict.keys.contains("TimeSpan") {
                    var model = SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams.TimeSpan()
                    model.fromMap(dict["TimeSpan"] as! [String: Any])
                    self.timeSpan = model
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var overwriteParams: SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.overwriteParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.overwriteParams != nil {
                map["OverwriteParams"] = self.overwriteParams?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OverwriteParams") {
                var model = SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams()
                model.fromMap(dict["OverwriteParams"] as! [String: Any])
                self.overwriteParams = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var input: SubmitDynamicImageJobRequest.Input?

    public var name: String?

    public var output: SubmitDynamicImageJobRequest.Output?

    public var scheduleConfig: SubmitDynamicImageJobRequest.ScheduleConfig?

    public var templateConfig: SubmitDynamicImageJobRequest.TemplateConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitDynamicImageJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitDynamicImageJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitDynamicImageJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateConfig") {
            var model = SubmitDynamicImageJobRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDynamicImageJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var templateConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDynamicImageJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDynamicImageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDynamicImageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitDynamicImageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitIProductionJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var functionName: String?

    public var input: SubmitIProductionJobRequest.Input?

    public var jobParams: String?

    public var name: String?

    public var output: SubmitIProductionJobRequest.Output?

    public var scheduleConfig: SubmitIProductionJobRequest.ScheduleConfig?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitIProductionJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("JobParams") {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitIProductionJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitIProductionJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitIProductionJobShrinkRequest : Tea.TeaModel {
    public var functionName: String?

    public var inputShrink: String?

    public var jobParams: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("JobParams") {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitIProductionJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitIProductionJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitIProductionJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitIProductionJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveEditingJobRequest : Tea.TeaModel {
    public var clips: String?

    public var liveStreamConfig: String?

    public var mediaProduceConfig: String?

    public var outputMediaConfig: String?

    public var outputMediaTarget: String?

    public var projectId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clips != nil {
            map["Clips"] = self.clips!
        }
        if self.liveStreamConfig != nil {
            map["LiveStreamConfig"] = self.liveStreamConfig!
        }
        if self.mediaProduceConfig != nil {
            map["MediaProduceConfig"] = self.mediaProduceConfig!
        }
        if self.outputMediaConfig != nil {
            map["OutputMediaConfig"] = self.outputMediaConfig!
        }
        if self.outputMediaTarget != nil {
            map["OutputMediaTarget"] = self.outputMediaTarget!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clips") {
            self.clips = dict["Clips"] as! String
        }
        if dict.keys.contains("LiveStreamConfig") {
            self.liveStreamConfig = dict["LiveStreamConfig"] as! String
        }
        if dict.keys.contains("MediaProduceConfig") {
            self.mediaProduceConfig = dict["MediaProduceConfig"] as! String
        }
        if dict.keys.contains("OutputMediaConfig") {
            self.outputMediaConfig = dict["OutputMediaConfig"] as! String
        }
        if dict.keys.contains("OutputMediaTarget") {
            self.outputMediaTarget = dict["OutputMediaTarget"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitLiveEditingJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var mediaURL: String?

    public var projectId: String?

    public var requestId: String?

    public var vodMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaURL != nil {
            map["MediaURL"] = self.mediaURL!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodMediaId != nil {
            map["VodMediaId"] = self.vodMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaURL") {
            self.mediaURL = dict["MediaURL"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodMediaId") {
            self.vodMediaId = dict["VodMediaId"] as! String
        }
    }
}

public class SubmitLiveEditingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveEditingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitLiveEditingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveRecordJobRequest : Tea.TeaModel {
    public class RecordOutput : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class StreamInput : Tea.TeaModel {
        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var name: String?

    public var notifyUrl: String?

    public var recordOutput: SubmitLiveRecordJobRequest.RecordOutput?

    public var streamInput: SubmitLiveRecordJobRequest.StreamInput?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordOutput?.validate()
        try self.streamInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.recordOutput != nil {
            map["RecordOutput"] = self.recordOutput?.toMap()
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("RecordOutput") {
            var model = SubmitLiveRecordJobRequest.RecordOutput()
            model.fromMap(dict["RecordOutput"] as! [String: Any])
            self.recordOutput = model
        }
        if dict.keys.contains("StreamInput") {
            var model = SubmitLiveRecordJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveRecordJobShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var notifyUrl: String?

    public var recordOutputShrink: String?

    public var streamInputShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.recordOutputShrink != nil {
            map["RecordOutput"] = self.recordOutputShrink!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("RecordOutput") {
            self.recordOutputShrink = dict["RecordOutput"] as! String
        }
        if dict.keys.contains("StreamInput") {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveRecordJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitLiveRecordJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveRecordJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitLiveRecordJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveSnapshotJobRequest : Tea.TeaModel {
    public class SnapshotOutput : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("StorageType") {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public class StreamInput : Tea.TeaModel {
        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var callbackUrl: String?

    public var jobName: String?

    public var snapshotOutput: SubmitLiveSnapshotJobRequest.SnapshotOutput?

    public var streamInput: SubmitLiveSnapshotJobRequest.StreamInput?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotOutput?.validate()
        try self.streamInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.snapshotOutput != nil {
            map["SnapshotOutput"] = self.snapshotOutput?.toMap()
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("SnapshotOutput") {
            var model = SubmitLiveSnapshotJobRequest.SnapshotOutput()
            model.fromMap(dict["SnapshotOutput"] as! [String: Any])
            self.snapshotOutput = model
        }
        if dict.keys.contains("StreamInput") {
            var model = SubmitLiveSnapshotJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveSnapshotJobShrinkRequest : Tea.TeaModel {
    public var callbackUrl: String?

    public var jobName: String?

    public var snapshotOutputShrink: String?

    public var streamInputShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.snapshotOutputShrink != nil {
            map["SnapshotOutput"] = self.snapshotOutputShrink!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("SnapshotOutput") {
            self.snapshotOutputShrink = dict["SnapshotOutput"] as! String
        }
        if dict.keys.contains("StreamInput") {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveSnapshotJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitLiveSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitLiveSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveTranscodeJobRequest : Tea.TeaModel {
    public class StreamInput : Tea.TeaModel {
        public var inputUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputUrl") {
                self.inputUrl = dict["InputUrl"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class TimedConfig : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class TranscodeOutput : Tea.TeaModel {
        public var domainName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var name: String?

    public var startMode: Int32?

    public var streamInput: SubmitLiveTranscodeJobRequest.StreamInput?

    public var templateId: String?

    public var timedConfig: SubmitLiveTranscodeJobRequest.TimedConfig?

    public var transcodeOutput: SubmitLiveTranscodeJobRequest.TranscodeOutput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamInput?.validate()
        try self.timedConfig?.validate()
        try self.transcodeOutput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.startMode != nil {
            map["StartMode"] = self.startMode!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timedConfig != nil {
            map["TimedConfig"] = self.timedConfig?.toMap()
        }
        if self.transcodeOutput != nil {
            map["TranscodeOutput"] = self.transcodeOutput?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StartMode") {
            self.startMode = dict["StartMode"] as! Int32
        }
        if dict.keys.contains("StreamInput") {
            var model = SubmitLiveTranscodeJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TimedConfig") {
            var model = SubmitLiveTranscodeJobRequest.TimedConfig()
            model.fromMap(dict["TimedConfig"] as! [String: Any])
            self.timedConfig = model
        }
        if dict.keys.contains("TranscodeOutput") {
            var model = SubmitLiveTranscodeJobRequest.TranscodeOutput()
            model.fromMap(dict["TranscodeOutput"] as! [String: Any])
            self.transcodeOutput = model
        }
    }
}

public class SubmitLiveTranscodeJobShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var startMode: Int32?

    public var streamInputShrink: String?

    public var templateId: String?

    public var timedConfigShrink: String?

    public var transcodeOutputShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.startMode != nil {
            map["StartMode"] = self.startMode!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timedConfigShrink != nil {
            map["TimedConfig"] = self.timedConfigShrink!
        }
        if self.transcodeOutputShrink != nil {
            map["TranscodeOutput"] = self.transcodeOutputShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StartMode") {
            self.startMode = dict["StartMode"] as! Int32
        }
        if dict.keys.contains("StreamInput") {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TimedConfig") {
            self.timedConfigShrink = dict["TimedConfig"] as! String
        }
        if dict.keys.contains("TranscodeOutput") {
            self.transcodeOutputShrink = dict["TranscodeOutput"] as! String
        }
    }
}

public class SubmitLiveTranscodeJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaCensorJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var barrages: String?

    public var coverImages: String?

    public var description_: String?

    public var input: SubmitMediaCensorJobRequest.Input?

    public var notifyUrl: String?

    public var output: String?

    public var scheduleConfig: SubmitMediaCensorJobRequest.ScheduleConfig?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.barrages != nil {
            map["Barrages"] = self.barrages!
        }
        if self.coverImages != nil {
            map["CoverImages"] = self.coverImages!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Barrages") {
            self.barrages = dict["Barrages"] as! String
        }
        if dict.keys.contains("CoverImages") {
            self.coverImages = dict["CoverImages"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitMediaCensorJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitMediaCensorJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaCensorJobShrinkRequest : Tea.TeaModel {
    public var barrages: String?

    public var coverImages: String?

    public var description_: String?

    public var inputShrink: String?

    public var notifyUrl: String?

    public var output: String?

    public var scheduleConfigShrink: String?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.barrages != nil {
            map["Barrages"] = self.barrages!
        }
        if self.coverImages != nil {
            map["CoverImages"] = self.coverImages!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Barrages") {
            self.barrages = dict["Barrages"] as! String
        }
        if dict.keys.contains("CoverImages") {
            self.coverImages = dict["CoverImages"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaCensorJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaCensorJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaCensorJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaCensorJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaInfoJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var input: SubmitMediaInfoJobRequest.Input?

    public var name: String?

    public var scheduleConfig: SubmitMediaInfoJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitMediaInfoJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitMediaInfoJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaInfoJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    var tmp : [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    var tmp : [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: SubmitMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var mediaInfoProperty: SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: SubmitMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: SubmitMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") {
            var model = SubmitMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaProducingJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var clipsParam: String?

    public var editingProduceConfig: String?

    public var mediaMetadata: String?

    public var outputMediaConfig: String?

    public var outputMediaTarget: String?

    public var projectId: String?

    public var projectMetadata: String?

    public var source: String?

    public var templateId: String?

    public var timeline: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clipsParam != nil {
            map["ClipsParam"] = self.clipsParam!
        }
        if self.editingProduceConfig != nil {
            map["EditingProduceConfig"] = self.editingProduceConfig!
        }
        if self.mediaMetadata != nil {
            map["MediaMetadata"] = self.mediaMetadata!
        }
        if self.outputMediaConfig != nil {
            map["OutputMediaConfig"] = self.outputMediaConfig!
        }
        if self.outputMediaTarget != nil {
            map["OutputMediaTarget"] = self.outputMediaTarget!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectMetadata != nil {
            map["ProjectMetadata"] = self.projectMetadata!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ClipsParam") {
            self.clipsParam = dict["ClipsParam"] as! String
        }
        if dict.keys.contains("EditingProduceConfig") {
            self.editingProduceConfig = dict["EditingProduceConfig"] as! String
        }
        if dict.keys.contains("MediaMetadata") {
            self.mediaMetadata = dict["MediaMetadata"] as! String
        }
        if dict.keys.contains("OutputMediaConfig") {
            self.outputMediaConfig = dict["OutputMediaConfig"] as! String
        }
        if dict.keys.contains("OutputMediaTarget") {
            self.outputMediaTarget = dict["OutputMediaTarget"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectMetadata") {
            self.projectMetadata = dict["ProjectMetadata"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaProducingJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var projectId: String?

    public var requestId: String?

    public var vodMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodMediaId != nil {
            map["VodMediaId"] = self.vodMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodMediaId") {
            self.vodMediaId = dict["VodMediaId"] as! String
        }
    }
}

public class SubmitMediaProducingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaProducingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaProducingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitPackageJobRequest : Tea.TeaModel {
    public class Inputs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var input: SubmitPackageJobRequest.Inputs.Input?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Input") {
                var model = SubmitPackageJobRequest.Inputs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var inputs: [SubmitPackageJobRequest.Inputs]?

    public var name: String?

    public var output: SubmitPackageJobRequest.Output?

    public var scheduleConfig: SubmitPackageJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.output?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputs != nil {
            var tmp : [Any] = []
            for k in self.inputs! {
                tmp.append(k.toMap())
            }
            map["Inputs"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Inputs") {
            var tmp : [SubmitPackageJobRequest.Inputs] = []
            for v in dict["Inputs"] as! [Any] {
                var model = SubmitPackageJobRequest.Inputs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inputs = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitPackageJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitPackageJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitPackageJobShrinkRequest : Tea.TeaModel {
    public var inputsShrink: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputsShrink != nil {
            map["Inputs"] = self.inputsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Inputs") {
            self.inputsShrink = dict["Inputs"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitPackageJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitPackageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitPackageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitPackageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSmarttagJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
        }
    }
    public var content: String?

    public var contentAddr: String?

    public var contentType: String?

    public var input: SubmitSmarttagJobRequest.Input?

    public var notifyUrl: String?

    public var params: String?

    public var scheduleConfig: SubmitSmarttagJobRequest.ScheduleConfig?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentAddr != nil {
            map["ContentAddr"] = self.contentAddr!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentAddr") {
            self.contentAddr = dict["ContentAddr"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitSmarttagJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitSmarttagJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSmarttagJobShrinkRequest : Tea.TeaModel {
    public var content: String?

    public var contentAddr: String?

    public var contentType: String?

    public var inputShrink: String?

    public var notifyUrl: String?

    public var params: String?

    public var scheduleConfigShrink: String?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentAddr != nil {
            map["ContentAddr"] = self.contentAddr!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentAddr") {
            self.contentAddr = dict["ContentAddr"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSmarttagJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSmarttagJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSmarttagJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSmarttagJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSnapshotJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
        }
    }
    public class TemplateConfig : Tea.TeaModel {
        public class OverwriteParams : Tea.TeaModel {
            public class SpriteSnapshotConfig : Tea.TeaModel {
                public var cellHeight: Int32?

                public var cellWidth: Int32?

                public var color: String?

                public var columns: Int32?

                public var lines: Int32?

                public var margin: Int32?

                public var padding: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cellHeight != nil {
                        map["CellHeight"] = self.cellHeight!
                    }
                    if self.cellWidth != nil {
                        map["CellWidth"] = self.cellWidth!
                    }
                    if self.color != nil {
                        map["Color"] = self.color!
                    }
                    if self.columns != nil {
                        map["Columns"] = self.columns!
                    }
                    if self.lines != nil {
                        map["Lines"] = self.lines!
                    }
                    if self.margin != nil {
                        map["Margin"] = self.margin!
                    }
                    if self.padding != nil {
                        map["Padding"] = self.padding!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CellHeight") {
                        self.cellHeight = dict["CellHeight"] as! Int32
                    }
                    if dict.keys.contains("CellWidth") {
                        self.cellWidth = dict["CellWidth"] as! Int32
                    }
                    if dict.keys.contains("Color") {
                        self.color = dict["Color"] as! String
                    }
                    if dict.keys.contains("Columns") {
                        self.columns = dict["Columns"] as! Int32
                    }
                    if dict.keys.contains("Lines") {
                        self.lines = dict["Lines"] as! Int32
                    }
                    if dict.keys.contains("Margin") {
                        self.margin = dict["Margin"] as! Int32
                    }
                    if dict.keys.contains("Padding") {
                        self.padding = dict["Padding"] as! Int32
                    }
                }
            }
            public var blackLevel: Int32?

            public var count: Int64?

            public var frameType: String?

            public var height: Int32?

            public var interval: Int64?

            public var isSptFrag: Bool?

            public var pixelBlackThreshold: Int32?

            public var spriteSnapshotConfig: SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams.SpriteSnapshotConfig?

            public var time: Int64?

            public var type: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.spriteSnapshotConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blackLevel != nil {
                    map["BlackLevel"] = self.blackLevel!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.frameType != nil {
                    map["FrameType"] = self.frameType!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.isSptFrag != nil {
                    map["IsSptFrag"] = self.isSptFrag!
                }
                if self.pixelBlackThreshold != nil {
                    map["PixelBlackThreshold"] = self.pixelBlackThreshold!
                }
                if self.spriteSnapshotConfig != nil {
                    map["SpriteSnapshotConfig"] = self.spriteSnapshotConfig?.toMap()
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlackLevel") {
                    self.blackLevel = dict["BlackLevel"] as! Int32
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("FrameType") {
                    self.frameType = dict["FrameType"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("IsSptFrag") {
                    self.isSptFrag = dict["IsSptFrag"] as! Bool
                }
                if dict.keys.contains("PixelBlackThreshold") {
                    self.pixelBlackThreshold = dict["PixelBlackThreshold"] as! Int32
                }
                if dict.keys.contains("SpriteSnapshotConfig") {
                    var model = SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams.SpriteSnapshotConfig()
                    model.fromMap(dict["SpriteSnapshotConfig"] as! [String: Any])
                    self.spriteSnapshotConfig = model
                }
                if dict.keys.contains("Time") {
                    self.time = dict["Time"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var overwriteParams: SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.overwriteParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.overwriteParams != nil {
                map["OverwriteParams"] = self.overwriteParams?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OverwriteParams") {
                var model = SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams()
                model.fromMap(dict["OverwriteParams"] as! [String: Any])
                self.overwriteParams = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var input: SubmitSnapshotJobRequest.Input?

    public var name: String?

    public var output: SubmitSnapshotJobRequest.Output?

    public var scheduleConfig: SubmitSnapshotJobRequest.ScheduleConfig?

    public var templateConfig: SubmitSnapshotJobRequest.TemplateConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitSnapshotJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitSnapshotJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitSnapshotJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateConfig") {
            var model = SubmitSnapshotJobRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSnapshotJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var templateConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSnapshotJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitStandardCustomizedVoiceJobRequest : Tea.TeaModel {
    public var audios: String?

    public var authentication: String?

    public var demoAudioMediaURL: String?

    public var gender: String?

    public var voiceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audios != nil {
            map["Audios"] = self.audios!
        }
        if self.authentication != nil {
            map["Authentication"] = self.authentication!
        }
        if self.demoAudioMediaURL != nil {
            map["DemoAudioMediaURL"] = self.demoAudioMediaURL!
        }
        if self.gender != nil {
            map["Gender"] = self.gender!
        }
        if self.voiceName != nil {
            map["VoiceName"] = self.voiceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Audios") {
            self.audios = dict["Audios"] as! String
        }
        if dict.keys.contains("Authentication") {
            self.authentication = dict["Authentication"] as! String
        }
        if dict.keys.contains("DemoAudioMediaURL") {
            self.demoAudioMediaURL = dict["DemoAudioMediaURL"] as! String
        }
        if dict.keys.contains("Gender") {
            self.gender = dict["Gender"] as! String
        }
        if dict.keys.contains("VoiceName") {
            self.voiceName = dict["VoiceName"] as! String
        }
    }
}

public class SubmitStandardCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitStandardCustomizedVoiceJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitStandardCustomizedVoiceJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitStandardCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitStandardCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitStandardCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSyncMediaInfoJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var input: SubmitSyncMediaInfoJobRequest.Input?

    public var name: String?

    public var scheduleConfig: SubmitSyncMediaInfoJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitSyncMediaInfoJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitSyncMediaInfoJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSyncMediaInfoJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSyncMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    var tmp : [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    var tmp : [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var mediaInfoProperty: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") {
                var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") {
            var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSyncMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSyncMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSyncMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTextGenerateJobRequest : Tea.TeaModel {
    public var description_: String?

    public var generateConfig: String?

    public var title: String?

    public var type: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.generateConfig != nil {
            map["GenerateConfig"] = self.generateConfig!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GenerateConfig") {
            self.generateConfig = dict["GenerateConfig"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTextGenerateJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitTextGenerateJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTextGenerateJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitTextGenerateJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTranscodeJobRequest : Tea.TeaModel {
    public class InputGroup : Tea.TeaModel {
        public var inputUrl: String?

        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputUrl") {
                self.inputUrl = dict["InputUrl"] as! String
            }
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class OutputGroup : Tea.TeaModel {
        public class Output : Tea.TeaModel {
            public var media: String?

            public var outputUrl: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.outputUrl != nil {
                    map["OutputUrl"] = self.outputUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OutputUrl") {
                    self.outputUrl = dict["OutputUrl"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class ProcessConfig : Tea.TeaModel {
            public class CombineConfigs : Tea.TeaModel {
                public var audioIndex: String?

                public var duration: Double?

                public var start: Double?

                public var videoIndex: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioIndex != nil {
                        map["AudioIndex"] = self.audioIndex!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.start != nil {
                        map["Start"] = self.start!
                    }
                    if self.videoIndex != nil {
                        map["VideoIndex"] = self.videoIndex!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioIndex") {
                        self.audioIndex = dict["AudioIndex"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Double
                    }
                    if dict.keys.contains("Start") {
                        self.start = dict["Start"] as! Double
                    }
                    if dict.keys.contains("VideoIndex") {
                        self.videoIndex = dict["VideoIndex"] as! String
                    }
                }
            }
            public class Encryption : Tea.TeaModel {
                public var cipherText: String?

                public var decryptKeyUri: String?

                public var encryptType: String?

                public var keyServiceType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cipherText != nil {
                        map["CipherText"] = self.cipherText!
                    }
                    if self.decryptKeyUri != nil {
                        map["DecryptKeyUri"] = self.decryptKeyUri!
                    }
                    if self.encryptType != nil {
                        map["EncryptType"] = self.encryptType!
                    }
                    if self.keyServiceType != nil {
                        map["KeyServiceType"] = self.keyServiceType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CipherText") {
                        self.cipherText = dict["CipherText"] as! String
                    }
                    if dict.keys.contains("DecryptKeyUri") {
                        self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                    }
                    if dict.keys.contains("EncryptType") {
                        self.encryptType = dict["EncryptType"] as! String
                    }
                    if dict.keys.contains("KeyServiceType") {
                        self.keyServiceType = dict["KeyServiceType"] as! String
                    }
                }
            }
            public class ImageWatermarks : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var media: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.media != nil {
                                map["Media"] = self.media!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Media") {
                                self.media = dict["Media"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public class Timeline : Tea.TeaModel {
                        public var duration: String?

                        public var start: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                        }
                    }
                    public var dx: String?

                    public var dy: String?

                    public var file: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                    public var height: String?

                    public var referPos: String?

                    public var timeline: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                        try self.timeline?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dx != nil {
                            map["Dx"] = self.dx!
                        }
                        if self.dy != nil {
                            map["Dy"] = self.dy!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.referPos != nil {
                            map["ReferPos"] = self.referPos!
                        }
                        if self.timeline != nil {
                            map["Timeline"] = self.timeline?.toMap()
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Dx") {
                            self.dx = dict["Dx"] as! String
                        }
                        if dict.keys.contains("Dy") {
                            self.dy = dict["Dy"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("ReferPos") {
                            self.referPos = dict["ReferPos"] as! String
                        }
                        if dict.keys.contains("Timeline") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                            model.fromMap(dict["Timeline"] as! [String: Any])
                            self.timeline = model
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public class Subtitles : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var media: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.media != nil {
                                map["Media"] = self.media!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Media") {
                                self.media = dict["Media"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public var charEnc: String?

                    public var file: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                    public var format: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.charEnc != nil {
                            map["CharEnc"] = self.charEnc!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CharEnc") {
                            self.charEnc = dict["CharEnc"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public class TextWatermarks : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public var adaptive: String?

                    public var borderColor: String?

                    public var borderWidth: Int32?

                    public var content: String?

                    public var fontAlpha: String?

                    public var fontColor: String?

                    public var fontName: String?

                    public var fontSize: Int32?

                    public var left_: String?

                    public var top: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adaptive != nil {
                            map["Adaptive"] = self.adaptive!
                        }
                        if self.borderColor != nil {
                            map["BorderColor"] = self.borderColor!
                        }
                        if self.borderWidth != nil {
                            map["BorderWidth"] = self.borderWidth!
                        }
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.fontAlpha != nil {
                            map["FontAlpha"] = self.fontAlpha!
                        }
                        if self.fontColor != nil {
                            map["FontColor"] = self.fontColor!
                        }
                        if self.fontName != nil {
                            map["FontName"] = self.fontName!
                        }
                        if self.fontSize != nil {
                            map["FontSize"] = self.fontSize!
                        }
                        if self.left_ != nil {
                            map["Left"] = self.left_!
                        }
                        if self.top != nil {
                            map["Top"] = self.top!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Adaptive") {
                            self.adaptive = dict["Adaptive"] as! String
                        }
                        if dict.keys.contains("BorderColor") {
                            self.borderColor = dict["BorderColor"] as! String
                        }
                        if dict.keys.contains("BorderWidth") {
                            self.borderWidth = dict["BorderWidth"] as! Int32
                        }
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("FontAlpha") {
                            self.fontAlpha = dict["FontAlpha"] as! String
                        }
                        if dict.keys.contains("FontColor") {
                            self.fontColor = dict["FontColor"] as! String
                        }
                        if dict.keys.contains("FontName") {
                            self.fontName = dict["FontName"] as! String
                        }
                        if dict.keys.contains("FontSize") {
                            self.fontSize = dict["FontSize"] as! Int32
                        }
                        if dict.keys.contains("Left") {
                            self.left_ = dict["Left"] as! String
                        }
                        if dict.keys.contains("Top") {
                            self.top = dict["Top"] as! String
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public class Transcode : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public class Audio : Tea.TeaModel {
                        public class Volume : Tea.TeaModel {
                            public var integratedLoudnessTarget: String?

                            public var loudnessRangeTarget: String?

                            public var method: String?

                            public var truePeak: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.integratedLoudnessTarget != nil {
                                    map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                }
                                if self.loudnessRangeTarget != nil {
                                    map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                }
                                if self.method != nil {
                                    map["Method"] = self.method!
                                }
                                if self.truePeak != nil {
                                    map["TruePeak"] = self.truePeak!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("IntegratedLoudnessTarget") {
                                    self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                }
                                if dict.keys.contains("LoudnessRangeTarget") {
                                    self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                }
                                if dict.keys.contains("Method") {
                                    self.method = dict["Method"] as! String
                                }
                                if dict.keys.contains("TruePeak") {
                                    self.truePeak = dict["TruePeak"] as! String
                                }
                            }
                        }
                        public var bitrate: String?

                        public var channels: String?

                        public var codec: String?

                        public var profile: String?

                        public var remove: String?

                        public var samplerate: String?

                        public var volume: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.volume?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.remove != nil {
                                map["Remove"] = self.remove!
                            }
                            if self.samplerate != nil {
                                map["Samplerate"] = self.samplerate!
                            }
                            if self.volume != nil {
                                map["Volume"] = self.volume?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Channels") {
                                self.channels = dict["Channels"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Remove") {
                                self.remove = dict["Remove"] as! String
                            }
                            if dict.keys.contains("Samplerate") {
                                self.samplerate = dict["Samplerate"] as! String
                            }
                            if dict.keys.contains("Volume") {
                                var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                model.fromMap(dict["Volume"] as! [String: Any])
                                self.volume = model
                            }
                        }
                    }
                    public class Container : Tea.TeaModel {
                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public class MuxConfig : Tea.TeaModel {
                        public class Segment : Tea.TeaModel {
                            public var duration: String?

                            public var forceSegTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.forceSegTime != nil {
                                    map["ForceSegTime"] = self.forceSegTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("ForceSegTime") {
                                    self.forceSegTime = dict["ForceSegTime"] as! String
                                }
                            }
                        }
                        public var segment: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.segment?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.segment != nil {
                                map["Segment"] = self.segment?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Segment") {
                                var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                model.fromMap(dict["Segment"] as! [String: Any])
                                self.segment = model
                            }
                        }
                    }
                    public class TransConfig : Tea.TeaModel {
                        public var adjDarMethod: String?

                        public var isCheckAudioBitrate: String?

                        public var isCheckAudioBitrateFail: String?

                        public var isCheckReso: String?

                        public var isCheckResoFail: String?

                        public var isCheckVideoBitrate: String?

                        public var isCheckVideoBitrateFail: String?

                        public var transMode: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adjDarMethod != nil {
                                map["AdjDarMethod"] = self.adjDarMethod!
                            }
                            if self.isCheckAudioBitrate != nil {
                                map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                            }
                            if self.isCheckAudioBitrateFail != nil {
                                map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                            }
                            if self.isCheckReso != nil {
                                map["IsCheckReso"] = self.isCheckReso!
                            }
                            if self.isCheckResoFail != nil {
                                map["IsCheckResoFail"] = self.isCheckResoFail!
                            }
                            if self.isCheckVideoBitrate != nil {
                                map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                            }
                            if self.isCheckVideoBitrateFail != nil {
                                map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                            }
                            if self.transMode != nil {
                                map["TransMode"] = self.transMode!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AdjDarMethod") {
                                self.adjDarMethod = dict["AdjDarMethod"] as! String
                            }
                            if dict.keys.contains("IsCheckAudioBitrate") {
                                self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                            }
                            if dict.keys.contains("IsCheckAudioBitrateFail") {
                                self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                            }
                            if dict.keys.contains("IsCheckReso") {
                                self.isCheckReso = dict["IsCheckReso"] as! String
                            }
                            if dict.keys.contains("IsCheckResoFail") {
                                self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                            }
                            if dict.keys.contains("IsCheckVideoBitrate") {
                                self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                            }
                            if dict.keys.contains("IsCheckVideoBitrateFail") {
                                self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                            }
                            if dict.keys.contains("TransMode") {
                                self.transMode = dict["TransMode"] as! String
                            }
                        }
                    }
                    public class Video : Tea.TeaModel {
                        public var abrMax: String?

                        public var bitrate: String?

                        public var bufsize: String?

                        public var codec: String?

                        public var crf: String?

                        public var crop: String?

                        public var fps: String?

                        public var gop: String?

                        public var height: String?

                        public var longShortMode: String?

                        public var maxrate: String?

                        public var pad: String?

                        public var pixFmt: String?

                        public var preset: String?

                        public var profile: String?

                        public var remove: String?

                        public var scanMode: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.abrMax != nil {
                                map["AbrMax"] = self.abrMax!
                            }
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.bufsize != nil {
                                map["Bufsize"] = self.bufsize!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.crf != nil {
                                map["Crf"] = self.crf!
                            }
                            if self.crop != nil {
                                map["Crop"] = self.crop!
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.gop != nil {
                                map["Gop"] = self.gop!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.longShortMode != nil {
                                map["LongShortMode"] = self.longShortMode!
                            }
                            if self.maxrate != nil {
                                map["Maxrate"] = self.maxrate!
                            }
                            if self.pad != nil {
                                map["Pad"] = self.pad!
                            }
                            if self.pixFmt != nil {
                                map["PixFmt"] = self.pixFmt!
                            }
                            if self.preset != nil {
                                map["Preset"] = self.preset!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.remove != nil {
                                map["Remove"] = self.remove!
                            }
                            if self.scanMode != nil {
                                map["ScanMode"] = self.scanMode!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AbrMax") {
                                self.abrMax = dict["AbrMax"] as! String
                            }
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Bufsize") {
                                self.bufsize = dict["Bufsize"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Crf") {
                                self.crf = dict["Crf"] as! String
                            }
                            if dict.keys.contains("Crop") {
                                self.crop = dict["Crop"] as! String
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("Gop") {
                                self.gop = dict["Gop"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("LongShortMode") {
                                self.longShortMode = dict["LongShortMode"] as! String
                            }
                            if dict.keys.contains("Maxrate") {
                                self.maxrate = dict["Maxrate"] as! String
                            }
                            if dict.keys.contains("Pad") {
                                self.pad = dict["Pad"] as! String
                            }
                            if dict.keys.contains("PixFmt") {
                                self.pixFmt = dict["PixFmt"] as! String
                            }
                            if dict.keys.contains("Preset") {
                                self.preset = dict["Preset"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Remove") {
                                self.remove = dict["Remove"] as! String
                            }
                            if dict.keys.contains("ScanMode") {
                                self.scanMode = dict["ScanMode"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var audio: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                    public var container: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                    public var muxConfig: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                    public var transConfig: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.TransConfig?

                    public var video: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audio?.validate()
                        try self.container?.validate()
                        try self.muxConfig?.validate()
                        try self.transConfig?.validate()
                        try self.video?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audio != nil {
                            map["Audio"] = self.audio?.toMap()
                        }
                        if self.container != nil {
                            map["Container"] = self.container?.toMap()
                        }
                        if self.muxConfig != nil {
                            map["MuxConfig"] = self.muxConfig?.toMap()
                        }
                        if self.transConfig != nil {
                            map["TransConfig"] = self.transConfig?.toMap()
                        }
                        if self.video != nil {
                            map["Video"] = self.video?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Audio") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                            model.fromMap(dict["Audio"] as! [String: Any])
                            self.audio = model
                        }
                        if dict.keys.contains("Container") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                            model.fromMap(dict["Container"] as! [String: Any])
                            self.container = model
                        }
                        if dict.keys.contains("MuxConfig") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                            model.fromMap(dict["MuxConfig"] as! [String: Any])
                            self.muxConfig = model
                        }
                        if dict.keys.contains("TransConfig") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.TransConfig()
                            model.fromMap(dict["TransConfig"] as! [String: Any])
                            self.transConfig = model
                        }
                        if dict.keys.contains("Video") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                            model.fromMap(dict["Video"] as! [String: Any])
                            self.video = model
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public var combineConfigs: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.CombineConfigs]?

            public var encryption: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Encryption?

            public var imageWatermarks: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks]?

            public var subtitles: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles]?

            public var textWatermarks: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks]?

            public var transcode: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.encryption?.validate()
                try self.transcode?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.combineConfigs != nil {
                    var tmp : [Any] = []
                    for k in self.combineConfigs! {
                        tmp.append(k.toMap())
                    }
                    map["CombineConfigs"] = tmp
                }
                if self.encryption != nil {
                    map["Encryption"] = self.encryption?.toMap()
                }
                if self.imageWatermarks != nil {
                    var tmp : [Any] = []
                    for k in self.imageWatermarks! {
                        tmp.append(k.toMap())
                    }
                    map["ImageWatermarks"] = tmp
                }
                if self.subtitles != nil {
                    var tmp : [Any] = []
                    for k in self.subtitles! {
                        tmp.append(k.toMap())
                    }
                    map["Subtitles"] = tmp
                }
                if self.textWatermarks != nil {
                    var tmp : [Any] = []
                    for k in self.textWatermarks! {
                        tmp.append(k.toMap())
                    }
                    map["TextWatermarks"] = tmp
                }
                if self.transcode != nil {
                    map["Transcode"] = self.transcode?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CombineConfigs") {
                    var tmp : [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.CombineConfigs] = []
                    for v in dict["CombineConfigs"] as! [Any] {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.CombineConfigs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.combineConfigs = tmp
                }
                if dict.keys.contains("Encryption") {
                    var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Encryption()
                    model.fromMap(dict["Encryption"] as! [String: Any])
                    self.encryption = model
                }
                if dict.keys.contains("ImageWatermarks") {
                    var tmp : [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks] = []
                    for v in dict["ImageWatermarks"] as! [Any] {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.imageWatermarks = tmp
                }
                if dict.keys.contains("Subtitles") {
                    var tmp : [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles] = []
                    for v in dict["Subtitles"] as! [Any] {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subtitles = tmp
                }
                if dict.keys.contains("TextWatermarks") {
                    var tmp : [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks] = []
                    for v in dict["TextWatermarks"] as! [Any] {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.textWatermarks = tmp
                }
                if dict.keys.contains("Transcode") {
                    var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode()
                    model.fromMap(dict["Transcode"] as! [String: Any])
                    self.transcode = model
                }
            }
        }
        public var output: SubmitTranscodeJobRequest.OutputGroup.Output?

        public var processConfig: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.output?.validate()
            try self.processConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.processConfig != nil {
                map["ProcessConfig"] = self.processConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Output") {
                var model = SubmitTranscodeJobRequest.OutputGroup.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("ProcessConfig") {
                var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig()
                model.fromMap(dict["ProcessConfig"] as! [String: Any])
                self.processConfig = model
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var clientToken: String?

    public var inputGroup: [SubmitTranscodeJobRequest.InputGroup]?

    public var name: String?

    public var outputGroup: [SubmitTranscodeJobRequest.OutputGroup]?

    public var scheduleConfig: SubmitTranscodeJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.inputGroup != nil {
            var tmp : [Any] = []
            for k in self.inputGroup! {
                tmp.append(k.toMap())
            }
            map["InputGroup"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputGroup != nil {
            var tmp : [Any] = []
            for k in self.outputGroup! {
                tmp.append(k.toMap())
            }
            map["OutputGroup"] = tmp
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InputGroup") {
            var tmp : [SubmitTranscodeJobRequest.InputGroup] = []
            for v in dict["InputGroup"] as! [Any] {
                var model = SubmitTranscodeJobRequest.InputGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inputGroup = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputGroup") {
            var tmp : [SubmitTranscodeJobRequest.OutputGroup] = []
            for v in dict["OutputGroup"] as! [Any] {
                var model = SubmitTranscodeJobRequest.OutputGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outputGroup = tmp
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitTranscodeJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTranscodeJobShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var inputGroupShrink: String?

    public var name: String?

    public var outputGroupShrink: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.inputGroupShrink != nil {
            map["InputGroup"] = self.inputGroupShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputGroupShrink != nil {
            map["OutputGroup"] = self.outputGroupShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InputGroup") {
            self.inputGroupShrink = dict["InputGroup"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputGroup") {
            self.outputGroupShrink = dict["OutputGroup"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTranscodeJobResponseBody : Tea.TeaModel {
    public class TranscodeParentJob : Tea.TeaModel {
        public class InputGroup : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class OutputGroup : Tea.TeaModel {
            public class Output : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public var keyServiceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        if self.keyServiceType != nil {
                            map["KeyServiceType"] = self.keyServiceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                        if dict.keys.contains("KeyServiceType") {
                            self.keyServiceType = dict["KeyServiceType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class TransConfig : Tea.TeaModel {
                            public var adjDarMethod: String?

                            public var isCheckAudioBitrate: String?

                            public var isCheckAudioBitrateFail: String?

                            public var isCheckReso: String?

                            public var isCheckResoFail: String?

                            public var isCheckVideoBitrate: String?

                            public var isCheckVideoBitrateFail: String?

                            public var transMode: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.adjDarMethod != nil {
                                    map["AdjDarMethod"] = self.adjDarMethod!
                                }
                                if self.isCheckAudioBitrate != nil {
                                    map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                                }
                                if self.isCheckAudioBitrateFail != nil {
                                    map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                                }
                                if self.isCheckReso != nil {
                                    map["IsCheckReso"] = self.isCheckReso!
                                }
                                if self.isCheckResoFail != nil {
                                    map["IsCheckResoFail"] = self.isCheckResoFail!
                                }
                                if self.isCheckVideoBitrate != nil {
                                    map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                                }
                                if self.isCheckVideoBitrateFail != nil {
                                    map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                                }
                                if self.transMode != nil {
                                    map["TransMode"] = self.transMode!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AdjDarMethod") {
                                    self.adjDarMethod = dict["AdjDarMethod"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrate") {
                                    self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrateFail") {
                                    self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                                }
                                if dict.keys.contains("IsCheckReso") {
                                    self.isCheckReso = dict["IsCheckReso"] as! String
                                }
                                if dict.keys.contains("IsCheckResoFail") {
                                    self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrate") {
                                    self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrateFail") {
                                    self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                                }
                                if dict.keys.contains("TransMode") {
                                    self.transMode = dict["TransMode"] as! String
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var transConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.TransConfig?

                        public var video: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.transConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.transConfig != nil {
                                map["TransConfig"] = self.transConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("TransConfig") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.TransConfig()
                                model.fromMap(dict["TransConfig"] as! [String: Any])
                                self.transConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs]?

                public var encryption: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption?

                public var imageWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks]?

                public var subtitles: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles]?

                public var textWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks]?

                public var transcode: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("Subtitles") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public var output: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output?

            public var processConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
                try self.processConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Output") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public class TranscodeJobList : Tea.TeaModel {
            public class InputGroup : Tea.TeaModel {
                public var inputUrl: String?

                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inputUrl != nil {
                        map["InputUrl"] = self.inputUrl!
                    }
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InputUrl") {
                        self.inputUrl = dict["InputUrl"] as! String
                    }
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class OutFileMeta : Tea.TeaModel {
                public class AudioStreamInfoList : Tea.TeaModel {
                    public var bitrate: String?

                    public var channelLayout: String?

                    public var channels: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var duration: String?

                    public var index: String?

                    public var lang: String?

                    public var sampleFmt: String?

                    public var sampleRate: String?

                    public var startTime: String?

                    public var timebase: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channelLayout != nil {
                            map["ChannelLayout"] = self.channelLayout!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codecLongName != nil {
                            map["CodecLongName"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["CodecName"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["CodecTag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["CodecTagString"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["CodecTimeBase"] = self.codecTimeBase!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.sampleFmt != nil {
                            map["SampleFmt"] = self.sampleFmt!
                        }
                        if self.sampleRate != nil {
                            map["SampleRate"] = self.sampleRate!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.timebase != nil {
                            map["Timebase"] = self.timebase!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("ChannelLayout") {
                            self.channelLayout = dict["ChannelLayout"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("CodecLongName") {
                            self.codecLongName = dict["CodecLongName"] as! String
                        }
                        if dict.keys.contains("CodecName") {
                            self.codecName = dict["CodecName"] as! String
                        }
                        if dict.keys.contains("CodecTag") {
                            self.codecTag = dict["CodecTag"] as! String
                        }
                        if dict.keys.contains("CodecTagString") {
                            self.codecTagString = dict["CodecTagString"] as! String
                        }
                        if dict.keys.contains("CodecTimeBase") {
                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Index") {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("SampleFmt") {
                            self.sampleFmt = dict["SampleFmt"] as! String
                        }
                        if dict.keys.contains("SampleRate") {
                            self.sampleRate = dict["SampleRate"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("Timebase") {
                            self.timebase = dict["Timebase"] as! String
                        }
                    }
                }
                public class FileBasicInfo : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var fileName: String?

                    public var fileSize: String?

                    public var fileStatus: String?

                    public var fileType: String?

                    public var fileUrl: String?

                    public var formatName: String?

                    public var height: String?

                    public var mediaId: String?

                    public var region: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileName != nil {
                            map["FileName"] = self.fileName!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.fileStatus != nil {
                            map["FileStatus"] = self.fileStatus!
                        }
                        if self.fileType != nil {
                            map["FileType"] = self.fileType!
                        }
                        if self.fileUrl != nil {
                            map["FileUrl"] = self.fileUrl!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.mediaId != nil {
                            map["MediaId"] = self.mediaId!
                        }
                        if self.region != nil {
                            map["Region"] = self.region!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileName") {
                            self.fileName = dict["FileName"] as! String
                        }
                        if dict.keys.contains("FileSize") {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("FileStatus") {
                            self.fileStatus = dict["FileStatus"] as! String
                        }
                        if dict.keys.contains("FileType") {
                            self.fileType = dict["FileType"] as! String
                        }
                        if dict.keys.contains("FileUrl") {
                            self.fileUrl = dict["FileUrl"] as! String
                        }
                        if dict.keys.contains("FormatName") {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MediaId") {
                            self.mediaId = dict["MediaId"] as! String
                        }
                        if dict.keys.contains("Region") {
                            self.region = dict["Region"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class VideoStreamInfoList : Tea.TeaModel {
                    public var avgFps: String?

                    public var bitRate: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var dar: String?

                    public var duration: String?

                    public var fps: String?

                    public var hasBFrames: String?

                    public var height: String?

                    public var index: String?

                    public var lang: String?

                    public var level: String?

                    public var numFrames: String?

                    public var pixFmt: String?

                    public var profile: String?

                    public var rotate: String?

                    public var sar: String?

                    public var startTime: String?

                    public var timeBase: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgFps != nil {
                            map["Avg_fps"] = self.avgFps!
                        }
                        if self.bitRate != nil {
                            map["Bit_rate"] = self.bitRate!
                        }
                        if self.codecLongName != nil {
                            map["Codec_long_name"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["Codec_name"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["Codec_tag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["Codec_tag_string"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["Codec_time_base"] = self.codecTimeBase!
                        }
                        if self.dar != nil {
                            map["Dar"] = self.dar!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.hasBFrames != nil {
                            map["Has_b_frames"] = self.hasBFrames!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.numFrames != nil {
                            map["NumFrames"] = self.numFrames!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.rotate != nil {
                            map["Rotate"] = self.rotate!
                        }
                        if self.sar != nil {
                            map["Sar"] = self.sar!
                        }
                        if self.startTime != nil {
                            map["Start_time"] = self.startTime!
                        }
                        if self.timeBase != nil {
                            map["Time_base"] = self.timeBase!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Avg_fps") {
                            self.avgFps = dict["Avg_fps"] as! String
                        }
                        if dict.keys.contains("Bit_rate") {
                            self.bitRate = dict["Bit_rate"] as! String
                        }
                        if dict.keys.contains("Codec_long_name") {
                            self.codecLongName = dict["Codec_long_name"] as! String
                        }
                        if dict.keys.contains("Codec_name") {
                            self.codecName = dict["Codec_name"] as! String
                        }
                        if dict.keys.contains("Codec_tag") {
                            self.codecTag = dict["Codec_tag"] as! String
                        }
                        if dict.keys.contains("Codec_tag_string") {
                            self.codecTagString = dict["Codec_tag_string"] as! String
                        }
                        if dict.keys.contains("Codec_time_base") {
                            self.codecTimeBase = dict["Codec_time_base"] as! String
                        }
                        if dict.keys.contains("Dar") {
                            self.dar = dict["Dar"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Has_b_frames") {
                            self.hasBFrames = dict["Has_b_frames"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Index") {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("Level") {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("NumFrames") {
                            self.numFrames = dict["NumFrames"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Rotate") {
                            self.rotate = dict["Rotate"] as! String
                        }
                        if dict.keys.contains("Sar") {
                            self.sar = dict["Sar"] as! String
                        }
                        if dict.keys.contains("Start_time") {
                            self.startTime = dict["Start_time"] as! String
                        }
                        if dict.keys.contains("Time_base") {
                            self.timeBase = dict["Time_base"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var audioStreamInfoList: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList]?

                public var fileBasicInfo: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo?

                public var videoStreamInfoList: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.fileBasicInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.audioStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["AudioStreamInfoList"] = tmp
                    }
                    if self.fileBasicInfo != nil {
                        map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                    }
                    if self.videoStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.videoStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["VideoStreamInfoList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioStreamInfoList") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList] = []
                        for v in dict["AudioStreamInfoList"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.audioStreamInfoList = tmp
                    }
                    if dict.keys.contains("FileBasicInfo") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo()
                        model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                        self.fileBasicInfo = model
                    }
                    if dict.keys.contains("VideoStreamInfoList") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList] = []
                        for v in dict["VideoStreamInfoList"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.videoStreamInfoList = tmp
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public var media: String?

                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public var keyServiceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        if self.keyServiceType != nil {
                            map["KeyServiceType"] = self.keyServiceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                        if dict.keys.contains("KeyServiceType") {
                            self.keyServiceType = dict["KeyServiceType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class TransConfig : Tea.TeaModel {
                            public var adjDarMethod: String?

                            public var isCheckAudioBitrate: String?

                            public var isCheckAudioBitrateFail: String?

                            public var isCheckReso: String?

                            public var isCheckResoFail: String?

                            public var isCheckVideoBitrate: String?

                            public var isCheckVideoBitrateFail: String?

                            public var transMode: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.adjDarMethod != nil {
                                    map["AdjDarMethod"] = self.adjDarMethod!
                                }
                                if self.isCheckAudioBitrate != nil {
                                    map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                                }
                                if self.isCheckAudioBitrateFail != nil {
                                    map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                                }
                                if self.isCheckReso != nil {
                                    map["IsCheckReso"] = self.isCheckReso!
                                }
                                if self.isCheckResoFail != nil {
                                    map["IsCheckResoFail"] = self.isCheckResoFail!
                                }
                                if self.isCheckVideoBitrate != nil {
                                    map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                                }
                                if self.isCheckVideoBitrateFail != nil {
                                    map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                                }
                                if self.transMode != nil {
                                    map["TransMode"] = self.transMode!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AdjDarMethod") {
                                    self.adjDarMethod = dict["AdjDarMethod"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrate") {
                                    self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrateFail") {
                                    self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                                }
                                if dict.keys.contains("IsCheckReso") {
                                    self.isCheckReso = dict["IsCheckReso"] as! String
                                }
                                if dict.keys.contains("IsCheckResoFail") {
                                    self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrate") {
                                    self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrateFail") {
                                    self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                                }
                                if dict.keys.contains("TransMode") {
                                    self.transMode = dict["TransMode"] as! String
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var transConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.TransConfig?

                        public var video: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.transConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.transConfig != nil {
                                map["TransConfig"] = self.transConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("TransConfig") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.TransConfig()
                                model.fromMap(dict["TransConfig"] as! [String: Any])
                                self.transConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs]?

                public var encryption: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption?

                public var imageWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks]?

                public var subtitles: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles]?

                public var textWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks]?

                public var transcode: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("Subtitles") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public class ScheduleConfig : Tea.TeaModel {
                public var pipelineId: String?

                public var priority: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PipelineId") {
                        self.pipelineId = dict["PipelineId"] as! String
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! Int32
                    }
                }
            }
            public var createTime: String?

            public var finishTime: String?

            public var inputGroup: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup]?

            public var jobId: String?

            public var jobIndex: Int32?

            public var name: String?

            public var outFileMeta: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta?

            public var output: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output?

            public var parentJobId: String?

            public var processConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig?

            public var requestId: String?

            public var scheduleConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig?

            public var status: String?

            public var submitResultJson: [String: Any]?

            public var submitTime: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outFileMeta?.validate()
                try self.output?.validate()
                try self.processConfig?.validate()
                try self.scheduleConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inputGroup != nil {
                    var tmp : [Any] = []
                    for k in self.inputGroup! {
                        tmp.append(k.toMap())
                    }
                    map["InputGroup"] = tmp
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobIndex != nil {
                    map["JobIndex"] = self.jobIndex!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outFileMeta != nil {
                    map["OutFileMeta"] = self.outFileMeta?.toMap()
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.parentJobId != nil {
                    map["ParentJobId"] = self.parentJobId!
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.scheduleConfig != nil {
                    map["ScheduleConfig"] = self.scheduleConfig?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitResultJson != nil {
                    map["SubmitResultJson"] = self.submitResultJson!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("InputGroup") {
                    var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup] = []
                    for v in dict["InputGroup"] as! [Any] {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputGroup = tmp
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobIndex") {
                    self.jobIndex = dict["JobIndex"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OutFileMeta") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta()
                    model.fromMap(dict["OutFileMeta"] as! [String: Any])
                    self.outFileMeta = model
                }
                if dict.keys.contains("Output") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ParentJobId") {
                    self.parentJobId = dict["ParentJobId"] as! String
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
                if dict.keys.contains("RequestId") {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ScheduleConfig") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig()
                    model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                    self.scheduleConfig = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitResultJson") {
                    self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
                }
                if dict.keys.contains("SubmitTime") {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var inputGroup: [SubmitTranscodeJobResponseBody.TranscodeParentJob.InputGroup]?

        public var jobCount: Int32?

        public var name: String?

        public var outputGroup: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup]?

        public var parentJobId: String?

        public var percent: Int32?

        public var requestId: String?

        public var scheduleConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig?

        public var status: String?

        public var submitTime: String?

        public var transcodeJobList: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList]?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputGroup != nil {
                var tmp : [Any] = []
                for k in self.inputGroup! {
                    tmp.append(k.toMap())
                }
                map["InputGroup"] = tmp
            }
            if self.jobCount != nil {
                map["JobCount"] = self.jobCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroup != nil {
                var tmp : [Any] = []
                for k in self.outputGroup! {
                    tmp.append(k.toMap())
                }
                map["OutputGroup"] = tmp
            }
            if self.parentJobId != nil {
                map["ParentJobId"] = self.parentJobId!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.transcodeJobList != nil {
                var tmp : [Any] = []
                for k in self.transcodeJobList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJobList"] = tmp
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("InputGroup") {
                var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.InputGroup] = []
                for v in dict["InputGroup"] as! [Any] {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.InputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputGroup = tmp
            }
            if dict.keys.contains("JobCount") {
                self.jobCount = dict["JobCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroup") {
                var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup] = []
                for v in dict["OutputGroup"] as! [Any] {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroup = tmp
            }
            if dict.keys.contains("ParentJobId") {
                self.parentJobId = dict["ParentJobId"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TranscodeJobList") {
                var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList] = []
                for v in dict["TranscodeJobList"] as! [Any] {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeJobList = tmp
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeParentJob: SubmitTranscodeJobResponseBody.TranscodeParentJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeParentJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeParentJob != nil {
            map["TranscodeParentJob"] = self.transcodeParentJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeParentJob") {
            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob()
            model.fromMap(dict["TranscodeParentJob"] as! [String: Any])
            self.transcodeParentJob = model
        }
    }
}

public class SubmitTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitVideoTranslationJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditingConfig") {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitVideoTranslationJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitVideoTranslationJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitVideoTranslationJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitVideoTranslationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitVideoTranslationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitVideoTranslationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAvatarTrainingJobRequest : Tea.TeaModel {
    public var avatarDescription: String?

    public var avatarName: String?

    public var jobId: String?

    public var portrait: String?

    public var thumbnail: String?

    public var transparent: Bool?

    public var video: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarDescription != nil {
            map["AvatarDescription"] = self.avatarDescription!
        }
        if self.avatarName != nil {
            map["AvatarName"] = self.avatarName!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.portrait != nil {
            map["Portrait"] = self.portrait!
        }
        if self.thumbnail != nil {
            map["Thumbnail"] = self.thumbnail!
        }
        if self.transparent != nil {
            map["Transparent"] = self.transparent!
        }
        if self.video != nil {
            map["Video"] = self.video!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarDescription") {
            self.avatarDescription = dict["AvatarDescription"] as! String
        }
        if dict.keys.contains("AvatarName") {
            self.avatarName = dict["AvatarName"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Portrait") {
            self.portrait = dict["Portrait"] as! String
        }
        if dict.keys.contains("Thumbnail") {
            self.thumbnail = dict["Thumbnail"] as! String
        }
        if dict.keys.contains("Transparent") {
            self.transparent = dict["Transparent"] as! Bool
        }
        if dict.keys.contains("Video") {
            self.video = dict["Video"] as! String
        }
    }
}

public class UpdateAvatarTrainingJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: UpdateAvatarTrainingJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = UpdateAvatarTrainingJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateAvatarTrainingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAvatarTrainingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAvatarTrainingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var cateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CateName") {
            self.cateName = dict["CateName"] as! String
        }
    }
}

public class UpdateCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCustomTemplateRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfig: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCustomizedVoiceRequest : Tea.TeaModel {
    public var demoAudioMediaId: String?

    public var voiceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.demoAudioMediaId != nil {
            map["DemoAudioMediaId"] = self.demoAudioMediaId!
        }
        if self.voiceId != nil {
            map["VoiceId"] = self.voiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DemoAudioMediaId") {
            self.demoAudioMediaId = dict["DemoAudioMediaId"] as! String
        }
        if dict.keys.contains("VoiceId") {
            self.voiceId = dict["VoiceId"] as! String
        }
    }
}

public class UpdateCustomizedVoiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCustomizedVoiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomizedVoiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCustomizedVoiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEditingProjectRequest : Tea.TeaModel {
    public var businessStatus: String?

    public var clipsParam: String?

    public var coverURL: String?

    public var description_: String?

    public var projectId: String?

    public var templateId: String?

    public var timeline: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.clipsParam != nil {
            map["ClipsParam"] = self.clipsParam!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessStatus") {
            self.businessStatus = dict["BusinessStatus"] as! String
        }
        if dict.keys.contains("ClipsParam") {
            self.clipsParam = dict["ClipsParam"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateEditingProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveRecordTemplateRequest : Tea.TeaModel {
    public class RecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var ossObjectPrefix: String?

        public var sliceDuration: Int32?

        public var sliceOssObjectPrefix: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.ossObjectPrefix != nil {
                map["OssObjectPrefix"] = self.ossObjectPrefix!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            if self.sliceOssObjectPrefix != nil {
                map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CycleDuration") {
                self.cycleDuration = dict["CycleDuration"] as! Int32
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("OssObjectPrefix") {
                self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
            }
            if dict.keys.contains("SliceDuration") {
                self.sliceDuration = dict["SliceDuration"] as! Int32
            }
            if dict.keys.contains("SliceOssObjectPrefix") {
                self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
            }
        }
    }
    public var name: String?

    public var recordFormat: [UpdateLiveRecordTemplateRequest.RecordFormat]?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormat != nil {
            var tmp : [Any] = []
            for k in self.recordFormat! {
                tmp.append(k.toMap())
            }
            map["RecordFormat"] = tmp
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") {
            var tmp : [UpdateLiveRecordTemplateRequest.RecordFormat] = []
            for v in dict["RecordFormat"] as! [Any] {
                var model = UpdateLiveRecordTemplateRequest.RecordFormat()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordFormat = tmp
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveRecordTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var recordFormatShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormatShrink != nil {
            map["RecordFormat"] = self.recordFormatShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") {
            self.recordFormatShrink = dict["RecordFormat"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveRecordTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var overwriteFormat: String?

    public var sequenceFormat: String?

    public var templateId: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OverwriteFormat") {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("SequenceFormat") {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class UpdateLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveTranscodeJobRequest : Tea.TeaModel {
    public class StreamInput : Tea.TeaModel {
        public var inputUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputUrl") {
                self.inputUrl = dict["InputUrl"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class TimedConfig : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class TranscodeOutput : Tea.TeaModel {
        public var domainName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var jobId: String?

    public var name: String?

    public var streamInput: UpdateLiveTranscodeJobRequest.StreamInput?

    public var timedConfig: UpdateLiveTranscodeJobRequest.TimedConfig?

    public var transcodeOutput: UpdateLiveTranscodeJobRequest.TranscodeOutput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamInput?.validate()
        try self.timedConfig?.validate()
        try self.transcodeOutput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.timedConfig != nil {
            map["TimedConfig"] = self.timedConfig?.toMap()
        }
        if self.transcodeOutput != nil {
            map["TranscodeOutput"] = self.transcodeOutput?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StreamInput") {
            var model = UpdateLiveTranscodeJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TimedConfig") {
            var model = UpdateLiveTranscodeJobRequest.TimedConfig()
            model.fromMap(dict["TimedConfig"] as! [String: Any])
            self.timedConfig = model
        }
        if dict.keys.contains("TranscodeOutput") {
            var model = UpdateLiveTranscodeJobRequest.TranscodeOutput()
            model.fromMap(dict["TranscodeOutput"] as! [String: Any])
            self.transcodeOutput = model
        }
    }
}

public class UpdateLiveTranscodeJobShrinkRequest : Tea.TeaModel {
    public var jobId: String?

    public var name: String?

    public var streamInputShrink: String?

    public var timedConfigShrink: String?

    public var transcodeOutputShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.timedConfigShrink != nil {
            map["TimedConfig"] = self.timedConfigShrink!
        }
        if self.transcodeOutputShrink != nil {
            map["TranscodeOutput"] = self.transcodeOutputShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StreamInput") {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TimedConfig") {
            self.timedConfigShrink = dict["TimedConfig"] as! String
        }
        if dict.keys.contains("TranscodeOutput") {
            self.transcodeOutputShrink = dict["TranscodeOutput"] as! String
        }
    }
}

public class UpdateLiveTranscodeJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveTranscodeTemplateRequest : Tea.TeaModel {
    public class TemplateConfig : Tea.TeaModel {
        public class AudioParams : Tea.TeaModel {
            public var bitrate: String?

            public var channels: String?

            public var codec: String?

            public var profile: String?

            public var samplerate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.samplerate != nil {
                    map["Samplerate"] = self.samplerate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Samplerate") {
                    self.samplerate = dict["Samplerate"] as! String
                }
            }
        }
        public class VideoParams : Tea.TeaModel {
            public var bitrate: String?

            public var codec: String?

            public var fps: String?

            public var gop: String?

            public var height: String?

            public var profile: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Gop") {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audioParams: UpdateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams?

        public var videoParams: UpdateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audioParams?.validate()
            try self.videoParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioParams != nil {
                map["AudioParams"] = self.audioParams?.toMap()
            }
            if self.videoParams != nil {
                map["VideoParams"] = self.videoParams?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioParams") {
                var model = UpdateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams()
                model.fromMap(dict["AudioParams"] as! [String: Any])
                self.audioParams = model
            }
            if dict.keys.contains("VideoParams") {
                var model = UpdateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams()
                model.fromMap(dict["VideoParams"] as! [String: Any])
                self.videoParams = model
            }
        }
    }
    public var name: String?

    public var templateConfig: UpdateLiveTranscodeTemplateRequest.TemplateConfig?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            var model = UpdateLiveTranscodeTemplateRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveTranscodeTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfigShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaInfoRequest : Tea.TeaModel {
    public var appendTags: Bool?

    public var businessType: String?

    public var cateId: Int64?

    public var category: String?

    public var coverURL: String?

    public var description_: String?

    public var inputURL: String?

    public var mediaId: String?

    public var mediaTags: String?

    public var referenceId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appendTags != nil {
            map["AppendTags"] = self.appendTags!
        }
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaTags != nil {
            map["MediaTags"] = self.mediaTags!
        }
        if self.referenceId != nil {
            map["ReferenceId"] = self.referenceId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppendTags") {
            self.appendTags = dict["AppendTags"] as! Bool
        }
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaTags") {
            self.mediaTags = dict["MediaTags"] as! String
        }
        if dict.keys.contains("ReferenceId") {
            self.referenceId = dict["ReferenceId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UpdateMediaInfoResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
    }
}

public class UpdateMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaToSearchLibRequest : Tea.TeaModel {
    public var mediaId: String?

    public var msgBody: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.msgBody != nil {
            map["MsgBody"] = self.msgBody!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MsgBody") {
            self.msgBody = dict["MsgBody"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class UpdateMediaToSearchLibResponseBody : Tea.TeaModel {
    public var code: String?

    public var mediaId: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class UpdateMediaToSearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaToSearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaToSearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePipelineRequest : Tea.TeaModel {
    public var name: String?

    public var pipelineId: String?

    public var priority: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdatePipelineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTemplateRequest : Tea.TeaModel {
    public var config: String?

    public var coverUrl: String?

    public var name: String?

    public var previewMedia: String?

    public var relatedMediaids: String?

    public var source: String?

    public var status: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.previewMedia != nil {
            map["PreviewMedia"] = self.previewMedia!
        }
        if self.relatedMediaids != nil {
            map["RelatedMediaids"] = self.relatedMediaids!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("CoverUrl") {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PreviewMedia") {
            self.previewMedia = dict["PreviewMedia"] as! String
        }
        if dict.keys.contains("RelatedMediaids") {
            self.relatedMediaids = dict["RelatedMediaids"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadMediaByURLRequest : Tea.TeaModel {
    public var appId: String?

    public var entityId: String?

    public var mediaMetaData: String?

    public var postProcessConfig: String?

    public var uploadTargetConfig: String?

    public var uploadURLs: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.mediaMetaData != nil {
            map["MediaMetaData"] = self.mediaMetaData!
        }
        if self.postProcessConfig != nil {
            map["PostProcessConfig"] = self.postProcessConfig!
        }
        if self.uploadTargetConfig != nil {
            map["UploadTargetConfig"] = self.uploadTargetConfig!
        }
        if self.uploadURLs != nil {
            map["UploadURLs"] = self.uploadURLs!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("MediaMetaData") {
            self.mediaMetaData = dict["MediaMetaData"] as! String
        }
        if dict.keys.contains("PostProcessConfig") {
            self.postProcessConfig = dict["PostProcessConfig"] as! String
        }
        if dict.keys.contains("UploadTargetConfig") {
            self.uploadTargetConfig = dict["UploadTargetConfig"] as! String
        }
        if dict.keys.contains("UploadURLs") {
            self.uploadURLs = dict["UploadURLs"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UploadMediaByURLResponseBody : Tea.TeaModel {
    public class UploadJobs : Tea.TeaModel {
        public var jobId: String?

        public var mediaId: String?

        public var sourceURL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.sourceURL != nil {
                map["SourceURL"] = self.sourceURL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("SourceURL") {
                self.sourceURL = dict["SourceURL"] as! String
            }
        }
    }
    public var requestId: String?

    public var uploadJobs: [UploadMediaByURLResponseBody.UploadJobs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadJobs != nil {
            var tmp : [Any] = []
            for k in self.uploadJobs! {
                tmp.append(k.toMap())
            }
            map["UploadJobs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadJobs") {
            var tmp : [UploadMediaByURLResponseBody.UploadJobs] = []
            for v in dict["UploadJobs"] as! [Any] {
                var model = UploadMediaByURLResponseBody.UploadJobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uploadJobs = tmp
        }
    }
}

public class UploadMediaByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadMediaByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadMediaByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadStreamByURLRequest : Tea.TeaModel {
    public var definition: String?

    public var fileExtension: String?

    public var HDRType: String?

    public var mediaId: String?

    public var streamURL: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.fileExtension != nil {
            map["FileExtension"] = self.fileExtension!
        }
        if self.HDRType != nil {
            map["HDRType"] = self.HDRType!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.streamURL != nil {
            map["StreamURL"] = self.streamURL!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("FileExtension") {
            self.fileExtension = dict["FileExtension"] as! String
        }
        if dict.keys.contains("HDRType") {
            self.HDRType = dict["HDRType"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("StreamURL") {
            self.streamURL = dict["StreamURL"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UploadStreamByURLResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var jobId: String?

    public var mediaId: String?

    public var requestId: String?

    public var sourceURL: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceURL != nil {
            map["SourceURL"] = self.sourceURL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceURL") {
            self.sourceURL = dict["SourceURL"] as! String
        }
    }
}

public class UploadStreamByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadStreamByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadStreamByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
