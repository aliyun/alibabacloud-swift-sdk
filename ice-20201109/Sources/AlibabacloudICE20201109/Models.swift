import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddCategoryRequest : Tea.TeaModel {
    public var cateName: String?

    public var parentId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateName") {
            self.cateName = dict["CateName"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddCategoryResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: Int64?

        public var cateName: String?

        public var level: Int64?

        public var parentId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var category: AddCategoryResponseBody.Category?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            var model = AddCategoryResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialMaps: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialMaps != nil {
            map["MaterialMaps"] = self.materialMaps!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialMaps") {
            self.materialMaps = dict["MaterialMaps"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class AddEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public class LiveMaterials : Tea.TeaModel {
        public var appName: String?

        public var domainName: String?

        public var liveUrl: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.liveUrl != nil {
                map["LiveUrl"] = self.liveUrl!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("LiveUrl") {
                self.liveUrl = dict["LiveUrl"] as! String
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
        }
    }
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: AddEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                self.fileInfoList = dict["FileInfoList"] as! [AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList]
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = AddEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var liveMaterials: [AddEditingProjectMaterialsResponseBody.LiveMaterials]?

    public var mediaInfos: [AddEditingProjectMaterialsResponseBody.MediaInfos]?

    public var projectId: String?

    public var projectMaterials: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveMaterials != nil {
            var tmp : [Any] = []
            for k in self.liveMaterials! {
                tmp.append(k.toMap())
            }
            map["LiveMaterials"] = tmp
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectMaterials != nil {
            map["ProjectMaterials"] = self.projectMaterials!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveMaterials") {
            self.liveMaterials = dict["LiveMaterials"] as! [AddEditingProjectMaterialsResponseBody.LiveMaterials]
        }
        if dict.keys.contains("MediaInfos") {
            self.mediaInfos = dict["MediaInfos"] as! [AddEditingProjectMaterialsResponseBody.MediaInfos]
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectMaterials") {
            self.projectMaterials = dict["ProjectMaterials"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddFavoritePublicMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class AddFavoritePublicMediaResponseBody : Tea.TeaModel {
    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IgnoredList") {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddFavoritePublicMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddFavoritePublicMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddFavoritePublicMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
    }
}

public class AddMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTemplateRequest : Tea.TeaModel {
    public var config: String?

    public var coverUrl: String?

    public var name: String?

    public var previewMedia: String?

    public var relatedMediaids: String?

    public var source: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.previewMedia != nil {
            map["PreviewMedia"] = self.previewMedia!
        }
        if self.relatedMediaids != nil {
            map["RelatedMediaids"] = self.relatedMediaids!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("CoverUrl") {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PreviewMedia") {
            self.previewMedia = dict["PreviewMedia"] as! String
        }
        if dict.keys.contains("RelatedMediaids") {
            self.relatedMediaids = dict["RelatedMediaids"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var config: String?

        public var coverUrl: String?

        public var createSource: String?

        public var modifiedSource: String?

        public var name: String?

        public var previewMedia: String?

        public var status: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.previewMedia != nil {
                map["PreviewMedia"] = self.previewMedia!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CoverUrl") {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PreviewMedia") {
                self.previewMedia = dict["PreviewMedia"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var template: AddTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") {
            var model = AddTemplateResponseBody.Template()
            model.fromMap(dict["Template"] as! [String: Any])
            self.template = model
        }
    }
}

public class AddTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchGetMediaInfosRequest : Tea.TeaModel {
    public var additionType: String?

    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionType != nil {
            map["AdditionType"] = self.additionType!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionType") {
            self.additionType = dict["AdditionType"] as! String
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class BatchGetMediaInfosResponseBody : Tea.TeaModel {
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: BatchGetMediaInfosResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                self.fileInfoList = dict["FileInfoList"] as! [BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList]
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = BatchGetMediaInfosResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var mediaInfos: [BatchGetMediaInfosResponseBody.MediaInfos]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfos") {
            self.mediaInfos = dict["MediaInfos"] as! [BatchGetMediaInfosResponseBody.MediaInfos]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchGetMediaInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchGetMediaInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchGetMediaInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelFavoritePublicMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class CancelFavoritePublicMediaResponseBody : Tea.TeaModel {
    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IgnoredList") {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelFavoritePublicMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelFavoritePublicMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelFavoritePublicMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAuditRequest : Tea.TeaModel {
    public var appId: String?

    public var auditContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.auditContent != nil {
            map["AuditContent"] = self.auditContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AuditContent") {
            self.auditContent = dict["AuditContent"] as! String
        }
    }
}

public class CreateAuditResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAuditResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAuditResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAuditResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomTemplateRequest : Tea.TeaModel {
    public var name: String?

    public var subtype: Int32?

    public var templateConfig: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Subtype") {
            self.subtype = dict["Subtype"] as! Int32
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class CreateCustomTemplateResponseBody : Tea.TeaModel {
    public class CustomTemplate : Tea.TeaModel {
        public var createTime: String?

        public var isDefault: Bool?

        public var modifiedTime: String?

        public var status: String?

        public var subtype: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var customTemplate: CreateCustomTemplateResponseBody.CustomTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplate != nil {
            map["CustomTemplate"] = self.customTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplate") {
            var model = CreateCustomTemplateResponseBody.CustomTemplate()
            model.fromMap(dict["CustomTemplate"] as! [String: Any])
            self.customTemplate = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEditingProjectRequest : Tea.TeaModel {
    public var businessConfig: String?

    public var clipsParam: String?

    public var coverURL: String?

    public var description_: String?

    public var materialMaps: String?

    public var projectType: String?

    public var templateId: String?

    public var timeline: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessConfig != nil {
            map["BusinessConfig"] = self.businessConfig!
        }
        if self.clipsParam != nil {
            map["ClipsParam"] = self.clipsParam!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.materialMaps != nil {
            map["MaterialMaps"] = self.materialMaps!
        }
        if self.projectType != nil {
            map["ProjectType"] = self.projectType!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessConfig") {
            self.businessConfig = dict["BusinessConfig"] as! String
        }
        if dict.keys.contains("ClipsParam") {
            self.clipsParam = dict["ClipsParam"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MaterialMaps") {
            self.materialMaps = dict["MaterialMaps"] as! String
        }
        if dict.keys.contains("ProjectType") {
            self.projectType = dict["ProjectType"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateEditingProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var clipsParam: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var duration: Double?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: Int64?

        public var statusName: String?

        public var templateId: String?

        public var templateType: String?

        public var timeline: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusName != nil {
                map["StatusName"] = self.statusName!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("StatusName") {
                self.statusName = dict["StatusName"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var project: CreateEditingProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") {
            var model = CreateEditingProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveRecordTemplateRequest : Tea.TeaModel {
    public class RecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var ossObjectPrefix: String?

        public var sliceDuration: Int32?

        public var sliceOssObjectPrefix: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.ossObjectPrefix != nil {
                map["OssObjectPrefix"] = self.ossObjectPrefix!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            if self.sliceOssObjectPrefix != nil {
                map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CycleDuration") {
                self.cycleDuration = dict["CycleDuration"] as! Int32
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("OssObjectPrefix") {
                self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
            }
            if dict.keys.contains("SliceDuration") {
                self.sliceDuration = dict["SliceDuration"] as! Int32
            }
            if dict.keys.contains("SliceOssObjectPrefix") {
                self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
            }
        }
    }
    public var name: String?

    public var recordFormat: [CreateLiveRecordTemplateRequest.RecordFormat]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormat != nil {
            var tmp : [Any] = []
            for k in self.recordFormat! {
                tmp.append(k.toMap())
            }
            map["RecordFormat"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") {
            self.recordFormat = dict["RecordFormat"] as! [CreateLiveRecordTemplateRequest.RecordFormat]
        }
    }
}

public class CreateLiveRecordTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var recordFormatShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormatShrink != nil {
            map["RecordFormat"] = self.recordFormatShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") {
            self.recordFormatShrink = dict["RecordFormat"] as! String
        }
    }
}

public class CreateLiveRecordTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var overwriteFormat: String?

    public var sequenceFormat: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OverwriteFormat") {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("SequenceFormat") {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class CreateLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveTranscodeTemplateRequest : Tea.TeaModel {
    public class TemplateConfig : Tea.TeaModel {
        public class AudioParams : Tea.TeaModel {
            public var bitrate: String?

            public var channels: String?

            public var codec: String?

            public var profile: String?

            public var samplerate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.samplerate != nil {
                    map["Samplerate"] = self.samplerate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Samplerate") {
                    self.samplerate = dict["Samplerate"] as! String
                }
            }
        }
        public class VideoParams : Tea.TeaModel {
            public var bitrate: String?

            public var codec: String?

            public var fps: String?

            public var gop: String?

            public var height: String?

            public var profile: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Gop") {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audioParams: CreateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams?

        public var videoParams: CreateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audioParams?.validate()
            try self.videoParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioParams != nil {
                map["AudioParams"] = self.audioParams?.toMap()
            }
            if self.videoParams != nil {
                map["VideoParams"] = self.videoParams?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioParams") {
                var model = CreateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams()
                model.fromMap(dict["AudioParams"] as! [String: Any])
                self.audioParams = model
            }
            if dict.keys.contains("VideoParams") {
                var model = CreateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams()
                model.fromMap(dict["VideoParams"] as! [String: Any])
                self.videoParams = model
            }
        }
    }
    public var name: String?

    public var templateConfig: CreateLiveTranscodeTemplateRequest.TemplateConfig?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            var model = CreateLiveTranscodeTemplateRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfigShrink: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePipelineRequest : Tea.TeaModel {
    public var name: String?

    public var priority: Int32?

    public var speed: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.speed != nil {
            map["Speed"] = self.speed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Speed") {
            self.speed = dict["Speed"] as! String
        }
    }
}

public class CreatePipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public var createTime: String?

        public var modifiedTime: String?

        public var name: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var speed: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipeline: CreatePipelineResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") {
            var model = CreatePipelineResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadMediaRequest : Tea.TeaModel {
    public var appId: String?

    public var entityId: String?

    public var fileInfo: String?

    public var mediaMetaData: String?

    public var postProcessConfig: String?

    public var uploadTargetConfig: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.fileInfo != nil {
            map["FileInfo"] = self.fileInfo!
        }
        if self.mediaMetaData != nil {
            map["MediaMetaData"] = self.mediaMetaData!
        }
        if self.postProcessConfig != nil {
            map["PostProcessConfig"] = self.postProcessConfig!
        }
        if self.uploadTargetConfig != nil {
            map["UploadTargetConfig"] = self.uploadTargetConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("FileInfo") {
            self.fileInfo = dict["FileInfo"] as! String
        }
        if dict.keys.contains("MediaMetaData") {
            self.mediaMetaData = dict["MediaMetaData"] as! String
        }
        if dict.keys.contains("PostProcessConfig") {
            self.postProcessConfig = dict["PostProcessConfig"] as! String
        }
        if dict.keys.contains("UploadTargetConfig") {
            self.uploadTargetConfig = dict["UploadTargetConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class CreateUploadMediaResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var mediaId: String?

    public var mediaURL: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaURL != nil {
            map["MediaURL"] = self.mediaURL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaURL") {
            self.mediaURL = dict["MediaURL"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class CreateUploadMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUploadMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadStreamRequest : Tea.TeaModel {
    public var definition: String?

    public var fileExtension: String?

    public var HDRType: String?

    public var mediaId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.fileExtension != nil {
            map["FileExtension"] = self.fileExtension!
        }
        if self.HDRType != nil {
            map["HDRType"] = self.HDRType!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("FileExtension") {
            self.fileExtension = dict["FileExtension"] as! String
        }
        if dict.keys.contains("HDRType") {
            self.HDRType = dict["HDRType"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class CreateUploadStreamResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var mediaId: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class CreateUploadStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUploadStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
    }
}

public class DeleteCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialIds: String?

    public var materialType: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialIds != nil {
            map["MaterialIds"] = self.materialIds!
        }
        if self.materialType != nil {
            map["MaterialType"] = self.materialType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialIds") {
            self.materialIds = dict["MaterialIds"] as! String
        }
        if dict.keys.contains("MaterialType") {
            self.materialType = dict["MaterialType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DeleteEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEditingProjectsRequest : Tea.TeaModel {
    public var projectIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectIds != nil {
            map["ProjectIds"] = self.projectIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectIds") {
            self.projectIds = dict["ProjectIds"] as! String
        }
    }
}

public class DeleteEditingProjectsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEditingProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEditingProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEditingProjectsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveRecordFilesRequest : Tea.TeaModel {
    public var recordIds: [String]?

    public var removeFile: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordIds != nil {
            map["RecordIds"] = self.recordIds!
        }
        if self.removeFile != nil {
            map["RemoveFile"] = self.removeFile!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordIds") {
            self.recordIds = dict["RecordIds"] as! [String]
        }
        if dict.keys.contains("RemoveFile") {
            self.removeFile = dict["RemoveFile"] as! Bool
        }
    }
}

public class DeleteLiveRecordFilesResponseBody : Tea.TeaModel {
    public class DeleteFileInfoList : Tea.TeaModel {
        public var code: String?

        public var message: String?

        public var recordId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! String
            }
        }
    }
    public var deleteFileInfoList: [DeleteLiveRecordFilesResponseBody.DeleteFileInfoList]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFileInfoList != nil {
            var tmp : [Any] = []
            for k in self.deleteFileInfoList! {
                tmp.append(k.toMap())
            }
            map["DeleteFileInfoList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteFileInfoList") {
            self.deleteFileInfoList = dict["DeleteFileInfoList"] as! [DeleteLiveRecordFilesResponseBody.DeleteFileInfoList]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveRecordFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRecordFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveRecordFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveRecordTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveRecordTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveSnapshotFilesRequest : Tea.TeaModel {
    public var createTimestampList: [Int64]?

    public var deleteOriginalFile: Bool?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimestampList != nil {
            map["CreateTimestampList"] = self.createTimestampList!
        }
        if self.deleteOriginalFile != nil {
            map["DeleteOriginalFile"] = self.deleteOriginalFile!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimestampList") {
            self.createTimestampList = dict["CreateTimestampList"] as! [Int64]
        }
        if dict.keys.contains("DeleteOriginalFile") {
            self.deleteOriginalFile = dict["DeleteOriginalFile"] as! Bool
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteLiveSnapshotFilesShrinkRequest : Tea.TeaModel {
    public var createTimestampListShrink: String?

    public var deleteOriginalFile: Bool?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimestampListShrink != nil {
            map["CreateTimestampList"] = self.createTimestampListShrink!
        }
        if self.deleteOriginalFile != nil {
            map["DeleteOriginalFile"] = self.deleteOriginalFile!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimestampList") {
            self.createTimestampListShrink = dict["CreateTimestampList"] as! String
        }
        if dict.keys.contains("DeleteOriginalFile") {
            self.deleteOriginalFile = dict["DeleteOriginalFile"] as! Bool
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteLiveSnapshotFilesResponseBody : Tea.TeaModel {
    public class DeleteFileResultList : Tea.TeaModel {
        public var createTimestamp: Int64?

        public var result: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! String
            }
        }
    }
    public var deleteFileResultList: [DeleteLiveSnapshotFilesResponseBody.DeleteFileResultList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFileResultList != nil {
            var tmp : [Any] = []
            for k in self.deleteFileResultList! {
                tmp.append(k.toMap())
            }
            map["DeleteFileResultList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteFileResultList") {
            self.deleteFileResultList = dict["DeleteFileResultList"] as! [DeleteLiveSnapshotFilesResponseBody.DeleteFileResultList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveSnapshotFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSnapshotFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveSnapshotFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveTranscodeJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteLiveTranscodeJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveTranscodeTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaInfosRequest : Tea.TeaModel {
    public var deletePhysicalFiles: Bool?

    public var inputURLs: String?

    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deletePhysicalFiles != nil {
            map["DeletePhysicalFiles"] = self.deletePhysicalFiles!
        }
        if self.inputURLs != nil {
            map["InputURLs"] = self.inputURLs!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeletePhysicalFiles") {
            self.deletePhysicalFiles = dict["DeletePhysicalFiles"] as! Bool
        }
        if dict.keys.contains("InputURLs") {
            self.inputURLs = dict["InputURLs"] as! String
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class DeleteMediaInfosResponseBody : Tea.TeaModel {
    public var forbiddenList: [String]?

    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenList != nil {
            map["ForbiddenList"] = self.forbiddenList!
        }
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenList") {
            self.forbiddenList = dict["ForbiddenList"] as! [String]
        }
        if dict.keys.contains("IgnoredList") {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
    }
}

public class DeleteMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePipelineRequest : Tea.TeaModel {
    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
    }
}

public class DeletePipelineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeletePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePlayInfoRequest : Tea.TeaModel {
    public var deletePhysicalFiles: Bool?

    public var fileURLs: String?

    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deletePhysicalFiles != nil {
            map["DeletePhysicalFiles"] = self.deletePhysicalFiles!
        }
        if self.fileURLs != nil {
            map["FileURLs"] = self.fileURLs!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeletePhysicalFiles") {
            self.deletePhysicalFiles = dict["DeletePhysicalFiles"] as! Bool
        }
        if dict.keys.contains("FileURLs") {
            self.fileURLs = dict["FileURLs"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class DeletePlayInfoResponseBody : Tea.TeaModel {
    public var forbiddenList: [String]?

    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenList != nil {
            map["ForbiddenList"] = self.forbiddenList!
        }
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenList") {
            self.forbiddenList = dict["ForbiddenList"] as! [String]
        }
        if dict.keys.contains("IgnoredList") {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSmartJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteSmartJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSmartJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSmartJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSmartJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTemplateRequest : Tea.TeaModel {
    public var templateIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateIds") {
            self.templateIds = dict["TemplateIds"] as! String
        }
    }
}

public class DeleteTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFilterConfigsRequest : Tea.TeaModel {
    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeFilterConfigsResponseBody : Tea.TeaModel {
    public class FilterConfigs : Tea.TeaModel {
        public var filterName: String?

        public var itemConfigs: String?

        public var type: String?

        public var uuId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.filterName != nil {
                map["FilterName"] = self.filterName!
            }
            if self.itemConfigs != nil {
                map["ItemConfigs"] = self.itemConfigs!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uuId != nil {
                map["UuId"] = self.uuId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FilterName") {
                self.filterName = dict["FilterName"] as! String
            }
            if dict.keys.contains("ItemConfigs") {
                self.itemConfigs = dict["ItemConfigs"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UuId") {
                self.uuId = dict["UuId"] as! String
            }
        }
    }
    public var filterConfigs: [DescribeFilterConfigsResponseBody.FilterConfigs]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filterConfigs != nil {
            var tmp : [Any] = []
            for k in self.filterConfigs! {
                tmp.append(k.toMap())
            }
            map["FilterConfigs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilterConfigs") {
            self.filterConfigs = dict["FilterConfigs"] as! [DescribeFilterConfigsResponseBody.FilterConfigs]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFilterConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFilterConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFilterConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterIceEditUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterIceEditUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var profile: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.profile != nil {
                map["Profile"] = self.profile!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Profile") {
                self.profile = dict["Profile"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterIceEditUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterIceEditUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterIceEditUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterIceEditUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterIceEditUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterIceLiveMediaConvertUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterIceLiveMediaConvertUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterIceLiveMediaConvertUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterIceLiveMediaConvertUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterIceLiveMediaConvertUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterIceLiveMediaConvertUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterIceLiveMediaConvertUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterIceMediaConvertUHDUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: String?

    public var regionId: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterIceMediaConvertUHDUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterIceMediaConvertUHDUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterIceMediaConvertUHDUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterIceMediaConvertUHDUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterIceMediaConvertUHDUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterIceMediaConvertUHDUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterIceMediaConvertUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterIceMediaConvertUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterIceMediaConvertUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterIceMediaConvertUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterIceMediaConvertUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterIceMediaConvertUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterIceMediaConvertUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterIceMpsAiUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterIceMpsAiUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var time: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [DescribeMeterIceMpsAiUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterIceMpsAiUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterIceMpsAiUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterIceMpsAiUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterIceMpsAiUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsEditUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsEditUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var profile: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.profile != nil {
                map["Profile"] = self.profile!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Profile") {
                self.profile = dict["Profile"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsEditUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterImsEditUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsEditUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsEditUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsEditUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsLiveEditUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsLiveEditUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var profile: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.profile != nil {
                map["Profile"] = self.profile!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Profile") {
                self.profile = dict["Profile"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsLiveEditUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterImsLiveEditUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsLiveEditUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsLiveEditUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsLiveEditUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsLiveMediaConvertUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsLiveMediaConvertUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsLiveMediaConvertUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterImsLiveMediaConvertUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsLiveMediaConvertUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsLiveMediaConvertUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsLiveMediaConvertUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsLiveRecordUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsLiveRecordUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var channels: Double?

        public var duration: Int64?

        public var time: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channels != nil {
                map["Channels"] = self.channels!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Channels") {
                self.channels = dict["Channels"] as! Double
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [DescribeMeterImsLiveRecordUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterImsLiveRecordUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsLiveRecordUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsLiveRecordUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsLiveRecordUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsLiveSnapshotUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsLiveSnapshotUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: Int64?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int64
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsLiveSnapshotUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterImsLiveSnapshotUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsLiveSnapshotUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsLiveSnapshotUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsLiveSnapshotUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsMediaConvertUHDUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: String?

    public var regionId: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsMediaConvertUHDUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsMediaConvertUHDUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterImsMediaConvertUHDUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsMediaConvertUHDUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsMediaConvertUHDUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsMediaConvertUHDUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsMediaConvertUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsMediaConvertUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsMediaConvertUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterImsMediaConvertUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsMediaConvertUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsMediaConvertUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsMediaConvertUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsMpsAiUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsMpsAiUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var time: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [DescribeMeterImsMpsAiUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterImsMpsAiUsageResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsMpsAiUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsMpsAiUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsMpsAiUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsSummaryRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var editingDuration: String?

        public var liveEditDuration: String?

        public var liveRecordDuration: String?

        public var liveSnapshotCount: String?

        public var liveTranscodeDuration: Int64?

        public var mpsAiDuration: Int64?

        public var mpsTranscodeDuration: Int64?

        public var mpsTranscodeUHDDuration: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.editingDuration != nil {
                map["EditingDuration"] = self.editingDuration!
            }
            if self.liveEditDuration != nil {
                map["LiveEditDuration"] = self.liveEditDuration!
            }
            if self.liveRecordDuration != nil {
                map["LiveRecordDuration"] = self.liveRecordDuration!
            }
            if self.liveSnapshotCount != nil {
                map["LiveSnapshotCount"] = self.liveSnapshotCount!
            }
            if self.liveTranscodeDuration != nil {
                map["LiveTranscodeDuration"] = self.liveTranscodeDuration!
            }
            if self.mpsAiDuration != nil {
                map["MpsAiDuration"] = self.mpsAiDuration!
            }
            if self.mpsTranscodeDuration != nil {
                map["MpsTranscodeDuration"] = self.mpsTranscodeDuration!
            }
            if self.mpsTranscodeUHDDuration != nil {
                map["MpsTranscodeUHDDuration"] = self.mpsTranscodeUHDDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EditingDuration") {
                self.editingDuration = dict["EditingDuration"] as! String
            }
            if dict.keys.contains("LiveEditDuration") {
                self.liveEditDuration = dict["LiveEditDuration"] as! String
            }
            if dict.keys.contains("LiveRecordDuration") {
                self.liveRecordDuration = dict["LiveRecordDuration"] as! String
            }
            if dict.keys.contains("LiveSnapshotCount") {
                self.liveSnapshotCount = dict["LiveSnapshotCount"] as! String
            }
            if dict.keys.contains("LiveTranscodeDuration") {
                self.liveTranscodeDuration = dict["LiveTranscodeDuration"] as! Int64
            }
            if dict.keys.contains("MpsAiDuration") {
                self.mpsAiDuration = dict["MpsAiDuration"] as! Int64
            }
            if dict.keys.contains("MpsTranscodeDuration") {
                self.mpsTranscodeDuration = dict["MpsTranscodeDuration"] as! Int64
            }
            if dict.keys.contains("MpsTranscodeUHDDuration") {
                self.mpsTranscodeUHDDuration = dict["MpsTranscodeUHDDuration"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsSummaryResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterImsSummaryResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayDetailRequest : Tea.TeaModel {
    public var playTs: String?

    public var sessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.playTs != nil {
            map["PlayTs"] = self.playTs!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PlayTs") {
            self.playTs = dict["PlayTs"] as! String
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
    }
}

public class DescribePlayDetailResponseBody : Tea.TeaModel {
    public class BaseInfos : Tea.TeaModel {
        public var appName: String?

        public var bps: String?

        public var broadcastPace: String?

        public var clientIP: String?

        public var codec: String?

        public var decodeStuckTime: String?

        public var definition: String?

        public var firstFrameDuration: String?

        public var fps: String?

        public var isHardDecode: String?

        public var mdat: String?

        public var moov: String?

        public var network: String?

        public var networkDuration: String?

        public var networkStuckTime: String?

        public var os: String?

        public var playTs: String?

        public var playerLoadDuration: String?

        public var playerPreDealDuration: String?

        public var playerReadyDuration: String?

        public var sdkVersion: String?

        public var sessionId: String?

        public var status: String?

        public var terminalType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.bps != nil {
                map["Bps"] = self.bps!
            }
            if self.broadcastPace != nil {
                map["BroadcastPace"] = self.broadcastPace!
            }
            if self.clientIP != nil {
                map["ClientIP"] = self.clientIP!
            }
            if self.codec != nil {
                map["Codec"] = self.codec!
            }
            if self.decodeStuckTime != nil {
                map["DecodeStuckTime"] = self.decodeStuckTime!
            }
            if self.definition != nil {
                map["Definition"] = self.definition!
            }
            if self.firstFrameDuration != nil {
                map["FirstFrameDuration"] = self.firstFrameDuration!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.isHardDecode != nil {
                map["IsHardDecode"] = self.isHardDecode!
            }
            if self.mdat != nil {
                map["Mdat"] = self.mdat!
            }
            if self.moov != nil {
                map["Moov"] = self.moov!
            }
            if self.network != nil {
                map["Network"] = self.network!
            }
            if self.networkDuration != nil {
                map["NetworkDuration"] = self.networkDuration!
            }
            if self.networkStuckTime != nil {
                map["NetworkStuckTime"] = self.networkStuckTime!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.playTs != nil {
                map["PlayTs"] = self.playTs!
            }
            if self.playerLoadDuration != nil {
                map["PlayerLoadDuration"] = self.playerLoadDuration!
            }
            if self.playerPreDealDuration != nil {
                map["PlayerPreDealDuration"] = self.playerPreDealDuration!
            }
            if self.playerReadyDuration != nil {
                map["PlayerReadyDuration"] = self.playerReadyDuration!
            }
            if self.sdkVersion != nil {
                map["SdkVersion"] = self.sdkVersion!
            }
            if self.sessionId != nil {
                map["SessionId"] = self.sessionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.terminalType != nil {
                map["TerminalType"] = self.terminalType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Bps") {
                self.bps = dict["Bps"] as! String
            }
            if dict.keys.contains("BroadcastPace") {
                self.broadcastPace = dict["BroadcastPace"] as! String
            }
            if dict.keys.contains("ClientIP") {
                self.clientIP = dict["ClientIP"] as! String
            }
            if dict.keys.contains("Codec") {
                self.codec = dict["Codec"] as! String
            }
            if dict.keys.contains("DecodeStuckTime") {
                self.decodeStuckTime = dict["DecodeStuckTime"] as! String
            }
            if dict.keys.contains("Definition") {
                self.definition = dict["Definition"] as! String
            }
            if dict.keys.contains("FirstFrameDuration") {
                self.firstFrameDuration = dict["FirstFrameDuration"] as! String
            }
            if dict.keys.contains("Fps") {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("IsHardDecode") {
                self.isHardDecode = dict["IsHardDecode"] as! String
            }
            if dict.keys.contains("Mdat") {
                self.mdat = dict["Mdat"] as! String
            }
            if dict.keys.contains("Moov") {
                self.moov = dict["Moov"] as! String
            }
            if dict.keys.contains("Network") {
                self.network = dict["Network"] as! String
            }
            if dict.keys.contains("NetworkDuration") {
                self.networkDuration = dict["NetworkDuration"] as! String
            }
            if dict.keys.contains("NetworkStuckTime") {
                self.networkStuckTime = dict["NetworkStuckTime"] as! String
            }
            if dict.keys.contains("Os") {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("PlayTs") {
                self.playTs = dict["PlayTs"] as! String
            }
            if dict.keys.contains("PlayerLoadDuration") {
                self.playerLoadDuration = dict["PlayerLoadDuration"] as! String
            }
            if dict.keys.contains("PlayerPreDealDuration") {
                self.playerPreDealDuration = dict["PlayerPreDealDuration"] as! String
            }
            if dict.keys.contains("PlayerReadyDuration") {
                self.playerReadyDuration = dict["PlayerReadyDuration"] as! String
            }
            if dict.keys.contains("SdkVersion") {
                self.sdkVersion = dict["SdkVersion"] as! String
            }
            if dict.keys.contains("SessionId") {
                self.sessionId = dict["SessionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TerminalType") {
                self.terminalType = dict["TerminalType"] as! String
            }
        }
    }
    public var baseInfos: [DescribePlayDetailResponseBody.BaseInfos]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseInfos != nil {
            var tmp : [Any] = []
            for k in self.baseInfos! {
                tmp.append(k.toMap())
            }
            map["BaseInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseInfos") {
            self.baseInfos = dict["BaseInfos"] as! [DescribePlayDetailResponseBody.BaseInfos]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePlayDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayEventListRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var playTs: String?

    public var sessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playTs != nil {
            map["PlayTs"] = self.playTs!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PlayTs") {
            self.playTs = dict["PlayTs"] as! String
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
    }
}

public class DescribePlayEventListResponseBody : Tea.TeaModel {
    public class EventList : Tea.TeaModel {
        public var description_: String?

        public var duration: Double?

        public var eventName: String?

        public var time: Int64?

        public var topic: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.eventName != nil {
                map["EventName"] = self.eventName!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("EventName") {
                self.eventName = dict["EventName"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
            if dict.keys.contains("Topic") {
                self.topic = dict["Topic"] as! String
            }
        }
    }
    public var eventList: [DescribePlayEventListResponseBody.EventList]?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventList != nil {
            var tmp : [Any] = []
            for k in self.eventList! {
                tmp.append(k.toMap())
            }
            map["EventList"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventList") {
            self.eventList = dict["EventList"] as! [DescribePlayEventListResponseBody.EventList]
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePlayEventListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayEventListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayEventListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayFirstFrameDurationMetricDataRequest : Tea.TeaModel {
    public var beginTs: String?

    public var endTs: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTs") {
            self.beginTs = dict["BeginTs"] as! String
        }
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! String
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribePlayFirstFrameDurationMetricDataResponseBody : Tea.TeaModel {
    public class Nodes : Tea.TeaModel {
        public var x: Int64?

        public var y: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.x != nil {
                map["X"] = self.x!
            }
            if self.y != nil {
                map["Y"] = self.y!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X") {
                self.x = dict["X"] as! Int64
            }
            if dict.keys.contains("Y") {
                self.y = dict["Y"] as! Int64
            }
        }
    }
    public var nodes: [DescribePlayFirstFrameDurationMetricDataResponseBody.Nodes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["Nodes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Nodes") {
            self.nodes = dict["Nodes"] as! [DescribePlayFirstFrameDurationMetricDataResponseBody.Nodes]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePlayFirstFrameDurationMetricDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayFirstFrameDurationMetricDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayFirstFrameDurationMetricDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayListRequest : Tea.TeaModel {
    public var beginTs: String?

    public var endTs: String?

    public var orderName: String?

    public var orderType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var playType: String?

    public var status: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playType != nil {
            map["PlayType"] = self.playType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTs") {
            self.beginTs = dict["BeginTs"] as! String
        }
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! String
        }
        if dict.keys.contains("OrderName") {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PlayType") {
            self.playType = dict["PlayType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribePlayListResponseBody : Tea.TeaModel {
    public class PlayList : Tea.TeaModel {
        public var firstFrameDuration: String?

        public var playDuration: String?

        public var playTs: String?

        public var playType: String?

        public var sessionId: String?

        public var status: String?

        public var stuckDuration: String?

        public var traceId: String?

        public var videoDuration: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.firstFrameDuration != nil {
                map["FirstFrameDuration"] = self.firstFrameDuration!
            }
            if self.playDuration != nil {
                map["PlayDuration"] = self.playDuration!
            }
            if self.playTs != nil {
                map["PlayTs"] = self.playTs!
            }
            if self.playType != nil {
                map["PlayType"] = self.playType!
            }
            if self.sessionId != nil {
                map["SessionId"] = self.sessionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stuckDuration != nil {
                map["StuckDuration"] = self.stuckDuration!
            }
            if self.traceId != nil {
                map["TraceId"] = self.traceId!
            }
            if self.videoDuration != nil {
                map["VideoDuration"] = self.videoDuration!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FirstFrameDuration") {
                self.firstFrameDuration = dict["FirstFrameDuration"] as! String
            }
            if dict.keys.contains("PlayDuration") {
                self.playDuration = dict["PlayDuration"] as! String
            }
            if dict.keys.contains("PlayTs") {
                self.playTs = dict["PlayTs"] as! String
            }
            if dict.keys.contains("PlayType") {
                self.playType = dict["PlayType"] as! String
            }
            if dict.keys.contains("SessionId") {
                self.sessionId = dict["SessionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StuckDuration") {
                self.stuckDuration = dict["StuckDuration"] as! String
            }
            if dict.keys.contains("TraceId") {
                self.traceId = dict["TraceId"] as! String
            }
            if dict.keys.contains("VideoDuration") {
                self.videoDuration = dict["VideoDuration"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var pageNum: Int64?

    public var pageSize: Int64?

    public var playList: [DescribePlayListResponseBody.PlayList]?

    public var requestId: String?

    public var totalNum: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playList != nil {
            var tmp : [Any] = []
            for k in self.playList! {
                tmp.append(k.toMap())
            }
            map["PlayList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PlayList") {
            self.playList = dict["PlayList"] as! [DescribePlayListResponseBody.PlayList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int64
        }
    }
}

public class DescribePlayListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayMetricDataRequest : Tea.TeaModel {
    public var appName: String?

    public var beginTs: Int64?

    public var definition: String?

    public var endTs: Int64?

    public var experienceLevel: String?

    public var itemConfigs: String?

    public var metricType: String?

    public var network: String?

    public var os: String?

    public var sdkVersion: String?

    public var terminalType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.experienceLevel != nil {
            map["ExperienceLevel"] = self.experienceLevel!
        }
        if self.itemConfigs != nil {
            map["ItemConfigs"] = self.itemConfigs!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.network != nil {
            map["Network"] = self.network!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.sdkVersion != nil {
            map["SdkVersion"] = self.sdkVersion!
        }
        if self.terminalType != nil {
            map["TerminalType"] = self.terminalType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BeginTs") {
            self.beginTs = dict["BeginTs"] as! Int64
        }
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("ExperienceLevel") {
            self.experienceLevel = dict["ExperienceLevel"] as! String
        }
        if dict.keys.contains("ItemConfigs") {
            self.itemConfigs = dict["ItemConfigs"] as! String
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Network") {
            self.network = dict["Network"] as! String
        }
        if dict.keys.contains("Os") {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("SdkVersion") {
            self.sdkVersion = dict["SdkVersion"] as! String
        }
        if dict.keys.contains("TerminalType") {
            self.terminalType = dict["TerminalType"] as! String
        }
    }
}

public class DescribePlayMetricDataResponseBody : Tea.TeaModel {
    public class Nodes : Tea.TeaModel {
        public var x: String?

        public var y: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.x != nil {
                map["X"] = self.x!
            }
            if self.y != nil {
                map["Y"] = self.y!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X") {
                self.x = dict["X"] as! String
            }
            if dict.keys.contains("Y") {
                self.y = dict["Y"] as! String
            }
        }
    }
    public var nodes: [DescribePlayMetricDataResponseBody.Nodes]?

    public var requestId: String?

    public var summaryData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["Nodes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.summaryData != nil {
            map["SummaryData"] = self.summaryData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Nodes") {
            self.nodes = dict["Nodes"] as! [DescribePlayMetricDataResponseBody.Nodes]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SummaryData") {
            self.summaryData = dict["SummaryData"] as! String
        }
    }
}

public class DescribePlayMetricDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayMetricDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayMetricDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayQoeListRequest : Tea.TeaModel {
    public var appName: String?

    public var beginTs: Int64?

    public var definition: String?

    public var endTs: Int64?

    public var itemConfigs: String?

    public var metricTypes: [String]?

    public var network: String?

    public var orderName: String?

    public var orderType: String?

    public var os: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var terminalType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.itemConfigs != nil {
            map["ItemConfigs"] = self.itemConfigs!
        }
        if self.metricTypes != nil {
            map["MetricTypes"] = self.metricTypes!
        }
        if self.network != nil {
            map["Network"] = self.network!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.terminalType != nil {
            map["TerminalType"] = self.terminalType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BeginTs") {
            self.beginTs = dict["BeginTs"] as! Int64
        }
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("ItemConfigs") {
            self.itemConfigs = dict["ItemConfigs"] as! String
        }
        if dict.keys.contains("MetricTypes") {
            self.metricTypes = dict["MetricTypes"] as! [String]
        }
        if dict.keys.contains("Network") {
            self.network = dict["Network"] as! String
        }
        if dict.keys.contains("OrderName") {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Os") {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TerminalType") {
            self.terminalType = dict["TerminalType"] as! String
        }
    }
}

public class DescribePlayQoeListShrinkRequest : Tea.TeaModel {
    public var appName: String?

    public var beginTs: Int64?

    public var definition: String?

    public var endTs: Int64?

    public var itemConfigs: String?

    public var metricTypesShrink: String?

    public var network: String?

    public var orderName: String?

    public var orderType: String?

    public var os: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var terminalType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.itemConfigs != nil {
            map["ItemConfigs"] = self.itemConfigs!
        }
        if self.metricTypesShrink != nil {
            map["MetricTypes"] = self.metricTypesShrink!
        }
        if self.network != nil {
            map["Network"] = self.network!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.terminalType != nil {
            map["TerminalType"] = self.terminalType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BeginTs") {
            self.beginTs = dict["BeginTs"] as! Int64
        }
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("ItemConfigs") {
            self.itemConfigs = dict["ItemConfigs"] as! String
        }
        if dict.keys.contains("MetricTypes") {
            self.metricTypesShrink = dict["MetricTypes"] as! String
        }
        if dict.keys.contains("Network") {
            self.network = dict["Network"] as! String
        }
        if dict.keys.contains("OrderName") {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Os") {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TerminalType") {
            self.terminalType = dict["TerminalType"] as! String
        }
    }
}

public class DescribePlayQoeListResponseBody : Tea.TeaModel {
    public class QoeInfoList : Tea.TeaModel {
        public var qoeFinishedVV: Double?

        public var qoeFinishedVVRate: Double?

        public var qoeUFinishedVVTime: Double?

        public var qoeUV: Double?

        public var qoeUVVDuration: Double?

        public var qoeUVVTime: Double?

        public var qoeVDuration: Double?

        public var qoeVVDuration: Double?

        public var traceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.qoeFinishedVV != nil {
                map["QoeFinishedVV"] = self.qoeFinishedVV!
            }
            if self.qoeFinishedVVRate != nil {
                map["QoeFinishedVVRate"] = self.qoeFinishedVVRate!
            }
            if self.qoeUFinishedVVTime != nil {
                map["QoeUFinishedVVTime"] = self.qoeUFinishedVVTime!
            }
            if self.qoeUV != nil {
                map["QoeUV"] = self.qoeUV!
            }
            if self.qoeUVVDuration != nil {
                map["QoeUVVDuration"] = self.qoeUVVDuration!
            }
            if self.qoeUVVTime != nil {
                map["QoeUVVTime"] = self.qoeUVVTime!
            }
            if self.qoeVDuration != nil {
                map["QoeVDuration"] = self.qoeVDuration!
            }
            if self.qoeVVDuration != nil {
                map["QoeVVDuration"] = self.qoeVVDuration!
            }
            if self.traceId != nil {
                map["TraceId"] = self.traceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("QoeFinishedVV") {
                self.qoeFinishedVV = dict["QoeFinishedVV"] as! Double
            }
            if dict.keys.contains("QoeFinishedVVRate") {
                self.qoeFinishedVVRate = dict["QoeFinishedVVRate"] as! Double
            }
            if dict.keys.contains("QoeUFinishedVVTime") {
                self.qoeUFinishedVVTime = dict["QoeUFinishedVVTime"] as! Double
            }
            if dict.keys.contains("QoeUV") {
                self.qoeUV = dict["QoeUV"] as! Double
            }
            if dict.keys.contains("QoeUVVDuration") {
                self.qoeUVVDuration = dict["QoeUVVDuration"] as! Double
            }
            if dict.keys.contains("QoeUVVTime") {
                self.qoeUVVTime = dict["QoeUVVTime"] as! Double
            }
            if dict.keys.contains("QoeVDuration") {
                self.qoeVDuration = dict["QoeVDuration"] as! Double
            }
            if dict.keys.contains("QoeVVDuration") {
                self.qoeVVDuration = dict["QoeVVDuration"] as! Double
            }
            if dict.keys.contains("TraceId") {
                self.traceId = dict["TraceId"] as! String
            }
        }
    }
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var qoeInfoList: [DescribePlayQoeListResponseBody.QoeInfoList]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.qoeInfoList != nil {
            var tmp : [Any] = []
            for k in self.qoeInfoList! {
                tmp.append(k.toMap())
            }
            map["QoeInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("QoeInfoList") {
            self.qoeInfoList = dict["QoeInfoList"] as! [DescribePlayQoeListResponseBody.QoeInfoList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePlayQoeListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayQoeListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayQoeListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayQosListRequest : Tea.TeaModel {
    public var appName: String?

    public var beginTs: String?

    public var definition: String?

    public var endTs: String?

    public var itemConfigs: String?

    public var metricTypes: [String]?

    public var network: String?

    public var orderName: String?

    public var orderType: String?

    public var os: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var terminalType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.itemConfigs != nil {
            map["ItemConfigs"] = self.itemConfigs!
        }
        if self.metricTypes != nil {
            map["MetricTypes"] = self.metricTypes!
        }
        if self.network != nil {
            map["Network"] = self.network!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.terminalType != nil {
            map["TerminalType"] = self.terminalType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BeginTs") {
            self.beginTs = dict["BeginTs"] as! String
        }
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! String
        }
        if dict.keys.contains("ItemConfigs") {
            self.itemConfigs = dict["ItemConfigs"] as! String
        }
        if dict.keys.contains("MetricTypes") {
            self.metricTypes = dict["MetricTypes"] as! [String]
        }
        if dict.keys.contains("Network") {
            self.network = dict["Network"] as! String
        }
        if dict.keys.contains("OrderName") {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Os") {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TerminalType") {
            self.terminalType = dict["TerminalType"] as! String
        }
    }
}

public class DescribePlayQosListShrinkRequest : Tea.TeaModel {
    public var appName: String?

    public var beginTs: String?

    public var definition: String?

    public var endTs: String?

    public var itemConfigs: String?

    public var metricTypesShrink: String?

    public var network: String?

    public var orderName: String?

    public var orderType: String?

    public var os: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var terminalType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.itemConfigs != nil {
            map["ItemConfigs"] = self.itemConfigs!
        }
        if self.metricTypesShrink != nil {
            map["MetricTypes"] = self.metricTypesShrink!
        }
        if self.network != nil {
            map["Network"] = self.network!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.terminalType != nil {
            map["TerminalType"] = self.terminalType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BeginTs") {
            self.beginTs = dict["BeginTs"] as! String
        }
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! String
        }
        if dict.keys.contains("ItemConfigs") {
            self.itemConfigs = dict["ItemConfigs"] as! String
        }
        if dict.keys.contains("MetricTypes") {
            self.metricTypesShrink = dict["MetricTypes"] as! String
        }
        if dict.keys.contains("Network") {
            self.network = dict["Network"] as! String
        }
        if dict.keys.contains("OrderName") {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Os") {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TerminalType") {
            self.terminalType = dict["TerminalType"] as! String
        }
    }
}

public class DescribePlayQosListResponseBody : Tea.TeaModel {
    public class QosInfoList : Tea.TeaModel {
        public var qosFirstFrame: String?

        public var qosKbps: String?

        public var qosPlay: String?

        public var qosPlayFail: String?

        public var qosRealPlay: String?

        public var qosSeedFailRate: String?

        public var qosStuckRate: String?

        public var traceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.qosFirstFrame != nil {
                map["QosFirstFrame"] = self.qosFirstFrame!
            }
            if self.qosKbps != nil {
                map["QosKbps"] = self.qosKbps!
            }
            if self.qosPlay != nil {
                map["QosPlay"] = self.qosPlay!
            }
            if self.qosPlayFail != nil {
                map["QosPlayFail"] = self.qosPlayFail!
            }
            if self.qosRealPlay != nil {
                map["QosRealPlay"] = self.qosRealPlay!
            }
            if self.qosSeedFailRate != nil {
                map["QosSeedFailRate"] = self.qosSeedFailRate!
            }
            if self.qosStuckRate != nil {
                map["QosStuckRate"] = self.qosStuckRate!
            }
            if self.traceId != nil {
                map["TraceId"] = self.traceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("QosFirstFrame") {
                self.qosFirstFrame = dict["QosFirstFrame"] as! String
            }
            if dict.keys.contains("QosKbps") {
                self.qosKbps = dict["QosKbps"] as! String
            }
            if dict.keys.contains("QosPlay") {
                self.qosPlay = dict["QosPlay"] as! String
            }
            if dict.keys.contains("QosPlayFail") {
                self.qosPlayFail = dict["QosPlayFail"] as! String
            }
            if dict.keys.contains("QosRealPlay") {
                self.qosRealPlay = dict["QosRealPlay"] as! String
            }
            if dict.keys.contains("QosSeedFailRate") {
                self.qosSeedFailRate = dict["QosSeedFailRate"] as! String
            }
            if dict.keys.contains("QosStuckRate") {
                self.qosStuckRate = dict["QosStuckRate"] as! String
            }
            if dict.keys.contains("TraceId") {
                self.traceId = dict["TraceId"] as! String
            }
        }
    }
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var qosInfoList: [DescribePlayQosListResponseBody.QosInfoList]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.qosInfoList != nil {
            var tmp : [Any] = []
            for k in self.qosInfoList! {
                tmp.append(k.toMap())
            }
            map["QosInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("QosInfoList") {
            self.qosInfoList = dict["QosInfoList"] as! [DescribePlayQosListResponseBody.QosInfoList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePlayQosListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayQosListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayQosListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeQueryConfigsRequest : Tea.TeaModel {
    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeQueryConfigsResponseBody : Tea.TeaModel {
    public class Configs : Tea.TeaModel {
        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var configs: [DescribeQueryConfigsResponseBody.Configs]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configs != nil {
            var tmp : [Any] = []
            for k in self.configs! {
                tmp.append(k.toMap())
            }
            map["Configs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Configs") {
            self.configs = dict["Configs"] as! [DescribeQueryConfigsResponseBody.Configs]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeQueryConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeQueryConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeQueryConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCategoriesRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetCategoriesResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: Int64?

        public var cateName: String?

        public var level: Int64?

        public var parentId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SubCategories : Tea.TeaModel {
        public class Category : Tea.TeaModel {
            public var cateId: Int64?

            public var cateName: String?

            public var level: Int64?

            public var parentId: Int64?

            public var subTotal: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.subTotal != nil {
                    map["SubTotal"] = self.subTotal!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! Int64
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! Int64
                }
                if dict.keys.contains("SubTotal") {
                    self.subTotal = dict["SubTotal"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var category: [GetCategoriesResponseBody.SubCategories.Category]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                var tmp : [Any] = []
                for k in self.category! {
                    tmp.append(k.toMap())
                }
                map["Category"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! [GetCategoriesResponseBody.SubCategories.Category]
            }
        }
    }
    public var category: GetCategoriesResponseBody.Category?

    public var requestId: String?

    public var subCategories: GetCategoriesResponseBody.SubCategories?

    public var subTotal: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
        try self.subCategories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCategories != nil {
            map["SubCategories"] = self.subCategories?.toMap()
        }
        if self.subTotal != nil {
            map["SubTotal"] = self.subTotal!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            var model = GetCategoriesResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCategories") {
            var model = GetCategoriesResponseBody.SubCategories()
            model.fromMap(dict["SubCategories"] as! [String: Any])
            self.subCategories = model
        }
        if dict.keys.contains("SubTotal") {
            self.subTotal = dict["SubTotal"] as! Int64
        }
    }
}

public class GetCategoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCategoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCategoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCustomTemplateRequest : Tea.TeaModel {
    public var subtype: Int32?

    public var templateId: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Subtype") {
            self.subtype = dict["Subtype"] as! Int32
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class GetCustomTemplateResponseBody : Tea.TeaModel {
    public class CustomTemplate : Tea.TeaModel {
        public var createTime: String?

        public var isDefault: Bool?

        public var modifiedTime: String?

        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var customTemplate: GetCustomTemplateResponseBody.CustomTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplate != nil {
            map["CustomTemplate"] = self.customTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplate") {
            var model = GetCustomTemplateResponseBody.CustomTemplate()
            model.fromMap(dict["CustomTemplate"] as! [String: Any])
            self.customTemplate = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDefaultStorageLocationResponseBody : Tea.TeaModel {
    public var bucket: String?

    public var path: String?

    public var requestId: String?

    public var status: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class GetDefaultStorageLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDefaultStorageLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDefaultStorageLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDynamicImageJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetDynamicImageJobResponseBody : Tea.TeaModel {
    public class DynamicImageJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetDynamicImageJobResponseBody.DynamicImageJob.Input.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") {
                    var model = GetDynamicImageJobResponseBody.DynamicImageJob.Input.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetDynamicImageJobResponseBody.DynamicImageJob.Output.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") {
                    var model = GetDynamicImageJobResponseBody.DynamicImageJob.Output.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var code: String?

        public var createTime: String?

        public var finishTime: String?

        public var input: GetDynamicImageJobResponseBody.DynamicImageJob.Input?

        public var jobId: String?

        public var message: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: GetDynamicImageJobResponseBody.DynamicImageJob.Output?

        public var outputUrl: String?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateConfig: String?

        public var templateId: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.outputUrl != nil {
                map["OutputUrl"] = self.outputUrl!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = GetDynamicImageJobResponseBody.DynamicImageJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = GetDynamicImageJobResponseBody.DynamicImageJob.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("OutputUrl") {
                self.outputUrl = dict["OutputUrl"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var dynamicImageJob: GetDynamicImageJobResponseBody.DynamicImageJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dynamicImageJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicImageJob != nil {
            map["DynamicImageJob"] = self.dynamicImageJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicImageJob") {
            var model = GetDynamicImageJobResponseBody.DynamicImageJob()
            model.fromMap(dict["DynamicImageJob"] as! [String: Any])
            self.dynamicImageJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDynamicImageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDynamicImageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDynamicImageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingProjectRequest : Tea.TeaModel {
    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class GetEditingProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var clipsParam: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var duration: Int64?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: String?

        public var templateId: String?

        public var templateType: String?

        public var timeline: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var project: GetEditingProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") {
            var model = GetEditingProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingProjectMaterialsRequest : Tea.TeaModel {
    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class GetEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public class LiveMaterials : Tea.TeaModel {
        public var appName: String?

        public var domainName: String?

        public var liveUrl: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.liveUrl != nil {
                map["LiveUrl"] = self.liveUrl!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("LiveUrl") {
                self.liveUrl = dict["LiveUrl"] as! String
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
        }
    }
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: GetEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                self.fileInfoList = dict["FileInfoList"] as! [GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList]
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = GetEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var liveMaterials: [GetEditingProjectMaterialsResponseBody.LiveMaterials]?

    public var mediaInfos: [GetEditingProjectMaterialsResponseBody.MediaInfos]?

    public var projectId: String?

    public var projectMaterials: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveMaterials != nil {
            var tmp : [Any] = []
            for k in self.liveMaterials! {
                tmp.append(k.toMap())
            }
            map["LiveMaterials"] = tmp
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectMaterials != nil {
            map["ProjectMaterials"] = self.projectMaterials!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveMaterials") {
            self.liveMaterials = dict["LiveMaterials"] as! [GetEditingProjectMaterialsResponseBody.LiveMaterials]
        }
        if dict.keys.contains("MediaInfos") {
            self.mediaInfos = dict["MediaInfos"] as! [GetEditingProjectMaterialsResponseBody.MediaInfos]
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectMaterials") {
            self.projectMaterials = dict["ProjectMaterials"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEventCallbackResponseBody : Tea.TeaModel {
    public var authKey: String?

    public var authSwitch: String?

    public var callbackQueueName: String?

    public var callbackType: String?

    public var callbackURL: String?

    public var eventTypeList: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.authSwitch != nil {
            map["AuthSwitch"] = self.authSwitch!
        }
        if self.callbackQueueName != nil {
            map["CallbackQueueName"] = self.callbackQueueName!
        }
        if self.callbackType != nil {
            map["CallbackType"] = self.callbackType!
        }
        if self.callbackURL != nil {
            map["CallbackURL"] = self.callbackURL!
        }
        if self.eventTypeList != nil {
            map["EventTypeList"] = self.eventTypeList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthKey") {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("AuthSwitch") {
            self.authSwitch = dict["AuthSwitch"] as! String
        }
        if dict.keys.contains("CallbackQueueName") {
            self.callbackQueueName = dict["CallbackQueueName"] as! String
        }
        if dict.keys.contains("CallbackType") {
            self.callbackType = dict["CallbackType"] as! String
        }
        if dict.keys.contains("CallbackURL") {
            self.callbackURL = dict["CallbackURL"] as! String
        }
        if dict.keys.contains("EventTypeList") {
            self.eventTypeList = dict["EventTypeList"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEventCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEventCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEventCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveEditingIndexFileRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var projectId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class GetLiveEditingIndexFileResponseBody : Tea.TeaModel {
    public var indexFile: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexFile != nil {
            map["IndexFile"] = self.indexFile!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndexFile") {
            self.indexFile = dict["IndexFile"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveEditingIndexFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveEditingIndexFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveEditingIndexFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveEditingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveEditingJobResponseBody : Tea.TeaModel {
    public class LiveEditingJob : Tea.TeaModel {
        public class LiveStreamConfig : Tea.TeaModel {
            public var appName: String?

            public var domainName: String?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
            }
        }
        public class MediaProduceConfig : Tea.TeaModel {
            public var mode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! String
                }
            }
        }
        public class OutputMediaConfig : Tea.TeaModel {
            public var bitrate: Int64?

            public var fileName: String?

            public var height: Int32?

            public var mediaURL: String?

            public var storageLocation: String?

            public var vodTemplateGroupId: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.mediaURL != nil {
                    map["MediaURL"] = self.mediaURL!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.vodTemplateGroupId != nil {
                    map["VodTemplateGroupId"] = self.vodTemplateGroupId!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! Int64
                }
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("MediaURL") {
                    self.mediaURL = dict["MediaURL"] as! String
                }
                if dict.keys.contains("StorageLocation") {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("VodTemplateGroupId") {
                    self.vodTemplateGroupId = dict["VodTemplateGroupId"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var clips: String?

        public var code: String?

        public var completeTime: String?

        public var creationTime: String?

        public var jobId: String?

        public var liveStreamConfig: GetLiveEditingJobResponseBody.LiveEditingJob.LiveStreamConfig?

        public var mediaId: String?

        public var mediaProduceConfig: GetLiveEditingJobResponseBody.LiveEditingJob.MediaProduceConfig?

        public var mediaURL: String?

        public var message: String?

        public var modifiedTime: String?

        public var outputMediaConfig: GetLiveEditingJobResponseBody.LiveEditingJob.OutputMediaConfig?

        public var projectId: String?

        public var status: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.liveStreamConfig?.validate()
            try self.mediaProduceConfig?.validate()
            try self.outputMediaConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clips != nil {
                map["Clips"] = self.clips!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.liveStreamConfig != nil {
                map["LiveStreamConfig"] = self.liveStreamConfig?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaProduceConfig != nil {
                map["MediaProduceConfig"] = self.mediaProduceConfig?.toMap()
            }
            if self.mediaURL != nil {
                map["MediaURL"] = self.mediaURL!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputMediaConfig != nil {
                map["OutputMediaConfig"] = self.outputMediaConfig?.toMap()
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Clips") {
                self.clips = dict["Clips"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("LiveStreamConfig") {
                var model = GetLiveEditingJobResponseBody.LiveEditingJob.LiveStreamConfig()
                model.fromMap(dict["LiveStreamConfig"] as! [String: Any])
                self.liveStreamConfig = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaProduceConfig") {
                var model = GetLiveEditingJobResponseBody.LiveEditingJob.MediaProduceConfig()
                model.fromMap(dict["MediaProduceConfig"] as! [String: Any])
                self.mediaProduceConfig = model
            }
            if dict.keys.contains("MediaURL") {
                self.mediaURL = dict["MediaURL"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputMediaConfig") {
                var model = GetLiveEditingJobResponseBody.LiveEditingJob.OutputMediaConfig()
                model.fromMap(dict["OutputMediaConfig"] as! [String: Any])
                self.outputMediaConfig = model
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var liveEditingJob: GetLiveEditingJobResponseBody.LiveEditingJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveEditingJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveEditingJob != nil {
            map["LiveEditingJob"] = self.liveEditingJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveEditingJob") {
            var model = GetLiveEditingJobResponseBody.LiveEditingJob()
            model.fromMap(dict["LiveEditingJob"] as! [String: Any])
            self.liveEditingJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveEditingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveEditingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveEditingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveRecordJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveRecordJobResponseBody : Tea.TeaModel {
    public class RecordJob : Tea.TeaModel {
        public class RecordOutput : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var notifyUrl: String?

        public var recordOutput: GetLiveRecordJobResponseBody.RecordJob.RecordOutput?

        public var status: String?

        public var streamInput: GetLiveRecordJobResponseBody.RecordJob.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordOutput?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            if self.recordOutput != nil {
                map["RecordOutput"] = self.recordOutput?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyUrl") {
                self.notifyUrl = dict["NotifyUrl"] as! String
            }
            if dict.keys.contains("RecordOutput") {
                var model = GetLiveRecordJobResponseBody.RecordJob.RecordOutput()
                model.fromMap(dict["RecordOutput"] as! [String: Any])
                self.recordOutput = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StreamInput") {
                var model = GetLiveRecordJobResponseBody.RecordJob.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var recordJob: GetLiveRecordJobResponseBody.RecordJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordJob != nil {
            map["RecordJob"] = self.recordJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordJob") {
            var model = GetLiveRecordJobResponseBody.RecordJob()
            model.fromMap(dict["RecordJob"] as! [String: Any])
            self.recordJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveRecordJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveRecordJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveRecordJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveRecordTemplateRequest : Tea.TeaModel {
    public var jobId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetLiveRecordTemplateResponseBody : Tea.TeaModel {
    public class RecordTemplate : Tea.TeaModel {
        public class RecordFormatList : Tea.TeaModel {
            public var cycleDuration: Int32?

            public var format: String?

            public var ossObjectPrefix: String?

            public var sliceDuration: Int32?

            public var sliceOssObjectPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleDuration != nil {
                    map["CycleDuration"] = self.cycleDuration!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.ossObjectPrefix != nil {
                    map["OssObjectPrefix"] = self.ossObjectPrefix!
                }
                if self.sliceDuration != nil {
                    map["SliceDuration"] = self.sliceDuration!
                }
                if self.sliceOssObjectPrefix != nil {
                    map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CycleDuration") {
                    self.cycleDuration = dict["CycleDuration"] as! Int32
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("OssObjectPrefix") {
                    self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
                }
                if dict.keys.contains("SliceDuration") {
                    self.sliceDuration = dict["SliceDuration"] as! Int32
                }
                if dict.keys.contains("SliceOssObjectPrefix") {
                    self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
                }
            }
        }
        public var createTime: String?

        public var lastModified: String?

        public var name: String?

        public var recordFormatList: [GetLiveRecordTemplateResponseBody.RecordTemplate.RecordFormatList]?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordFormatList != nil {
                var tmp : [Any] = []
                for k in self.recordFormatList! {
                    tmp.append(k.toMap())
                }
                map["RecordFormatList"] = tmp
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordFormatList") {
                self.recordFormatList = dict["RecordFormatList"] as! [GetLiveRecordTemplateResponseBody.RecordTemplate.RecordFormatList]
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var recordTemplate: GetLiveRecordTemplateResponseBody.RecordTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordTemplate != nil {
            map["RecordTemplate"] = self.recordTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordTemplate") {
            var model = GetLiveRecordTemplateResponseBody.RecordTemplate()
            model.fromMap(dict["RecordTemplate"] as! [String: Any])
            self.recordTemplate = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveSnapshotJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveSnapshotJobResponseBody : Tea.TeaModel {
    public class SnapshotOutput : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("StorageType") {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public class StreamInput : Tea.TeaModel {
        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var callbackUrl: String?

    public var createTime: String?

    public var jobId: String?

    public var jobName: String?

    public var lastModified: String?

    public var overwriteFormat: String?

    public var requestId: String?

    public var sequenceFormat: String?

    public var snapshotOutput: GetLiveSnapshotJobResponseBody.SnapshotOutput?

    public var status: String?

    public var streamInput: GetLiveSnapshotJobResponseBody.StreamInput?

    public var templateId: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotOutput?.validate()
        try self.streamInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.lastModified != nil {
            map["LastModified"] = self.lastModified!
        }
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.snapshotOutput != nil {
            map["SnapshotOutput"] = self.snapshotOutput?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("LastModified") {
            self.lastModified = dict["LastModified"] as! String
        }
        if dict.keys.contains("OverwriteFormat") {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SequenceFormat") {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("SnapshotOutput") {
            var model = GetLiveSnapshotJobResponseBody.SnapshotOutput()
            model.fromMap(dict["SnapshotOutput"] as! [String: Any])
            self.snapshotOutput = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StreamInput") {
            var model = GetLiveSnapshotJobResponseBody.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class GetLiveSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var createTime: String?

    public var lastModified: String?

    public var overwriteFormat: String?

    public var requestId: String?

    public var sequenceFormat: String?

    public var templateId: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.lastModified != nil {
            map["LastModified"] = self.lastModified!
        }
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("LastModified") {
            self.lastModified = dict["LastModified"] as! String
        }
        if dict.keys.contains("OverwriteFormat") {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SequenceFormat") {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveTranscodeJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveTranscodeJobResponseBody : Tea.TeaModel {
    public class Job : Tea.TeaModel {
        public class OutputStream : Tea.TeaModel {
            public class StreamInfos : Tea.TeaModel {
                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var streamInfos: [GetLiveTranscodeJobResponseBody.Job.OutputStream.StreamInfos]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.streamInfos != nil {
                    var tmp : [Any] = []
                    for k in self.streamInfos! {
                        tmp.append(k.toMap())
                    }
                    map["StreamInfos"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("StreamInfos") {
                    self.streamInfos = dict["StreamInfos"] as! [GetLiveTranscodeJobResponseBody.Job.OutputStream.StreamInfos]
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var inputUrl: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputUrl") {
                    self.inputUrl = dict["InputUrl"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var outputStream: GetLiveTranscodeJobResponseBody.Job.OutputStream?

        public var startMode: Int32?

        public var status: Int32?

        public var streamInput: GetLiveTranscodeJobResponseBody.Job.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.outputStream?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputStream != nil {
                map["OutputStream"] = self.outputStream?.toMap()
            }
            if self.startMode != nil {
                map["StartMode"] = self.startMode!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputStream") {
                var model = GetLiveTranscodeJobResponseBody.Job.OutputStream()
                model.fromMap(dict["OutputStream"] as! [String: Any])
                self.outputStream = model
            }
            if dict.keys.contains("StartMode") {
                self.startMode = dict["StartMode"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StreamInput") {
                var model = GetLiveTranscodeJobResponseBody.Job.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var job: GetLiveTranscodeJobResponseBody.Job?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.job?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.job != nil {
            map["Job"] = self.job?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Job") {
            var model = GetLiveTranscodeJobResponseBody.Job()
            model.fromMap(dict["Job"] as! [String: Any])
            self.job = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveTranscodeTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public class TemplateContent : Tea.TeaModel {
        public class TemplateConfig : Tea.TeaModel {
            public class AudioParams : Tea.TeaModel {
                public var bitrate: String?

                public var channels: String?

                public var codec: String?

                public var profile: String?

                public var samplerate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.samplerate != nil {
                        map["Samplerate"] = self.samplerate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Samplerate") {
                        self.samplerate = dict["Samplerate"] as! String
                    }
                }
            }
            public class VideoParams : Tea.TeaModel {
                public var bitrate: String?

                public var codec: String?

                public var fps: String?

                public var gop: String?

                public var height: String?

                public var profile: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Gop") {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioParams: GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.AudioParams?

            public var videoParams: GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.VideoParams?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioParams?.validate()
                try self.videoParams?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioParams != nil {
                    map["AudioParams"] = self.audioParams?.toMap()
                }
                if self.videoParams != nil {
                    map["VideoParams"] = self.videoParams?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioParams") {
                    var model = GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.AudioParams()
                    model.fromMap(dict["AudioParams"] as! [String: Any])
                    self.audioParams = model
                }
                if dict.keys.contains("VideoParams") {
                    var model = GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.VideoParams()
                    model.fromMap(dict["VideoParams"] as! [String: Any])
                    self.videoParams = model
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var name: String?

        public var templateConfig: GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.templateConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                var model = GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig()
                model.fromMap(dict["TemplateConfig"] as! [String: Any])
                self.templateConfig = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateContent: GetLiveTranscodeTemplateResponseBody.TemplateContent?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateContent != nil {
            map["TemplateContent"] = self.templateContent?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateContent") {
            var model = GetLiveTranscodeTemplateResponseBody.TemplateContent()
            model.fromMap(dict["TemplateContent"] as! [String: Any])
            self.templateContent = model
        }
    }
}

public class GetLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaInfoRequest : Tea.TeaModel {
    public var inputURL: String?

    public var mediaId: String?

    public var outputType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OutputType") {
            self.outputType = dict["OutputType"] as! String
        }
    }
}

public class GetMediaInfoResponseBody : Tea.TeaModel {
    public class MediaInfo : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var fps: String?

                public var index: String?

                public var lang: String?

                public var numFrames: String?

                public var profile: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var createTime: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var modifiedTime: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class SubtitleStreamInfoList : Tea.TeaModel {
                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFPS: String?

                public var bitrate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var nbFrames: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timebase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFPS != nil {
                        map["AvgFPS"] = self.avgFPS!
                    }
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["HasBFrames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.nbFrames != nil {
                        map["Nb_frames"] = self.nbFrames!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvgFPS") {
                        self.avgFPS = dict["AvgFPS"] as! String
                    }
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("HasBFrames") {
                        self.hasBFrames = dict["HasBFrames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Nb_frames") {
                        self.nbFrames = dict["Nb_frames"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList]?

            public var fileBasicInfo: GetMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo?

            public var subtitleStreamInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList]?

            public var videoStreamInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.subtitleStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.subtitleStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["SubtitleStreamInfoList"] = tmp
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    self.audioStreamInfoList = dict["AudioStreamInfoList"] as! [GetMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList]
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("SubtitleStreamInfoList") {
                    self.subtitleStreamInfoList = dict["SubtitleStreamInfoList"] as! [GetMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList]
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    self.videoStreamInfoList = dict["VideoStreamInfoList"] as! [GetMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList]
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var cateId: Int64?

            public var cateName: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var referenceId: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var uploadSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.uploadSource != nil {
                    map["UploadSource"] = self.uploadSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UploadSource") {
                    self.uploadSource = dict["UploadSource"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList]?

        public var mediaBasicInfo: GetMediaInfoResponseBody.MediaInfo.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                self.fileInfoList = dict["FileInfoList"] as! [GetMediaInfoResponseBody.MediaInfo.FileInfoList]
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = GetMediaInfoResponseBody.MediaInfo.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var mediaInfo: GetMediaInfoResponseBody.MediaInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfo != nil {
            map["MediaInfo"] = self.mediaInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfo") {
            var model = GetMediaInfoResponseBody.MediaInfo()
            model.fromMap(dict["MediaInfo"] as! [String: Any])
            self.mediaInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaInfoJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    self.audioStreamInfoList = dict["AudioStreamInfoList"] as! [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    self.videoStreamInfoList = dict["VideoStreamInfoList"] as! [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: GetMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var mediaInfoProperty: GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: GetMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = GetMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") {
                var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = GetMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: GetMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") {
            var model = GetMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
    }
}

public class GetMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaProducingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetMediaProducingJobResponseBody : Tea.TeaModel {
    public class MediaProducingJob : Tea.TeaModel {
        public var clipsParam: String?

        public var code: String?

        public var completeTime: String?

        public var createTime: String?

        public var duration: Double?

        public var jobId: String?

        public var mediaId: String?

        public var mediaURL: String?

        public var message: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var status: String?

        public var templateId: String?

        public var timeline: String?

        public var vodMediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaURL != nil {
                map["MediaURL"] = self.mediaURL!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.vodMediaId != nil {
                map["VodMediaId"] = self.vodMediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaURL") {
                self.mediaURL = dict["MediaURL"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("VodMediaId") {
                self.vodMediaId = dict["VodMediaId"] as! String
            }
        }
    }
    public var mediaProducingJob: GetMediaProducingJobResponseBody.MediaProducingJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaProducingJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaProducingJob != nil {
            map["MediaProducingJob"] = self.mediaProducingJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaProducingJob") {
            var model = GetMediaProducingJobResponseBody.MediaProducingJob()
            model.fromMap(dict["MediaProducingJob"] as! [String: Any])
            self.mediaProducingJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaProducingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaProducingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaProducingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPackageJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetPackageJobResponseBody : Tea.TeaModel {
    public class PackageJob : Tea.TeaModel {
        public class Inputs : Tea.TeaModel {
            public class Input : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var input: GetPackageJobResponseBody.PackageJob.Inputs.Input?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.input?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Input") {
                    var model = GetPackageJobResponseBody.PackageJob.Inputs.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var code: String?

        public var createTime: String?

        public var finishTime: String?

        public var inputs: [GetPackageJobResponseBody.PackageJob.Inputs]?

        public var jobId: String?

        public var message: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: GetPackageJobResponseBody.PackageJob.Output?

        public var outputUrl: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var status: String?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputs != nil {
                var tmp : [Any] = []
                for k in self.inputs! {
                    tmp.append(k.toMap())
                }
                map["Inputs"] = tmp
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.outputUrl != nil {
                map["OutputUrl"] = self.outputUrl!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Inputs") {
                self.inputs = dict["Inputs"] as! [GetPackageJobResponseBody.PackageJob.Inputs]
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = GetPackageJobResponseBody.PackageJob.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("OutputUrl") {
                self.outputUrl = dict["OutputUrl"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var packageJob: GetPackageJobResponseBody.PackageJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packageJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packageJob != nil {
            map["PackageJob"] = self.packageJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackageJob") {
            var model = GetPackageJobResponseBody.PackageJob()
            model.fromMap(dict["PackageJob"] as! [String: Any])
            self.packageJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPackageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPackageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPackageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPipelineRequest : Tea.TeaModel {
    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
    }
}

public class GetPipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public var createTime: String?

        public var modifiedTime: String?

        public var name: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var speed: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipeline: GetPipelineResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") {
            var model = GetPipelineResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPlayInfoRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class GetPlayInfoResponseBody : Tea.TeaModel {
    public class MediaBase : Tea.TeaModel {
        public var coverURL: String?

        public var creationTime: String?

        public var mediaId: String?

        public var mediaType: String?

        public var status: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaType != nil {
                map["MediaType"] = self.mediaType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaType") {
                self.mediaType = dict["MediaType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class PlayInfoList : Tea.TeaModel {
        public var bitDepth: Int32?

        public var bitrate: String?

        public var creationTime: String?

        public var definition: String?

        public var duration: String?

        public var encrypt: Int64?

        public var encryptType: String?

        public var fileURL: String?

        public var format: String?

        public var fps: String?

        public var HDRType: String?

        public var height: Int64?

        public var modificationTime: String?

        public var narrowBandType: String?

        public var playURL: String?

        public var size: Int64?

        public var status: String?

        public var streamType: String?

        public var transTemplateType: String?

        public var watermarkId: String?

        public var width: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitDepth != nil {
                map["BitDepth"] = self.bitDepth!
            }
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.definition != nil {
                map["Definition"] = self.definition!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.encrypt != nil {
                map["Encrypt"] = self.encrypt!
            }
            if self.encryptType != nil {
                map["EncryptType"] = self.encryptType!
            }
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.HDRType != nil {
                map["HDRType"] = self.HDRType!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.narrowBandType != nil {
                map["NarrowBandType"] = self.narrowBandType!
            }
            if self.playURL != nil {
                map["PlayURL"] = self.playURL!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamType != nil {
                map["StreamType"] = self.streamType!
            }
            if self.transTemplateType != nil {
                map["TransTemplateType"] = self.transTemplateType!
            }
            if self.watermarkId != nil {
                map["WatermarkId"] = self.watermarkId!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BitDepth") {
                self.bitDepth = dict["BitDepth"] as! Int32
            }
            if dict.keys.contains("Bitrate") {
                self.bitrate = dict["Bitrate"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Definition") {
                self.definition = dict["Definition"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Encrypt") {
                self.encrypt = dict["Encrypt"] as! Int64
            }
            if dict.keys.contains("EncryptType") {
                self.encryptType = dict["EncryptType"] as! String
            }
            if dict.keys.contains("FileURL") {
                self.fileURL = dict["FileURL"] as! String
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Fps") {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("HDRType") {
                self.HDRType = dict["HDRType"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int64
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("NarrowBandType") {
                self.narrowBandType = dict["NarrowBandType"] as! String
            }
            if dict.keys.contains("PlayURL") {
                self.playURL = dict["PlayURL"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StreamType") {
                self.streamType = dict["StreamType"] as! String
            }
            if dict.keys.contains("TransTemplateType") {
                self.transTemplateType = dict["TransTemplateType"] as! String
            }
            if dict.keys.contains("WatermarkId") {
                self.watermarkId = dict["WatermarkId"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int64
            }
        }
    }
    public var mediaBase: GetPlayInfoResponseBody.MediaBase?

    public var playInfoList: [GetPlayInfoResponseBody.PlayInfoList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaBase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaBase != nil {
            map["MediaBase"] = self.mediaBase?.toMap()
        }
        if self.playInfoList != nil {
            var tmp : [Any] = []
            for k in self.playInfoList! {
                tmp.append(k.toMap())
            }
            map["PlayInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaBase") {
            var model = GetPlayInfoResponseBody.MediaBase()
            model.fromMap(dict["MediaBase"] as! [String: Any])
            self.mediaBase = model
        }
        if dict.keys.contains("PlayInfoList") {
            self.playInfoList = dict["PlayInfoList"] as! [GetPlayInfoResponseBody.PlayInfoList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPublicMediaInfoRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class GetPublicMediaInfoResponseBody : Tea.TeaModel {
    public class MediaInfo : Tea.TeaModel {
        public class DynamicMetaData : Tea.TeaModel {
            public var data: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class FileInfoList : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var fps: String?

                public var index: String?

                public var lang: String?

                public var numFrames: String?

                public var profile: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class SubtitleStreamInfoList : Tea.TeaModel {
                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFPS: String?

                public var bitrate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var nbFrames: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timebase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFPS != nil {
                        map["AvgFPS"] = self.avgFPS!
                    }
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["HasBFrames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.nbFrames != nil {
                        map["Nb_frames"] = self.nbFrames!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvgFPS") {
                        self.avgFPS = dict["AvgFPS"] as! String
                    }
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("HasBFrames") {
                        self.hasBFrames = dict["HasBFrames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Nb_frames") {
                        self.nbFrames = dict["Nb_frames"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList]?

            public var fileBasicInfo: GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo?

            public var subtitleStreamInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList]?

            public var videoStreamInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.subtitleStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.subtitleStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["SubtitleStreamInfoList"] = tmp
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    self.audioStreamInfoList = dict["AudioStreamInfoList"] as! [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList]
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("SubtitleStreamInfoList") {
                    self.subtitleStreamInfoList = dict["SubtitleStreamInfoList"] as! [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList]
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    self.videoStreamInfoList = dict["VideoStreamInfoList"] as! [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList]
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var dynamicMetaData: GetPublicMediaInfoResponseBody.MediaInfo.DynamicMetaData?

        public var fileInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList]?

        public var mediaBasicInfo: GetPublicMediaInfoResponseBody.MediaInfo.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dynamicMetaData?.validate()
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dynamicMetaData != nil {
                map["DynamicMetaData"] = self.dynamicMetaData?.toMap()
            }
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DynamicMetaData") {
                var model = GetPublicMediaInfoResponseBody.MediaInfo.DynamicMetaData()
                model.fromMap(dict["DynamicMetaData"] as! [String: Any])
                self.dynamicMetaData = model
            }
            if dict.keys.contains("FileInfoList") {
                self.fileInfoList = dict["FileInfoList"] as! [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList]
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = GetPublicMediaInfoResponseBody.MediaInfo.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var mediaInfo: GetPublicMediaInfoResponseBody.MediaInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfo != nil {
            map["MediaInfo"] = self.mediaInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfo") {
            var model = GetPublicMediaInfoResponseBody.MediaInfo()
            model.fromMap(dict["MediaInfo"] as! [String: Any])
            self.mediaInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPublicMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPublicMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPublicMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSmartHandleJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetSmartHandleJobResponseBody : Tea.TeaModel {
    public class SmartJobInfo : Tea.TeaModel {
        public class InputConfig : Tea.TeaModel {
            public var inputFile: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputFile != nil {
                    map["InputFile"] = self.inputFile!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputFile") {
                    self.inputFile = dict["InputFile"] as! String
                }
            }
        }
        public class OutputConfig : Tea.TeaModel {
            public var bucket: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public var createTime: String?

        public var description_: String?

        public var inputConfig: GetSmartHandleJobResponseBody.SmartJobInfo.InputConfig?

        public var jobType: String?

        public var modifiedTime: String?

        public var outputConfig: GetSmartHandleJobResponseBody.SmartJobInfo.OutputConfig?

        public var title: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inputConfig?.validate()
            try self.outputConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.inputConfig != nil {
                map["InputConfig"] = self.inputConfig?.toMap()
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputConfig != nil {
                map["OutputConfig"] = self.outputConfig?.toMap()
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InputConfig") {
                var model = GetSmartHandleJobResponseBody.SmartJobInfo.InputConfig()
                model.fromMap(dict["InputConfig"] as! [String: Any])
                self.inputConfig = model
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputConfig") {
                var model = GetSmartHandleJobResponseBody.SmartJobInfo.OutputConfig()
                model.fromMap(dict["OutputConfig"] as! [String: Any])
                self.outputConfig = model
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var jobId: String?

    public var output: String?

    public var requestId: String?

    public var smartJobInfo: GetSmartHandleJobResponseBody.SmartJobInfo?

    public var state: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.smartJobInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.smartJobInfo != nil {
            map["SmartJobInfo"] = self.smartJobInfo?.toMap()
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SmartJobInfo") {
            var model = GetSmartHandleJobResponseBody.SmartJobInfo()
            model.fromMap(dict["SmartJobInfo"] as! [String: Any])
            self.smartJobInfo = model
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class GetSmartHandleJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSmartHandleJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSmartHandleJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSnapshotJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetSnapshotJobResponseBody : Tea.TeaModel {
    public class SnapshotJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetSnapshotJobResponseBody.SnapshotJob.Input.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") {
                    var model = GetSnapshotJobResponseBody.SnapshotJob.Input.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetSnapshotJobResponseBody.SnapshotJob.Output.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") {
                    var model = GetSnapshotJobResponseBody.SnapshotJob.Output.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var async: Bool?

        public var code: String?

        public var count: Int32?

        public var createTime: String?

        public var finishTime: String?

        public var input: GetSnapshotJobResponseBody.SnapshotJob.Input?

        public var jobId: String?

        public var message: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: GetSnapshotJobResponseBody.SnapshotJob.Output?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateConfig: String?

        public var templateId: String?

        public var triggerSource: String?

        public var type: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = GetSnapshotJobResponseBody.SnapshotJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = GetSnapshotJobResponseBody.SnapshotJob.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var snapshotJob: GetSnapshotJobResponseBody.SnapshotJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotJob != nil {
            map["SnapshotJob"] = self.snapshotJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotJob") {
            var model = GetSnapshotJobResponseBody.SnapshotJob()
            model.fromMap(dict["SnapshotJob"] as! [String: Any])
            self.snapshotJob = model
        }
    }
}

public class GetSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSnapshotUrlsRequest : Tea.TeaModel {
    public var jobId: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
    }
}

public class GetSnapshotUrlsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotUrls: [String]?

    public var total: Int32?

    public var webVTTUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotUrls != nil {
            map["SnapshotUrls"] = self.snapshotUrls!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.webVTTUrl != nil {
            map["WebVTTUrl"] = self.webVTTUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotUrls") {
            self.snapshotUrls = dict["SnapshotUrls"] as! [String]
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
        if dict.keys.contains("WebVTTUrl") {
            self.webVTTUrl = dict["WebVTTUrl"] as! String
        }
    }
}

public class GetSnapshotUrlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSnapshotUrlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSnapshotUrlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSystemTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetSystemTemplateResponseBody : Tea.TeaModel {
    public class SystemTemplate : Tea.TeaModel {
        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var requestId: String?

    public var systemTemplate: GetSystemTemplateResponseBody.SystemTemplate?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemTemplate != nil {
            map["SystemTemplate"] = self.systemTemplate?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemTemplate") {
            var model = GetSystemTemplateResponseBody.SystemTemplate()
            model.fromMap(dict["SystemTemplate"] as! [String: Any])
            self.systemTemplate = model
        }
    }
}

public class GetSystemTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSystemTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSystemTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateRequest : Tea.TeaModel {
    public var relatedMediaidFlag: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.relatedMediaidFlag != nil {
            map["RelatedMediaidFlag"] = self.relatedMediaidFlag!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RelatedMediaidFlag") {
            self.relatedMediaidFlag = dict["RelatedMediaidFlag"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var clipsParam: String?

        public var config: String?

        public var coverURL: String?

        public var createSource: String?

        public var creationTime: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var name: String?

        public var previewMedia: String?

        public var previewMediaStatus: String?

        public var relatedMediaids: String?

        public var status: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.previewMedia != nil {
                map["PreviewMedia"] = self.previewMedia!
            }
            if self.previewMediaStatus != nil {
                map["PreviewMediaStatus"] = self.previewMediaStatus!
            }
            if self.relatedMediaids != nil {
                map["RelatedMediaids"] = self.relatedMediaids!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PreviewMedia") {
                self.previewMedia = dict["PreviewMedia"] as! String
            }
            if dict.keys.contains("PreviewMediaStatus") {
                self.previewMediaStatus = dict["PreviewMediaStatus"] as! String
            }
            if dict.keys.contains("RelatedMediaids") {
                self.relatedMediaids = dict["RelatedMediaids"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var template: GetTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") {
            var model = GetTemplateResponseBody.Template()
            model.fromMap(dict["Template"] as! [String: Any])
            self.template = model
        }
    }
}

public class GetTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateMaterialsRequest : Tea.TeaModel {
    public var fileList: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileList != nil {
            map["FileList"] = self.fileList!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileList") {
            self.fileList = dict["FileList"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateMaterialsResponseBody : Tea.TeaModel {
    public var materialUrls: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialUrls != nil {
            map["MaterialUrls"] = self.materialUrls!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialUrls") {
            self.materialUrls = dict["MaterialUrls"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTemplateMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTemplateMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTranscodeJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetTranscodeJobResponseBody : Tea.TeaModel {
    public class TranscodeParentJob : Tea.TeaModel {
        public class InputGroup : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class OutputGroup : Tea.TeaModel {
            public class Output : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var video: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs]?

                public var encryption: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption?

                public var imageWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks]?

                public var subtitles: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles]?

                public var textWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks]?

                public var transcode: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        self.combineConfigs = dict["CombineConfigs"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs]
                    }
                    if dict.keys.contains("Encryption") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        self.imageWatermarks = dict["ImageWatermarks"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks]
                    }
                    if dict.keys.contains("Subtitles") {
                        self.subtitles = dict["Subtitles"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles]
                    }
                    if dict.keys.contains("TextWatermarks") {
                        self.textWatermarks = dict["TextWatermarks"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks]
                    }
                    if dict.keys.contains("Transcode") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public var output: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output?

            public var processConfig: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
                try self.processConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Output") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public class TranscodeJobList : Tea.TeaModel {
            public class InputGroup : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class OutFileMeta : Tea.TeaModel {
                public class AudioStreamInfoList : Tea.TeaModel {
                    public var bitrate: String?

                    public var channelLayout: String?

                    public var channels: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var duration: String?

                    public var index: String?

                    public var lang: String?

                    public var sampleFmt: String?

                    public var sampleRate: String?

                    public var startTime: String?

                    public var timebase: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channelLayout != nil {
                            map["ChannelLayout"] = self.channelLayout!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codecLongName != nil {
                            map["CodecLongName"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["CodecName"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["CodecTag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["CodecTagString"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["CodecTimeBase"] = self.codecTimeBase!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.sampleFmt != nil {
                            map["SampleFmt"] = self.sampleFmt!
                        }
                        if self.sampleRate != nil {
                            map["SampleRate"] = self.sampleRate!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.timebase != nil {
                            map["Timebase"] = self.timebase!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("ChannelLayout") {
                            self.channelLayout = dict["ChannelLayout"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("CodecLongName") {
                            self.codecLongName = dict["CodecLongName"] as! String
                        }
                        if dict.keys.contains("CodecName") {
                            self.codecName = dict["CodecName"] as! String
                        }
                        if dict.keys.contains("CodecTag") {
                            self.codecTag = dict["CodecTag"] as! String
                        }
                        if dict.keys.contains("CodecTagString") {
                            self.codecTagString = dict["CodecTagString"] as! String
                        }
                        if dict.keys.contains("CodecTimeBase") {
                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Index") {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("SampleFmt") {
                            self.sampleFmt = dict["SampleFmt"] as! String
                        }
                        if dict.keys.contains("SampleRate") {
                            self.sampleRate = dict["SampleRate"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("Timebase") {
                            self.timebase = dict["Timebase"] as! String
                        }
                    }
                }
                public class FileBasicInfo : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var fileName: String?

                    public var fileSize: String?

                    public var fileStatus: String?

                    public var fileType: String?

                    public var fileUrl: String?

                    public var formatName: String?

                    public var height: String?

                    public var mediaId: String?

                    public var region: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileName != nil {
                            map["FileName"] = self.fileName!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.fileStatus != nil {
                            map["FileStatus"] = self.fileStatus!
                        }
                        if self.fileType != nil {
                            map["FileType"] = self.fileType!
                        }
                        if self.fileUrl != nil {
                            map["FileUrl"] = self.fileUrl!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.mediaId != nil {
                            map["MediaId"] = self.mediaId!
                        }
                        if self.region != nil {
                            map["Region"] = self.region!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileName") {
                            self.fileName = dict["FileName"] as! String
                        }
                        if dict.keys.contains("FileSize") {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("FileStatus") {
                            self.fileStatus = dict["FileStatus"] as! String
                        }
                        if dict.keys.contains("FileType") {
                            self.fileType = dict["FileType"] as! String
                        }
                        if dict.keys.contains("FileUrl") {
                            self.fileUrl = dict["FileUrl"] as! String
                        }
                        if dict.keys.contains("FormatName") {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MediaId") {
                            self.mediaId = dict["MediaId"] as! String
                        }
                        if dict.keys.contains("Region") {
                            self.region = dict["Region"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class VideoStreamInfoList : Tea.TeaModel {
                    public var avgFps: String?

                    public var bitRate: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var dar: String?

                    public var duration: String?

                    public var fps: String?

                    public var hasBFrames: String?

                    public var height: String?

                    public var index: String?

                    public var lang: String?

                    public var level: String?

                    public var numFrames: String?

                    public var pixFmt: String?

                    public var profile: String?

                    public var rotate: String?

                    public var sar: String?

                    public var startTime: String?

                    public var timeBase: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgFps != nil {
                            map["Avg_fps"] = self.avgFps!
                        }
                        if self.bitRate != nil {
                            map["Bit_rate"] = self.bitRate!
                        }
                        if self.codecLongName != nil {
                            map["Codec_long_name"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["Codec_name"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["Codec_tag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["Codec_tag_string"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["Codec_time_base"] = self.codecTimeBase!
                        }
                        if self.dar != nil {
                            map["Dar"] = self.dar!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.hasBFrames != nil {
                            map["Has_b_frames"] = self.hasBFrames!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.numFrames != nil {
                            map["NumFrames"] = self.numFrames!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.rotate != nil {
                            map["Rotate"] = self.rotate!
                        }
                        if self.sar != nil {
                            map["Sar"] = self.sar!
                        }
                        if self.startTime != nil {
                            map["Start_time"] = self.startTime!
                        }
                        if self.timeBase != nil {
                            map["Time_base"] = self.timeBase!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Avg_fps") {
                            self.avgFps = dict["Avg_fps"] as! String
                        }
                        if dict.keys.contains("Bit_rate") {
                            self.bitRate = dict["Bit_rate"] as! String
                        }
                        if dict.keys.contains("Codec_long_name") {
                            self.codecLongName = dict["Codec_long_name"] as! String
                        }
                        if dict.keys.contains("Codec_name") {
                            self.codecName = dict["Codec_name"] as! String
                        }
                        if dict.keys.contains("Codec_tag") {
                            self.codecTag = dict["Codec_tag"] as! String
                        }
                        if dict.keys.contains("Codec_tag_string") {
                            self.codecTagString = dict["Codec_tag_string"] as! String
                        }
                        if dict.keys.contains("Codec_time_base") {
                            self.codecTimeBase = dict["Codec_time_base"] as! String
                        }
                        if dict.keys.contains("Dar") {
                            self.dar = dict["Dar"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Has_b_frames") {
                            self.hasBFrames = dict["Has_b_frames"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Index") {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("Level") {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("NumFrames") {
                            self.numFrames = dict["NumFrames"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Rotate") {
                            self.rotate = dict["Rotate"] as! String
                        }
                        if dict.keys.contains("Sar") {
                            self.sar = dict["Sar"] as! String
                        }
                        if dict.keys.contains("Start_time") {
                            self.startTime = dict["Start_time"] as! String
                        }
                        if dict.keys.contains("Time_base") {
                            self.timeBase = dict["Time_base"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var audioStreamInfoList: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList]?

                public var fileBasicInfo: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo?

                public var videoStreamInfoList: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.fileBasicInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.audioStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["AudioStreamInfoList"] = tmp
                    }
                    if self.fileBasicInfo != nil {
                        map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                    }
                    if self.videoStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.videoStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["VideoStreamInfoList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioStreamInfoList") {
                        self.audioStreamInfoList = dict["AudioStreamInfoList"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList]
                    }
                    if dict.keys.contains("FileBasicInfo") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo()
                        model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                        self.fileBasicInfo = model
                    }
                    if dict.keys.contains("VideoStreamInfoList") {
                        self.videoStreamInfoList = dict["VideoStreamInfoList"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList]
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var video: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs]?

                public var encryption: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption?

                public var imageWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks]?

                public var subtitles: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles]?

                public var textWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks]?

                public var transcode: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        self.combineConfigs = dict["CombineConfigs"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs]
                    }
                    if dict.keys.contains("Encryption") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        self.imageWatermarks = dict["ImageWatermarks"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks]
                    }
                    if dict.keys.contains("Subtitles") {
                        self.subtitles = dict["Subtitles"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles]
                    }
                    if dict.keys.contains("TextWatermarks") {
                        self.textWatermarks = dict["TextWatermarks"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks]
                    }
                    if dict.keys.contains("Transcode") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public class ScheduleConfig : Tea.TeaModel {
                public var pipelineId: String?

                public var priority: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PipelineId") {
                        self.pipelineId = dict["PipelineId"] as! String
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! Int32
                    }
                }
            }
            public var createTime: String?

            public var finishTime: String?

            public var inputGroup: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup]?

            public var jobId: String?

            public var jobIndex: Int32?

            public var name: String?

            public var outFileMeta: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta?

            public var output: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output?

            public var parentJobId: String?

            public var processConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig?

            public var requestId: String?

            public var scheduleConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig?

            public var status: String?

            public var submitResultJson: [String: Any]?

            public var submitTime: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outFileMeta?.validate()
                try self.output?.validate()
                try self.processConfig?.validate()
                try self.scheduleConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inputGroup != nil {
                    var tmp : [Any] = []
                    for k in self.inputGroup! {
                        tmp.append(k.toMap())
                    }
                    map["InputGroup"] = tmp
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobIndex != nil {
                    map["JobIndex"] = self.jobIndex!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outFileMeta != nil {
                    map["OutFileMeta"] = self.outFileMeta?.toMap()
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.parentJobId != nil {
                    map["ParentJobId"] = self.parentJobId!
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.scheduleConfig != nil {
                    map["ScheduleConfig"] = self.scheduleConfig?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitResultJson != nil {
                    map["SubmitResultJson"] = self.submitResultJson!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("InputGroup") {
                    self.inputGroup = dict["InputGroup"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup]
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobIndex") {
                    self.jobIndex = dict["JobIndex"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OutFileMeta") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta()
                    model.fromMap(dict["OutFileMeta"] as! [String: Any])
                    self.outFileMeta = model
                }
                if dict.keys.contains("Output") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ParentJobId") {
                    self.parentJobId = dict["ParentJobId"] as! String
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
                if dict.keys.contains("RequestId") {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ScheduleConfig") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig()
                    model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                    self.scheduleConfig = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitResultJson") {
                    self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
                }
                if dict.keys.contains("SubmitTime") {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var inputGroup: [GetTranscodeJobResponseBody.TranscodeParentJob.InputGroup]?

        public var jobCount: Int32?

        public var name: String?

        public var outputGroup: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup]?

        public var parentJobId: String?

        public var percent: Int32?

        public var requestId: String?

        public var scheduleConfig: GetTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig?

        public var status: String?

        public var submitTime: String?

        public var transcodeJobList: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList]?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputGroup != nil {
                var tmp : [Any] = []
                for k in self.inputGroup! {
                    tmp.append(k.toMap())
                }
                map["InputGroup"] = tmp
            }
            if self.jobCount != nil {
                map["JobCount"] = self.jobCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroup != nil {
                var tmp : [Any] = []
                for k in self.outputGroup! {
                    tmp.append(k.toMap())
                }
                map["OutputGroup"] = tmp
            }
            if self.parentJobId != nil {
                map["ParentJobId"] = self.parentJobId!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.transcodeJobList != nil {
                var tmp : [Any] = []
                for k in self.transcodeJobList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJobList"] = tmp
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("InputGroup") {
                self.inputGroup = dict["InputGroup"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.InputGroup]
            }
            if dict.keys.contains("JobCount") {
                self.jobCount = dict["JobCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroup") {
                self.outputGroup = dict["OutputGroup"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup]
            }
            if dict.keys.contains("ParentJobId") {
                self.parentJobId = dict["ParentJobId"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = GetTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TranscodeJobList") {
                self.transcodeJobList = dict["TranscodeJobList"] as! [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList]
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeParentJob: GetTranscodeJobResponseBody.TranscodeParentJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeParentJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeParentJob != nil {
            map["TranscodeParentJob"] = self.transcodeParentJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeParentJob") {
            var model = GetTranscodeJobResponseBody.TranscodeParentJob()
            model.fromMap(dict["TranscodeParentJob"] as! [String: Any])
            self.transcodeParentJob = model
        }
    }
}

public class GetTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUrlUploadInfosRequest : Tea.TeaModel {
    public var jobIds: String?

    public var uploadURLs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.uploadURLs != nil {
            map["UploadURLs"] = self.uploadURLs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("UploadURLs") {
            self.uploadURLs = dict["UploadURLs"] as! String
        }
    }
}

public class GetUrlUploadInfosResponseBody : Tea.TeaModel {
    public class URLUploadInfoList : Tea.TeaModel {
        public var completeTime: String?

        public var creationTime: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var fileSize: String?

        public var jobId: String?

        public var mediaId: String?

        public var status: String?

        public var uploadURL: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uploadURL != nil {
                map["UploadURL"] = self.uploadURL!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("FileSize") {
                self.fileSize = dict["FileSize"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UploadURL") {
                self.uploadURL = dict["UploadURL"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var nonExists: [String]?

    public var requestId: String?

    public var URLUploadInfoList: [GetUrlUploadInfosResponseBody.URLUploadInfoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExists != nil {
            map["NonExists"] = self.nonExists!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.URLUploadInfoList != nil {
            var tmp : [Any] = []
            for k in self.URLUploadInfoList! {
                tmp.append(k.toMap())
            }
            map["URLUploadInfoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExists") {
            self.nonExists = dict["NonExists"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("URLUploadInfoList") {
            self.URLUploadInfoList = dict["URLUploadInfoList"] as! [GetUrlUploadInfosResponseBody.URLUploadInfoList]
        }
    }
}

public class GetUrlUploadInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUrlUploadInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUrlUploadInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAllPublicMediaTagsRequest : Tea.TeaModel {
    public var businessType: String?

    public var entityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
    }
}

public class ListAllPublicMediaTagsResponseBody : Tea.TeaModel {
    public class MediaTagList : Tea.TeaModel {
        public class Options : Tea.TeaModel {
            public var optionChineseName: String?

            public var optionEnglishName: String?

            public var optionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.optionChineseName != nil {
                    map["OptionChineseName"] = self.optionChineseName!
                }
                if self.optionEnglishName != nil {
                    map["OptionEnglishName"] = self.optionEnglishName!
                }
                if self.optionId != nil {
                    map["OptionId"] = self.optionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OptionChineseName") {
                    self.optionChineseName = dict["OptionChineseName"] as! String
                }
                if dict.keys.contains("OptionEnglishName") {
                    self.optionEnglishName = dict["OptionEnglishName"] as! String
                }
                if dict.keys.contains("OptionId") {
                    self.optionId = dict["OptionId"] as! String
                }
            }
        }
        public var mediaTagId: String?

        public var mediaTagNameChinese: String?

        public var mediaTagNameEnglish: String?

        public var options: [ListAllPublicMediaTagsResponseBody.MediaTagList.Options]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaTagId != nil {
                map["MediaTagId"] = self.mediaTagId!
            }
            if self.mediaTagNameChinese != nil {
                map["MediaTagNameChinese"] = self.mediaTagNameChinese!
            }
            if self.mediaTagNameEnglish != nil {
                map["MediaTagNameEnglish"] = self.mediaTagNameEnglish!
            }
            if self.options != nil {
                var tmp : [Any] = []
                for k in self.options! {
                    tmp.append(k.toMap())
                }
                map["Options"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaTagId") {
                self.mediaTagId = dict["MediaTagId"] as! String
            }
            if dict.keys.contains("MediaTagNameChinese") {
                self.mediaTagNameChinese = dict["MediaTagNameChinese"] as! String
            }
            if dict.keys.contains("MediaTagNameEnglish") {
                self.mediaTagNameEnglish = dict["MediaTagNameEnglish"] as! String
            }
            if dict.keys.contains("Options") {
                self.options = dict["Options"] as! [ListAllPublicMediaTagsResponseBody.MediaTagList.Options]
            }
        }
    }
    public var mediaTagList: [ListAllPublicMediaTagsResponseBody.MediaTagList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaTagList != nil {
            var tmp : [Any] = []
            for k in self.mediaTagList! {
                tmp.append(k.toMap())
            }
            map["MediaTagList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaTagList") {
            self.mediaTagList = dict["MediaTagList"] as! [ListAllPublicMediaTagsResponseBody.MediaTagList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAllPublicMediaTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllPublicMediaTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAllPublicMediaTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomTemplatesRequest : Tea.TeaModel {
    public var name: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var subtype: String?

    public var templateId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Subtype") {
            self.subtype = dict["Subtype"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListCustomTemplatesResponseBody : Tea.TeaModel {
    public class CustomTemplateList : Tea.TeaModel {
        public var createTime: String?

        public var isDefault: Bool?

        public var modifiedTime: String?

        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var customTemplateList: [ListCustomTemplatesResponseBody.CustomTemplateList]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplateList != nil {
            var tmp : [Any] = []
            for k in self.customTemplateList! {
                tmp.append(k.toMap())
            }
            map["CustomTemplateList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplateList") {
            self.customTemplateList = dict["CustomTemplateList"] as! [ListCustomTemplatesResponseBody.CustomTemplateList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListCustomTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCustomTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDynamicImageJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListDynamicImageJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var input: ListDynamicImageJobsResponseBody.Jobs.Input?

        public var jobId: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: ListDynamicImageJobsResponseBody.Jobs.Output?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateId: String?

        public var triggerSource: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = ListDynamicImageJobsResponseBody.Jobs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = ListDynamicImageJobsResponseBody.Jobs.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
        }
    }
    public var jobs: [ListDynamicImageJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            self.jobs = dict["Jobs"] as! [ListDynamicImageJobsResponseBody.Jobs]
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDynamicImageJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDynamicImageJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDynamicImageJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordFilesRequest : Tea.TeaModel {
    public var endTime: String?

    public var jobIds: [String]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var recordFormat: String?

    public var sortBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordFormat != nil {
            map["RecordFormat"] = self.recordFormat!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! [String]
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecordFormat") {
            self.recordFormat = dict["RecordFormat"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListLiveRecordFilesResponseBody : Tea.TeaModel {
    public class Files : Tea.TeaModel {
        public var createTime: String?

        public var duration: Double?

        public var endTime: String?

        public var format: String?

        public var height: Int32?

        public var jobId: String?

        public var jobName: String?

        public var recordId: String?

        public var recordOutput: String?

        public var recordUrl: String?

        public var startTime: String?

        public var streamUrl: String?

        public var width: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.recordOutput != nil {
                map["RecordOutput"] = self.recordOutput!
            }
            if self.recordUrl != nil {
                map["RecordUrl"] = self.recordUrl!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.streamUrl != nil {
                map["StreamUrl"] = self.streamUrl!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobName") {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("RecordOutput") {
                self.recordOutput = dict["RecordOutput"] as! String
            }
            if dict.keys.contains("RecordUrl") {
                self.recordUrl = dict["RecordUrl"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("StreamUrl") {
                self.streamUrl = dict["StreamUrl"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int32
            }
        }
    }
    public var files: [ListLiveRecordFilesResponseBody.Files]?

    public var pageNo: Int64?

    public var pageSize: String?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.files != nil {
            var tmp : [Any] = []
            for k in self.files! {
                tmp.append(k.toMap())
            }
            map["Files"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Files") {
            self.files = dict["Files"] as! [ListLiveRecordFilesResponseBody.Files]
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListLiveRecordFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRecordFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListLiveRecordJobsResponseBody : Tea.TeaModel {
    public class LiveRecordJobs : Tea.TeaModel {
        public class RecordOutput : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var notifyUrl: String?

        public var recordOutput: ListLiveRecordJobsResponseBody.LiveRecordJobs.RecordOutput?

        public var status: String?

        public var streamInput: ListLiveRecordJobsResponseBody.LiveRecordJobs.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordOutput?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            if self.recordOutput != nil {
                map["RecordOutput"] = self.recordOutput?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyUrl") {
                self.notifyUrl = dict["NotifyUrl"] as! String
            }
            if dict.keys.contains("RecordOutput") {
                var model = ListLiveRecordJobsResponseBody.LiveRecordJobs.RecordOutput()
                model.fromMap(dict["RecordOutput"] as! [String: Any])
                self.recordOutput = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StreamInput") {
                var model = ListLiveRecordJobsResponseBody.LiveRecordJobs.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var liveRecordJobs: [ListLiveRecordJobsResponseBody.LiveRecordJobs]?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveRecordJobs != nil {
            var tmp : [Any] = []
            for k in self.liveRecordJobs! {
                tmp.append(k.toMap())
            }
            map["LiveRecordJobs"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveRecordJobs") {
            self.liveRecordJobs = dict["LiveRecordJobs"] as! [ListLiveRecordJobsResponseBody.LiveRecordJobs]
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveRecordJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRecordJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordTemplatesRequest : Tea.TeaModel {
    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var templateIds: [String]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TemplateIds") {
            self.templateIds = dict["TemplateIds"] as! [String]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListLiveRecordTemplatesResponseBody : Tea.TeaModel {
    public class RecordTemplateList : Tea.TeaModel {
        public class RecordFormatList : Tea.TeaModel {
            public var cycleDuration: Int32?

            public var format: String?

            public var ossObjectPrefix: String?

            public var sliceDuration: Int32?

            public var sliceOssObjectPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleDuration != nil {
                    map["CycleDuration"] = self.cycleDuration!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.ossObjectPrefix != nil {
                    map["OssObjectPrefix"] = self.ossObjectPrefix!
                }
                if self.sliceDuration != nil {
                    map["SliceDuration"] = self.sliceDuration!
                }
                if self.sliceOssObjectPrefix != nil {
                    map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CycleDuration") {
                    self.cycleDuration = dict["CycleDuration"] as! Int32
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("OssObjectPrefix") {
                    self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
                }
                if dict.keys.contains("SliceDuration") {
                    self.sliceDuration = dict["SliceDuration"] as! Int32
                }
                if dict.keys.contains("SliceOssObjectPrefix") {
                    self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
                }
            }
        }
        public var createTime: String?

        public var lastModified: String?

        public var name: String?

        public var recordFormatList: [ListLiveRecordTemplatesResponseBody.RecordTemplateList.RecordFormatList]?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordFormatList != nil {
                var tmp : [Any] = []
                for k in self.recordFormatList! {
                    tmp.append(k.toMap())
                }
                map["RecordFormatList"] = tmp
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordFormatList") {
                self.recordFormatList = dict["RecordFormatList"] as! [ListLiveRecordTemplatesResponseBody.RecordTemplateList.RecordFormatList]
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var recordTemplateList: [ListLiveRecordTemplatesResponseBody.RecordTemplateList]?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordTemplateList != nil {
            var tmp : [Any] = []
            for k in self.recordTemplateList! {
                tmp.append(k.toMap())
            }
            map["RecordTemplateList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RecordTemplateList") {
            self.recordTemplateList = dict["RecordTemplateList"] as! [ListLiveRecordTemplatesResponseBody.RecordTemplateList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveRecordTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRecordTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveSnapshotFilesRequest : Tea.TeaModel {
    public var endTime: String?

    public var jobId: String?

    public var limit: Int32?

    public var sortBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListLiveSnapshotFilesResponseBody : Tea.TeaModel {
    public class FileList : Tea.TeaModel {
        public var createTime: String?

        public var createTimestamp: Int64?

        public var isOverlay: Bool?

        public var ossBucket: String?

        public var ossEndpoint: String?

        public var ossObject: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.isOverlay != nil {
                map["IsOverlay"] = self.isOverlay!
            }
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossEndpoint != nil {
                map["OssEndpoint"] = self.ossEndpoint!
            }
            if self.ossObject != nil {
                map["OssObject"] = self.ossObject!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("IsOverlay") {
                self.isOverlay = dict["IsOverlay"] as! Bool
            }
            if dict.keys.contains("OssBucket") {
                self.ossBucket = dict["OssBucket"] as! String
            }
            if dict.keys.contains("OssEndpoint") {
                self.ossEndpoint = dict["OssEndpoint"] as! String
            }
            if dict.keys.contains("OssObject") {
                self.ossObject = dict["OssObject"] as! String
            }
        }
    }
    public var fileList: [ListLiveSnapshotFilesResponseBody.FileList]?

    public var nextStartTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileList != nil {
            var tmp : [Any] = []
            for k in self.fileList! {
                tmp.append(k.toMap())
            }
            map["FileList"] = tmp
        }
        if self.nextStartTime != nil {
            map["NextStartTime"] = self.nextStartTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileList") {
            self.fileList = dict["FileList"] as! [ListLiveSnapshotFilesResponseBody.FileList]
        }
        if dict.keys.contains("NextStartTime") {
            self.nextStartTime = dict["NextStartTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListLiveSnapshotFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveSnapshotFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveSnapshotFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveSnapshotJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchKeyWord: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListLiveSnapshotJobsResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class SnapshotOutput : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var storageType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.storageType != nil {
                    map["StorageType"] = self.storageType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("StorageType") {
                    self.storageType = dict["StorageType"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var jobName: String?

        public var snapshotOutput: ListLiveSnapshotJobsResponseBody.JobList.SnapshotOutput?

        public var status: String?

        public var templateId: String?

        public var templateName: String?

        public var timeInterval: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.snapshotOutput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.snapshotOutput != nil {
                map["SnapshotOutput"] = self.snapshotOutput?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.timeInterval != nil {
                map["TimeInterval"] = self.timeInterval!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobName") {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("SnapshotOutput") {
                var model = ListLiveSnapshotJobsResponseBody.JobList.SnapshotOutput()
                model.fromMap(dict["SnapshotOutput"] as! [String: Any])
                self.snapshotOutput = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TimeInterval") {
                self.timeInterval = dict["TimeInterval"] as! Int32
            }
        }
    }
    public var jobList: [ListLiveSnapshotJobsResponseBody.JobList]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            var tmp : [Any] = []
            for k in self.jobList! {
                tmp.append(k.toMap())
            }
            map["JobList"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            self.jobList = dict["JobList"] as! [ListLiveSnapshotJobsResponseBody.JobList]
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveSnapshotJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveSnapshotJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveSnapshotJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveSnapshotTemplatesRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchKeyWord: String?

    public var sortBy: String?

    public var templateIds: [String]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TemplateIds") {
            self.templateIds = dict["TemplateIds"] as! [String]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListLiveSnapshotTemplatesResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public var createTime: String?

        public var templateId: String?

        public var templateName: String?

        public var timeInterval: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.timeInterval != nil {
                map["TimeInterval"] = self.timeInterval!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TimeInterval") {
                self.timeInterval = dict["TimeInterval"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sortBy: String?

    public var templateList: [ListLiveSnapshotTemplatesResponseBody.TemplateList]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.templateList != nil {
            var tmp : [Any] = []
            for k in self.templateList! {
                tmp.append(k.toMap())
            }
            map["TemplateList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TemplateList") {
            self.templateList = dict["TemplateList"] as! [ListLiveSnapshotTemplatesResponseBody.TemplateList]
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveSnapshotTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveSnapshotTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveSnapshotTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveTranscodeJobsRequest : Tea.TeaModel {
    public var keyWord: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var startMode: Int32?

    public var status: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startMode != nil {
            map["StartMode"] = self.startMode!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartMode") {
            self.startMode = dict["StartMode"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListLiveTranscodeJobsResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class OutputStream : Tea.TeaModel {
            public class StreamInfos : Tea.TeaModel {
                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var streamInfos: [ListLiveTranscodeJobsResponseBody.JobList.OutputStream.StreamInfos]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.streamInfos != nil {
                    var tmp : [Any] = []
                    for k in self.streamInfos! {
                        tmp.append(k.toMap())
                    }
                    map["StreamInfos"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("StreamInfos") {
                    self.streamInfos = dict["StreamInfos"] as! [ListLiveTranscodeJobsResponseBody.JobList.OutputStream.StreamInfos]
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var inputUrl: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputUrl") {
                    self.inputUrl = dict["InputUrl"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var outputStream: ListLiveTranscodeJobsResponseBody.JobList.OutputStream?

        public var startMode: Int32?

        public var status: Int32?

        public var streamInput: ListLiveTranscodeJobsResponseBody.JobList.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.outputStream?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputStream != nil {
                map["OutputStream"] = self.outputStream?.toMap()
            }
            if self.startMode != nil {
                map["StartMode"] = self.startMode!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputStream") {
                var model = ListLiveTranscodeJobsResponseBody.JobList.OutputStream()
                model.fromMap(dict["OutputStream"] as! [String: Any])
                self.outputStream = model
            }
            if dict.keys.contains("StartMode") {
                self.startMode = dict["StartMode"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StreamInput") {
                var model = ListLiveTranscodeJobsResponseBody.JobList.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var jobList: [ListLiveTranscodeJobsResponseBody.JobList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            var tmp : [Any] = []
            for k in self.jobList! {
                tmp.append(k.toMap())
            }
            map["JobList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            self.jobList = dict["JobList"] as! [ListLiveTranscodeJobsResponseBody.JobList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListLiveTranscodeJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveTranscodeJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveTranscodeJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveTranscodeTemplatesRequest : Tea.TeaModel {
    public var category: String?

    public var keyWord: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var type: String?

    public var videoCodec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.videoCodec != nil {
            map["VideoCodec"] = self.videoCodec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VideoCodec") {
            self.videoCodec = dict["VideoCodec"] as! String
        }
    }
}

public class ListLiveTranscodeTemplatesResponseBody : Tea.TeaModel {
    public class TemplateContentList : Tea.TeaModel {
        public class TemplateConfig : Tea.TeaModel {
            public class AudioParams : Tea.TeaModel {
                public var bitrate: String?

                public var channels: String?

                public var codec: String?

                public var profile: String?

                public var samplerate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.samplerate != nil {
                        map["Samplerate"] = self.samplerate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Samplerate") {
                        self.samplerate = dict["Samplerate"] as! String
                    }
                }
            }
            public class VideoParams : Tea.TeaModel {
                public var bitrate: String?

                public var codec: String?

                public var fps: String?

                public var gop: String?

                public var height: String?

                public var profile: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Gop") {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioParams: ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.AudioParams?

            public var videoParams: ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.VideoParams?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioParams?.validate()
                try self.videoParams?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioParams != nil {
                    map["AudioParams"] = self.audioParams?.toMap()
                }
                if self.videoParams != nil {
                    map["VideoParams"] = self.videoParams?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioParams") {
                    var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.AudioParams()
                    model.fromMap(dict["AudioParams"] as! [String: Any])
                    self.audioParams = model
                }
                if dict.keys.contains("VideoParams") {
                    var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.VideoParams()
                    model.fromMap(dict["VideoParams"] as! [String: Any])
                    self.videoParams = model
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var name: String?

        public var templateConfig: ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.templateConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig()
                model.fromMap(dict["TemplateConfig"] as! [String: Any])
                self.templateConfig = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateContentList: [ListLiveTranscodeTemplatesResponseBody.TemplateContentList]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateContentList != nil {
            var tmp : [Any] = []
            for k in self.templateContentList! {
                tmp.append(k.toMap())
            }
            map["TemplateContentList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateContentList") {
            self.templateContentList = dict["TemplateContentList"] as! [ListLiveTranscodeTemplatesResponseBody.TemplateContentList]
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListLiveTranscodeTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveTranscodeTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveTranscodeTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaBasicInfosRequest : Tea.TeaModel {
    public var businessType: String?

    public var endTime: String?

    public var includeFileBasicInfo: Bool?

    public var maxResults: Int32?

    public var mediaId: String?

    public var mediaType: String?

    public var nextToken: String?

    public var sortBy: String?

    public var source: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.includeFileBasicInfo != nil {
            map["IncludeFileBasicInfo"] = self.includeFileBasicInfo!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IncludeFileBasicInfo") {
            self.includeFileBasicInfo = dict["IncludeFileBasicInfo"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListMediaBasicInfosResponseBody : Tea.TeaModel {
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var createTime: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var modifiedTime: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var cateId: Int64?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var referenceId: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var uploadSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.uploadSource != nil {
                    map["UploadSource"] = self.uploadSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UploadSource") {
                    self.uploadSource = dict["UploadSource"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: ListMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                self.fileInfoList = dict["FileInfoList"] as! [ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList]
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = ListMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var mediaInfos: [ListMediaBasicInfosResponseBody.MediaInfos]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaInfos") {
            self.mediaInfos = dict["MediaInfos"] as! [ListMediaBasicInfosResponseBody.MediaInfos]
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListMediaBasicInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaBasicInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaBasicInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaInfoJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListMediaInfoJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    self.audioStreamInfoList = dict["AudioStreamInfoList"] as! [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.AudioStreamInfoList]
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    self.videoStreamInfoList = dict["VideoStreamInfoList"] as! [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.VideoStreamInfoList]
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: ListMediaInfoJobsResponseBody.Jobs.Input?

        public var jobId: String?

        public var mediaInfoProperty: ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: ListMediaInfoJobsResponseBody.Jobs.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = ListMediaInfoJobsResponseBody.Jobs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") {
                var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = ListMediaInfoJobsResponseBody.Jobs.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var jobs: [ListMediaInfoJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            self.jobs = dict["Jobs"] as! [ListMediaInfoJobsResponseBody.Jobs]
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaInfoJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaInfoJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaInfoJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
    }
}

public class ListMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPackageJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListPackageJobsResponseBody : Tea.TeaModel {
    public class PackageJobList : Tea.TeaModel {
        public class PackageJobs : Tea.TeaModel {
            public class Inputs : Tea.TeaModel {
                public class Input : Tea.TeaModel {
                    public var media: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.media != nil {
                            map["Media"] = self.media!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Media") {
                            self.media = dict["Media"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var input: ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs.Input?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.input?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.input != nil {
                        map["Input"] = self.input?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Input") {
                        var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs.Input()
                        model.fromMap(dict["Input"] as! [String: Any])
                        self.input = model
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var code: String?

            public var createTime: String?

            public var finishTime: String?

            public var inputs: [ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs]?

            public var jobId: String?

            public var message: String?

            public var modifiedTime: String?

            public var name: String?

            public var output: ListPackageJobsResponseBody.PackageJobList.PackageJobs.Output?

            public var pipelineId: String?

            public var priority: Int32?

            public var status: String?

            public var submitTime: String?

            public var triggerSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inputs != nil {
                    var tmp : [Any] = []
                    for k in self.inputs! {
                        tmp.append(k.toMap())
                    }
                    map["Inputs"] = tmp
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.triggerSource != nil {
                    map["TriggerSource"] = self.triggerSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Inputs") {
                    self.inputs = dict["Inputs"] as! [ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs]
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Output") {
                    var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitTime") {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("TriggerSource") {
                    self.triggerSource = dict["TriggerSource"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var nextPageToken: String?

        public var packageJobs: [ListPackageJobsResponseBody.PackageJobList.PackageJobs]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextPageToken != nil {
                map["NextPageToken"] = self.nextPageToken!
            }
            if self.packageJobs != nil {
                var tmp : [Any] = []
                for k in self.packageJobs! {
                    tmp.append(k.toMap())
                }
                map["PackageJobs"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextPageToken") {
                self.nextPageToken = dict["NextPageToken"] as! String
            }
            if dict.keys.contains("PackageJobs") {
                self.packageJobs = dict["PackageJobs"] as! [ListPackageJobsResponseBody.PackageJobList.PackageJobs]
            }
        }
    }
    public var packageJobList: ListPackageJobsResponseBody.PackageJobList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packageJobList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packageJobList != nil {
            map["PackageJobList"] = self.packageJobList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackageJobList") {
            var model = ListPackageJobsResponseBody.PackageJobList()
            model.fromMap(dict["PackageJobList"] as! [String: Any])
            self.packageJobList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPackageJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPackageJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPackageJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelinesRequest : Tea.TeaModel {
    public var speed: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.speed != nil {
            map["Speed"] = self.speed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Speed") {
            self.speed = dict["Speed"] as! String
        }
    }
}

public class ListPipelinesResponseBody : Tea.TeaModel {
    public class PipelineList : Tea.TeaModel {
        public var createTime: String?

        public var modifiedTime: String?

        public var name: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var speed: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipelineList: [ListPipelinesResponseBody.PipelineList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineList != nil {
            var tmp : [Any] = []
            for k in self.pipelineList! {
                tmp.append(k.toMap())
            }
            map["PipelineList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineList") {
            self.pipelineList = dict["PipelineList"] as! [ListPipelinesResponseBody.PipelineList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPipelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPublicMediaBasicInfosRequest : Tea.TeaModel {
    public var includeFileBasicInfo: Bool?

    public var maxResults: Int32?

    public var mediaTagId: String?

    public var nextToken: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.includeFileBasicInfo != nil {
            map["IncludeFileBasicInfo"] = self.includeFileBasicInfo!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaTagId != nil {
            map["MediaTagId"] = self.mediaTagId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IncludeFileBasicInfo") {
            self.includeFileBasicInfo = dict["IncludeFileBasicInfo"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaTagId") {
            self.mediaTagId = dict["MediaTagId"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListPublicMediaBasicInfosResponseBody : Tea.TeaModel {
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: ListPublicMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                self.fileInfoList = dict["FileInfoList"] as! [ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList]
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = ListPublicMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var mediaInfos: [ListPublicMediaBasicInfosResponseBody.MediaInfos]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaInfos") {
            self.mediaInfos = dict["MediaInfos"] as! [ListPublicMediaBasicInfosResponseBody.MediaInfos]
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListPublicMediaBasicInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPublicMediaBasicInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPublicMediaBasicInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSmartJobsRequest : Tea.TeaModel {
    public var jobState: String?

    public var jobType: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobState != nil {
            map["JobState"] = self.jobState!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobState") {
            self.jobState = dict["JobState"] as! String
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class ListSmartJobsResponseBody : Tea.TeaModel {
    public class SmartJobList : Tea.TeaModel {
        public class InputConfig : Tea.TeaModel {
            public var inputFile: String?

            public var keyword: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputFile != nil {
                    map["InputFile"] = self.inputFile!
                }
                if self.keyword != nil {
                    map["Keyword"] = self.keyword!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputFile") {
                    self.inputFile = dict["InputFile"] as! String
                }
                if dict.keys.contains("Keyword") {
                    self.keyword = dict["Keyword"] as! String
                }
            }
        }
        public class OutputConfig : Tea.TeaModel {
            public var bucket: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public var createTime: String?

        public var description_: String?

        public var editingConfig: String?

        public var inputConfig: ListSmartJobsResponseBody.SmartJobList.InputConfig?

        public var jobId: String?

        public var jobState: String?

        public var jobType: String?

        public var modifiedTime: String?

        public var outputConfig: ListSmartJobsResponseBody.SmartJobList.OutputConfig?

        public var title: String?

        public var userData: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inputConfig?.validate()
            try self.outputConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.editingConfig != nil {
                map["EditingConfig"] = self.editingConfig!
            }
            if self.inputConfig != nil {
                map["InputConfig"] = self.inputConfig?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobState != nil {
                map["JobState"] = self.jobState!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputConfig != nil {
                map["OutputConfig"] = self.outputConfig?.toMap()
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EditingConfig") {
                self.editingConfig = dict["EditingConfig"] as! String
            }
            if dict.keys.contains("InputConfig") {
                var model = ListSmartJobsResponseBody.SmartJobList.InputConfig()
                model.fromMap(dict["InputConfig"] as! [String: Any])
                self.inputConfig = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobState") {
                self.jobState = dict["JobState"] as! String
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputConfig") {
                var model = ListSmartJobsResponseBody.SmartJobList.OutputConfig()
                model.fromMap(dict["OutputConfig"] as! [String: Any])
                self.outputConfig = model
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var maxResults: String?

    public var nextToken: String?

    public var requestId: String?

    public var smartJobList: [ListSmartJobsResponseBody.SmartJobList]?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.smartJobList != nil {
            var tmp : [Any] = []
            for k in self.smartJobList! {
                tmp.append(k.toMap())
            }
            map["SmartJobList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SmartJobList") {
            self.smartJobList = dict["SmartJobList"] as! [ListSmartJobsResponseBody.SmartJobList]
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListSmartJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSmartJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSmartJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSnapshotJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListSnapshotJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var async: Bool?

        public var count: Int32?

        public var createTime: String?

        public var finishTime: String?

        public var input: ListSnapshotJobsResponseBody.Jobs.Input?

        public var jobId: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: ListSnapshotJobsResponseBody.Jobs.Output?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateId: String?

        public var triggerSource: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = ListSnapshotJobsResponseBody.Jobs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = ListSnapshotJobsResponseBody.Jobs.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var jobs: [ListSnapshotJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            self.jobs = dict["Jobs"] as! [ListSnapshotJobsResponseBody.Jobs]
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSnapshotJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSnapshotJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSnapshotJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSystemTemplatesRequest : Tea.TeaModel {
    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var subtype: String?

    public var templateId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Subtype") {
            self.subtype = dict["Subtype"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListSystemTemplatesResponseBody : Tea.TeaModel {
    public class SystemTemplateList : Tea.TeaModel {
        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var requestId: String?

    public var systemTemplateList: [ListSystemTemplatesResponseBody.SystemTemplateList]?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemTemplateList != nil {
            var tmp : [Any] = []
            for k in self.systemTemplateList! {
                tmp.append(k.toMap())
            }
            map["SystemTemplateList"] = tmp
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemTemplateList") {
            self.systemTemplateList = dict["SystemTemplateList"] as! [ListSystemTemplatesResponseBody.SystemTemplateList]
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListSystemTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSystemTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSystemTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTemplatesRequest : Tea.TeaModel {
    public var createSource: String?

    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortType: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createSource != nil {
            map["CreateSource"] = self.createSource!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateSource") {
            self.createSource = dict["CreateSource"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortType") {
            self.sortType = dict["SortType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListTemplatesResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public var clipsParam: String?

        public var config: String?

        public var coverURL: String?

        public var createSource: String?

        public var creationTime: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var name: String?

        public var previewMedia: String?

        public var previewMediaStatus: String?

        public var status: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.previewMedia != nil {
                map["PreviewMedia"] = self.previewMedia!
            }
            if self.previewMediaStatus != nil {
                map["PreviewMediaStatus"] = self.previewMediaStatus!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PreviewMedia") {
                self.previewMedia = dict["PreviewMedia"] as! String
            }
            if dict.keys.contains("PreviewMediaStatus") {
                self.previewMediaStatus = dict["PreviewMediaStatus"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var templates: [ListTemplatesResponseBody.Templates]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templates != nil {
            var tmp : [Any] = []
            for k in self.templates! {
                tmp.append(k.toMap())
            }
            map["Templates"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Templates") {
            self.templates = dict["Templates"] as! [ListTemplatesResponseBody.Templates]
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTranscodeJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListTranscodeJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class InputGroup : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class OutputGroup : Tea.TeaModel {
            public class Output : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var video: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.CombineConfigs]?

                public var encryption: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Encryption?

                public var imageWatermarks: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks]?

                public var subtitles: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles]?

                public var textWatermarks: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks]?

                public var transcode: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        self.combineConfigs = dict["CombineConfigs"] as! [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.CombineConfigs]
                    }
                    if dict.keys.contains("Encryption") {
                        var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        self.imageWatermarks = dict["ImageWatermarks"] as! [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks]
                    }
                    if dict.keys.contains("Subtitles") {
                        self.subtitles = dict["Subtitles"] as! [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles]
                    }
                    if dict.keys.contains("TextWatermarks") {
                        self.textWatermarks = dict["TextWatermarks"] as! [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks]
                    }
                    if dict.keys.contains("Transcode") {
                        var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public var output: ListTranscodeJobsResponseBody.Jobs.OutputGroup.Output?

            public var processConfig: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
                try self.processConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Output") {
                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var inputGroup: [ListTranscodeJobsResponseBody.Jobs.InputGroup]?

        public var jobCount: Int32?

        public var name: String?

        public var outputGroup: [ListTranscodeJobsResponseBody.Jobs.OutputGroup]?

        public var parentJobId: String?

        public var percent: Int32?

        public var requestId: String?

        public var scheduleConfig: ListTranscodeJobsResponseBody.Jobs.ScheduleConfig?

        public var status: String?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputGroup != nil {
                var tmp : [Any] = []
                for k in self.inputGroup! {
                    tmp.append(k.toMap())
                }
                map["InputGroup"] = tmp
            }
            if self.jobCount != nil {
                map["JobCount"] = self.jobCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroup != nil {
                var tmp : [Any] = []
                for k in self.outputGroup! {
                    tmp.append(k.toMap())
                }
                map["OutputGroup"] = tmp
            }
            if self.parentJobId != nil {
                map["ParentJobId"] = self.parentJobId!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("InputGroup") {
                self.inputGroup = dict["InputGroup"] as! [ListTranscodeJobsResponseBody.Jobs.InputGroup]
            }
            if dict.keys.contains("JobCount") {
                self.jobCount = dict["JobCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroup") {
                self.outputGroup = dict["OutputGroup"] as! [ListTranscodeJobsResponseBody.Jobs.OutputGroup]
            }
            if dict.keys.contains("ParentJobId") {
                self.parentJobId = dict["ParentJobId"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = ListTranscodeJobsResponseBody.Jobs.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var jobs: [ListTranscodeJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            self.jobs = dict["Jobs"] as! [ListTranscodeJobsResponseBody.Jobs]
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTranscodeJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTranscodeJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTranscodeJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCensorJobListRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryCensorJobListResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class CensorJob : Tea.TeaModel {
            public class CensorConfig : Tea.TeaModel {
                public class OutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                    }
                }
                public var bizType: String?

                public var interval: String?

                public var outputFile: QueryCensorJobListResponseBody.Jobs.CensorJob.CensorConfig.OutputFile?

                public var saveType: String?

                public var scenes: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.outputFile?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizType != nil {
                        map["BizType"] = self.bizType!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.outputFile != nil {
                        map["OutputFile"] = self.outputFile?.toMap()
                    }
                    if self.saveType != nil {
                        map["SaveType"] = self.saveType!
                    }
                    if self.scenes != nil {
                        map["Scenes"] = self.scenes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizType") {
                        self.bizType = dict["BizType"] as! String
                    }
                    if dict.keys.contains("Interval") {
                        self.interval = dict["Interval"] as! String
                    }
                    if dict.keys.contains("OutputFile") {
                        var model = QueryCensorJobListResponseBody.Jobs.CensorJob.CensorConfig.OutputFile()
                        model.fromMap(dict["OutputFile"] as! [String: Any])
                        self.outputFile = model
                    }
                    if dict.keys.contains("SaveType") {
                        self.saveType = dict["SaveType"] as! String
                    }
                    if dict.keys.contains("Scenes") {
                        self.scenes = dict["Scenes"] as! String
                    }
                }
            }
            public class CensorPornResult : Tea.TeaModel {
                public class PornCounterList : Tea.TeaModel {
                    public class Counter : Tea.TeaModel {
                        public var count: Int32?

                        public var label: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") {
                                self.count = dict["Count"] as! Int32
                            }
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                        }
                    }
                    public var counter: [QueryCensorJobListResponseBody.Jobs.CensorJob.CensorPornResult.PornCounterList.Counter]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.counter != nil {
                            var tmp : [Any] = []
                            for k in self.counter! {
                                tmp.append(k.toMap())
                            }
                            map["Counter"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Counter") {
                            self.counter = dict["Counter"] as! [QueryCensorJobListResponseBody.Jobs.CensorJob.CensorPornResult.PornCounterList.Counter]
                        }
                    }
                }
                public class PornTopList : Tea.TeaModel {
                    public class Top : Tea.TeaModel {
                        public var index: String?

                        public var label: String?

                        public var object: String?

                        public var score: String?

                        public var timestamp: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.index != nil {
                                map["Index"] = self.index!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.object != nil {
                                map["Object"] = self.object!
                            }
                            if self.score != nil {
                                map["Score"] = self.score!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Index") {
                                self.index = dict["Index"] as! String
                            }
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Object") {
                                self.object = dict["Object"] as! String
                            }
                            if dict.keys.contains("Score") {
                                self.score = dict["Score"] as! String
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                        }
                    }
                    public var top: [QueryCensorJobListResponseBody.Jobs.CensorJob.CensorPornResult.PornTopList.Top]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.top != nil {
                            var tmp : [Any] = []
                            for k in self.top! {
                                tmp.append(k.toMap())
                            }
                            map["Top"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Top") {
                            self.top = dict["Top"] as! [QueryCensorJobListResponseBody.Jobs.CensorJob.CensorPornResult.PornTopList.Top]
                        }
                    }
                }
                public var averageScore: String?

                public var label: String?

                public var maxScore: String?

                public var pornCounterList: QueryCensorJobListResponseBody.Jobs.CensorJob.CensorPornResult.PornCounterList?

                public var pornTopList: QueryCensorJobListResponseBody.Jobs.CensorJob.CensorPornResult.PornTopList?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.pornCounterList?.validate()
                    try self.pornTopList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageScore != nil {
                        map["AverageScore"] = self.averageScore!
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.maxScore != nil {
                        map["MaxScore"] = self.maxScore!
                    }
                    if self.pornCounterList != nil {
                        map["PornCounterList"] = self.pornCounterList?.toMap()
                    }
                    if self.pornTopList != nil {
                        map["PornTopList"] = self.pornTopList?.toMap()
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageScore") {
                        self.averageScore = dict["AverageScore"] as! String
                    }
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("MaxScore") {
                        self.maxScore = dict["MaxScore"] as! String
                    }
                    if dict.keys.contains("PornCounterList") {
                        var model = QueryCensorJobListResponseBody.Jobs.CensorJob.CensorPornResult.PornCounterList()
                        model.fromMap(dict["PornCounterList"] as! [String: Any])
                        self.pornCounterList = model
                    }
                    if dict.keys.contains("PornTopList") {
                        var model = QueryCensorJobListResponseBody.Jobs.CensorJob.CensorPornResult.PornTopList()
                        model.fromMap(dict["PornTopList"] as! [String: Any])
                        self.pornTopList = model
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class CensorTerrorismResult : Tea.TeaModel {
                public class TerrorismCounterList : Tea.TeaModel {
                    public class Counter : Tea.TeaModel {
                        public var count: Int32?

                        public var label: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") {
                                self.count = dict["Count"] as! Int32
                            }
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                        }
                    }
                    public var counter: [QueryCensorJobListResponseBody.Jobs.CensorJob.CensorTerrorismResult.TerrorismCounterList.Counter]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.counter != nil {
                            var tmp : [Any] = []
                            for k in self.counter! {
                                tmp.append(k.toMap())
                            }
                            map["Counter"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Counter") {
                            self.counter = dict["Counter"] as! [QueryCensorJobListResponseBody.Jobs.CensorJob.CensorTerrorismResult.TerrorismCounterList.Counter]
                        }
                    }
                }
                public class TerrorismTopList : Tea.TeaModel {
                    public class Top : Tea.TeaModel {
                        public var index: String?

                        public var label: String?

                        public var object: String?

                        public var score: String?

                        public var timestamp: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.index != nil {
                                map["Index"] = self.index!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.object != nil {
                                map["Object"] = self.object!
                            }
                            if self.score != nil {
                                map["Score"] = self.score!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Index") {
                                self.index = dict["Index"] as! String
                            }
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Object") {
                                self.object = dict["Object"] as! String
                            }
                            if dict.keys.contains("Score") {
                                self.score = dict["Score"] as! String
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                        }
                    }
                    public var top: [QueryCensorJobListResponseBody.Jobs.CensorJob.CensorTerrorismResult.TerrorismTopList.Top]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.top != nil {
                            var tmp : [Any] = []
                            for k in self.top! {
                                tmp.append(k.toMap())
                            }
                            map["Top"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Top") {
                            self.top = dict["Top"] as! [QueryCensorJobListResponseBody.Jobs.CensorJob.CensorTerrorismResult.TerrorismTopList.Top]
                        }
                    }
                }
                public var averageScore: String?

                public var label: String?

                public var maxScore: String?

                public var suggestion: String?

                public var terrorismCounterList: QueryCensorJobListResponseBody.Jobs.CensorJob.CensorTerrorismResult.TerrorismCounterList?

                public var terrorismTopList: QueryCensorJobListResponseBody.Jobs.CensorJob.CensorTerrorismResult.TerrorismTopList?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.terrorismCounterList?.validate()
                    try self.terrorismTopList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageScore != nil {
                        map["AverageScore"] = self.averageScore!
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.maxScore != nil {
                        map["MaxScore"] = self.maxScore!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.terrorismCounterList != nil {
                        map["TerrorismCounterList"] = self.terrorismCounterList?.toMap()
                    }
                    if self.terrorismTopList != nil {
                        map["TerrorismTopList"] = self.terrorismTopList?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageScore") {
                        self.averageScore = dict["AverageScore"] as! String
                    }
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("MaxScore") {
                        self.maxScore = dict["MaxScore"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TerrorismCounterList") {
                        var model = QueryCensorJobListResponseBody.Jobs.CensorJob.CensorTerrorismResult.TerrorismCounterList()
                        model.fromMap(dict["TerrorismCounterList"] as! [String: Any])
                        self.terrorismCounterList = model
                    }
                    if dict.keys.contains("TerrorismTopList") {
                        var model = QueryCensorJobListResponseBody.Jobs.CensorJob.CensorTerrorismResult.TerrorismTopList()
                        model.fromMap(dict["TerrorismTopList"] as! [String: Any])
                        self.terrorismTopList = model
                    }
                }
            }
            public class ImageCensorResults : Tea.TeaModel {
                public class ImageCensorResult : Tea.TeaModel {
                    public var imageBucket: String?

                    public var imageLocation: String?

                    public var imageObject: String?

                    public var result: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.imageBucket != nil {
                            map["ImageBucket"] = self.imageBucket!
                        }
                        if self.imageLocation != nil {
                            map["ImageLocation"] = self.imageLocation!
                        }
                        if self.imageObject != nil {
                            map["ImageObject"] = self.imageObject!
                        }
                        if self.result != nil {
                            map["Result"] = self.result!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ImageBucket") {
                            self.imageBucket = dict["ImageBucket"] as! String
                        }
                        if dict.keys.contains("ImageLocation") {
                            self.imageLocation = dict["ImageLocation"] as! String
                        }
                        if dict.keys.contains("ImageObject") {
                            self.imageObject = dict["ImageObject"] as! String
                        }
                        if dict.keys.contains("Result") {
                            self.result = dict["Result"] as! String
                        }
                    }
                }
                public var imageCensorResult: [QueryCensorJobListResponseBody.Jobs.CensorJob.ImageCensorResults.ImageCensorResult]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.imageCensorResult != nil {
                        var tmp : [Any] = []
                        for k in self.imageCensorResult! {
                            tmp.append(k.toMap())
                        }
                        map["ImageCensorResult"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ImageCensorResult") {
                        self.imageCensorResult = dict["ImageCensorResult"] as! [QueryCensorJobListResponseBody.Jobs.CensorJob.ImageCensorResults.ImageCensorResult]
                    }
                }
            }
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var barrageCensorResult: String?

            public var censorConfig: QueryCensorJobListResponseBody.Jobs.CensorJob.CensorConfig?

            public var censorPornResult: QueryCensorJobListResponseBody.Jobs.CensorJob.CensorPornResult?

            public var censorTerrorismResult: QueryCensorJobListResponseBody.Jobs.CensorJob.CensorTerrorismResult?

            public var code: String?

            public var creationTime: String?

            public var descCensorResult: String?

            public var id: String?

            public var imageCensorResults: QueryCensorJobListResponseBody.Jobs.CensorJob.ImageCensorResults?

            public var input: QueryCensorJobListResponseBody.Jobs.CensorJob.Input?

            public var message: String?

            public var pipelineId: String?

            public var resultSaveObject: String?

            public var state: String?

            public var titleCensorResult: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.censorConfig?.validate()
                try self.censorPornResult?.validate()
                try self.censorTerrorismResult?.validate()
                try self.imageCensorResults?.validate()
                try self.input?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.barrageCensorResult != nil {
                    map["BarrageCensorResult"] = self.barrageCensorResult!
                }
                if self.censorConfig != nil {
                    map["CensorConfig"] = self.censorConfig?.toMap()
                }
                if self.censorPornResult != nil {
                    map["CensorPornResult"] = self.censorPornResult?.toMap()
                }
                if self.censorTerrorismResult != nil {
                    map["CensorTerrorismResult"] = self.censorTerrorismResult?.toMap()
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.descCensorResult != nil {
                    map["DescCensorResult"] = self.descCensorResult!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.imageCensorResults != nil {
                    map["ImageCensorResults"] = self.imageCensorResults?.toMap()
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.resultSaveObject != nil {
                    map["ResultSaveObject"] = self.resultSaveObject!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.titleCensorResult != nil {
                    map["TitleCensorResult"] = self.titleCensorResult!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BarrageCensorResult") {
                    self.barrageCensorResult = dict["BarrageCensorResult"] as! String
                }
                if dict.keys.contains("CensorConfig") {
                    var model = QueryCensorJobListResponseBody.Jobs.CensorJob.CensorConfig()
                    model.fromMap(dict["CensorConfig"] as! [String: Any])
                    self.censorConfig = model
                }
                if dict.keys.contains("CensorPornResult") {
                    var model = QueryCensorJobListResponseBody.Jobs.CensorJob.CensorPornResult()
                    model.fromMap(dict["CensorPornResult"] as! [String: Any])
                    self.censorPornResult = model
                }
                if dict.keys.contains("CensorTerrorismResult") {
                    var model = QueryCensorJobListResponseBody.Jobs.CensorJob.CensorTerrorismResult()
                    model.fromMap(dict["CensorTerrorismResult"] as! [String: Any])
                    self.censorTerrorismResult = model
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DescCensorResult") {
                    self.descCensorResult = dict["DescCensorResult"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("ImageCensorResults") {
                    var model = QueryCensorJobListResponseBody.Jobs.CensorJob.ImageCensorResults()
                    model.fromMap(dict["ImageCensorResults"] as! [String: Any])
                    self.imageCensorResults = model
                }
                if dict.keys.contains("Input") {
                    var model = QueryCensorJobListResponseBody.Jobs.CensorJob.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("ResultSaveObject") {
                    self.resultSaveObject = dict["ResultSaveObject"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TitleCensorResult") {
                    self.titleCensorResult = dict["TitleCensorResult"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var censorJob: [QueryCensorJobListResponseBody.Jobs.CensorJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.censorJob != nil {
                var tmp : [Any] = []
                for k in self.censorJob! {
                    tmp.append(k.toMap())
                }
                map["CensorJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CensorJob") {
                self.censorJob = dict["CensorJob"] as! [QueryCensorJobListResponseBody.Jobs.CensorJob]
            }
        }
    }
    public class NonExistIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var jobs: QueryCensorJobListResponseBody.Jobs?

    public var nonExistIds: QueryCensorJobListResponseBody.NonExistIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobs?.validate()
        try self.nonExistIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            map["Jobs"] = self.jobs?.toMap()
        }
        if self.nonExistIds != nil {
            map["NonExistIds"] = self.nonExistIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            var model = QueryCensorJobListResponseBody.Jobs()
            model.fromMap(dict["Jobs"] as! [String: Any])
            self.jobs = model
        }
        if dict.keys.contains("NonExistIds") {
            var model = QueryCensorJobListResponseBody.NonExistIds()
            model.fromMap(dict["NonExistIds"] as! [String: Any])
            self.nonExistIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryCensorJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCensorJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryCensorJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryIProductionJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class QueryIProductionJobResponseBody : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var createTime: String?

    public var finishTime: String?

    public var functionName: String?

    public var input: QueryIProductionJobResponseBody.Input?

    public var jobId: String?

    public var jobParams: String?

    public var name: String?

    public var output: QueryIProductionJobResponseBody.Output?

    public var outputFiles: [String]?

    public var outputUrls: [String]?

    public var requestId: String?

    public var result: String?

    public var scheduleConfig: QueryIProductionJobResponseBody.ScheduleConfig?

    public var status: String?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.finishTime != nil {
            map["FinishTime"] = self.finishTime!
        }
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.outputFiles != nil {
            map["OutputFiles"] = self.outputFiles!
        }
        if self.outputUrls != nil {
            map["OutputUrls"] = self.outputUrls!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("FinishTime") {
            self.finishTime = dict["FinishTime"] as! String
        }
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") {
            var model = QueryIProductionJobResponseBody.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobParams") {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = QueryIProductionJobResponseBody.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("OutputFiles") {
            self.outputFiles = dict["OutputFiles"] as! [String]
        }
        if dict.keys.contains("OutputUrls") {
            self.outputUrls = dict["OutputUrls"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = QueryIProductionJobResponseBody.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class QueryIProductionJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryIProductionJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryIProductionJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaCensorJobDetailRequest : Tea.TeaModel {
    public var jobId: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaCensorJobDetailResponseBody : Tea.TeaModel {
    public class MediaCensorJobDetail : Tea.TeaModel {
        public class BarrageCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class CoverImageCensorResults : Tea.TeaModel {
            public class CoverImageCensorResult : Tea.TeaModel {
                public class Results : Tea.TeaModel {
                    public class Result : Tea.TeaModel {
                        public var label: String?

                        public var rate: String?

                        public var scene: String?

                        public var suggestion: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.rate != nil {
                                map["Rate"] = self.rate!
                            }
                            if self.scene != nil {
                                map["Scene"] = self.scene!
                            }
                            if self.suggestion != nil {
                                map["Suggestion"] = self.suggestion!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Rate") {
                                self.rate = dict["Rate"] as! String
                            }
                            if dict.keys.contains("Scene") {
                                self.scene = dict["Scene"] as! String
                            }
                            if dict.keys.contains("Suggestion") {
                                self.suggestion = dict["Suggestion"] as! String
                            }
                        }
                    }
                    public var result: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.result != nil {
                            var tmp : [Any] = []
                            for k in self.result! {
                                tmp.append(k.toMap())
                            }
                            map["Result"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Result") {
                            self.result = dict["Result"] as! [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result]
                        }
                    }
                }
                public var bucket: String?

                public var location: String?

                public var object: String?

                public var results: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.results?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    if self.results != nil {
                        map["Results"] = self.results?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                    if dict.keys.contains("Results") {
                        var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results()
                        model.fromMap(dict["Results"] as! [String: Any])
                        self.results = model
                    }
                }
            }
            public var coverImageCensorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coverImageCensorResult != nil {
                    var tmp : [Any] = []
                    for k in self.coverImageCensorResult! {
                        tmp.append(k.toMap())
                    }
                    map["CoverImageCensorResult"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CoverImageCensorResult") {
                    self.coverImageCensorResult = dict["CoverImageCensorResult"] as! [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult]
                }
            }
        }
        public class DescCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class Input : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public class TitleCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class VensorCensorResult : Tea.TeaModel {
            public class CensorResults : Tea.TeaModel {
                public class CensorResult : Tea.TeaModel {
                    public var label: String?

                    public var rate: String?

                    public var scene: String?

                    public var suggestion: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.rate != nil {
                            map["Rate"] = self.rate!
                        }
                        if self.scene != nil {
                            map["Scene"] = self.scene!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Rate") {
                            self.rate = dict["Rate"] as! String
                        }
                        if dict.keys.contains("Scene") {
                            self.scene = dict["Scene"] as! String
                        }
                        if dict.keys.contains("Suggestion") {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                    }
                }
                public var censorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.censorResult != nil {
                        var tmp : [Any] = []
                        for k in self.censorResult! {
                            tmp.append(k.toMap())
                        }
                        map["CensorResult"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CensorResult") {
                        self.censorResult = dict["CensorResult"] as! [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult]
                    }
                }
            }
            public class VideoTimelines : Tea.TeaModel {
                public class VideoTimeline : Tea.TeaModel {
                    public class CensorResults : Tea.TeaModel {
                        public class CensorResult : Tea.TeaModel {
                            public var label: String?

                            public var rate: String?

                            public var scene: String?

                            public var suggestion: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.label != nil {
                                    map["Label"] = self.label!
                                }
                                if self.rate != nil {
                                    map["Rate"] = self.rate!
                                }
                                if self.scene != nil {
                                    map["Scene"] = self.scene!
                                }
                                if self.suggestion != nil {
                                    map["Suggestion"] = self.suggestion!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Label") {
                                    self.label = dict["Label"] as! String
                                }
                                if dict.keys.contains("Rate") {
                                    self.rate = dict["Rate"] as! String
                                }
                                if dict.keys.contains("Scene") {
                                    self.scene = dict["Scene"] as! String
                                }
                                if dict.keys.contains("Suggestion") {
                                    self.suggestion = dict["Suggestion"] as! String
                                }
                            }
                        }
                        public var censorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.censorResult != nil {
                                var tmp : [Any] = []
                                for k in self.censorResult! {
                                    tmp.append(k.toMap())
                                }
                                map["CensorResult"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CensorResult") {
                                self.censorResult = dict["CensorResult"] as! [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult]
                            }
                        }
                    }
                    public var censorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults?

                    public var object: String?

                    public var timestamp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.censorResults?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.censorResults != nil {
                            map["CensorResults"] = self.censorResults?.toMap()
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CensorResults") {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults()
                            model.fromMap(dict["CensorResults"] as! [String: Any])
                            self.censorResults = model
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("Timestamp") {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                    }
                }
                public var videoTimeline: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.videoTimeline != nil {
                        var tmp : [Any] = []
                        for k in self.videoTimeline! {
                            tmp.append(k.toMap())
                        }
                        map["VideoTimeline"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VideoTimeline") {
                        self.videoTimeline = dict["VideoTimeline"] as! [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline]
                    }
                }
            }
            public var censorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults?

            public var nextPageToken: String?

            public var videoTimelines: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.censorResults?.validate()
                try self.videoTimelines?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.censorResults != nil {
                    map["CensorResults"] = self.censorResults?.toMap()
                }
                if self.nextPageToken != nil {
                    map["NextPageToken"] = self.nextPageToken!
                }
                if self.videoTimelines != nil {
                    map["VideoTimelines"] = self.videoTimelines?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CensorResults") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults()
                    model.fromMap(dict["CensorResults"] as! [String: Any])
                    self.censorResults = model
                }
                if dict.keys.contains("NextPageToken") {
                    self.nextPageToken = dict["NextPageToken"] as! String
                }
                if dict.keys.contains("VideoTimelines") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines()
                    model.fromMap(dict["VideoTimelines"] as! [String: Any])
                    self.videoTimelines = model
                }
            }
        }
        public class VideoCensorConfig : Tea.TeaModel {
            public class OutputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var bizType: String?

            public var outputFile: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig.OutputFile?

            public var videoCensor: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.outputFile != nil {
                    map["OutputFile"] = self.outputFile?.toMap()
                }
                if self.videoCensor != nil {
                    map["VideoCensor"] = self.videoCensor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizType") {
                    self.bizType = dict["BizType"] as! String
                }
                if dict.keys.contains("OutputFile") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig.OutputFile()
                    model.fromMap(dict["OutputFile"] as! [String: Any])
                    self.outputFile = model
                }
                if dict.keys.contains("VideoCensor") {
                    self.videoCensor = dict["VideoCensor"] as! String
                }
            }
        }
        public var barrageCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.BarrageCensorResult?

        public var code: String?

        public var coverImageCensorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults?

        public var creationTime: String?

        public var descCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.DescCensorResult?

        public var finishTime: String?

        public var input: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.Input?

        public var jobId: String?

        public var message: String?

        public var pipelineId: String?

        public var state: String?

        public var suggestion: String?

        public var titleCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.TitleCensorResult?

        public var userData: String?

        public var vensorCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult?

        public var videoCensorConfig: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.barrageCensorResult?.validate()
            try self.coverImageCensorResults?.validate()
            try self.descCensorResult?.validate()
            try self.input?.validate()
            try self.titleCensorResult?.validate()
            try self.vensorCensorResult?.validate()
            try self.videoCensorConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.barrageCensorResult != nil {
                map["BarrageCensorResult"] = self.barrageCensorResult?.toMap()
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.coverImageCensorResults != nil {
                map["CoverImageCensorResults"] = self.coverImageCensorResults?.toMap()
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.descCensorResult != nil {
                map["DescCensorResult"] = self.descCensorResult?.toMap()
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.suggestion != nil {
                map["Suggestion"] = self.suggestion!
            }
            if self.titleCensorResult != nil {
                map["TitleCensorResult"] = self.titleCensorResult?.toMap()
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.vensorCensorResult != nil {
                map["VensorCensorResult"] = self.vensorCensorResult?.toMap()
            }
            if self.videoCensorConfig != nil {
                map["VideoCensorConfig"] = self.videoCensorConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BarrageCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.BarrageCensorResult()
                model.fromMap(dict["BarrageCensorResult"] as! [String: Any])
                self.barrageCensorResult = model
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CoverImageCensorResults") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults()
                model.fromMap(dict["CoverImageCensorResults"] as! [String: Any])
                self.coverImageCensorResults = model
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DescCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.DescCensorResult()
                model.fromMap(dict["DescCensorResult"] as! [String: Any])
                self.descCensorResult = model
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Suggestion") {
                self.suggestion = dict["Suggestion"] as! String
            }
            if dict.keys.contains("TitleCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.TitleCensorResult()
                model.fromMap(dict["TitleCensorResult"] as! [String: Any])
                self.titleCensorResult = model
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("VensorCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult()
                model.fromMap(dict["VensorCensorResult"] as! [String: Any])
                self.vensorCensorResult = model
            }
            if dict.keys.contains("VideoCensorConfig") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig()
                model.fromMap(dict["VideoCensorConfig"] as! [String: Any])
                self.videoCensorConfig = model
            }
        }
    }
    public var mediaCensorJobDetail: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaCensorJobDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaCensorJobDetail != nil {
            map["MediaCensorJobDetail"] = self.mediaCensorJobDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaCensorJobDetail") {
            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail()
            model.fromMap(dict["MediaCensorJobDetail"] as! [String: Any])
            self.mediaCensorJobDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaCensorJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaCensorJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaCensorJobDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySmarttagJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var params: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
    }
}

public class QuerySmarttagJobResponseBody : Tea.TeaModel {
    public class Results : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var data: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var result: [QuerySmarttagJobResponseBody.Results.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! [QuerySmarttagJobResponseBody.Results.Result]
            }
        }
    }
    public var jobStatus: String?

    public var requestId: String?

    public var results: QuerySmarttagJobResponseBody.Results?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.results?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobStatus != nil {
            map["JobStatus"] = self.jobStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.results != nil {
            map["Results"] = self.results?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobStatus") {
            self.jobStatus = dict["JobStatus"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Results") {
            var model = QuerySmarttagJobResponseBody.Results()
            model.fromMap(dict["Results"] as! [String: Any])
            self.results = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class QuerySmarttagJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySmarttagJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySmarttagJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshUploadMediaRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class RefreshUploadMediaResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class RefreshUploadMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshUploadMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RefreshUploadMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterMediaInfoRequest : Tea.TeaModel {
    public var businessType: String?

    public var cateId: Int64?

    public var clientToken: String?

    public var coverURL: String?

    public var description_: String?

    public var inputURL: String?

    public var mediaTags: String?

    public var mediaType: String?

    public var overwrite: Bool?

    public var referenceId: String?

    public var registerConfig: String?

    public var title: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaTags != nil {
            map["MediaTags"] = self.mediaTags!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.referenceId != nil {
            map["ReferenceId"] = self.referenceId!
        }
        if self.registerConfig != nil {
            map["RegisterConfig"] = self.registerConfig!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaTags") {
            self.mediaTags = dict["MediaTags"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("Overwrite") {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("ReferenceId") {
            self.referenceId = dict["ReferenceId"] as! String
        }
        if dict.keys.contains("RegisterConfig") {
            self.registerConfig = dict["RegisterConfig"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class RegisterMediaInfoResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterMediaStreamRequest : Tea.TeaModel {
    public var inputURL: String?

    public var mediaId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class RegisterMediaStreamResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterMediaStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterMediaStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterMediaStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchEditingProjectRequest : Tea.TeaModel {
    public var createSource: String?

    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var projectType: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createSource != nil {
            map["CreateSource"] = self.createSource!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.projectType != nil {
            map["ProjectType"] = self.projectType!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateSource") {
            self.createSource = dict["CreateSource"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ProjectType") {
            self.projectType = dict["ProjectType"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class SearchEditingProjectResponseBody : Tea.TeaModel {
    public class ProjectList : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var duration: Int64?

        public var errorCode: String?

        public var errorMessage: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: String?

        public var templateType: String?

        public var timeline: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var projectList: [SearchEditingProjectResponseBody.ProjectList]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.projectList != nil {
            var tmp : [Any] = []
            for k in self.projectList! {
                tmp.append(k.toMap())
            }
            map["ProjectList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ProjectList") {
            self.projectList = dict["ProjectList"] as! [SearchEditingProjectResponseBody.ProjectList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaRequest : Tea.TeaModel {
    public var entityId: String?

    public var match: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.match != nil {
            map["Match"] = self.match!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("Match") {
            self.match = dict["Match"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class SearchMediaResponseBody : Tea.TeaModel {
    public class MediaInfoList : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var createTime: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var modifiedTime: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: SearchMediaResponseBody.MediaInfoList.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = SearchMediaResponseBody.MediaInfoList.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var cateId: Int64?

            public var cateName: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var referenceId: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var uploadSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.uploadSource != nil {
                    map["UploadSource"] = self.uploadSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UploadSource") {
                    self.uploadSource = dict["UploadSource"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [SearchMediaResponseBody.MediaInfoList.FileInfoList]?

        public var mediaBasicInfo: SearchMediaResponseBody.MediaInfoList.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                self.fileInfoList = dict["FileInfoList"] as! [SearchMediaResponseBody.MediaInfoList.FileInfoList]
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = SearchMediaResponseBody.MediaInfoList.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var code: String?

    public var mediaInfoList: [SearchMediaResponseBody.MediaInfoList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaInfoList != nil {
            var tmp : [Any] = []
            for k in self.mediaInfoList! {
                tmp.append(k.toMap())
            }
            map["MediaInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaInfoList") {
            self.mediaInfoList = dict["MediaInfoList"] as! [SearchMediaResponseBody.MediaInfoList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchPublicMediaInfoRequest : Tea.TeaModel {
    public var authorized: Bool?

    public var dynamicMetaDataMatchFields: String?

    public var entityId: String?

    public var favorite: Bool?

    public var mediaIds: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorized != nil {
            map["Authorized"] = self.authorized!
        }
        if self.dynamicMetaDataMatchFields != nil {
            map["DynamicMetaDataMatchFields"] = self.dynamicMetaDataMatchFields!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.favorite != nil {
            map["Favorite"] = self.favorite!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Authorized") {
            self.authorized = dict["Authorized"] as! Bool
        }
        if dict.keys.contains("DynamicMetaDataMatchFields") {
            self.dynamicMetaDataMatchFields = dict["DynamicMetaDataMatchFields"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("Favorite") {
            self.favorite = dict["Favorite"] as! Bool
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class SearchPublicMediaInfoResponseBody : Tea.TeaModel {
    public class PublicMediaInfos : Tea.TeaModel {
        public class MediaInfo : Tea.TeaModel {
            public class DynamicMetaData : Tea.TeaModel {
                public var data: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.data != nil {
                        map["Data"] = self.data!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Data") {
                        self.data = dict["Data"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class MediaBasicInfo : Tea.TeaModel {
                public var businessType: String?

                public var category: String?

                public var coverURL: String?

                public var createTime: String?

                public var deletedTime: String?

                public var description_: String?

                public var mediaId: String?

                public var mediaTags: String?

                public var mediaType: String?

                public var modifiedTime: String?

                public var source: String?

                public var spriteImages: String?

                public var status: String?

                public var title: String?

                public var userData: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.businessType != nil {
                        map["BusinessType"] = self.businessType!
                    }
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.coverURL != nil {
                        map["CoverURL"] = self.coverURL!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.deletedTime != nil {
                        map["DeletedTime"] = self.deletedTime!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.mediaTags != nil {
                        map["MediaTags"] = self.mediaTags!
                    }
                    if self.mediaType != nil {
                        map["MediaType"] = self.mediaType!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.source != nil {
                        map["Source"] = self.source!
                    }
                    if self.spriteImages != nil {
                        map["SpriteImages"] = self.spriteImages!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BusinessType") {
                        self.businessType = dict["BusinessType"] as! String
                    }
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("CoverURL") {
                        self.coverURL = dict["CoverURL"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("DeletedTime") {
                        self.deletedTime = dict["DeletedTime"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("MediaTags") {
                        self.mediaTags = dict["MediaTags"] as! String
                    }
                    if dict.keys.contains("MediaType") {
                        self.mediaType = dict["MediaType"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Source") {
                        self.source = dict["Source"] as! String
                    }
                    if dict.keys.contains("SpriteImages") {
                        self.spriteImages = dict["SpriteImages"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Title") {
                        self.title = dict["Title"] as! String
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                }
            }
            public var dynamicMetaData: SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.DynamicMetaData?

            public var mediaBasicInfo: SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.MediaBasicInfo?

            public var mediaId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dynamicMetaData?.validate()
                try self.mediaBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dynamicMetaData != nil {
                    map["DynamicMetaData"] = self.dynamicMetaData?.toMap()
                }
                if self.mediaBasicInfo != nil {
                    map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DynamicMetaData") {
                    var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.DynamicMetaData()
                    model.fromMap(dict["DynamicMetaData"] as! [String: Any])
                    self.dynamicMetaData = model
                }
                if dict.keys.contains("MediaBasicInfo") {
                    var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.MediaBasicInfo()
                    model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                    self.mediaBasicInfo = model
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
            }
        }
        public var authorized: Bool?

        public var favorite: Bool?

        public var mediaInfo: SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo?

        public var remainingAuthTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorized != nil {
                map["Authorized"] = self.authorized!
            }
            if self.favorite != nil {
                map["Favorite"] = self.favorite!
            }
            if self.mediaInfo != nil {
                map["MediaInfo"] = self.mediaInfo?.toMap()
            }
            if self.remainingAuthTime != nil {
                map["RemainingAuthTime"] = self.remainingAuthTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Authorized") {
                self.authorized = dict["Authorized"] as! Bool
            }
            if dict.keys.contains("Favorite") {
                self.favorite = dict["Favorite"] as! Bool
            }
            if dict.keys.contains("MediaInfo") {
                var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo()
                model.fromMap(dict["MediaInfo"] as! [String: Any])
                self.mediaInfo = model
            }
            if dict.keys.contains("RemainingAuthTime") {
                self.remainingAuthTime = dict["RemainingAuthTime"] as! String
            }
        }
    }
    public var publicMediaInfos: [SearchPublicMediaInfoResponseBody.PublicMediaInfos]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.publicMediaInfos != nil {
            var tmp : [Any] = []
            for k in self.publicMediaInfos! {
                tmp.append(k.toMap())
            }
            map["PublicMediaInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PublicMediaInfos") {
            self.publicMediaInfos = dict["PublicMediaInfos"] as! [SearchPublicMediaInfoResponseBody.PublicMediaInfos]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchPublicMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchPublicMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchPublicMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendLiveSnapshotJobCommandRequest : Tea.TeaModel {
    public var command: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class SendLiveSnapshotJobCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendLiveSnapshotJobCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendLiveSnapshotJobCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendLiveSnapshotJobCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendLiveTranscodeJobCommandRequest : Tea.TeaModel {
    public var command: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class SendLiveTranscodeJobCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendLiveTranscodeJobCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendLiveTranscodeJobCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendLiveTranscodeJobCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultCustomTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SetDefaultCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetDefaultCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDefaultCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultStorageLocationRequest : Tea.TeaModel {
    public var bucket: String?

    public var path: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class SetDefaultStorageLocationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetDefaultStorageLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultStorageLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDefaultStorageLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetEventCallbackRequest : Tea.TeaModel {
    public var authKey: String?

    public var authSwitch: String?

    public var callbackQueueName: String?

    public var callbackType: String?

    public var callbackURL: String?

    public var eventTypeList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.authSwitch != nil {
            map["AuthSwitch"] = self.authSwitch!
        }
        if self.callbackQueueName != nil {
            map["CallbackQueueName"] = self.callbackQueueName!
        }
        if self.callbackType != nil {
            map["CallbackType"] = self.callbackType!
        }
        if self.callbackURL != nil {
            map["CallbackURL"] = self.callbackURL!
        }
        if self.eventTypeList != nil {
            map["EventTypeList"] = self.eventTypeList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthKey") {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("AuthSwitch") {
            self.authSwitch = dict["AuthSwitch"] as! String
        }
        if dict.keys.contains("CallbackQueueName") {
            self.callbackQueueName = dict["CallbackQueueName"] as! String
        }
        if dict.keys.contains("CallbackType") {
            self.callbackType = dict["CallbackType"] as! String
        }
        if dict.keys.contains("CallbackURL") {
            self.callbackURL = dict["CallbackURL"] as! String
        }
        if dict.keys.contains("EventTypeList") {
            self.eventTypeList = dict["EventTypeList"] as! String
        }
    }
}

public class SetEventCallbackResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetEventCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetEventCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetEventCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitASRJobRequest : Tea.TeaModel {
    public var description_: String?

    public var duration: String?

    public var inputFile: String?

    public var startTime: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.inputFile != nil {
            map["InputFile"] = self.inputFile!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("InputFile") {
            self.inputFile = dict["InputFile"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitASRJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class SubmitASRJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitASRJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitASRJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAudioProduceJobRequest : Tea.TeaModel {
    public var description_: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var overwrite: Bool?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditingConfig") {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Overwrite") {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAudioProduceJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class SubmitAudioProduceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAudioProduceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAudioProduceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDynamicChartJobRequest : Tea.TeaModel {
    public var axisParams: String?

    public var background: String?

    public var chartConfig: String?

    public var chartTitle: String?

    public var chartType: String?

    public var dataSource: String?

    public var description_: String?

    public var input: String?

    public var outputConfig: String?

    public var subtitle: String?

    public var title: String?

    public var unit: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.axisParams != nil {
            map["AxisParams"] = self.axisParams!
        }
        if self.background != nil {
            map["Background"] = self.background!
        }
        if self.chartConfig != nil {
            map["ChartConfig"] = self.chartConfig!
        }
        if self.chartTitle != nil {
            map["ChartTitle"] = self.chartTitle!
        }
        if self.chartType != nil {
            map["ChartType"] = self.chartType!
        }
        if self.dataSource != nil {
            map["DataSource"] = self.dataSource!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.subtitle != nil {
            map["Subtitle"] = self.subtitle!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.unit != nil {
            map["Unit"] = self.unit!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AxisParams") {
            self.axisParams = dict["AxisParams"] as! String
        }
        if dict.keys.contains("Background") {
            self.background = dict["Background"] as! String
        }
        if dict.keys.contains("ChartConfig") {
            self.chartConfig = dict["ChartConfig"] as! String
        }
        if dict.keys.contains("ChartTitle") {
            self.chartTitle = dict["ChartTitle"] as! String
        }
        if dict.keys.contains("ChartType") {
            self.chartType = dict["ChartType"] as! String
        }
        if dict.keys.contains("DataSource") {
            self.dataSource = dict["DataSource"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Subtitle") {
            self.subtitle = dict["Subtitle"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("Unit") {
            self.unit = dict["Unit"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDynamicChartJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDynamicChartJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDynamicChartJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitDynamicChartJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDynamicImageJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public class TemplateConfig : Tea.TeaModel {
        public class OverwriteParams : Tea.TeaModel {
            public class TimeSpan : Tea.TeaModel {
                public var duration: String?

                public var end: String?

                public var seek: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.end != nil {
                        map["End"] = self.end!
                    }
                    if self.seek != nil {
                        map["Seek"] = self.seek!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("End") {
                        self.end = dict["End"] as! String
                    }
                    if dict.keys.contains("Seek") {
                        self.seek = dict["Seek"] as! String
                    }
                }
            }
            public var format: String?

            public var fps: Int32?

            public var height: Int32?

            public var longShortMode: Bool?

            public var scanMode: String?

            public var timeSpan: SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams.TimeSpan?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.timeSpan?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.longShortMode != nil {
                    map["LongShortMode"] = self.longShortMode!
                }
                if self.scanMode != nil {
                    map["ScanMode"] = self.scanMode!
                }
                if self.timeSpan != nil {
                    map["TimeSpan"] = self.timeSpan?.toMap()
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! Int32
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("LongShortMode") {
                    self.longShortMode = dict["LongShortMode"] as! Bool
                }
                if dict.keys.contains("ScanMode") {
                    self.scanMode = dict["ScanMode"] as! String
                }
                if dict.keys.contains("TimeSpan") {
                    var model = SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams.TimeSpan()
                    model.fromMap(dict["TimeSpan"] as! [String: Any])
                    self.timeSpan = model
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var overwriteParams: SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.overwriteParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.overwriteParams != nil {
                map["OverwriteParams"] = self.overwriteParams?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OverwriteParams") {
                var model = SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams()
                model.fromMap(dict["OverwriteParams"] as! [String: Any])
                self.overwriteParams = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var input: SubmitDynamicImageJobRequest.Input?

    public var name: String?

    public var output: SubmitDynamicImageJobRequest.Output?

    public var scheduleConfig: SubmitDynamicImageJobRequest.ScheduleConfig?

    public var templateConfig: SubmitDynamicImageJobRequest.TemplateConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitDynamicImageJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitDynamicImageJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitDynamicImageJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateConfig") {
            var model = SubmitDynamicImageJobRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDynamicImageJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var templateConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDynamicImageJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDynamicImageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDynamicImageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitDynamicImageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitIProductionJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var functionName: String?

    public var input: SubmitIProductionJobRequest.Input?

    public var jobParams: String?

    public var name: String?

    public var output: SubmitIProductionJobRequest.Output?

    public var scheduleConfig: SubmitIProductionJobRequest.ScheduleConfig?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitIProductionJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("JobParams") {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitIProductionJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitIProductionJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitIProductionJobShrinkRequest : Tea.TeaModel {
    public var functionName: String?

    public var inputShrink: String?

    public var jobParams: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("JobParams") {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitIProductionJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitIProductionJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitIProductionJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitIProductionJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveEditingJobRequest : Tea.TeaModel {
    public var clips: String?

    public var liveStreamConfig: String?

    public var mediaProduceConfig: String?

    public var outputMediaConfig: String?

    public var outputMediaTarget: String?

    public var projectId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clips != nil {
            map["Clips"] = self.clips!
        }
        if self.liveStreamConfig != nil {
            map["LiveStreamConfig"] = self.liveStreamConfig!
        }
        if self.mediaProduceConfig != nil {
            map["MediaProduceConfig"] = self.mediaProduceConfig!
        }
        if self.outputMediaConfig != nil {
            map["OutputMediaConfig"] = self.outputMediaConfig!
        }
        if self.outputMediaTarget != nil {
            map["OutputMediaTarget"] = self.outputMediaTarget!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clips") {
            self.clips = dict["Clips"] as! String
        }
        if dict.keys.contains("LiveStreamConfig") {
            self.liveStreamConfig = dict["LiveStreamConfig"] as! String
        }
        if dict.keys.contains("MediaProduceConfig") {
            self.mediaProduceConfig = dict["MediaProduceConfig"] as! String
        }
        if dict.keys.contains("OutputMediaConfig") {
            self.outputMediaConfig = dict["OutputMediaConfig"] as! String
        }
        if dict.keys.contains("OutputMediaTarget") {
            self.outputMediaTarget = dict["OutputMediaTarget"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitLiveEditingJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var mediaURL: String?

    public var projectId: String?

    public var requestId: String?

    public var vodMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaURL != nil {
            map["MediaURL"] = self.mediaURL!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodMediaId != nil {
            map["VodMediaId"] = self.vodMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaURL") {
            self.mediaURL = dict["MediaURL"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodMediaId") {
            self.vodMediaId = dict["VodMediaId"] as! String
        }
    }
}

public class SubmitLiveEditingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveEditingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitLiveEditingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveRecordJobRequest : Tea.TeaModel {
    public class RecordOutput : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class StreamInput : Tea.TeaModel {
        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var name: String?

    public var notifyUrl: String?

    public var recordOutput: SubmitLiveRecordJobRequest.RecordOutput?

    public var streamInput: SubmitLiveRecordJobRequest.StreamInput?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordOutput?.validate()
        try self.streamInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.recordOutput != nil {
            map["RecordOutput"] = self.recordOutput?.toMap()
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("RecordOutput") {
            var model = SubmitLiveRecordJobRequest.RecordOutput()
            model.fromMap(dict["RecordOutput"] as! [String: Any])
            self.recordOutput = model
        }
        if dict.keys.contains("StreamInput") {
            var model = SubmitLiveRecordJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveRecordJobShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var notifyUrl: String?

    public var recordOutputShrink: String?

    public var streamInputShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.recordOutputShrink != nil {
            map["RecordOutput"] = self.recordOutputShrink!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("RecordOutput") {
            self.recordOutputShrink = dict["RecordOutput"] as! String
        }
        if dict.keys.contains("StreamInput") {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveRecordJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitLiveRecordJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveRecordJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitLiveRecordJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveSnapshotJobRequest : Tea.TeaModel {
    public class SnapshotOutput : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("StorageType") {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public class StreamInput : Tea.TeaModel {
        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var callbackUrl: String?

    public var jobName: String?

    public var snapshotOutput: SubmitLiveSnapshotJobRequest.SnapshotOutput?

    public var streamInput: SubmitLiveSnapshotJobRequest.StreamInput?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotOutput?.validate()
        try self.streamInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.snapshotOutput != nil {
            map["SnapshotOutput"] = self.snapshotOutput?.toMap()
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("SnapshotOutput") {
            var model = SubmitLiveSnapshotJobRequest.SnapshotOutput()
            model.fromMap(dict["SnapshotOutput"] as! [String: Any])
            self.snapshotOutput = model
        }
        if dict.keys.contains("StreamInput") {
            var model = SubmitLiveSnapshotJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveSnapshotJobShrinkRequest : Tea.TeaModel {
    public var callbackUrl: String?

    public var jobName: String?

    public var snapshotOutputShrink: String?

    public var streamInputShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.snapshotOutputShrink != nil {
            map["SnapshotOutput"] = self.snapshotOutputShrink!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("SnapshotOutput") {
            self.snapshotOutputShrink = dict["SnapshotOutput"] as! String
        }
        if dict.keys.contains("StreamInput") {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveSnapshotJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitLiveSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitLiveSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveTranscodeJobRequest : Tea.TeaModel {
    public class StreamInput : Tea.TeaModel {
        public var inputUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputUrl") {
                self.inputUrl = dict["InputUrl"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class TimedConfig : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class TranscodeOutput : Tea.TeaModel {
        public var domainName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var name: String?

    public var startMode: Int32?

    public var streamInput: SubmitLiveTranscodeJobRequest.StreamInput?

    public var templateId: String?

    public var timedConfig: SubmitLiveTranscodeJobRequest.TimedConfig?

    public var transcodeOutput: SubmitLiveTranscodeJobRequest.TranscodeOutput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamInput?.validate()
        try self.timedConfig?.validate()
        try self.transcodeOutput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.startMode != nil {
            map["StartMode"] = self.startMode!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timedConfig != nil {
            map["TimedConfig"] = self.timedConfig?.toMap()
        }
        if self.transcodeOutput != nil {
            map["TranscodeOutput"] = self.transcodeOutput?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StartMode") {
            self.startMode = dict["StartMode"] as! Int32
        }
        if dict.keys.contains("StreamInput") {
            var model = SubmitLiveTranscodeJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TimedConfig") {
            var model = SubmitLiveTranscodeJobRequest.TimedConfig()
            model.fromMap(dict["TimedConfig"] as! [String: Any])
            self.timedConfig = model
        }
        if dict.keys.contains("TranscodeOutput") {
            var model = SubmitLiveTranscodeJobRequest.TranscodeOutput()
            model.fromMap(dict["TranscodeOutput"] as! [String: Any])
            self.transcodeOutput = model
        }
    }
}

public class SubmitLiveTranscodeJobShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var startMode: Int32?

    public var streamInputShrink: String?

    public var templateId: String?

    public var timedConfigShrink: String?

    public var transcodeOutputShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.startMode != nil {
            map["StartMode"] = self.startMode!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timedConfigShrink != nil {
            map["TimedConfig"] = self.timedConfigShrink!
        }
        if self.transcodeOutputShrink != nil {
            map["TranscodeOutput"] = self.transcodeOutputShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StartMode") {
            self.startMode = dict["StartMode"] as! Int32
        }
        if dict.keys.contains("StreamInput") {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TimedConfig") {
            self.timedConfigShrink = dict["TimedConfig"] as! String
        }
        if dict.keys.contains("TranscodeOutput") {
            self.transcodeOutputShrink = dict["TranscodeOutput"] as! String
        }
    }
}

public class SubmitLiveTranscodeJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaCensorJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var barrages: String?

    public var coverImages: String?

    public var description_: String?

    public var input: SubmitMediaCensorJobRequest.Input?

    public var notifyUrl: String?

    public var output: String?

    public var scheduleConfig: SubmitMediaCensorJobRequest.ScheduleConfig?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.barrages != nil {
            map["Barrages"] = self.barrages!
        }
        if self.coverImages != nil {
            map["CoverImages"] = self.coverImages!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Barrages") {
            self.barrages = dict["Barrages"] as! String
        }
        if dict.keys.contains("CoverImages") {
            self.coverImages = dict["CoverImages"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitMediaCensorJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitMediaCensorJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaCensorJobShrinkRequest : Tea.TeaModel {
    public var barrages: String?

    public var coverImages: String?

    public var description_: String?

    public var inputShrink: String?

    public var notifyUrl: String?

    public var output: String?

    public var scheduleConfigShrink: String?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.barrages != nil {
            map["Barrages"] = self.barrages!
        }
        if self.coverImages != nil {
            map["CoverImages"] = self.coverImages!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Barrages") {
            self.barrages = dict["Barrages"] as! String
        }
        if dict.keys.contains("CoverImages") {
            self.coverImages = dict["CoverImages"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaCensorJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaCensorJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaCensorJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaCensorJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaInfoJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var input: SubmitMediaInfoJobRequest.Input?

    public var name: String?

    public var scheduleConfig: SubmitMediaInfoJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitMediaInfoJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitMediaInfoJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaInfoJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    self.audioStreamInfoList = dict["AudioStreamInfoList"] as! [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    self.videoStreamInfoList = dict["VideoStreamInfoList"] as! [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: SubmitMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var mediaInfoProperty: SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: SubmitMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: SubmitMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") {
            var model = SubmitMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaProducingJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var clipsParam: String?

    public var editingProduceConfig: String?

    public var outputMediaConfig: String?

    public var outputMediaTarget: String?

    public var projectId: String?

    public var projectMetadata: String?

    public var source: String?

    public var templateId: String?

    public var timeline: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clipsParam != nil {
            map["ClipsParam"] = self.clipsParam!
        }
        if self.editingProduceConfig != nil {
            map["EditingProduceConfig"] = self.editingProduceConfig!
        }
        if self.outputMediaConfig != nil {
            map["OutputMediaConfig"] = self.outputMediaConfig!
        }
        if self.outputMediaTarget != nil {
            map["OutputMediaTarget"] = self.outputMediaTarget!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectMetadata != nil {
            map["ProjectMetadata"] = self.projectMetadata!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ClipsParam") {
            self.clipsParam = dict["ClipsParam"] as! String
        }
        if dict.keys.contains("EditingProduceConfig") {
            self.editingProduceConfig = dict["EditingProduceConfig"] as! String
        }
        if dict.keys.contains("OutputMediaConfig") {
            self.outputMediaConfig = dict["OutputMediaConfig"] as! String
        }
        if dict.keys.contains("OutputMediaTarget") {
            self.outputMediaTarget = dict["OutputMediaTarget"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectMetadata") {
            self.projectMetadata = dict["ProjectMetadata"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaProducingJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var projectId: String?

    public var requestId: String?

    public var vodMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodMediaId != nil {
            map["VodMediaId"] = self.vodMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodMediaId") {
            self.vodMediaId = dict["VodMediaId"] as! String
        }
    }
}

public class SubmitMediaProducingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaProducingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaProducingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitPackageJobRequest : Tea.TeaModel {
    public class Inputs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var input: SubmitPackageJobRequest.Inputs.Input?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Input") {
                var model = SubmitPackageJobRequest.Inputs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var inputs: [SubmitPackageJobRequest.Inputs]?

    public var name: String?

    public var output: SubmitPackageJobRequest.Output?

    public var scheduleConfig: SubmitPackageJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.output?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputs != nil {
            var tmp : [Any] = []
            for k in self.inputs! {
                tmp.append(k.toMap())
            }
            map["Inputs"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Inputs") {
            self.inputs = dict["Inputs"] as! [SubmitPackageJobRequest.Inputs]
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitPackageJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitPackageJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitPackageJobShrinkRequest : Tea.TeaModel {
    public var inputsShrink: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputsShrink != nil {
            map["Inputs"] = self.inputsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Inputs") {
            self.inputsShrink = dict["Inputs"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitPackageJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitPackageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitPackageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitPackageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSmarttagJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
        }
    }
    public var content: String?

    public var contentAddr: String?

    public var contentType: String?

    public var input: SubmitSmarttagJobRequest.Input?

    public var notifyUrl: String?

    public var params: String?

    public var scheduleConfig: SubmitSmarttagJobRequest.ScheduleConfig?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentAddr != nil {
            map["ContentAddr"] = self.contentAddr!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentAddr") {
            self.contentAddr = dict["ContentAddr"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitSmarttagJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitSmarttagJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSmarttagJobShrinkRequest : Tea.TeaModel {
    public var content: String?

    public var contentAddr: String?

    public var contentType: String?

    public var inputShrink: String?

    public var notifyUrl: String?

    public var params: String?

    public var scheduleConfigShrink: String?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentAddr != nil {
            map["ContentAddr"] = self.contentAddr!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentAddr") {
            self.contentAddr = dict["ContentAddr"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSmarttagJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSmarttagJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSmarttagJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSmarttagJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSnapshotJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
        }
    }
    public class TemplateConfig : Tea.TeaModel {
        public class OverwriteParams : Tea.TeaModel {
            public class SpriteSnapshotConfig : Tea.TeaModel {
                public var cellHeight: Int32?

                public var cellWidth: Int32?

                public var color: String?

                public var columns: Int32?

                public var lines: Int32?

                public var margin: Int32?

                public var padding: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cellHeight != nil {
                        map["CellHeight"] = self.cellHeight!
                    }
                    if self.cellWidth != nil {
                        map["CellWidth"] = self.cellWidth!
                    }
                    if self.color != nil {
                        map["Color"] = self.color!
                    }
                    if self.columns != nil {
                        map["Columns"] = self.columns!
                    }
                    if self.lines != nil {
                        map["Lines"] = self.lines!
                    }
                    if self.margin != nil {
                        map["Margin"] = self.margin!
                    }
                    if self.padding != nil {
                        map["Padding"] = self.padding!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CellHeight") {
                        self.cellHeight = dict["CellHeight"] as! Int32
                    }
                    if dict.keys.contains("CellWidth") {
                        self.cellWidth = dict["CellWidth"] as! Int32
                    }
                    if dict.keys.contains("Color") {
                        self.color = dict["Color"] as! String
                    }
                    if dict.keys.contains("Columns") {
                        self.columns = dict["Columns"] as! Int32
                    }
                    if dict.keys.contains("Lines") {
                        self.lines = dict["Lines"] as! Int32
                    }
                    if dict.keys.contains("Margin") {
                        self.margin = dict["Margin"] as! Int32
                    }
                    if dict.keys.contains("Padding") {
                        self.padding = dict["Padding"] as! Int32
                    }
                }
            }
            public var blackLevel: Int32?

            public var count: Int64?

            public var frameType: String?

            public var height: Int32?

            public var interval: Int64?

            public var isSptFrag: Bool?

            public var pixelBlackThreshold: Int32?

            public var spriteSnapshotConfig: SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams.SpriteSnapshotConfig?

            public var time: Int64?

            public var type: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.spriteSnapshotConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blackLevel != nil {
                    map["BlackLevel"] = self.blackLevel!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.frameType != nil {
                    map["FrameType"] = self.frameType!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.isSptFrag != nil {
                    map["IsSptFrag"] = self.isSptFrag!
                }
                if self.pixelBlackThreshold != nil {
                    map["PixelBlackThreshold"] = self.pixelBlackThreshold!
                }
                if self.spriteSnapshotConfig != nil {
                    map["SpriteSnapshotConfig"] = self.spriteSnapshotConfig?.toMap()
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlackLevel") {
                    self.blackLevel = dict["BlackLevel"] as! Int32
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("FrameType") {
                    self.frameType = dict["FrameType"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("IsSptFrag") {
                    self.isSptFrag = dict["IsSptFrag"] as! Bool
                }
                if dict.keys.contains("PixelBlackThreshold") {
                    self.pixelBlackThreshold = dict["PixelBlackThreshold"] as! Int32
                }
                if dict.keys.contains("SpriteSnapshotConfig") {
                    var model = SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams.SpriteSnapshotConfig()
                    model.fromMap(dict["SpriteSnapshotConfig"] as! [String: Any])
                    self.spriteSnapshotConfig = model
                }
                if dict.keys.contains("Time") {
                    self.time = dict["Time"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var overwriteParams: SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.overwriteParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.overwriteParams != nil {
                map["OverwriteParams"] = self.overwriteParams?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OverwriteParams") {
                var model = SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams()
                model.fromMap(dict["OverwriteParams"] as! [String: Any])
                self.overwriteParams = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var input: SubmitSnapshotJobRequest.Input?

    public var name: String?

    public var output: SubmitSnapshotJobRequest.Output?

    public var scheduleConfig: SubmitSnapshotJobRequest.ScheduleConfig?

    public var templateConfig: SubmitSnapshotJobRequest.TemplateConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitSnapshotJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitSnapshotJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitSnapshotJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateConfig") {
            var model = SubmitSnapshotJobRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSnapshotJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var templateConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSnapshotJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSubtitleProduceJobRequest : Tea.TeaModel {
    public var description_: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var isAsync: Int64?

    public var outputConfig: String?

    public var title: String?

    public var type: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.isAsync != nil {
            map["IsAsync"] = self.isAsync!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditingConfig") {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("IsAsync") {
            self.isAsync = dict["IsAsync"] as! Int64
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSubtitleProduceJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSubtitleProduceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSubtitleProduceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSubtitleProduceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSyncMediaInfoJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var input: SubmitSyncMediaInfoJobRequest.Input?

    public var name: String?

    public var scheduleConfig: SubmitSyncMediaInfoJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitSyncMediaInfoJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitSyncMediaInfoJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSyncMediaInfoJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSyncMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    self.audioStreamInfoList = dict["AudioStreamInfoList"] as! [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    self.videoStreamInfoList = dict["VideoStreamInfoList"] as! [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var mediaInfoProperty: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") {
                var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") {
            var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSyncMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSyncMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSyncMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTranscodeJobRequest : Tea.TeaModel {
    public class InputGroup : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class OutputGroup : Tea.TeaModel {
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class ProcessConfig : Tea.TeaModel {
            public class CombineConfigs : Tea.TeaModel {
                public var audioIndex: String?

                public var duration: Double?

                public var start: Double?

                public var videoIndex: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioIndex != nil {
                        map["AudioIndex"] = self.audioIndex!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.start != nil {
                        map["Start"] = self.start!
                    }
                    if self.videoIndex != nil {
                        map["VideoIndex"] = self.videoIndex!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioIndex") {
                        self.audioIndex = dict["AudioIndex"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Double
                    }
                    if dict.keys.contains("Start") {
                        self.start = dict["Start"] as! Double
                    }
                    if dict.keys.contains("VideoIndex") {
                        self.videoIndex = dict["VideoIndex"] as! String
                    }
                }
            }
            public class Encryption : Tea.TeaModel {
                public var cipherText: String?

                public var decryptKeyUri: String?

                public var encryptType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cipherText != nil {
                        map["CipherText"] = self.cipherText!
                    }
                    if self.decryptKeyUri != nil {
                        map["DecryptKeyUri"] = self.decryptKeyUri!
                    }
                    if self.encryptType != nil {
                        map["EncryptType"] = self.encryptType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CipherText") {
                        self.cipherText = dict["CipherText"] as! String
                    }
                    if dict.keys.contains("DecryptKeyUri") {
                        self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                    }
                    if dict.keys.contains("EncryptType") {
                        self.encryptType = dict["EncryptType"] as! String
                    }
                }
            }
            public class ImageWatermarks : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var media: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.media != nil {
                                map["Media"] = self.media!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Media") {
                                self.media = dict["Media"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public class Timeline : Tea.TeaModel {
                        public var duration: String?

                        public var start: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                        }
                    }
                    public var dx: String?

                    public var dy: String?

                    public var file: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                    public var height: String?

                    public var referPos: String?

                    public var timeline: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                        try self.timeline?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dx != nil {
                            map["Dx"] = self.dx!
                        }
                        if self.dy != nil {
                            map["Dy"] = self.dy!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.referPos != nil {
                            map["ReferPos"] = self.referPos!
                        }
                        if self.timeline != nil {
                            map["Timeline"] = self.timeline?.toMap()
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Dx") {
                            self.dx = dict["Dx"] as! String
                        }
                        if dict.keys.contains("Dy") {
                            self.dy = dict["Dy"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("ReferPos") {
                            self.referPos = dict["ReferPos"] as! String
                        }
                        if dict.keys.contains("Timeline") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                            model.fromMap(dict["Timeline"] as! [String: Any])
                            self.timeline = model
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public class Subtitles : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var media: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.media != nil {
                                map["Media"] = self.media!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Media") {
                                self.media = dict["Media"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public var charEnc: String?

                    public var file: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                    public var format: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.charEnc != nil {
                            map["CharEnc"] = self.charEnc!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CharEnc") {
                            self.charEnc = dict["CharEnc"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public class TextWatermarks : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public var adaptive: String?

                    public var borderColor: String?

                    public var borderWidth: Int32?

                    public var content: String?

                    public var fontAlpha: String?

                    public var fontColor: String?

                    public var fontName: String?

                    public var fontSize: Int32?

                    public var left_: String?

                    public var top: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adaptive != nil {
                            map["Adaptive"] = self.adaptive!
                        }
                        if self.borderColor != nil {
                            map["BorderColor"] = self.borderColor!
                        }
                        if self.borderWidth != nil {
                            map["BorderWidth"] = self.borderWidth!
                        }
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.fontAlpha != nil {
                            map["FontAlpha"] = self.fontAlpha!
                        }
                        if self.fontColor != nil {
                            map["FontColor"] = self.fontColor!
                        }
                        if self.fontName != nil {
                            map["FontName"] = self.fontName!
                        }
                        if self.fontSize != nil {
                            map["FontSize"] = self.fontSize!
                        }
                        if self.left_ != nil {
                            map["Left"] = self.left_!
                        }
                        if self.top != nil {
                            map["Top"] = self.top!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Adaptive") {
                            self.adaptive = dict["Adaptive"] as! String
                        }
                        if dict.keys.contains("BorderColor") {
                            self.borderColor = dict["BorderColor"] as! String
                        }
                        if dict.keys.contains("BorderWidth") {
                            self.borderWidth = dict["BorderWidth"] as! Int32
                        }
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("FontAlpha") {
                            self.fontAlpha = dict["FontAlpha"] as! String
                        }
                        if dict.keys.contains("FontColor") {
                            self.fontColor = dict["FontColor"] as! String
                        }
                        if dict.keys.contains("FontName") {
                            self.fontName = dict["FontName"] as! String
                        }
                        if dict.keys.contains("FontSize") {
                            self.fontSize = dict["FontSize"] as! Int32
                        }
                        if dict.keys.contains("Left") {
                            self.left_ = dict["Left"] as! String
                        }
                        if dict.keys.contains("Top") {
                            self.top = dict["Top"] as! String
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public class Transcode : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public class Audio : Tea.TeaModel {
                        public class Volume : Tea.TeaModel {
                            public var integratedLoudnessTarget: String?

                            public var loudnessRangeTarget: String?

                            public var method: String?

                            public var truePeak: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.integratedLoudnessTarget != nil {
                                    map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                }
                                if self.loudnessRangeTarget != nil {
                                    map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                }
                                if self.method != nil {
                                    map["Method"] = self.method!
                                }
                                if self.truePeak != nil {
                                    map["TruePeak"] = self.truePeak!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("IntegratedLoudnessTarget") {
                                    self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                }
                                if dict.keys.contains("LoudnessRangeTarget") {
                                    self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                }
                                if dict.keys.contains("Method") {
                                    self.method = dict["Method"] as! String
                                }
                                if dict.keys.contains("TruePeak") {
                                    self.truePeak = dict["TruePeak"] as! String
                                }
                            }
                        }
                        public var bitrate: String?

                        public var channels: String?

                        public var codec: String?

                        public var profile: String?

                        public var remove: String?

                        public var samplerate: String?

                        public var volume: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.volume?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.remove != nil {
                                map["Remove"] = self.remove!
                            }
                            if self.samplerate != nil {
                                map["Samplerate"] = self.samplerate!
                            }
                            if self.volume != nil {
                                map["Volume"] = self.volume?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Channels") {
                                self.channels = dict["Channels"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Remove") {
                                self.remove = dict["Remove"] as! String
                            }
                            if dict.keys.contains("Samplerate") {
                                self.samplerate = dict["Samplerate"] as! String
                            }
                            if dict.keys.contains("Volume") {
                                var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                model.fromMap(dict["Volume"] as! [String: Any])
                                self.volume = model
                            }
                        }
                    }
                    public class Container : Tea.TeaModel {
                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public class MuxConfig : Tea.TeaModel {
                        public class Segment : Tea.TeaModel {
                            public var duration: String?

                            public var forceSegTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.forceSegTime != nil {
                                    map["ForceSegTime"] = self.forceSegTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("ForceSegTime") {
                                    self.forceSegTime = dict["ForceSegTime"] as! String
                                }
                            }
                        }
                        public var segment: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.segment?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.segment != nil {
                                map["Segment"] = self.segment?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Segment") {
                                var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                model.fromMap(dict["Segment"] as! [String: Any])
                                self.segment = model
                            }
                        }
                    }
                    public class Video : Tea.TeaModel {
                        public var abrMax: String?

                        public var bitrate: String?

                        public var bufsize: String?

                        public var codec: String?

                        public var crf: String?

                        public var crop: String?

                        public var fps: String?

                        public var gop: String?

                        public var height: String?

                        public var longShortMode: String?

                        public var maxrate: String?

                        public var pad: String?

                        public var pixFmt: String?

                        public var preset: String?

                        public var profile: String?

                        public var remove: String?

                        public var scanMode: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.abrMax != nil {
                                map["AbrMax"] = self.abrMax!
                            }
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.bufsize != nil {
                                map["Bufsize"] = self.bufsize!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.crf != nil {
                                map["Crf"] = self.crf!
                            }
                            if self.crop != nil {
                                map["Crop"] = self.crop!
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.gop != nil {
                                map["Gop"] = self.gop!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.longShortMode != nil {
                                map["LongShortMode"] = self.longShortMode!
                            }
                            if self.maxrate != nil {
                                map["Maxrate"] = self.maxrate!
                            }
                            if self.pad != nil {
                                map["Pad"] = self.pad!
                            }
                            if self.pixFmt != nil {
                                map["PixFmt"] = self.pixFmt!
                            }
                            if self.preset != nil {
                                map["Preset"] = self.preset!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.remove != nil {
                                map["Remove"] = self.remove!
                            }
                            if self.scanMode != nil {
                                map["ScanMode"] = self.scanMode!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AbrMax") {
                                self.abrMax = dict["AbrMax"] as! String
                            }
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Bufsize") {
                                self.bufsize = dict["Bufsize"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Crf") {
                                self.crf = dict["Crf"] as! String
                            }
                            if dict.keys.contains("Crop") {
                                self.crop = dict["Crop"] as! String
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("Gop") {
                                self.gop = dict["Gop"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("LongShortMode") {
                                self.longShortMode = dict["LongShortMode"] as! String
                            }
                            if dict.keys.contains("Maxrate") {
                                self.maxrate = dict["Maxrate"] as! String
                            }
                            if dict.keys.contains("Pad") {
                                self.pad = dict["Pad"] as! String
                            }
                            if dict.keys.contains("PixFmt") {
                                self.pixFmt = dict["PixFmt"] as! String
                            }
                            if dict.keys.contains("Preset") {
                                self.preset = dict["Preset"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Remove") {
                                self.remove = dict["Remove"] as! String
                            }
                            if dict.keys.contains("ScanMode") {
                                self.scanMode = dict["ScanMode"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var audio: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                    public var container: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                    public var muxConfig: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                    public var video: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audio?.validate()
                        try self.container?.validate()
                        try self.muxConfig?.validate()
                        try self.video?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audio != nil {
                            map["Audio"] = self.audio?.toMap()
                        }
                        if self.container != nil {
                            map["Container"] = self.container?.toMap()
                        }
                        if self.muxConfig != nil {
                            map["MuxConfig"] = self.muxConfig?.toMap()
                        }
                        if self.video != nil {
                            map["Video"] = self.video?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Audio") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                            model.fromMap(dict["Audio"] as! [String: Any])
                            self.audio = model
                        }
                        if dict.keys.contains("Container") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                            model.fromMap(dict["Container"] as! [String: Any])
                            self.container = model
                        }
                        if dict.keys.contains("MuxConfig") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                            model.fromMap(dict["MuxConfig"] as! [String: Any])
                            self.muxConfig = model
                        }
                        if dict.keys.contains("Video") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                            model.fromMap(dict["Video"] as! [String: Any])
                            self.video = model
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public var combineConfigs: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.CombineConfigs]?

            public var encryption: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Encryption?

            public var imageWatermarks: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks]?

            public var subtitles: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles]?

            public var textWatermarks: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks]?

            public var transcode: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.encryption?.validate()
                try self.transcode?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.combineConfigs != nil {
                    var tmp : [Any] = []
                    for k in self.combineConfigs! {
                        tmp.append(k.toMap())
                    }
                    map["CombineConfigs"] = tmp
                }
                if self.encryption != nil {
                    map["Encryption"] = self.encryption?.toMap()
                }
                if self.imageWatermarks != nil {
                    var tmp : [Any] = []
                    for k in self.imageWatermarks! {
                        tmp.append(k.toMap())
                    }
                    map["ImageWatermarks"] = tmp
                }
                if self.subtitles != nil {
                    var tmp : [Any] = []
                    for k in self.subtitles! {
                        tmp.append(k.toMap())
                    }
                    map["Subtitles"] = tmp
                }
                if self.textWatermarks != nil {
                    var tmp : [Any] = []
                    for k in self.textWatermarks! {
                        tmp.append(k.toMap())
                    }
                    map["TextWatermarks"] = tmp
                }
                if self.transcode != nil {
                    map["Transcode"] = self.transcode?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CombineConfigs") {
                    self.combineConfigs = dict["CombineConfigs"] as! [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.CombineConfigs]
                }
                if dict.keys.contains("Encryption") {
                    var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Encryption()
                    model.fromMap(dict["Encryption"] as! [String: Any])
                    self.encryption = model
                }
                if dict.keys.contains("ImageWatermarks") {
                    self.imageWatermarks = dict["ImageWatermarks"] as! [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks]
                }
                if dict.keys.contains("Subtitles") {
                    self.subtitles = dict["Subtitles"] as! [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles]
                }
                if dict.keys.contains("TextWatermarks") {
                    self.textWatermarks = dict["TextWatermarks"] as! [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks]
                }
                if dict.keys.contains("Transcode") {
                    var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode()
                    model.fromMap(dict["Transcode"] as! [String: Any])
                    self.transcode = model
                }
            }
        }
        public var output: SubmitTranscodeJobRequest.OutputGroup.Output?

        public var processConfig: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.output?.validate()
            try self.processConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.processConfig != nil {
                map["ProcessConfig"] = self.processConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Output") {
                var model = SubmitTranscodeJobRequest.OutputGroup.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("ProcessConfig") {
                var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig()
                model.fromMap(dict["ProcessConfig"] as! [String: Any])
                self.processConfig = model
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var inputGroup: [SubmitTranscodeJobRequest.InputGroup]?

    public var name: String?

    public var outputGroup: [SubmitTranscodeJobRequest.OutputGroup]?

    public var scheduleConfig: SubmitTranscodeJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputGroup != nil {
            var tmp : [Any] = []
            for k in self.inputGroup! {
                tmp.append(k.toMap())
            }
            map["InputGroup"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputGroup != nil {
            var tmp : [Any] = []
            for k in self.outputGroup! {
                tmp.append(k.toMap())
            }
            map["OutputGroup"] = tmp
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputGroup") {
            self.inputGroup = dict["InputGroup"] as! [SubmitTranscodeJobRequest.InputGroup]
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputGroup") {
            self.outputGroup = dict["OutputGroup"] as! [SubmitTranscodeJobRequest.OutputGroup]
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitTranscodeJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTranscodeJobShrinkRequest : Tea.TeaModel {
    public var inputGroupShrink: String?

    public var name: String?

    public var outputGroupShrink: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputGroupShrink != nil {
            map["InputGroup"] = self.inputGroupShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputGroupShrink != nil {
            map["OutputGroup"] = self.outputGroupShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputGroup") {
            self.inputGroupShrink = dict["InputGroup"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputGroup") {
            self.outputGroupShrink = dict["OutputGroup"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTranscodeJobResponseBody : Tea.TeaModel {
    public class TranscodeParentJob : Tea.TeaModel {
        public class InputGroup : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class OutputGroup : Tea.TeaModel {
            public class Output : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var video: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs]?

                public var encryption: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption?

                public var imageWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks]?

                public var subtitles: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles]?

                public var textWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks]?

                public var transcode: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        self.combineConfigs = dict["CombineConfigs"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs]
                    }
                    if dict.keys.contains("Encryption") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        self.imageWatermarks = dict["ImageWatermarks"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks]
                    }
                    if dict.keys.contains("Subtitles") {
                        self.subtitles = dict["Subtitles"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles]
                    }
                    if dict.keys.contains("TextWatermarks") {
                        self.textWatermarks = dict["TextWatermarks"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks]
                    }
                    if dict.keys.contains("Transcode") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public var output: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output?

            public var processConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
                try self.processConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Output") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public class TranscodeJobList : Tea.TeaModel {
            public class InputGroup : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class OutFileMeta : Tea.TeaModel {
                public class AudioStreamInfoList : Tea.TeaModel {
                    public var bitrate: String?

                    public var channelLayout: String?

                    public var channels: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var duration: String?

                    public var index: String?

                    public var lang: String?

                    public var sampleFmt: String?

                    public var sampleRate: String?

                    public var startTime: String?

                    public var timebase: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channelLayout != nil {
                            map["ChannelLayout"] = self.channelLayout!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codecLongName != nil {
                            map["CodecLongName"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["CodecName"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["CodecTag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["CodecTagString"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["CodecTimeBase"] = self.codecTimeBase!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.sampleFmt != nil {
                            map["SampleFmt"] = self.sampleFmt!
                        }
                        if self.sampleRate != nil {
                            map["SampleRate"] = self.sampleRate!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.timebase != nil {
                            map["Timebase"] = self.timebase!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("ChannelLayout") {
                            self.channelLayout = dict["ChannelLayout"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("CodecLongName") {
                            self.codecLongName = dict["CodecLongName"] as! String
                        }
                        if dict.keys.contains("CodecName") {
                            self.codecName = dict["CodecName"] as! String
                        }
                        if dict.keys.contains("CodecTag") {
                            self.codecTag = dict["CodecTag"] as! String
                        }
                        if dict.keys.contains("CodecTagString") {
                            self.codecTagString = dict["CodecTagString"] as! String
                        }
                        if dict.keys.contains("CodecTimeBase") {
                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Index") {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("SampleFmt") {
                            self.sampleFmt = dict["SampleFmt"] as! String
                        }
                        if dict.keys.contains("SampleRate") {
                            self.sampleRate = dict["SampleRate"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("Timebase") {
                            self.timebase = dict["Timebase"] as! String
                        }
                    }
                }
                public class FileBasicInfo : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var fileName: String?

                    public var fileSize: String?

                    public var fileStatus: String?

                    public var fileType: String?

                    public var fileUrl: String?

                    public var formatName: String?

                    public var height: String?

                    public var mediaId: String?

                    public var region: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileName != nil {
                            map["FileName"] = self.fileName!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.fileStatus != nil {
                            map["FileStatus"] = self.fileStatus!
                        }
                        if self.fileType != nil {
                            map["FileType"] = self.fileType!
                        }
                        if self.fileUrl != nil {
                            map["FileUrl"] = self.fileUrl!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.mediaId != nil {
                            map["MediaId"] = self.mediaId!
                        }
                        if self.region != nil {
                            map["Region"] = self.region!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileName") {
                            self.fileName = dict["FileName"] as! String
                        }
                        if dict.keys.contains("FileSize") {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("FileStatus") {
                            self.fileStatus = dict["FileStatus"] as! String
                        }
                        if dict.keys.contains("FileType") {
                            self.fileType = dict["FileType"] as! String
                        }
                        if dict.keys.contains("FileUrl") {
                            self.fileUrl = dict["FileUrl"] as! String
                        }
                        if dict.keys.contains("FormatName") {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MediaId") {
                            self.mediaId = dict["MediaId"] as! String
                        }
                        if dict.keys.contains("Region") {
                            self.region = dict["Region"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class VideoStreamInfoList : Tea.TeaModel {
                    public var avgFps: String?

                    public var bitRate: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var dar: String?

                    public var duration: String?

                    public var fps: String?

                    public var hasBFrames: String?

                    public var height: String?

                    public var index: String?

                    public var lang: String?

                    public var level: String?

                    public var numFrames: String?

                    public var pixFmt: String?

                    public var profile: String?

                    public var rotate: String?

                    public var sar: String?

                    public var startTime: String?

                    public var timeBase: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgFps != nil {
                            map["Avg_fps"] = self.avgFps!
                        }
                        if self.bitRate != nil {
                            map["Bit_rate"] = self.bitRate!
                        }
                        if self.codecLongName != nil {
                            map["Codec_long_name"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["Codec_name"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["Codec_tag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["Codec_tag_string"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["Codec_time_base"] = self.codecTimeBase!
                        }
                        if self.dar != nil {
                            map["Dar"] = self.dar!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.hasBFrames != nil {
                            map["Has_b_frames"] = self.hasBFrames!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.numFrames != nil {
                            map["NumFrames"] = self.numFrames!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.rotate != nil {
                            map["Rotate"] = self.rotate!
                        }
                        if self.sar != nil {
                            map["Sar"] = self.sar!
                        }
                        if self.startTime != nil {
                            map["Start_time"] = self.startTime!
                        }
                        if self.timeBase != nil {
                            map["Time_base"] = self.timeBase!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Avg_fps") {
                            self.avgFps = dict["Avg_fps"] as! String
                        }
                        if dict.keys.contains("Bit_rate") {
                            self.bitRate = dict["Bit_rate"] as! String
                        }
                        if dict.keys.contains("Codec_long_name") {
                            self.codecLongName = dict["Codec_long_name"] as! String
                        }
                        if dict.keys.contains("Codec_name") {
                            self.codecName = dict["Codec_name"] as! String
                        }
                        if dict.keys.contains("Codec_tag") {
                            self.codecTag = dict["Codec_tag"] as! String
                        }
                        if dict.keys.contains("Codec_tag_string") {
                            self.codecTagString = dict["Codec_tag_string"] as! String
                        }
                        if dict.keys.contains("Codec_time_base") {
                            self.codecTimeBase = dict["Codec_time_base"] as! String
                        }
                        if dict.keys.contains("Dar") {
                            self.dar = dict["Dar"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Has_b_frames") {
                            self.hasBFrames = dict["Has_b_frames"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Index") {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("Level") {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("NumFrames") {
                            self.numFrames = dict["NumFrames"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Rotate") {
                            self.rotate = dict["Rotate"] as! String
                        }
                        if dict.keys.contains("Sar") {
                            self.sar = dict["Sar"] as! String
                        }
                        if dict.keys.contains("Start_time") {
                            self.startTime = dict["Start_time"] as! String
                        }
                        if dict.keys.contains("Time_base") {
                            self.timeBase = dict["Time_base"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var audioStreamInfoList: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList]?

                public var fileBasicInfo: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo?

                public var videoStreamInfoList: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.fileBasicInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.audioStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["AudioStreamInfoList"] = tmp
                    }
                    if self.fileBasicInfo != nil {
                        map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                    }
                    if self.videoStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.videoStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["VideoStreamInfoList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioStreamInfoList") {
                        self.audioStreamInfoList = dict["AudioStreamInfoList"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList]
                    }
                    if dict.keys.contains("FileBasicInfo") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo()
                        model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                        self.fileBasicInfo = model
                    }
                    if dict.keys.contains("VideoStreamInfoList") {
                        self.videoStreamInfoList = dict["VideoStreamInfoList"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList]
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var video: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs]?

                public var encryption: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption?

                public var imageWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks]?

                public var subtitles: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles]?

                public var textWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks]?

                public var transcode: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        self.combineConfigs = dict["CombineConfigs"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs]
                    }
                    if dict.keys.contains("Encryption") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        self.imageWatermarks = dict["ImageWatermarks"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks]
                    }
                    if dict.keys.contains("Subtitles") {
                        self.subtitles = dict["Subtitles"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles]
                    }
                    if dict.keys.contains("TextWatermarks") {
                        self.textWatermarks = dict["TextWatermarks"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks]
                    }
                    if dict.keys.contains("Transcode") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public class ScheduleConfig : Tea.TeaModel {
                public var pipelineId: String?

                public var priority: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PipelineId") {
                        self.pipelineId = dict["PipelineId"] as! String
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! Int32
                    }
                }
            }
            public var createTime: String?

            public var finishTime: String?

            public var inputGroup: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup]?

            public var jobId: String?

            public var jobIndex: Int32?

            public var name: String?

            public var outFileMeta: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta?

            public var output: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output?

            public var parentJobId: String?

            public var processConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig?

            public var requestId: String?

            public var scheduleConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig?

            public var status: String?

            public var submitResultJson: [String: Any]?

            public var submitTime: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outFileMeta?.validate()
                try self.output?.validate()
                try self.processConfig?.validate()
                try self.scheduleConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inputGroup != nil {
                    var tmp : [Any] = []
                    for k in self.inputGroup! {
                        tmp.append(k.toMap())
                    }
                    map["InputGroup"] = tmp
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobIndex != nil {
                    map["JobIndex"] = self.jobIndex!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outFileMeta != nil {
                    map["OutFileMeta"] = self.outFileMeta?.toMap()
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.parentJobId != nil {
                    map["ParentJobId"] = self.parentJobId!
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.scheduleConfig != nil {
                    map["ScheduleConfig"] = self.scheduleConfig?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitResultJson != nil {
                    map["SubmitResultJson"] = self.submitResultJson!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("InputGroup") {
                    self.inputGroup = dict["InputGroup"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup]
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobIndex") {
                    self.jobIndex = dict["JobIndex"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OutFileMeta") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta()
                    model.fromMap(dict["OutFileMeta"] as! [String: Any])
                    self.outFileMeta = model
                }
                if dict.keys.contains("Output") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ParentJobId") {
                    self.parentJobId = dict["ParentJobId"] as! String
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
                if dict.keys.contains("RequestId") {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ScheduleConfig") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig()
                    model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                    self.scheduleConfig = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitResultJson") {
                    self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
                }
                if dict.keys.contains("SubmitTime") {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var inputGroup: [SubmitTranscodeJobResponseBody.TranscodeParentJob.InputGroup]?

        public var jobCount: Int32?

        public var name: String?

        public var outputGroup: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup]?

        public var parentJobId: String?

        public var percent: Int32?

        public var requestId: String?

        public var scheduleConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig?

        public var status: String?

        public var submitTime: String?

        public var transcodeJobList: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList]?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputGroup != nil {
                var tmp : [Any] = []
                for k in self.inputGroup! {
                    tmp.append(k.toMap())
                }
                map["InputGroup"] = tmp
            }
            if self.jobCount != nil {
                map["JobCount"] = self.jobCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroup != nil {
                var tmp : [Any] = []
                for k in self.outputGroup! {
                    tmp.append(k.toMap())
                }
                map["OutputGroup"] = tmp
            }
            if self.parentJobId != nil {
                map["ParentJobId"] = self.parentJobId!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.transcodeJobList != nil {
                var tmp : [Any] = []
                for k in self.transcodeJobList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJobList"] = tmp
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("InputGroup") {
                self.inputGroup = dict["InputGroup"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.InputGroup]
            }
            if dict.keys.contains("JobCount") {
                self.jobCount = dict["JobCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroup") {
                self.outputGroup = dict["OutputGroup"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup]
            }
            if dict.keys.contains("ParentJobId") {
                self.parentJobId = dict["ParentJobId"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TranscodeJobList") {
                self.transcodeJobList = dict["TranscodeJobList"] as! [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList]
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeParentJob: SubmitTranscodeJobResponseBody.TranscodeParentJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeParentJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeParentJob != nil {
            map["TranscodeParentJob"] = self.transcodeParentJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeParentJob") {
            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob()
            model.fromMap(dict["TranscodeParentJob"] as! [String: Any])
            self.transcodeParentJob = model
        }
    }
}

public class SubmitTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var cateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CateName") {
            self.cateName = dict["CateName"] as! String
        }
    }
}

public class UpdateCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCustomTemplateRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfig: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEditingProjectRequest : Tea.TeaModel {
    public var businessStatus: String?

    public var clipsParam: String?

    public var coverURL: String?

    public var description_: String?

    public var projectId: String?

    public var templateId: String?

    public var timeline: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.clipsParam != nil {
            map["ClipsParam"] = self.clipsParam!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessStatus") {
            self.businessStatus = dict["BusinessStatus"] as! String
        }
        if dict.keys.contains("ClipsParam") {
            self.clipsParam = dict["ClipsParam"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateEditingProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveRecordTemplateRequest : Tea.TeaModel {
    public class RecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var ossObjectPrefix: String?

        public var sliceDuration: Int32?

        public var sliceOssObjectPrefix: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.ossObjectPrefix != nil {
                map["OssObjectPrefix"] = self.ossObjectPrefix!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            if self.sliceOssObjectPrefix != nil {
                map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CycleDuration") {
                self.cycleDuration = dict["CycleDuration"] as! Int32
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("OssObjectPrefix") {
                self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
            }
            if dict.keys.contains("SliceDuration") {
                self.sliceDuration = dict["SliceDuration"] as! Int32
            }
            if dict.keys.contains("SliceOssObjectPrefix") {
                self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
            }
        }
    }
    public var name: String?

    public var recordFormat: [UpdateLiveRecordTemplateRequest.RecordFormat]?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormat != nil {
            var tmp : [Any] = []
            for k in self.recordFormat! {
                tmp.append(k.toMap())
            }
            map["RecordFormat"] = tmp
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") {
            self.recordFormat = dict["RecordFormat"] as! [UpdateLiveRecordTemplateRequest.RecordFormat]
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveRecordTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var recordFormatShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormatShrink != nil {
            map["RecordFormat"] = self.recordFormatShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") {
            self.recordFormatShrink = dict["RecordFormat"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveRecordTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var overwriteFormat: String?

    public var sequenceFormat: String?

    public var templateId: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OverwriteFormat") {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("SequenceFormat") {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class UpdateLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveTranscodeJobRequest : Tea.TeaModel {
    public class StreamInput : Tea.TeaModel {
        public var inputUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputUrl") {
                self.inputUrl = dict["InputUrl"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class TimedConfig : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class TranscodeOutput : Tea.TeaModel {
        public var domainName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var jobId: String?

    public var name: String?

    public var streamInput: UpdateLiveTranscodeJobRequest.StreamInput?

    public var timedConfig: UpdateLiveTranscodeJobRequest.TimedConfig?

    public var transcodeOutput: UpdateLiveTranscodeJobRequest.TranscodeOutput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamInput?.validate()
        try self.timedConfig?.validate()
        try self.transcodeOutput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.timedConfig != nil {
            map["TimedConfig"] = self.timedConfig?.toMap()
        }
        if self.transcodeOutput != nil {
            map["TranscodeOutput"] = self.transcodeOutput?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StreamInput") {
            var model = UpdateLiveTranscodeJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TimedConfig") {
            var model = UpdateLiveTranscodeJobRequest.TimedConfig()
            model.fromMap(dict["TimedConfig"] as! [String: Any])
            self.timedConfig = model
        }
        if dict.keys.contains("TranscodeOutput") {
            var model = UpdateLiveTranscodeJobRequest.TranscodeOutput()
            model.fromMap(dict["TranscodeOutput"] as! [String: Any])
            self.transcodeOutput = model
        }
    }
}

public class UpdateLiveTranscodeJobShrinkRequest : Tea.TeaModel {
    public var jobId: String?

    public var name: String?

    public var streamInputShrink: String?

    public var timedConfigShrink: String?

    public var transcodeOutputShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.timedConfigShrink != nil {
            map["TimedConfig"] = self.timedConfigShrink!
        }
        if self.transcodeOutputShrink != nil {
            map["TranscodeOutput"] = self.transcodeOutputShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StreamInput") {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TimedConfig") {
            self.timedConfigShrink = dict["TimedConfig"] as! String
        }
        if dict.keys.contains("TranscodeOutput") {
            self.transcodeOutputShrink = dict["TranscodeOutput"] as! String
        }
    }
}

public class UpdateLiveTranscodeJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveTranscodeTemplateRequest : Tea.TeaModel {
    public class TemplateConfig : Tea.TeaModel {
        public class AudioParams : Tea.TeaModel {
            public var bitrate: String?

            public var channels: String?

            public var codec: String?

            public var profile: String?

            public var samplerate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.samplerate != nil {
                    map["Samplerate"] = self.samplerate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Samplerate") {
                    self.samplerate = dict["Samplerate"] as! String
                }
            }
        }
        public class VideoParams : Tea.TeaModel {
            public var bitrate: String?

            public var codec: String?

            public var fps: String?

            public var gop: String?

            public var height: String?

            public var profile: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Gop") {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audioParams: UpdateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams?

        public var videoParams: UpdateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audioParams?.validate()
            try self.videoParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioParams != nil {
                map["AudioParams"] = self.audioParams?.toMap()
            }
            if self.videoParams != nil {
                map["VideoParams"] = self.videoParams?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioParams") {
                var model = UpdateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams()
                model.fromMap(dict["AudioParams"] as! [String: Any])
                self.audioParams = model
            }
            if dict.keys.contains("VideoParams") {
                var model = UpdateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams()
                model.fromMap(dict["VideoParams"] as! [String: Any])
                self.videoParams = model
            }
        }
    }
    public var name: String?

    public var templateConfig: UpdateLiveTranscodeTemplateRequest.TemplateConfig?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            var model = UpdateLiveTranscodeTemplateRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveTranscodeTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfigShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaInfoRequest : Tea.TeaModel {
    public var appendTags: Bool?

    public var businessType: String?

    public var cateId: Int64?

    public var category: String?

    public var coverURL: String?

    public var description_: String?

    public var inputURL: String?

    public var mediaId: String?

    public var mediaTags: String?

    public var referenceId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appendTags != nil {
            map["AppendTags"] = self.appendTags!
        }
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaTags != nil {
            map["MediaTags"] = self.mediaTags!
        }
        if self.referenceId != nil {
            map["ReferenceId"] = self.referenceId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppendTags") {
            self.appendTags = dict["AppendTags"] as! Bool
        }
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaTags") {
            self.mediaTags = dict["MediaTags"] as! String
        }
        if dict.keys.contains("ReferenceId") {
            self.referenceId = dict["ReferenceId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UpdateMediaInfoResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
    }
}

public class UpdateMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePipelineRequest : Tea.TeaModel {
    public var name: String?

    public var pipelineId: String?

    public var priority: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdatePipelineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSmartJobRequest : Tea.TeaModel {
    public var FEExtend: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.FEExtend != nil {
            map["FEExtend"] = self.FEExtend!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FEExtend") {
            self.FEExtend = dict["FEExtend"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class UpdateSmartJobResponseBody : Tea.TeaModel {
    public var FEExtend: String?

    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.FEExtend != nil {
            map["FEExtend"] = self.FEExtend!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FEExtend") {
            self.FEExtend = dict["FEExtend"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateSmartJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSmartJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSmartJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTemplateRequest : Tea.TeaModel {
    public var config: String?

    public var coverUrl: String?

    public var name: String?

    public var previewMedia: String?

    public var relatedMediaids: String?

    public var source: String?

    public var status: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.previewMedia != nil {
            map["PreviewMedia"] = self.previewMedia!
        }
        if self.relatedMediaids != nil {
            map["RelatedMediaids"] = self.relatedMediaids!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("CoverUrl") {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PreviewMedia") {
            self.previewMedia = dict["PreviewMedia"] as! String
        }
        if dict.keys.contains("RelatedMediaids") {
            self.relatedMediaids = dict["RelatedMediaids"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadMediaByURLRequest : Tea.TeaModel {
    public var appId: String?

    public var entityId: String?

    public var mediaMetaData: String?

    public var postProcessConfig: String?

    public var uploadTargetConfig: String?

    public var uploadURLs: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.mediaMetaData != nil {
            map["MediaMetaData"] = self.mediaMetaData!
        }
        if self.postProcessConfig != nil {
            map["PostProcessConfig"] = self.postProcessConfig!
        }
        if self.uploadTargetConfig != nil {
            map["UploadTargetConfig"] = self.uploadTargetConfig!
        }
        if self.uploadURLs != nil {
            map["UploadURLs"] = self.uploadURLs!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("MediaMetaData") {
            self.mediaMetaData = dict["MediaMetaData"] as! String
        }
        if dict.keys.contains("PostProcessConfig") {
            self.postProcessConfig = dict["PostProcessConfig"] as! String
        }
        if dict.keys.contains("UploadTargetConfig") {
            self.uploadTargetConfig = dict["UploadTargetConfig"] as! String
        }
        if dict.keys.contains("UploadURLs") {
            self.uploadURLs = dict["UploadURLs"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UploadMediaByURLResponseBody : Tea.TeaModel {
    public class UploadJobs : Tea.TeaModel {
        public var jobId: String?

        public var mediaId: String?

        public var sourceURL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.sourceURL != nil {
                map["SourceURL"] = self.sourceURL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("SourceURL") {
                self.sourceURL = dict["SourceURL"] as! String
            }
        }
    }
    public var requestId: String?

    public var uploadJobs: [UploadMediaByURLResponseBody.UploadJobs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadJobs != nil {
            var tmp : [Any] = []
            for k in self.uploadJobs! {
                tmp.append(k.toMap())
            }
            map["UploadJobs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadJobs") {
            self.uploadJobs = dict["UploadJobs"] as! [UploadMediaByURLResponseBody.UploadJobs]
        }
    }
}

public class UploadMediaByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadMediaByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadMediaByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadStreamByURLRequest : Tea.TeaModel {
    public var definition: String?

    public var fileExtension: String?

    public var HDRType: String?

    public var mediaId: String?

    public var streamURL: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.fileExtension != nil {
            map["FileExtension"] = self.fileExtension!
        }
        if self.HDRType != nil {
            map["HDRType"] = self.HDRType!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.streamURL != nil {
            map["StreamURL"] = self.streamURL!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("FileExtension") {
            self.fileExtension = dict["FileExtension"] as! String
        }
        if dict.keys.contains("HDRType") {
            self.HDRType = dict["HDRType"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("StreamURL") {
            self.streamURL = dict["StreamURL"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UploadStreamByURLResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var jobId: String?

    public var mediaId: String?

    public var requestId: String?

    public var sourceURL: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceURL != nil {
            map["SourceURL"] = self.sourceURL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceURL") {
            self.sourceURL = dict["SourceURL"] as! String
        }
    }
}

public class UploadStreamByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadStreamByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadStreamByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
