import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AIAgentRuntimeConfig : Tea.TeaModel {
    public class AvatarChat3D : Tea.TeaModel {
        public var agentUserId: String?

        public var authToken: String?

        public var channelId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentUserId != nil {
                map["AgentUserId"] = self.agentUserId!
            }
            if self.authToken != nil {
                map["AuthToken"] = self.authToken!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentUserId") {
                self.agentUserId = dict["AgentUserId"] as! String
            }
            if dict.keys.contains("AuthToken") {
                self.authToken = dict["AuthToken"] as! String
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
        }
    }
    public class VisionChat : Tea.TeaModel {
        public var agentUserId: String?

        public var authToken: String?

        public var channelId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentUserId != nil {
                map["AgentUserId"] = self.agentUserId!
            }
            if self.authToken != nil {
                map["AuthToken"] = self.authToken!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentUserId") {
                self.agentUserId = dict["AgentUserId"] as! String
            }
            if dict.keys.contains("AuthToken") {
                self.authToken = dict["AuthToken"] as! String
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
        }
    }
    public class VoiceChat : Tea.TeaModel {
        public var agentUserId: String?

        public var authToken: String?

        public var channelId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentUserId != nil {
                map["AgentUserId"] = self.agentUserId!
            }
            if self.authToken != nil {
                map["AuthToken"] = self.authToken!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentUserId") {
                self.agentUserId = dict["AgentUserId"] as! String
            }
            if dict.keys.contains("AuthToken") {
                self.authToken = dict["AuthToken"] as! String
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
        }
    }
    public var avatarChat3D: AIAgentRuntimeConfig.AvatarChat3D?

    public var visionChat: AIAgentRuntimeConfig.VisionChat?

    public var voiceChat: AIAgentRuntimeConfig.VoiceChat?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.avatarChat3D?.validate()
        try self.visionChat?.validate()
        try self.voiceChat?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarChat3D != nil {
            map["AvatarChat3D"] = self.avatarChat3D?.toMap()
        }
        if self.visionChat != nil {
            map["VisionChat"] = self.visionChat?.toMap()
        }
        if self.voiceChat != nil {
            map["VoiceChat"] = self.voiceChat?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarChat3D") {
            var model = AIAgentRuntimeConfig.AvatarChat3D()
            model.fromMap(dict["AvatarChat3D"] as! [String: Any])
            self.avatarChat3D = model
        }
        if dict.keys.contains("VisionChat") {
            var model = AIAgentRuntimeConfig.VisionChat()
            model.fromMap(dict["VisionChat"] as! [String: Any])
            self.visionChat = model
        }
        if dict.keys.contains("VoiceChat") {
            var model = AIAgentRuntimeConfig.VoiceChat()
            model.fromMap(dict["VoiceChat"] as! [String: Any])
            self.voiceChat = model
        }
    }
}

public class AIAgentTemplateConfig : Tea.TeaModel {
    public class AvatarChat3D : Tea.TeaModel {
        public class LlmHistory : Tea.TeaModel {
            public var content: String?

            public var role: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
            }
        }
        public var asrLanguageId: String?

        public var asrMaxSilence: Int32?

        public var avatarId: String?

        public var bailianAppParams: String?

        public var enableIntelligentSegment: Bool?

        public var enablePushToTalk: Bool?

        public var enableVoiceInterrupt: Bool?

        public var gracefulShutdown: Bool?

        public var greeting: String?

        public var interruptWords: [String]?

        public var llmHistory: [AIAgentTemplateConfig.AvatarChat3D.LlmHistory]?

        public var llmHistoryLimit: Int32?

        public var llmSystemPrompt: String?

        public var maxIdleTime: Int32?

        public var useVoiceprint: Bool?

        public var userOfflineTimeout: Int32?

        public var userOnlineTimeout: Int32?

        public var vadLevel: Int32?

        public var voiceId: String?

        public var voiceIdList: [String]?

        public var voiceprintId: String?

        public var volume: Int64?

        public var wakeUpQuery: String?

        public var workflowOverrideParams: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asrLanguageId != nil {
                map["AsrLanguageId"] = self.asrLanguageId!
            }
            if self.asrMaxSilence != nil {
                map["AsrMaxSilence"] = self.asrMaxSilence!
            }
            if self.avatarId != nil {
                map["AvatarId"] = self.avatarId!
            }
            if self.bailianAppParams != nil {
                map["BailianAppParams"] = self.bailianAppParams!
            }
            if self.enableIntelligentSegment != nil {
                map["EnableIntelligentSegment"] = self.enableIntelligentSegment!
            }
            if self.enablePushToTalk != nil {
                map["EnablePushToTalk"] = self.enablePushToTalk!
            }
            if self.enableVoiceInterrupt != nil {
                map["EnableVoiceInterrupt"] = self.enableVoiceInterrupt!
            }
            if self.gracefulShutdown != nil {
                map["GracefulShutdown"] = self.gracefulShutdown!
            }
            if self.greeting != nil {
                map["Greeting"] = self.greeting!
            }
            if self.interruptWords != nil {
                map["InterruptWords"] = self.interruptWords!
            }
            if self.llmHistory != nil {
                var tmp : [Any] = []
                for k in self.llmHistory! {
                    tmp.append(k.toMap())
                }
                map["LlmHistory"] = tmp
            }
            if self.llmHistoryLimit != nil {
                map["LlmHistoryLimit"] = self.llmHistoryLimit!
            }
            if self.llmSystemPrompt != nil {
                map["LlmSystemPrompt"] = self.llmSystemPrompt!
            }
            if self.maxIdleTime != nil {
                map["MaxIdleTime"] = self.maxIdleTime!
            }
            if self.useVoiceprint != nil {
                map["UseVoiceprint"] = self.useVoiceprint!
            }
            if self.userOfflineTimeout != nil {
                map["UserOfflineTimeout"] = self.userOfflineTimeout!
            }
            if self.userOnlineTimeout != nil {
                map["UserOnlineTimeout"] = self.userOnlineTimeout!
            }
            if self.vadLevel != nil {
                map["VadLevel"] = self.vadLevel!
            }
            if self.voiceId != nil {
                map["VoiceId"] = self.voiceId!
            }
            if self.voiceIdList != nil {
                map["VoiceIdList"] = self.voiceIdList!
            }
            if self.voiceprintId != nil {
                map["VoiceprintId"] = self.voiceprintId!
            }
            if self.volume != nil {
                map["Volume"] = self.volume!
            }
            if self.wakeUpQuery != nil {
                map["WakeUpQuery"] = self.wakeUpQuery!
            }
            if self.workflowOverrideParams != nil {
                map["WorkflowOverrideParams"] = self.workflowOverrideParams!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsrLanguageId") {
                self.asrLanguageId = dict["AsrLanguageId"] as! String
            }
            if dict.keys.contains("AsrMaxSilence") {
                self.asrMaxSilence = dict["AsrMaxSilence"] as! Int32
            }
            if dict.keys.contains("AvatarId") {
                self.avatarId = dict["AvatarId"] as! String
            }
            if dict.keys.contains("BailianAppParams") {
                self.bailianAppParams = dict["BailianAppParams"] as! String
            }
            if dict.keys.contains("EnableIntelligentSegment") {
                self.enableIntelligentSegment = dict["EnableIntelligentSegment"] as! Bool
            }
            if dict.keys.contains("EnablePushToTalk") {
                self.enablePushToTalk = dict["EnablePushToTalk"] as! Bool
            }
            if dict.keys.contains("EnableVoiceInterrupt") {
                self.enableVoiceInterrupt = dict["EnableVoiceInterrupt"] as! Bool
            }
            if dict.keys.contains("GracefulShutdown") {
                self.gracefulShutdown = dict["GracefulShutdown"] as! Bool
            }
            if dict.keys.contains("Greeting") {
                self.greeting = dict["Greeting"] as! String
            }
            if dict.keys.contains("InterruptWords") {
                self.interruptWords = dict["InterruptWords"] as! [String]
            }
            if dict.keys.contains("LlmHistory") {
                var tmp : [AIAgentTemplateConfig.AvatarChat3D.LlmHistory] = []
                for v in dict["LlmHistory"] as! [Any] {
                    var model = AIAgentTemplateConfig.AvatarChat3D.LlmHistory()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.llmHistory = tmp
            }
            if dict.keys.contains("LlmHistoryLimit") {
                self.llmHistoryLimit = dict["LlmHistoryLimit"] as! Int32
            }
            if dict.keys.contains("LlmSystemPrompt") {
                self.llmSystemPrompt = dict["LlmSystemPrompt"] as! String
            }
            if dict.keys.contains("MaxIdleTime") {
                self.maxIdleTime = dict["MaxIdleTime"] as! Int32
            }
            if dict.keys.contains("UseVoiceprint") {
                self.useVoiceprint = dict["UseVoiceprint"] as! Bool
            }
            if dict.keys.contains("UserOfflineTimeout") {
                self.userOfflineTimeout = dict["UserOfflineTimeout"] as! Int32
            }
            if dict.keys.contains("UserOnlineTimeout") {
                self.userOnlineTimeout = dict["UserOnlineTimeout"] as! Int32
            }
            if dict.keys.contains("VadLevel") {
                self.vadLevel = dict["VadLevel"] as! Int32
            }
            if dict.keys.contains("VoiceId") {
                self.voiceId = dict["VoiceId"] as! String
            }
            if dict.keys.contains("VoiceIdList") {
                self.voiceIdList = dict["VoiceIdList"] as! [String]
            }
            if dict.keys.contains("VoiceprintId") {
                self.voiceprintId = dict["VoiceprintId"] as! String
            }
            if dict.keys.contains("Volume") {
                self.volume = dict["Volume"] as! Int64
            }
            if dict.keys.contains("WakeUpQuery") {
                self.wakeUpQuery = dict["WakeUpQuery"] as! String
            }
            if dict.keys.contains("WorkflowOverrideParams") {
                self.workflowOverrideParams = dict["WorkflowOverrideParams"] as! String
            }
        }
    }
    public class VisionChat : Tea.TeaModel {
        public class LlmHistory : Tea.TeaModel {
            public var content: String?

            public var role: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
            }
        }
        public var asrLanguageId: String?

        public var asrMaxSilence: Int32?

        public var bailianAppParams: String?

        public var enableIntelligentSegment: Bool?

        public var enablePushToTalk: Bool?

        public var enableVoiceInterrupt: Bool?

        public var gracefulShutdown: Bool?

        public var greeting: String?

        public var interruptWords: [String]?

        public var llmHistory: [AIAgentTemplateConfig.VisionChat.LlmHistory]?

        public var llmHistoryLimit: Int32?

        public var llmSystemPrompt: String?

        public var maxIdleTime: Int32?

        public var useVoiceprint: Bool?

        public var userOfflineTimeout: Int32?

        public var userOnlineTimeout: Int32?

        public var vadLevel: Int32?

        public var voiceId: String?

        public var voiceIdList: [String]?

        public var voiceprintId: String?

        public var volume: Int64?

        public var wakeUpQuery: String?

        public var workflowOverrideParams: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asrLanguageId != nil {
                map["AsrLanguageId"] = self.asrLanguageId!
            }
            if self.asrMaxSilence != nil {
                map["AsrMaxSilence"] = self.asrMaxSilence!
            }
            if self.bailianAppParams != nil {
                map["BailianAppParams"] = self.bailianAppParams!
            }
            if self.enableIntelligentSegment != nil {
                map["EnableIntelligentSegment"] = self.enableIntelligentSegment!
            }
            if self.enablePushToTalk != nil {
                map["EnablePushToTalk"] = self.enablePushToTalk!
            }
            if self.enableVoiceInterrupt != nil {
                map["EnableVoiceInterrupt"] = self.enableVoiceInterrupt!
            }
            if self.gracefulShutdown != nil {
                map["GracefulShutdown"] = self.gracefulShutdown!
            }
            if self.greeting != nil {
                map["Greeting"] = self.greeting!
            }
            if self.interruptWords != nil {
                map["InterruptWords"] = self.interruptWords!
            }
            if self.llmHistory != nil {
                var tmp : [Any] = []
                for k in self.llmHistory! {
                    tmp.append(k.toMap())
                }
                map["LlmHistory"] = tmp
            }
            if self.llmHistoryLimit != nil {
                map["LlmHistoryLimit"] = self.llmHistoryLimit!
            }
            if self.llmSystemPrompt != nil {
                map["LlmSystemPrompt"] = self.llmSystemPrompt!
            }
            if self.maxIdleTime != nil {
                map["MaxIdleTime"] = self.maxIdleTime!
            }
            if self.useVoiceprint != nil {
                map["UseVoiceprint"] = self.useVoiceprint!
            }
            if self.userOfflineTimeout != nil {
                map["UserOfflineTimeout"] = self.userOfflineTimeout!
            }
            if self.userOnlineTimeout != nil {
                map["UserOnlineTimeout"] = self.userOnlineTimeout!
            }
            if self.vadLevel != nil {
                map["VadLevel"] = self.vadLevel!
            }
            if self.voiceId != nil {
                map["VoiceId"] = self.voiceId!
            }
            if self.voiceIdList != nil {
                map["VoiceIdList"] = self.voiceIdList!
            }
            if self.voiceprintId != nil {
                map["VoiceprintId"] = self.voiceprintId!
            }
            if self.volume != nil {
                map["Volume"] = self.volume!
            }
            if self.wakeUpQuery != nil {
                map["WakeUpQuery"] = self.wakeUpQuery!
            }
            if self.workflowOverrideParams != nil {
                map["WorkflowOverrideParams"] = self.workflowOverrideParams!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsrLanguageId") {
                self.asrLanguageId = dict["AsrLanguageId"] as! String
            }
            if dict.keys.contains("AsrMaxSilence") {
                self.asrMaxSilence = dict["AsrMaxSilence"] as! Int32
            }
            if dict.keys.contains("BailianAppParams") {
                self.bailianAppParams = dict["BailianAppParams"] as! String
            }
            if dict.keys.contains("EnableIntelligentSegment") {
                self.enableIntelligentSegment = dict["EnableIntelligentSegment"] as! Bool
            }
            if dict.keys.contains("EnablePushToTalk") {
                self.enablePushToTalk = dict["EnablePushToTalk"] as! Bool
            }
            if dict.keys.contains("EnableVoiceInterrupt") {
                self.enableVoiceInterrupt = dict["EnableVoiceInterrupt"] as! Bool
            }
            if dict.keys.contains("GracefulShutdown") {
                self.gracefulShutdown = dict["GracefulShutdown"] as! Bool
            }
            if dict.keys.contains("Greeting") {
                self.greeting = dict["Greeting"] as! String
            }
            if dict.keys.contains("InterruptWords") {
                self.interruptWords = dict["InterruptWords"] as! [String]
            }
            if dict.keys.contains("LlmHistory") {
                var tmp : [AIAgentTemplateConfig.VisionChat.LlmHistory] = []
                for v in dict["LlmHistory"] as! [Any] {
                    var model = AIAgentTemplateConfig.VisionChat.LlmHistory()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.llmHistory = tmp
            }
            if dict.keys.contains("LlmHistoryLimit") {
                self.llmHistoryLimit = dict["LlmHistoryLimit"] as! Int32
            }
            if dict.keys.contains("LlmSystemPrompt") {
                self.llmSystemPrompt = dict["LlmSystemPrompt"] as! String
            }
            if dict.keys.contains("MaxIdleTime") {
                self.maxIdleTime = dict["MaxIdleTime"] as! Int32
            }
            if dict.keys.contains("UseVoiceprint") {
                self.useVoiceprint = dict["UseVoiceprint"] as! Bool
            }
            if dict.keys.contains("UserOfflineTimeout") {
                self.userOfflineTimeout = dict["UserOfflineTimeout"] as! Int32
            }
            if dict.keys.contains("UserOnlineTimeout") {
                self.userOnlineTimeout = dict["UserOnlineTimeout"] as! Int32
            }
            if dict.keys.contains("VadLevel") {
                self.vadLevel = dict["VadLevel"] as! Int32
            }
            if dict.keys.contains("VoiceId") {
                self.voiceId = dict["VoiceId"] as! String
            }
            if dict.keys.contains("VoiceIdList") {
                self.voiceIdList = dict["VoiceIdList"] as! [String]
            }
            if dict.keys.contains("VoiceprintId") {
                self.voiceprintId = dict["VoiceprintId"] as! String
            }
            if dict.keys.contains("Volume") {
                self.volume = dict["Volume"] as! Int64
            }
            if dict.keys.contains("WakeUpQuery") {
                self.wakeUpQuery = dict["WakeUpQuery"] as! String
            }
            if dict.keys.contains("WorkflowOverrideParams") {
                self.workflowOverrideParams = dict["WorkflowOverrideParams"] as! String
            }
        }
    }
    public class VoiceChat : Tea.TeaModel {
        public class LlmHistory : Tea.TeaModel {
            public var content: String?

            public var role: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
            }
        }
        public var asrLanguageId: String?

        public var asrMaxSilence: Int32?

        public var avatarUrl: String?

        public var avatarUrlType: String?

        public var bailianAppParams: String?

        public var enableIntelligentSegment: Bool?

        public var enablePushToTalk: Bool?

        public var enableVoiceInterrupt: Bool?

        public var gracefulShutdown: Bool?

        public var greeting: String?

        public var interruptWords: [String]?

        public var llmHistory: [AIAgentTemplateConfig.VoiceChat.LlmHistory]?

        public var llmHistoryLimit: Int32?

        public var llmSystemPrompt: String?

        public var maxIdleTime: Int32?

        public var useVoiceprint: Bool?

        public var userOfflineTimeout: Int32?

        public var userOnlineTimeout: Int32?

        public var vadLevel: Int32?

        public var voiceId: String?

        public var voiceIdList: [String]?

        public var voiceprintId: String?

        public var volume: Int64?

        public var wakeUpQuery: String?

        public var workflowOverrideParams: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asrLanguageId != nil {
                map["AsrLanguageId"] = self.asrLanguageId!
            }
            if self.asrMaxSilence != nil {
                map["AsrMaxSilence"] = self.asrMaxSilence!
            }
            if self.avatarUrl != nil {
                map["AvatarUrl"] = self.avatarUrl!
            }
            if self.avatarUrlType != nil {
                map["AvatarUrlType"] = self.avatarUrlType!
            }
            if self.bailianAppParams != nil {
                map["BailianAppParams"] = self.bailianAppParams!
            }
            if self.enableIntelligentSegment != nil {
                map["EnableIntelligentSegment"] = self.enableIntelligentSegment!
            }
            if self.enablePushToTalk != nil {
                map["EnablePushToTalk"] = self.enablePushToTalk!
            }
            if self.enableVoiceInterrupt != nil {
                map["EnableVoiceInterrupt"] = self.enableVoiceInterrupt!
            }
            if self.gracefulShutdown != nil {
                map["GracefulShutdown"] = self.gracefulShutdown!
            }
            if self.greeting != nil {
                map["Greeting"] = self.greeting!
            }
            if self.interruptWords != nil {
                map["InterruptWords"] = self.interruptWords!
            }
            if self.llmHistory != nil {
                var tmp : [Any] = []
                for k in self.llmHistory! {
                    tmp.append(k.toMap())
                }
                map["LlmHistory"] = tmp
            }
            if self.llmHistoryLimit != nil {
                map["LlmHistoryLimit"] = self.llmHistoryLimit!
            }
            if self.llmSystemPrompt != nil {
                map["LlmSystemPrompt"] = self.llmSystemPrompt!
            }
            if self.maxIdleTime != nil {
                map["MaxIdleTime"] = self.maxIdleTime!
            }
            if self.useVoiceprint != nil {
                map["UseVoiceprint"] = self.useVoiceprint!
            }
            if self.userOfflineTimeout != nil {
                map["UserOfflineTimeout"] = self.userOfflineTimeout!
            }
            if self.userOnlineTimeout != nil {
                map["UserOnlineTimeout"] = self.userOnlineTimeout!
            }
            if self.vadLevel != nil {
                map["VadLevel"] = self.vadLevel!
            }
            if self.voiceId != nil {
                map["VoiceId"] = self.voiceId!
            }
            if self.voiceIdList != nil {
                map["VoiceIdList"] = self.voiceIdList!
            }
            if self.voiceprintId != nil {
                map["VoiceprintId"] = self.voiceprintId!
            }
            if self.volume != nil {
                map["Volume"] = self.volume!
            }
            if self.wakeUpQuery != nil {
                map["WakeUpQuery"] = self.wakeUpQuery!
            }
            if self.workflowOverrideParams != nil {
                map["WorkflowOverrideParams"] = self.workflowOverrideParams!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsrLanguageId") {
                self.asrLanguageId = dict["AsrLanguageId"] as! String
            }
            if dict.keys.contains("AsrMaxSilence") {
                self.asrMaxSilence = dict["AsrMaxSilence"] as! Int32
            }
            if dict.keys.contains("AvatarUrl") {
                self.avatarUrl = dict["AvatarUrl"] as! String
            }
            if dict.keys.contains("AvatarUrlType") {
                self.avatarUrlType = dict["AvatarUrlType"] as! String
            }
            if dict.keys.contains("BailianAppParams") {
                self.bailianAppParams = dict["BailianAppParams"] as! String
            }
            if dict.keys.contains("EnableIntelligentSegment") {
                self.enableIntelligentSegment = dict["EnableIntelligentSegment"] as! Bool
            }
            if dict.keys.contains("EnablePushToTalk") {
                self.enablePushToTalk = dict["EnablePushToTalk"] as! Bool
            }
            if dict.keys.contains("EnableVoiceInterrupt") {
                self.enableVoiceInterrupt = dict["EnableVoiceInterrupt"] as! Bool
            }
            if dict.keys.contains("GracefulShutdown") {
                self.gracefulShutdown = dict["GracefulShutdown"] as! Bool
            }
            if dict.keys.contains("Greeting") {
                self.greeting = dict["Greeting"] as! String
            }
            if dict.keys.contains("InterruptWords") {
                self.interruptWords = dict["InterruptWords"] as! [String]
            }
            if dict.keys.contains("LlmHistory") {
                var tmp : [AIAgentTemplateConfig.VoiceChat.LlmHistory] = []
                for v in dict["LlmHistory"] as! [Any] {
                    var model = AIAgentTemplateConfig.VoiceChat.LlmHistory()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.llmHistory = tmp
            }
            if dict.keys.contains("LlmHistoryLimit") {
                self.llmHistoryLimit = dict["LlmHistoryLimit"] as! Int32
            }
            if dict.keys.contains("LlmSystemPrompt") {
                self.llmSystemPrompt = dict["LlmSystemPrompt"] as! String
            }
            if dict.keys.contains("MaxIdleTime") {
                self.maxIdleTime = dict["MaxIdleTime"] as! Int32
            }
            if dict.keys.contains("UseVoiceprint") {
                self.useVoiceprint = dict["UseVoiceprint"] as! Bool
            }
            if dict.keys.contains("UserOfflineTimeout") {
                self.userOfflineTimeout = dict["UserOfflineTimeout"] as! Int32
            }
            if dict.keys.contains("UserOnlineTimeout") {
                self.userOnlineTimeout = dict["UserOnlineTimeout"] as! Int32
            }
            if dict.keys.contains("VadLevel") {
                self.vadLevel = dict["VadLevel"] as! Int32
            }
            if dict.keys.contains("VoiceId") {
                self.voiceId = dict["VoiceId"] as! String
            }
            if dict.keys.contains("VoiceIdList") {
                self.voiceIdList = dict["VoiceIdList"] as! [String]
            }
            if dict.keys.contains("VoiceprintId") {
                self.voiceprintId = dict["VoiceprintId"] as! String
            }
            if dict.keys.contains("Volume") {
                self.volume = dict["Volume"] as! Int64
            }
            if dict.keys.contains("WakeUpQuery") {
                self.wakeUpQuery = dict["WakeUpQuery"] as! String
            }
            if dict.keys.contains("WorkflowOverrideParams") {
                self.workflowOverrideParams = dict["WorkflowOverrideParams"] as! String
            }
        }
    }
    public var avatarChat3D: AIAgentTemplateConfig.AvatarChat3D?

    public var visionChat: AIAgentTemplateConfig.VisionChat?

    public var voiceChat: AIAgentTemplateConfig.VoiceChat?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.avatarChat3D?.validate()
        try self.visionChat?.validate()
        try self.voiceChat?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarChat3D != nil {
            map["AvatarChat3D"] = self.avatarChat3D?.toMap()
        }
        if self.visionChat != nil {
            map["VisionChat"] = self.visionChat?.toMap()
        }
        if self.voiceChat != nil {
            map["VoiceChat"] = self.voiceChat?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarChat3D") {
            var model = AIAgentTemplateConfig.AvatarChat3D()
            model.fromMap(dict["AvatarChat3D"] as! [String: Any])
            self.avatarChat3D = model
        }
        if dict.keys.contains("VisionChat") {
            var model = AIAgentTemplateConfig.VisionChat()
            model.fromMap(dict["VisionChat"] as! [String: Any])
            self.visionChat = model
        }
        if dict.keys.contains("VoiceChat") {
            var model = AIAgentTemplateConfig.VoiceChat()
            model.fromMap(dict["VoiceChat"] as! [String: Any])
            self.voiceChat = model
        }
    }
}

public class AppInfoDTO : Tea.TeaModel {
    public class Platforms : Tea.TeaModel {
        public var itemId: String?

        public var licenseItemIds: [String]?

        public var pkgName: String?

        public var pkgSignature: String?

        public var platformType: Int64?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.licenseItemIds != nil {
                map["LicenseItemIds"] = self.licenseItemIds!
            }
            if self.pkgName != nil {
                map["PkgName"] = self.pkgName!
            }
            if self.pkgSignature != nil {
                map["PkgSignature"] = self.pkgSignature!
            }
            if self.platformType != nil {
                map["PlatformType"] = self.platformType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") {
                self.itemId = dict["ItemId"] as! String
            }
            if dict.keys.contains("LicenseItemIds") {
                self.licenseItemIds = dict["LicenseItemIds"] as! [String]
            }
            if dict.keys.contains("PkgName") {
                self.pkgName = dict["PkgName"] as! String
            }
            if dict.keys.contains("PkgSignature") {
                self.pkgSignature = dict["PkgSignature"] as! String
            }
            if dict.keys.contains("PlatformType") {
                self.platformType = dict["PlatformType"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int64
            }
        }
    }
    public var appName: String?

    public var appType: Int32?

    public var gmtCreate: String?

    public var itemId: String?

    public var platforms: [AppInfoDTO.Platforms]?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.platforms != nil {
            var tmp : [Any] = []
            for k in self.platforms! {
                tmp.append(k.toMap())
            }
            map["Platforms"] = tmp
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! Int32
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("ItemId") {
            self.itemId = dict["ItemId"] as! String
        }
        if dict.keys.contains("Platforms") {
            var tmp : [AppInfoDTO.Platforms] = []
            for v in dict["Platforms"] as! [Any] {
                var model = AppInfoDTO.Platforms()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.platforms = tmp
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class Channel : Tea.TeaModel {
    public class OutPutConfigList : Tea.TeaModel {
        public var channelName: String?

        public var format: String?

        public var manifestName: String?

        public var manifestSettings: String?

        public var playbackUrl: String?

        public var sourceGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.manifestName != nil {
                map["ManifestName"] = self.manifestName!
            }
            if self.manifestSettings != nil {
                map["ManifestSettings"] = self.manifestSettings!
            }
            if self.playbackUrl != nil {
                map["PlaybackUrl"] = self.playbackUrl!
            }
            if self.sourceGroupName != nil {
                map["SourceGroupName"] = self.sourceGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("ManifestName") {
                self.manifestName = dict["ManifestName"] as! String
            }
            if dict.keys.contains("ManifestSettings") {
                self.manifestSettings = dict["ManifestSettings"] as! String
            }
            if dict.keys.contains("PlaybackUrl") {
                self.playbackUrl = dict["PlaybackUrl"] as! String
            }
            if dict.keys.contains("SourceGroupName") {
                self.sourceGroupName = dict["SourceGroupName"] as! String
            }
        }
    }
    public var accessPolicy: Bool?

    public var accessToken: String?

    public var arn: String?

    public var channelName: String?

    public var channelTier: String?

    public var fillerSourceLocationName: String?

    public var fillerSourceName: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var outPutConfigList: [Channel.OutPutConfigList]?

    public var playbackMode: String?

    public var state: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPolicy != nil {
            map["AccessPolicy"] = self.accessPolicy!
        }
        if self.accessToken != nil {
            map["AccessToken"] = self.accessToken!
        }
        if self.arn != nil {
            map["Arn"] = self.arn!
        }
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.channelTier != nil {
            map["ChannelTier"] = self.channelTier!
        }
        if self.fillerSourceLocationName != nil {
            map["FillerSourceLocationName"] = self.fillerSourceLocationName!
        }
        if self.fillerSourceName != nil {
            map["FillerSourceName"] = self.fillerSourceName!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.outPutConfigList != nil {
            var tmp : [Any] = []
            for k in self.outPutConfigList! {
                tmp.append(k.toMap())
            }
            map["OutPutConfigList"] = tmp
        }
        if self.playbackMode != nil {
            map["PlaybackMode"] = self.playbackMode!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessPolicy") {
            self.accessPolicy = dict["AccessPolicy"] as! Bool
        }
        if dict.keys.contains("AccessToken") {
            self.accessToken = dict["AccessToken"] as! String
        }
        if dict.keys.contains("Arn") {
            self.arn = dict["Arn"] as! String
        }
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ChannelTier") {
            self.channelTier = dict["ChannelTier"] as! String
        }
        if dict.keys.contains("FillerSourceLocationName") {
            self.fillerSourceLocationName = dict["FillerSourceLocationName"] as! String
        }
        if dict.keys.contains("FillerSourceName") {
            self.fillerSourceName = dict["FillerSourceName"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("OutPutConfigList") {
            var tmp : [Channel.OutPutConfigList] = []
            for v in dict["OutPutConfigList"] as! [Any] {
                var model = Channel.OutPutConfigList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outPutConfigList = tmp
        }
        if dict.keys.contains("PlaybackMode") {
            self.playbackMode = dict["PlaybackMode"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! Int32
        }
    }
}

public class ChannelAssemblyChannel : Tea.TeaModel {
    public class OutPutConfigList : Tea.TeaModel {
        public var channelName: String?

        public var format: String?

        public var manifestName: String?

        public var manifestSettings: String?

        public var playbackUrl: String?

        public var sourceGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.manifestName != nil {
                map["ManifestName"] = self.manifestName!
            }
            if self.manifestSettings != nil {
                map["ManifestSettings"] = self.manifestSettings!
            }
            if self.playbackUrl != nil {
                map["PlaybackUrl"] = self.playbackUrl!
            }
            if self.sourceGroupName != nil {
                map["SourceGroupName"] = self.sourceGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("ManifestName") {
                self.manifestName = dict["ManifestName"] as! String
            }
            if dict.keys.contains("ManifestSettings") {
                self.manifestSettings = dict["ManifestSettings"] as! String
            }
            if dict.keys.contains("PlaybackUrl") {
                self.playbackUrl = dict["PlaybackUrl"] as! String
            }
            if dict.keys.contains("SourceGroupName") {
                self.sourceGroupName = dict["SourceGroupName"] as! String
            }
        }
    }
    public var accessPolicy: Bool?

    public var accessToken: String?

    public var arn: String?

    public var channelName: String?

    public var channelTier: String?

    public var fillerSourceLocationName: String?

    public var fillerSourceName: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var outPutConfigList: [ChannelAssemblyChannel.OutPutConfigList]?

    public var playbackMode: String?

    public var state: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPolicy != nil {
            map["AccessPolicy"] = self.accessPolicy!
        }
        if self.accessToken != nil {
            map["AccessToken"] = self.accessToken!
        }
        if self.arn != nil {
            map["Arn"] = self.arn!
        }
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.channelTier != nil {
            map["ChannelTier"] = self.channelTier!
        }
        if self.fillerSourceLocationName != nil {
            map["FillerSourceLocationName"] = self.fillerSourceLocationName!
        }
        if self.fillerSourceName != nil {
            map["FillerSourceName"] = self.fillerSourceName!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.outPutConfigList != nil {
            var tmp : [Any] = []
            for k in self.outPutConfigList! {
                tmp.append(k.toMap())
            }
            map["OutPutConfigList"] = tmp
        }
        if self.playbackMode != nil {
            map["PlaybackMode"] = self.playbackMode!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessPolicy") {
            self.accessPolicy = dict["AccessPolicy"] as! Bool
        }
        if dict.keys.contains("AccessToken") {
            self.accessToken = dict["AccessToken"] as! String
        }
        if dict.keys.contains("Arn") {
            self.arn = dict["Arn"] as! String
        }
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ChannelTier") {
            self.channelTier = dict["ChannelTier"] as! String
        }
        if dict.keys.contains("FillerSourceLocationName") {
            self.fillerSourceLocationName = dict["FillerSourceLocationName"] as! String
        }
        if dict.keys.contains("FillerSourceName") {
            self.fillerSourceName = dict["FillerSourceName"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("OutPutConfigList") {
            var tmp : [ChannelAssemblyChannel.OutPutConfigList] = []
            for v in dict["OutPutConfigList"] as! [Any] {
                var model = ChannelAssemblyChannel.OutPutConfigList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outPutConfigList = tmp
        }
        if dict.keys.contains("PlaybackMode") {
            self.playbackMode = dict["PlaybackMode"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! Int32
        }
    }
}

public class ChannelAssemblyProgram : Tea.TeaModel {
    public class AdBreaks : Tea.TeaModel {
        public var channelName: String?

        public var messageType: String?

        public var offsetMillis: Int64?

        public var programName: String?

        public var sourceLocationName: String?

        public var sourceName: String?

        public var spliceInsertSettings: String?

        public var timeSignalSettings: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.messageType != nil {
                map["MessageType"] = self.messageType!
            }
            if self.offsetMillis != nil {
                map["OffsetMillis"] = self.offsetMillis!
            }
            if self.programName != nil {
                map["ProgramName"] = self.programName!
            }
            if self.sourceLocationName != nil {
                map["SourceLocationName"] = self.sourceLocationName!
            }
            if self.sourceName != nil {
                map["SourceName"] = self.sourceName!
            }
            if self.spliceInsertSettings != nil {
                map["SpliceInsertSettings"] = self.spliceInsertSettings!
            }
            if self.timeSignalSettings != nil {
                map["TimeSignalSettings"] = self.timeSignalSettings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("MessageType") {
                self.messageType = dict["MessageType"] as! String
            }
            if dict.keys.contains("OffsetMillis") {
                self.offsetMillis = dict["OffsetMillis"] as! Int64
            }
            if dict.keys.contains("ProgramName") {
                self.programName = dict["ProgramName"] as! String
            }
            if dict.keys.contains("SourceLocationName") {
                self.sourceLocationName = dict["SourceLocationName"] as! String
            }
            if dict.keys.contains("SourceName") {
                self.sourceName = dict["SourceName"] as! String
            }
            if dict.keys.contains("SpliceInsertSettings") {
                self.spliceInsertSettings = dict["SpliceInsertSettings"] as! String
            }
            if dict.keys.contains("TimeSignalSettings") {
                self.timeSignalSettings = dict["TimeSignalSettings"] as! String
            }
        }
    }
    public var adBreaks: [ChannelAssemblyProgram.AdBreaks]?

    public var arn: String?

    public var channelName: String?

    public var clipRange: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var programName: String?

    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public var transition: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adBreaks != nil {
            var tmp : [Any] = []
            for k in self.adBreaks! {
                tmp.append(k.toMap())
            }
            map["AdBreaks"] = tmp
        }
        if self.arn != nil {
            map["Arn"] = self.arn!
        }
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.clipRange != nil {
            map["ClipRange"] = self.clipRange!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.transition != nil {
            map["Transition"] = self.transition!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdBreaks") {
            var tmp : [ChannelAssemblyProgram.AdBreaks] = []
            for v in dict["AdBreaks"] as! [Any] {
                var model = ChannelAssemblyProgram.AdBreaks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.adBreaks = tmp
        }
        if dict.keys.contains("Arn") {
            self.arn = dict["Arn"] as! String
        }
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ClipRange") {
            self.clipRange = dict["ClipRange"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("ProgramName") {
            self.programName = dict["ProgramName"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("Transition") {
            self.transition = dict["Transition"] as! String
        }
    }
}

public class ChannelAssemblyScheduleData : Tea.TeaModel {
    public class AdBreaks : Tea.TeaModel {
        public var messageType: String?

        public var offsetMillis: String?

        public var sourceLocationName: String?

        public var sourceName: String?

        public var spliceInsertSettings: String?

        public var timeSignalSettings: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.messageType != nil {
                map["MessageType"] = self.messageType!
            }
            if self.offsetMillis != nil {
                map["OffsetMillis"] = self.offsetMillis!
            }
            if self.sourceLocationName != nil {
                map["SourceLocationName"] = self.sourceLocationName!
            }
            if self.sourceName != nil {
                map["SourceName"] = self.sourceName!
            }
            if self.spliceInsertSettings != nil {
                map["SpliceInsertSettings"] = self.spliceInsertSettings!
            }
            if self.timeSignalSettings != nil {
                map["TimeSignalSettings"] = self.timeSignalSettings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MessageType") {
                self.messageType = dict["MessageType"] as! String
            }
            if dict.keys.contains("OffsetMillis") {
                self.offsetMillis = dict["OffsetMillis"] as! String
            }
            if dict.keys.contains("SourceLocationName") {
                self.sourceLocationName = dict["SourceLocationName"] as! String
            }
            if dict.keys.contains("SourceName") {
                self.sourceName = dict["SourceName"] as! String
            }
            if dict.keys.contains("SpliceInsertSettings") {
                self.spliceInsertSettings = dict["SpliceInsertSettings"] as! String
            }
            if dict.keys.contains("TimeSignalSettings") {
                self.timeSignalSettings = dict["TimeSignalSettings"] as! String
            }
        }
    }
    public var adBreaks: [ChannelAssemblyScheduleData.AdBreaks]?

    public var approximateDurationSeconds: Int64?

    public var approximateStartTime: String?

    public var entryType: String?

    public var programName: String?

    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adBreaks != nil {
            var tmp : [Any] = []
            for k in self.adBreaks! {
                tmp.append(k.toMap())
            }
            map["AdBreaks"] = tmp
        }
        if self.approximateDurationSeconds != nil {
            map["ApproximateDurationSeconds"] = self.approximateDurationSeconds!
        }
        if self.approximateStartTime != nil {
            map["ApproximateStartTime"] = self.approximateStartTime!
        }
        if self.entryType != nil {
            map["EntryType"] = self.entryType!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdBreaks") {
            var tmp : [ChannelAssemblyScheduleData.AdBreaks] = []
            for v in dict["AdBreaks"] as! [Any] {
                var model = ChannelAssemblyScheduleData.AdBreaks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.adBreaks = tmp
        }
        if dict.keys.contains("ApproximateDurationSeconds") {
            self.approximateDurationSeconds = dict["ApproximateDurationSeconds"] as! Int64
        }
        if dict.keys.contains("ApproximateStartTime") {
            self.approximateStartTime = dict["ApproximateStartTime"] as! String
        }
        if dict.keys.contains("EntryType") {
            self.entryType = dict["EntryType"] as! String
        }
        if dict.keys.contains("ProgramName") {
            self.programName = dict["ProgramName"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class ChannelAssemblySource : Tea.TeaModel {
    public var arn: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var httpPackageConfigurations: String?

    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public var state: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arn != nil {
            map["Arn"] = self.arn!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.httpPackageConfigurations != nil {
            map["HttpPackageConfigurations"] = self.httpPackageConfigurations!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Arn") {
            self.arn = dict["Arn"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("HttpPackageConfigurations") {
            self.httpPackageConfigurations = dict["HttpPackageConfigurations"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! Int32
        }
    }
}

public class ChannelAssemblySourceLocation : Tea.TeaModel {
    public var arn: String?

    public var baseUrl: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var segmentDeliveryConfigurations: String?

    public var sourceLocationName: String?

    public var state: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arn != nil {
            map["Arn"] = self.arn!
        }
        if self.baseUrl != nil {
            map["BaseUrl"] = self.baseUrl!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.segmentDeliveryConfigurations != nil {
            map["SegmentDeliveryConfigurations"] = self.segmentDeliveryConfigurations!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Arn") {
            self.arn = dict["Arn"] as! String
        }
        if dict.keys.contains("BaseUrl") {
            self.baseUrl = dict["BaseUrl"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("SegmentDeliveryConfigurations") {
            self.segmentDeliveryConfigurations = dict["SegmentDeliveryConfigurations"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! Int32
        }
    }
}

public class LicenseInstanceAppDTO : Tea.TeaModel {
    public class LicenseConfigs : Tea.TeaModel {
        public var businessType: String?

        public var featureIds: String?

        public var isTrial: Bool?

        public var sdkId: Int32?

        public var sdkName: String?

        public var subscription: String?

        public var subscriptionImp: String?

        public var subscriptionPkg: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessType != nil {
                map["BusinessType"] = self.businessType!
            }
            if self.featureIds != nil {
                map["FeatureIds"] = self.featureIds!
            }
            if self.isTrial != nil {
                map["IsTrial"] = self.isTrial!
            }
            if self.sdkId != nil {
                map["SdkId"] = self.sdkId!
            }
            if self.sdkName != nil {
                map["SdkName"] = self.sdkName!
            }
            if self.subscription != nil {
                map["Subscription"] = self.subscription!
            }
            if self.subscriptionImp != nil {
                map["SubscriptionImp"] = self.subscriptionImp!
            }
            if self.subscriptionPkg != nil {
                map["SubscriptionPkg"] = self.subscriptionPkg!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessType") {
                self.businessType = dict["BusinessType"] as! String
            }
            if dict.keys.contains("FeatureIds") {
                self.featureIds = dict["FeatureIds"] as! String
            }
            if dict.keys.contains("IsTrial") {
                self.isTrial = dict["IsTrial"] as! Bool
            }
            if dict.keys.contains("SdkId") {
                self.sdkId = dict["SdkId"] as! Int32
            }
            if dict.keys.contains("SdkName") {
                self.sdkName = dict["SdkName"] as! String
            }
            if dict.keys.contains("Subscription") {
                self.subscription = dict["Subscription"] as! String
            }
            if dict.keys.contains("SubscriptionImp") {
                self.subscriptionImp = dict["SubscriptionImp"] as! String
            }
            if dict.keys.contains("SubscriptionPkg") {
                self.subscriptionPkg = dict["SubscriptionPkg"] as! String
            }
        }
    }
    public var appId: String?

    public var beginOn: String?

    public var contractNo: String?

    public var creationTime: String?

    public var expiredOn: String?

    public var instanceId: String?

    public var itemId: String?

    public var licenseConfigs: [LicenseInstanceAppDTO.LicenseConfigs]?

    public var modificationTime: String?

    public var status: String?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.beginOn != nil {
            map["BeginOn"] = self.beginOn!
        }
        if self.contractNo != nil {
            map["ContractNo"] = self.contractNo!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.expiredOn != nil {
            map["ExpiredOn"] = self.expiredOn!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.licenseConfigs != nil {
            var tmp : [Any] = []
            for k in self.licenseConfigs! {
                tmp.append(k.toMap())
            }
            map["LicenseConfigs"] = tmp
        }
        if self.modificationTime != nil {
            map["ModificationTime"] = self.modificationTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BeginOn") {
            self.beginOn = dict["BeginOn"] as! String
        }
        if dict.keys.contains("ContractNo") {
            self.contractNo = dict["ContractNo"] as! String
        }
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("ExpiredOn") {
            self.expiredOn = dict["ExpiredOn"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ItemId") {
            self.itemId = dict["ItemId"] as! String
        }
        if dict.keys.contains("LicenseConfigs") {
            var tmp : [LicenseInstanceAppDTO.LicenseConfigs] = []
            for v in dict["LicenseConfigs"] as! [Any] {
                var model = LicenseInstanceAppDTO.LicenseConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.licenseConfigs = tmp
        }
        if dict.keys.contains("ModificationTime") {
            self.modificationTime = dict["ModificationTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class LiveManifestConfig : Tea.TeaModel {
    public var adMarkers: String?

    public var dateTimeInterval: Int32?

    public var manifestDuration: Int32?

    public var maxVideoBitrate: Int32?

    public var minBufferTime: Int32?

    public var minUpdatePeriod: Int32?

    public var minVideoBitrate: Int32?

    public var presentationDelay: Int32?

    public var segmentCount: Int32?

    public var segmentTemplateFormat: String?

    public var streamOrder: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adMarkers != nil {
            map["AdMarkers"] = self.adMarkers!
        }
        if self.dateTimeInterval != nil {
            map["DateTimeInterval"] = self.dateTimeInterval!
        }
        if self.manifestDuration != nil {
            map["ManifestDuration"] = self.manifestDuration!
        }
        if self.maxVideoBitrate != nil {
            map["MaxVideoBitrate"] = self.maxVideoBitrate!
        }
        if self.minBufferTime != nil {
            map["MinBufferTime"] = self.minBufferTime!
        }
        if self.minUpdatePeriod != nil {
            map["MinUpdatePeriod"] = self.minUpdatePeriod!
        }
        if self.minVideoBitrate != nil {
            map["MinVideoBitrate"] = self.minVideoBitrate!
        }
        if self.presentationDelay != nil {
            map["PresentationDelay"] = self.presentationDelay!
        }
        if self.segmentCount != nil {
            map["SegmentCount"] = self.segmentCount!
        }
        if self.segmentTemplateFormat != nil {
            map["SegmentTemplateFormat"] = self.segmentTemplateFormat!
        }
        if self.streamOrder != nil {
            map["StreamOrder"] = self.streamOrder!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdMarkers") {
            self.adMarkers = dict["AdMarkers"] as! String
        }
        if dict.keys.contains("DateTimeInterval") {
            self.dateTimeInterval = dict["DateTimeInterval"] as! Int32
        }
        if dict.keys.contains("ManifestDuration") {
            self.manifestDuration = dict["ManifestDuration"] as! Int32
        }
        if dict.keys.contains("MaxVideoBitrate") {
            self.maxVideoBitrate = dict["MaxVideoBitrate"] as! Int32
        }
        if dict.keys.contains("MinBufferTime") {
            self.minBufferTime = dict["MinBufferTime"] as! Int32
        }
        if dict.keys.contains("MinUpdatePeriod") {
            self.minUpdatePeriod = dict["MinUpdatePeriod"] as! Int32
        }
        if dict.keys.contains("MinVideoBitrate") {
            self.minVideoBitrate = dict["MinVideoBitrate"] as! Int32
        }
        if dict.keys.contains("PresentationDelay") {
            self.presentationDelay = dict["PresentationDelay"] as! Int32
        }
        if dict.keys.contains("SegmentCount") {
            self.segmentCount = dict["SegmentCount"] as! Int32
        }
        if dict.keys.contains("SegmentTemplateFormat") {
            self.segmentTemplateFormat = dict["SegmentTemplateFormat"] as! String
        }
        if dict.keys.contains("StreamOrder") {
            self.streamOrder = dict["StreamOrder"] as! String
        }
    }
}

public class LivePackagingConfig : Tea.TeaModel {
    public class DrmConfig : Tea.TeaModel {
        public var contentId: String?

        public var encryptionMethod: String?

        public var IV: String?

        public var rotatePeriod: Int32?

        public var systemIds: [String]?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contentId != nil {
                map["ContentId"] = self.contentId!
            }
            if self.encryptionMethod != nil {
                map["EncryptionMethod"] = self.encryptionMethod!
            }
            if self.IV != nil {
                map["IV"] = self.IV!
            }
            if self.rotatePeriod != nil {
                map["RotatePeriod"] = self.rotatePeriod!
            }
            if self.systemIds != nil {
                map["SystemIds"] = self.systemIds!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContentId") {
                self.contentId = dict["ContentId"] as! String
            }
            if dict.keys.contains("EncryptionMethod") {
                self.encryptionMethod = dict["EncryptionMethod"] as! String
            }
            if dict.keys.contains("IV") {
                self.IV = dict["IV"] as! String
            }
            if dict.keys.contains("RotatePeriod") {
                self.rotatePeriod = dict["RotatePeriod"] as! Int32
            }
            if dict.keys.contains("SystemIds") {
                self.systemIds = dict["SystemIds"] as! [String]
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var drmConfig: LivePackagingConfig.DrmConfig?

    public var liveManifestConfigs: [LiveManifestConfig]?

    public var segmentDuration: Int32?

    public var useAudioRenditionGroups: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.drmConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.drmConfig != nil {
            map["DrmConfig"] = self.drmConfig?.toMap()
        }
        if self.liveManifestConfigs != nil {
            var tmp : [Any] = []
            for k in self.liveManifestConfigs! {
                tmp.append(k.toMap())
            }
            map["LiveManifestConfigs"] = tmp
        }
        if self.segmentDuration != nil {
            map["SegmentDuration"] = self.segmentDuration!
        }
        if self.useAudioRenditionGroups != nil {
            map["UseAudioRenditionGroups"] = self.useAudioRenditionGroups!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DrmConfig") {
            var model = LivePackagingConfig.DrmConfig()
            model.fromMap(dict["DrmConfig"] as! [String: Any])
            self.drmConfig = model
        }
        if dict.keys.contains("LiveManifestConfigs") {
            var tmp : [LiveManifestConfig] = []
            for v in dict["LiveManifestConfigs"] as! [Any] {
                var model = LiveManifestConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.liveManifestConfigs = tmp
        }
        if dict.keys.contains("SegmentDuration") {
            self.segmentDuration = dict["SegmentDuration"] as! Int32
        }
        if dict.keys.contains("UseAudioRenditionGroups") {
            self.useAudioRenditionGroups = dict["UseAudioRenditionGroups"] as! Bool
        }
    }
}

public class MediaConvertAudio : Tea.TeaModel {
    public var bitrate: Int64?

    public var channels: Int64?

    public var codec: String?

    public var profile: String?

    public var remove: Bool?

    public var samplerate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bitrate != nil {
            map["Bitrate"] = self.bitrate!
        }
        if self.channels != nil {
            map["Channels"] = self.channels!
        }
        if self.codec != nil {
            map["Codec"] = self.codec!
        }
        if self.profile != nil {
            map["Profile"] = self.profile!
        }
        if self.remove != nil {
            map["Remove"] = self.remove!
        }
        if self.samplerate != nil {
            map["Samplerate"] = self.samplerate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bitrate") {
            self.bitrate = dict["Bitrate"] as! Int64
        }
        if dict.keys.contains("Channels") {
            self.channels = dict["Channels"] as! Int64
        }
        if dict.keys.contains("Codec") {
            self.codec = dict["Codec"] as! String
        }
        if dict.keys.contains("Profile") {
            self.profile = dict["Profile"] as! String
        }
        if dict.keys.contains("Remove") {
            self.remove = dict["Remove"] as! Bool
        }
        if dict.keys.contains("Samplerate") {
            self.samplerate = dict["Samplerate"] as! String
        }
    }
}

public class MediaConvertInput : Tea.TeaModel {
    public var inputFile: MediaObject?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.inputFile?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputFile != nil {
            map["InputFile"] = self.inputFile?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputFile") {
            var model = MediaObject()
            model.fromMap(dict["InputFile"] as! [String: Any])
            self.inputFile = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class MediaConvertMuxConfig : Tea.TeaModel {
    public var segment: MediaConvertSegment?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.segment?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.segment != nil {
            map["Segment"] = self.segment?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Segment") {
            var model = MediaConvertSegment()
            model.fromMap(dict["Segment"] as! [String: Any])
            self.segment = model
        }
    }
}

public class MediaConvertOutput : Tea.TeaModel {
    public var features: String?

    public var name: String?

    public var outputFile: MediaObject?

    public var overrideParams: String?

    public var priority: Int32?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.outputFile?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.features != nil {
            map["Features"] = self.features!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputFile != nil {
            map["OutputFile"] = self.outputFile?.toMap()
        }
        if self.overrideParams != nil {
            map["OverrideParams"] = self.overrideParams!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Features") {
            self.features = dict["Features"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputFile") {
            var model = MediaObject()
            model.fromMap(dict["OutputFile"] as! [String: Any])
            self.outputFile = model
        }
        if dict.keys.contains("OverrideParams") {
            self.overrideParams = dict["OverrideParams"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class MediaConvertOutputDetail : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var name: String?

    public var status: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class MediaConvertOutputGroup : Tea.TeaModel {
    public var groupConfig: MediaConvertOutputGroupConfig?

    public var name: String?

    public var outputs: [MediaConvertOutputGroupOutput]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.groupConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupConfig != nil {
            map["GroupConfig"] = self.groupConfig?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputs != nil {
            var tmp : [Any] = []
            for k in self.outputs! {
                tmp.append(k.toMap())
            }
            map["Outputs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupConfig") {
            var model = MediaConvertOutputGroupConfig()
            model.fromMap(dict["GroupConfig"] as! [String: Any])
            self.groupConfig = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Outputs") {
            var tmp : [MediaConvertOutputGroupOutput] = []
            for v in dict["Outputs"] as! [Any] {
                var model = MediaConvertOutputGroupOutput()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outputs = tmp
        }
    }
}

public class MediaConvertOutputGroupConfig : Tea.TeaModel {
    public var manifestName: String?

    public var outputFileBase: MediaObject?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.outputFileBase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.manifestName != nil {
            map["ManifestName"] = self.manifestName!
        }
        if self.outputFileBase != nil {
            map["OutputFileBase"] = self.outputFileBase?.toMap()
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ManifestName") {
            self.manifestName = dict["ManifestName"] as! String
        }
        if dict.keys.contains("OutputFileBase") {
            var model = MediaObject()
            model.fromMap(dict["OutputFileBase"] as! [String: Any])
            self.outputFileBase = model
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class MediaConvertOutputGroupDetail : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var name: String?

    public var outputs: [MediaConvertOutputDetail]?

    public var status: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputs != nil {
            var tmp : [Any] = []
            for k in self.outputs! {
                tmp.append(k.toMap())
            }
            map["Outputs"] = tmp
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Outputs") {
            var tmp : [MediaConvertOutputDetail] = []
            for v in dict["Outputs"] as! [Any] {
                var model = MediaConvertOutputDetail()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outputs = tmp
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class MediaConvertOutputGroupOutput : Tea.TeaModel {
    public var features: String?

    public var name: String?

    public var outputFileName: String?

    public var overrideParams: String?

    public var priority: Int32?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.features != nil {
            map["Features"] = self.features!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputFileName != nil {
            map["OutputFileName"] = self.outputFileName!
        }
        if self.overrideParams != nil {
            map["OverrideParams"] = self.overrideParams!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Features") {
            self.features = dict["Features"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputFileName") {
            self.outputFileName = dict["OutputFileName"] as! String
        }
        if dict.keys.contains("OverrideParams") {
            self.overrideParams = dict["OverrideParams"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class MediaConvertSegment : Tea.TeaModel {
    public var duration: Int32?

    public var forceSegTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.forceSegTime != nil {
            map["ForceSegTime"] = self.forceSegTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("ForceSegTime") {
            self.forceSegTime = dict["ForceSegTime"] as! String
        }
    }
}

public class MediaConvertTransConfig : Tea.TeaModel {
    public var adjDarMethod: String?

    public var isCheckAudioBitrate: Bool?

    public var isCheckAudioBitrateFail: Bool?

    public var isCheckReso: Bool?

    public var isCheckResoFail: Bool?

    public var isCheckVideoBitrate: Bool?

    public var isCheckVideoBitrateFail: Bool?

    public var transMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adjDarMethod != nil {
            map["AdjDarMethod"] = self.adjDarMethod!
        }
        if self.isCheckAudioBitrate != nil {
            map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
        }
        if self.isCheckAudioBitrateFail != nil {
            map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
        }
        if self.isCheckReso != nil {
            map["IsCheckReso"] = self.isCheckReso!
        }
        if self.isCheckResoFail != nil {
            map["IsCheckResoFail"] = self.isCheckResoFail!
        }
        if self.isCheckVideoBitrate != nil {
            map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
        }
        if self.isCheckVideoBitrateFail != nil {
            map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
        }
        if self.transMode != nil {
            map["TransMode"] = self.transMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdjDarMethod") {
            self.adjDarMethod = dict["AdjDarMethod"] as! String
        }
        if dict.keys.contains("IsCheckAudioBitrate") {
            self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! Bool
        }
        if dict.keys.contains("IsCheckAudioBitrateFail") {
            self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! Bool
        }
        if dict.keys.contains("IsCheckReso") {
            self.isCheckReso = dict["IsCheckReso"] as! Bool
        }
        if dict.keys.contains("IsCheckResoFail") {
            self.isCheckResoFail = dict["IsCheckResoFail"] as! Bool
        }
        if dict.keys.contains("IsCheckVideoBitrate") {
            self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! Bool
        }
        if dict.keys.contains("IsCheckVideoBitrateFail") {
            self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! Bool
        }
        if dict.keys.contains("TransMode") {
            self.transMode = dict["TransMode"] as! String
        }
    }
}

public class MediaConvertVideo : Tea.TeaModel {
    public var bitrate: Int32?

    public var bufsize: Int32?

    public var codec: String?

    public var crf: Any?

    public var crop: String?

    public var fps: Any?

    public var gop: Any?

    public var height: Int32?

    public var longShortMode: Bool?

    public var maxFps: Any?

    public var maxrate: Int32?

    public var pad: String?

    public var profile: String?

    public var qscale: Int32?

    public var remove: Bool?

    public var scanMode: String?

    public var width: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bitrate != nil {
            map["Bitrate"] = self.bitrate!
        }
        if self.bufsize != nil {
            map["Bufsize"] = self.bufsize!
        }
        if self.codec != nil {
            map["Codec"] = self.codec!
        }
        if self.crf != nil {
            map["Crf"] = self.crf!
        }
        if self.crop != nil {
            map["Crop"] = self.crop!
        }
        if self.fps != nil {
            map["Fps"] = self.fps!
        }
        if self.gop != nil {
            map["Gop"] = self.gop!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.longShortMode != nil {
            map["LongShortMode"] = self.longShortMode!
        }
        if self.maxFps != nil {
            map["MaxFps"] = self.maxFps!
        }
        if self.maxrate != nil {
            map["Maxrate"] = self.maxrate!
        }
        if self.pad != nil {
            map["Pad"] = self.pad!
        }
        if self.profile != nil {
            map["Profile"] = self.profile!
        }
        if self.qscale != nil {
            map["Qscale"] = self.qscale!
        }
        if self.remove != nil {
            map["Remove"] = self.remove!
        }
        if self.scanMode != nil {
            map["ScanMode"] = self.scanMode!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bitrate") {
            self.bitrate = dict["Bitrate"] as! Int32
        }
        if dict.keys.contains("Bufsize") {
            self.bufsize = dict["Bufsize"] as! Int32
        }
        if dict.keys.contains("Codec") {
            self.codec = dict["Codec"] as! String
        }
        if dict.keys.contains("Crf") {
            self.crf = dict["Crf"] as! Any
        }
        if dict.keys.contains("Crop") {
            self.crop = dict["Crop"] as! String
        }
        if dict.keys.contains("Fps") {
            self.fps = dict["Fps"] as! Any
        }
        if dict.keys.contains("Gop") {
            self.gop = dict["Gop"] as! Any
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! Int32
        }
        if dict.keys.contains("LongShortMode") {
            self.longShortMode = dict["LongShortMode"] as! Bool
        }
        if dict.keys.contains("MaxFps") {
            self.maxFps = dict["MaxFps"] as! Any
        }
        if dict.keys.contains("Maxrate") {
            self.maxrate = dict["Maxrate"] as! Int32
        }
        if dict.keys.contains("Pad") {
            self.pad = dict["Pad"] as! String
        }
        if dict.keys.contains("Profile") {
            self.profile = dict["Profile"] as! String
        }
        if dict.keys.contains("Qscale") {
            self.qscale = dict["Qscale"] as! Int32
        }
        if dict.keys.contains("Remove") {
            self.remove = dict["Remove"] as! Bool
        }
        if dict.keys.contains("ScanMode") {
            self.scanMode = dict["ScanMode"] as! String
        }
        if dict.keys.contains("Width") {
            self.width = dict["Width"] as! Int32
        }
    }
}

public class MediaConvertVolume : Tea.TeaModel {
    public var integratedLoudnessTarget: Int32?

    public var level: Int32?

    public var loudnessRangeTarget: Int32?

    public var method: String?

    public var truePeak: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.integratedLoudnessTarget != nil {
            map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.loudnessRangeTarget != nil {
            map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
        }
        if self.method != nil {
            map["Method"] = self.method!
        }
        if self.truePeak != nil {
            map["TruePeak"] = self.truePeak!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IntegratedLoudnessTarget") {
            self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! Int32
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! Int32
        }
        if dict.keys.contains("LoudnessRangeTarget") {
            self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! Int32
        }
        if dict.keys.contains("Method") {
            self.method = dict["Method"] as! String
        }
        if dict.keys.contains("TruePeak") {
            self.truePeak = dict["TruePeak"] as! Int32
        }
    }
}

public class MediaObject : Tea.TeaModel {
    public var media: String?

    public var type: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.media != nil {
            map["Media"] = self.media!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Media") {
            self.media = dict["Media"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class Program : Tea.TeaModel {
    public class AdBreaks : Tea.TeaModel {
        public var channelName: String?

        public var messageType: String?

        public var offsetMillis: Int64?

        public var programName: String?

        public var sourceLocationName: String?

        public var sourceName: String?

        public var spliceInsertSettings: String?

        public var timeSignalSettings: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.messageType != nil {
                map["MessageType"] = self.messageType!
            }
            if self.offsetMillis != nil {
                map["OffsetMillis"] = self.offsetMillis!
            }
            if self.programName != nil {
                map["ProgramName"] = self.programName!
            }
            if self.sourceLocationName != nil {
                map["SourceLocationName"] = self.sourceLocationName!
            }
            if self.sourceName != nil {
                map["SourceName"] = self.sourceName!
            }
            if self.spliceInsertSettings != nil {
                map["SpliceInsertSettings"] = self.spliceInsertSettings!
            }
            if self.timeSignalSettings != nil {
                map["TimeSignalSettings"] = self.timeSignalSettings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("MessageType") {
                self.messageType = dict["MessageType"] as! String
            }
            if dict.keys.contains("OffsetMillis") {
                self.offsetMillis = dict["OffsetMillis"] as! Int64
            }
            if dict.keys.contains("ProgramName") {
                self.programName = dict["ProgramName"] as! String
            }
            if dict.keys.contains("SourceLocationName") {
                self.sourceLocationName = dict["SourceLocationName"] as! String
            }
            if dict.keys.contains("SourceName") {
                self.sourceName = dict["SourceName"] as! String
            }
            if dict.keys.contains("SpliceInsertSettings") {
                self.spliceInsertSettings = dict["SpliceInsertSettings"] as! String
            }
            if dict.keys.contains("TimeSignalSettings") {
                self.timeSignalSettings = dict["TimeSignalSettings"] as! String
            }
        }
    }
    public var adBreaks: [Program.AdBreaks]?

    public var arn: String?

    public var channelName: String?

    public var clipRange: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var programName: String?

    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public var transition: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adBreaks != nil {
            var tmp : [Any] = []
            for k in self.adBreaks! {
                tmp.append(k.toMap())
            }
            map["AdBreaks"] = tmp
        }
        if self.arn != nil {
            map["Arn"] = self.arn!
        }
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.clipRange != nil {
            map["ClipRange"] = self.clipRange!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.transition != nil {
            map["Transition"] = self.transition!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdBreaks") {
            var tmp : [Program.AdBreaks] = []
            for v in dict["AdBreaks"] as! [Any] {
                var model = Program.AdBreaks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.adBreaks = tmp
        }
        if dict.keys.contains("Arn") {
            self.arn = dict["Arn"] as! String
        }
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ClipRange") {
            self.clipRange = dict["ClipRange"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("ProgramName") {
            self.programName = dict["ProgramName"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("Transition") {
            self.transition = dict["Transition"] as! String
        }
    }
}

public class ScheduleData : Tea.TeaModel {
    public class AdBreaks : Tea.TeaModel {
        public var messageType: String?

        public var offsetMillis: String?

        public var sourceLocationName: String?

        public var sourceName: String?

        public var spliceInsertSettings: String?

        public var timeSignalSettings: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.messageType != nil {
                map["MessageType"] = self.messageType!
            }
            if self.offsetMillis != nil {
                map["OffsetMillis"] = self.offsetMillis!
            }
            if self.sourceLocationName != nil {
                map["SourceLocationName"] = self.sourceLocationName!
            }
            if self.sourceName != nil {
                map["SourceName"] = self.sourceName!
            }
            if self.spliceInsertSettings != nil {
                map["SpliceInsertSettings"] = self.spliceInsertSettings!
            }
            if self.timeSignalSettings != nil {
                map["TimeSignalSettings"] = self.timeSignalSettings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MessageType") {
                self.messageType = dict["MessageType"] as! String
            }
            if dict.keys.contains("OffsetMillis") {
                self.offsetMillis = dict["OffsetMillis"] as! String
            }
            if dict.keys.contains("SourceLocationName") {
                self.sourceLocationName = dict["SourceLocationName"] as! String
            }
            if dict.keys.contains("SourceName") {
                self.sourceName = dict["SourceName"] as! String
            }
            if dict.keys.contains("SpliceInsertSettings") {
                self.spliceInsertSettings = dict["SpliceInsertSettings"] as! String
            }
            if dict.keys.contains("TimeSignalSettings") {
                self.timeSignalSettings = dict["TimeSignalSettings"] as! String
            }
        }
    }
    public var adBreaks: [ScheduleData.AdBreaks]?

    public var approximateDurationSeconds: Int64?

    public var approximateStartTime: String?

    public var entryType: String?

    public var programName: String?

    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adBreaks != nil {
            var tmp : [Any] = []
            for k in self.adBreaks! {
                tmp.append(k.toMap())
            }
            map["AdBreaks"] = tmp
        }
        if self.approximateDurationSeconds != nil {
            map["ApproximateDurationSeconds"] = self.approximateDurationSeconds!
        }
        if self.approximateStartTime != nil {
            map["ApproximateStartTime"] = self.approximateStartTime!
        }
        if self.entryType != nil {
            map["EntryType"] = self.entryType!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdBreaks") {
            var tmp : [ScheduleData.AdBreaks] = []
            for v in dict["AdBreaks"] as! [Any] {
                var model = ScheduleData.AdBreaks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.adBreaks = tmp
        }
        if dict.keys.contains("ApproximateDurationSeconds") {
            self.approximateDurationSeconds = dict["ApproximateDurationSeconds"] as! Int64
        }
        if dict.keys.contains("ApproximateStartTime") {
            self.approximateStartTime = dict["ApproximateStartTime"] as! String
        }
        if dict.keys.contains("EntryType") {
            self.entryType = dict["EntryType"] as! String
        }
        if dict.keys.contains("ProgramName") {
            self.programName = dict["ProgramName"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class Source : Tea.TeaModel {
    public var arn: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var httpPackageConfigurations: String?

    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public var state: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arn != nil {
            map["Arn"] = self.arn!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.httpPackageConfigurations != nil {
            map["HttpPackageConfigurations"] = self.httpPackageConfigurations!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Arn") {
            self.arn = dict["Arn"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("HttpPackageConfigurations") {
            self.httpPackageConfigurations = dict["HttpPackageConfigurations"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! Int32
        }
    }
}

public class SourceLocation : Tea.TeaModel {
    public var arn: String?

    public var baseUrl: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var segmentDeliveryConfigurations: String?

    public var sourceLocationName: String?

    public var state: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arn != nil {
            map["Arn"] = self.arn!
        }
        if self.baseUrl != nil {
            map["BaseUrl"] = self.baseUrl!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.segmentDeliveryConfigurations != nil {
            map["SegmentDeliveryConfigurations"] = self.segmentDeliveryConfigurations!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Arn") {
            self.arn = dict["Arn"] as! String
        }
        if dict.keys.contains("BaseUrl") {
            self.baseUrl = dict["BaseUrl"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("SegmentDeliveryConfigurations") {
            self.segmentDeliveryConfigurations = dict["SegmentDeliveryConfigurations"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! Int32
        }
    }
}

public class VodPackagingAsset : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var assetName: String?

    public var contentId: String?

    public var createTime: String?

    public var groupName: String?

    public var input: VodPackagingAsset.Input?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetName != nil {
            map["AssetName"] = self.assetName!
        }
        if self.contentId != nil {
            map["ContentId"] = self.contentId!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetName") {
            self.assetName = dict["AssetName"] as! String
        }
        if dict.keys.contains("ContentId") {
            self.contentId = dict["ContentId"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Input") {
            var model = VodPackagingAsset.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
    }
}

public class VodPackagingConfig : Tea.TeaModel {
    public class DrmProvider : Tea.TeaModel {
        public var encryptionMethod: String?

        public var IV: String?

        public var systemIds: [String]?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.encryptionMethod != nil {
                map["EncryptionMethod"] = self.encryptionMethod!
            }
            if self.IV != nil {
                map["IV"] = self.IV!
            }
            if self.systemIds != nil {
                map["SystemIds"] = self.systemIds!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EncryptionMethod") {
                self.encryptionMethod = dict["EncryptionMethod"] as! String
            }
            if dict.keys.contains("IV") {
                self.IV = dict["IV"] as! String
            }
            if dict.keys.contains("SystemIds") {
                self.systemIds = dict["SystemIds"] as! [String]
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public class StreamSelection : Tea.TeaModel {
        public var maxVideoBitsPerSecond: Int64?

        public var minVideoBitsPerSecond: Int64?

        public var streamOrder: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxVideoBitsPerSecond != nil {
                map["MaxVideoBitsPerSecond"] = self.maxVideoBitsPerSecond!
            }
            if self.minVideoBitsPerSecond != nil {
                map["MinVideoBitsPerSecond"] = self.minVideoBitsPerSecond!
            }
            if self.streamOrder != nil {
                map["StreamOrder"] = self.streamOrder!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MaxVideoBitsPerSecond") {
                self.maxVideoBitsPerSecond = dict["MaxVideoBitsPerSecond"] as! Int64
            }
            if dict.keys.contains("MinVideoBitsPerSecond") {
                self.minVideoBitsPerSecond = dict["MinVideoBitsPerSecond"] as! Int64
            }
            if dict.keys.contains("StreamOrder") {
                self.streamOrder = dict["StreamOrder"] as! String
            }
        }
    }
    public var drmProvider: VodPackagingConfig.DrmProvider?

    public var manifestName: String?

    public var segmentDuration: Int64?

    public var streamSelection: VodPackagingConfig.StreamSelection?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.drmProvider?.validate()
        try self.streamSelection?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.drmProvider != nil {
            map["DrmProvider"] = self.drmProvider?.toMap()
        }
        if self.manifestName != nil {
            map["ManifestName"] = self.manifestName!
        }
        if self.segmentDuration != nil {
            map["SegmentDuration"] = self.segmentDuration!
        }
        if self.streamSelection != nil {
            map["StreamSelection"] = self.streamSelection?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DrmProvider") {
            var model = VodPackagingConfig.DrmProvider()
            model.fromMap(dict["DrmProvider"] as! [String: Any])
            self.drmProvider = model
        }
        if dict.keys.contains("ManifestName") {
            self.manifestName = dict["ManifestName"] as! String
        }
        if dict.keys.contains("SegmentDuration") {
            self.segmentDuration = dict["SegmentDuration"] as! Int64
        }
        if dict.keys.contains("StreamSelection") {
            var model = VodPackagingConfig.StreamSelection()
            model.fromMap(dict["StreamSelection"] as! [String: Any])
            self.streamSelection = model
        }
    }
}

public class VodPackagingConfiguration : Tea.TeaModel {
    public var configurationName: String?

    public var createTime: String?

    public var description_: String?

    public var groupName: String?

    public var packageConfig: VodPackagingConfig?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packageConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configurationName != nil {
            map["ConfigurationName"] = self.configurationName!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.packageConfig != nil {
            map["PackageConfig"] = self.packageConfig?.toMap()
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigurationName") {
            self.configurationName = dict["ConfigurationName"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("PackageConfig") {
            var model = VodPackagingConfig()
            model.fromMap(dict["PackageConfig"] as! [String: Any])
            self.packageConfig = model
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
    }
}

public class VodPackagingGroup : Tea.TeaModel {
    public var approximateAssetCount: Int64?

    public var configurationCount: Int64?

    public var createTime: String?

    public var description_: String?

    public var domainName: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.approximateAssetCount != nil {
            map["ApproximateAssetCount"] = self.approximateAssetCount!
        }
        if self.configurationCount != nil {
            map["ConfigurationCount"] = self.configurationCount!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApproximateAssetCount") {
            self.approximateAssetCount = dict["ApproximateAssetCount"] as! Int64
        }
        if dict.keys.contains("ConfigurationCount") {
            self.configurationCount = dict["ConfigurationCount"] as! Int64
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class AddAdInsertionRequest : Tea.TeaModel {
    public var adMarkerPassthrough: String?

    public var adsUrl: String?

    public var cdnAdSegmentUrlPrefix: String?

    public var cdnContentSegmentUrlPrefix: String?

    public var clientToken: String?

    public var configAliases: String?

    public var contentUrlPrefix: String?

    public var name: String?

    public var personalizationThreshold: Int32?

    public var slateAdUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adMarkerPassthrough != nil {
            map["AdMarkerPassthrough"] = self.adMarkerPassthrough!
        }
        if self.adsUrl != nil {
            map["AdsUrl"] = self.adsUrl!
        }
        if self.cdnAdSegmentUrlPrefix != nil {
            map["CdnAdSegmentUrlPrefix"] = self.cdnAdSegmentUrlPrefix!
        }
        if self.cdnContentSegmentUrlPrefix != nil {
            map["CdnContentSegmentUrlPrefix"] = self.cdnContentSegmentUrlPrefix!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configAliases != nil {
            map["ConfigAliases"] = self.configAliases!
        }
        if self.contentUrlPrefix != nil {
            map["ContentUrlPrefix"] = self.contentUrlPrefix!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.personalizationThreshold != nil {
            map["PersonalizationThreshold"] = self.personalizationThreshold!
        }
        if self.slateAdUrl != nil {
            map["SlateAdUrl"] = self.slateAdUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdMarkerPassthrough") {
            self.adMarkerPassthrough = dict["AdMarkerPassthrough"] as! String
        }
        if dict.keys.contains("AdsUrl") {
            self.adsUrl = dict["AdsUrl"] as! String
        }
        if dict.keys.contains("CdnAdSegmentUrlPrefix") {
            self.cdnAdSegmentUrlPrefix = dict["CdnAdSegmentUrlPrefix"] as! String
        }
        if dict.keys.contains("CdnContentSegmentUrlPrefix") {
            self.cdnContentSegmentUrlPrefix = dict["CdnContentSegmentUrlPrefix"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfigAliases") {
            self.configAliases = dict["ConfigAliases"] as! String
        }
        if dict.keys.contains("ContentUrlPrefix") {
            self.contentUrlPrefix = dict["ContentUrlPrefix"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PersonalizationThreshold") {
            self.personalizationThreshold = dict["PersonalizationThreshold"] as! Int32
        }
        if dict.keys.contains("SlateAdUrl") {
            self.slateAdUrl = dict["SlateAdUrl"] as! String
        }
    }
}

public class AddAdInsertionResponseBody : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public class CdnConfig : Tea.TeaModel {
            public var adSegmentUrlPrefix: String?

            public var contentSegmentUrlPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adSegmentUrlPrefix != nil {
                    map["AdSegmentUrlPrefix"] = self.adSegmentUrlPrefix!
                }
                if self.contentSegmentUrlPrefix != nil {
                    map["ContentSegmentUrlPrefix"] = self.contentSegmentUrlPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdSegmentUrlPrefix") {
                    self.adSegmentUrlPrefix = dict["AdSegmentUrlPrefix"] as! String
                }
                if dict.keys.contains("ContentSegmentUrlPrefix") {
                    self.contentSegmentUrlPrefix = dict["ContentSegmentUrlPrefix"] as! String
                }
            }
        }
        public class ManifestEndpointConfig : Tea.TeaModel {
            public var hlsPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hlsPrefix != nil {
                    map["HlsPrefix"] = self.hlsPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HlsPrefix") {
                    self.hlsPrefix = dict["HlsPrefix"] as! String
                }
            }
        }
        public var adMarkerPassthrough: String?

        public var adsUrl: String?

        public var cdnConfig: AddAdInsertionResponseBody.Config.CdnConfig?

        public var configAliases: String?

        public var contentUrlPrefix: String?

        public var createTime: String?

        public var lastModified: String?

        public var manifestEndpointConfig: AddAdInsertionResponseBody.Config.ManifestEndpointConfig?

        public var name: String?

        public var personalizationThreshold: Int32?

        public var slateAdUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cdnConfig?.validate()
            try self.manifestEndpointConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adMarkerPassthrough != nil {
                map["AdMarkerPassthrough"] = self.adMarkerPassthrough!
            }
            if self.adsUrl != nil {
                map["AdsUrl"] = self.adsUrl!
            }
            if self.cdnConfig != nil {
                map["CdnConfig"] = self.cdnConfig?.toMap()
            }
            if self.configAliases != nil {
                map["ConfigAliases"] = self.configAliases!
            }
            if self.contentUrlPrefix != nil {
                map["ContentUrlPrefix"] = self.contentUrlPrefix!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.manifestEndpointConfig != nil {
                map["ManifestEndpointConfig"] = self.manifestEndpointConfig?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.personalizationThreshold != nil {
                map["PersonalizationThreshold"] = self.personalizationThreshold!
            }
            if self.slateAdUrl != nil {
                map["SlateAdUrl"] = self.slateAdUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AdMarkerPassthrough") {
                self.adMarkerPassthrough = dict["AdMarkerPassthrough"] as! String
            }
            if dict.keys.contains("AdsUrl") {
                self.adsUrl = dict["AdsUrl"] as! String
            }
            if dict.keys.contains("CdnConfig") {
                var model = AddAdInsertionResponseBody.Config.CdnConfig()
                model.fromMap(dict["CdnConfig"] as! [String: Any])
                self.cdnConfig = model
            }
            if dict.keys.contains("ConfigAliases") {
                self.configAliases = dict["ConfigAliases"] as! String
            }
            if dict.keys.contains("ContentUrlPrefix") {
                self.contentUrlPrefix = dict["ContentUrlPrefix"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("ManifestEndpointConfig") {
                var model = AddAdInsertionResponseBody.Config.ManifestEndpointConfig()
                model.fromMap(dict["ManifestEndpointConfig"] as! [String: Any])
                self.manifestEndpointConfig = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PersonalizationThreshold") {
                self.personalizationThreshold = dict["PersonalizationThreshold"] as! Int32
            }
            if dict.keys.contains("SlateAdUrl") {
                self.slateAdUrl = dict["SlateAdUrl"] as! String
            }
        }
    }
    public var config: AddAdInsertionResponseBody.Config?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.config?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            var model = AddAdInsertionResponseBody.Config()
            model.fromMap(dict["Config"] as! [String: Any])
            self.config = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddAdInsertionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAdInsertionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAdInsertionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCategoryRequest : Tea.TeaModel {
    public var cateName: String?

    public var parentId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateName") {
            self.cateName = dict["CateName"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddCategoryResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: Int64?

        public var cateName: String?

        public var level: Int64?

        public var parentId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var category: AddCategoryResponseBody.Category?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            var model = AddCategoryResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialMaps: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialMaps != nil {
            map["MaterialMaps"] = self.materialMaps!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialMaps") {
            self.materialMaps = dict["MaterialMaps"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class AddEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public class LiveMaterials : Tea.TeaModel {
        public var appName: String?

        public var domainName: String?

        public var liveUrl: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.liveUrl != nil {
                map["LiveUrl"] = self.liveUrl!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("LiveUrl") {
                self.liveUrl = dict["LiveUrl"] as! String
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
        }
    }
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: AddEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                var tmp : [AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = AddEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = AddEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var liveMaterials: [AddEditingProjectMaterialsResponseBody.LiveMaterials]?

    public var mediaInfos: [AddEditingProjectMaterialsResponseBody.MediaInfos]?

    public var projectId: String?

    public var projectMaterials: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveMaterials != nil {
            var tmp : [Any] = []
            for k in self.liveMaterials! {
                tmp.append(k.toMap())
            }
            map["LiveMaterials"] = tmp
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectMaterials != nil {
            map["ProjectMaterials"] = self.projectMaterials!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveMaterials") {
            var tmp : [AddEditingProjectMaterialsResponseBody.LiveMaterials] = []
            for v in dict["LiveMaterials"] as! [Any] {
                var model = AddEditingProjectMaterialsResponseBody.LiveMaterials()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.liveMaterials = tmp
        }
        if dict.keys.contains("MediaInfos") {
            var tmp : [AddEditingProjectMaterialsResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = AddEditingProjectMaterialsResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectMaterials") {
            self.projectMaterials = dict["ProjectMaterials"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddFavoritePublicMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class AddFavoritePublicMediaResponseBody : Tea.TeaModel {
    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IgnoredList") {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddFavoritePublicMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddFavoritePublicMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddFavoritePublicMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMediaConnectFlowInputRequest : Tea.TeaModel {
    public var cidrs: String?

    public var flowId: String?

    public var inputFromUrl: String?

    public var inputName: String?

    public var inputProtocol: String?

    public var maxBitrate: Int32?

    public var pairFlowId: String?

    public var pairOutputName: String?

    public var srtLatency: Int32?

    public var srtPassphrase: String?

    public var srtPbkeyLen: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrs != nil {
            map["Cidrs"] = self.cidrs!
        }
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.inputFromUrl != nil {
            map["InputFromUrl"] = self.inputFromUrl!
        }
        if self.inputName != nil {
            map["InputName"] = self.inputName!
        }
        if self.inputProtocol != nil {
            map["InputProtocol"] = self.inputProtocol!
        }
        if self.maxBitrate != nil {
            map["MaxBitrate"] = self.maxBitrate!
        }
        if self.pairFlowId != nil {
            map["PairFlowId"] = self.pairFlowId!
        }
        if self.pairOutputName != nil {
            map["PairOutputName"] = self.pairOutputName!
        }
        if self.srtLatency != nil {
            map["SrtLatency"] = self.srtLatency!
        }
        if self.srtPassphrase != nil {
            map["SrtPassphrase"] = self.srtPassphrase!
        }
        if self.srtPbkeyLen != nil {
            map["SrtPbkeyLen"] = self.srtPbkeyLen!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cidrs") {
            self.cidrs = dict["Cidrs"] as! String
        }
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
        if dict.keys.contains("InputFromUrl") {
            self.inputFromUrl = dict["InputFromUrl"] as! String
        }
        if dict.keys.contains("InputName") {
            self.inputName = dict["InputName"] as! String
        }
        if dict.keys.contains("InputProtocol") {
            self.inputProtocol = dict["InputProtocol"] as! String
        }
        if dict.keys.contains("MaxBitrate") {
            self.maxBitrate = dict["MaxBitrate"] as! Int32
        }
        if dict.keys.contains("PairFlowId") {
            self.pairFlowId = dict["PairFlowId"] as! String
        }
        if dict.keys.contains("PairOutputName") {
            self.pairOutputName = dict["PairOutputName"] as! String
        }
        if dict.keys.contains("SrtLatency") {
            self.srtLatency = dict["SrtLatency"] as! Int32
        }
        if dict.keys.contains("SrtPassphrase") {
            self.srtPassphrase = dict["SrtPassphrase"] as! String
        }
        if dict.keys.contains("SrtPbkeyLen") {
            self.srtPbkeyLen = dict["SrtPbkeyLen"] as! String
        }
    }
}

public class AddMediaConnectFlowInputResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var inputUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputUrl") {
                self.inputUrl = dict["InputUrl"] as! String
            }
        }
    }
    public var content: AddMediaConnectFlowInputResponseBody.Content?

    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            var model = AddMediaConnectFlowInputResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetCode") {
            self.retCode = dict["RetCode"] as! Int32
        }
    }
}

public class AddMediaConnectFlowInputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMediaConnectFlowInputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMediaConnectFlowInputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMediaConnectFlowOutputRequest : Tea.TeaModel {
    public var cidrs: String?

    public var flowId: String?

    public var outputName: String?

    public var outputProtocol: String?

    public var outputToUrl: String?

    public var pairFlowId: String?

    public var pairInputName: String?

    public var playerLimit: Int32?

    public var srtLatency: Int32?

    public var srtPassphrase: String?

    public var srtPbkeyLen: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrs != nil {
            map["Cidrs"] = self.cidrs!
        }
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.outputName != nil {
            map["OutputName"] = self.outputName!
        }
        if self.outputProtocol != nil {
            map["OutputProtocol"] = self.outputProtocol!
        }
        if self.outputToUrl != nil {
            map["OutputToUrl"] = self.outputToUrl!
        }
        if self.pairFlowId != nil {
            map["PairFlowId"] = self.pairFlowId!
        }
        if self.pairInputName != nil {
            map["PairInputName"] = self.pairInputName!
        }
        if self.playerLimit != nil {
            map["PlayerLimit"] = self.playerLimit!
        }
        if self.srtLatency != nil {
            map["SrtLatency"] = self.srtLatency!
        }
        if self.srtPassphrase != nil {
            map["SrtPassphrase"] = self.srtPassphrase!
        }
        if self.srtPbkeyLen != nil {
            map["SrtPbkeyLen"] = self.srtPbkeyLen!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cidrs") {
            self.cidrs = dict["Cidrs"] as! String
        }
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
        if dict.keys.contains("OutputName") {
            self.outputName = dict["OutputName"] as! String
        }
        if dict.keys.contains("OutputProtocol") {
            self.outputProtocol = dict["OutputProtocol"] as! String
        }
        if dict.keys.contains("OutputToUrl") {
            self.outputToUrl = dict["OutputToUrl"] as! String
        }
        if dict.keys.contains("PairFlowId") {
            self.pairFlowId = dict["PairFlowId"] as! String
        }
        if dict.keys.contains("PairInputName") {
            self.pairInputName = dict["PairInputName"] as! String
        }
        if dict.keys.contains("PlayerLimit") {
            self.playerLimit = dict["PlayerLimit"] as! Int32
        }
        if dict.keys.contains("SrtLatency") {
            self.srtLatency = dict["SrtLatency"] as! Int32
        }
        if dict.keys.contains("SrtPassphrase") {
            self.srtPassphrase = dict["SrtPassphrase"] as! String
        }
        if dict.keys.contains("SrtPbkeyLen") {
            self.srtPbkeyLen = dict["SrtPbkeyLen"] as! String
        }
    }
}

public class AddMediaConnectFlowOutputResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var outputUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.outputUrl != nil {
                map["OutputUrl"] = self.outputUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OutputUrl") {
                self.outputUrl = dict["OutputUrl"] as! String
            }
        }
    }
    public var content: AddMediaConnectFlowOutputResponseBody.Content?

    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            var model = AddMediaConnectFlowOutputResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetCode") {
            self.retCode = dict["RetCode"] as! Int32
        }
    }
}

public class AddMediaConnectFlowOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMediaConnectFlowOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMediaConnectFlowOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
    }
}

public class AddMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTemplateRequest : Tea.TeaModel {
    public var config: String?

    public var coverUrl: String?

    public var name: String?

    public var previewMedia: String?

    public var relatedMediaids: String?

    public var source: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.previewMedia != nil {
            map["PreviewMedia"] = self.previewMedia!
        }
        if self.relatedMediaids != nil {
            map["RelatedMediaids"] = self.relatedMediaids!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("CoverUrl") {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PreviewMedia") {
            self.previewMedia = dict["PreviewMedia"] as! String
        }
        if dict.keys.contains("RelatedMediaids") {
            self.relatedMediaids = dict["RelatedMediaids"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var config: String?

        public var coverUrl: String?

        public var createSource: String?

        public var modifiedSource: String?

        public var name: String?

        public var previewMedia: String?

        public var status: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.previewMedia != nil {
                map["PreviewMedia"] = self.previewMedia!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CoverUrl") {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PreviewMedia") {
                self.previewMedia = dict["PreviewMedia"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var template: AddTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") {
            var model = AddTemplateResponseBody.Template()
            model.fromMap(dict["Template"] as! [String: Any])
            self.template = model
        }
    }
}

public class AddTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AlterSearchIndexRequest : Tea.TeaModel {
    public var indexConfig: String?

    public var indexStatus: String?

    public var indexType: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexConfig != nil {
            map["IndexConfig"] = self.indexConfig!
        }
        if self.indexStatus != nil {
            map["IndexStatus"] = self.indexStatus!
        }
        if self.indexType != nil {
            map["IndexType"] = self.indexType!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndexConfig") {
            self.indexConfig = dict["IndexConfig"] as! String
        }
        if dict.keys.contains("IndexStatus") {
            self.indexStatus = dict["IndexStatus"] as! String
        }
        if dict.keys.contains("IndexType") {
            self.indexType = dict["IndexType"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class AlterSearchIndexResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class AlterSearchIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AlterSearchIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AlterSearchIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchCreateVodPackagingAssetRequest : Tea.TeaModel {
    public class Assets : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var assetName: String?

        public var contentId: String?

        public var input: BatchCreateVodPackagingAssetRequest.Assets.Input?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assetName != nil {
                map["AssetName"] = self.assetName!
            }
            if self.contentId != nil {
                map["ContentId"] = self.contentId!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssetName") {
                self.assetName = dict["AssetName"] as! String
            }
            if dict.keys.contains("ContentId") {
                self.contentId = dict["ContentId"] as! String
            }
            if dict.keys.contains("Input") {
                var model = BatchCreateVodPackagingAssetRequest.Assets.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
        }
    }
    public var assets: [BatchCreateVodPackagingAssetRequest.Assets]?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assets != nil {
            var tmp : [Any] = []
            for k in self.assets! {
                tmp.append(k.toMap())
            }
            map["Assets"] = tmp
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Assets") {
            var tmp : [BatchCreateVodPackagingAssetRequest.Assets] = []
            for v in dict["Assets"] as! [Any] {
                var model = BatchCreateVodPackagingAssetRequest.Assets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.assets = tmp
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class BatchCreateVodPackagingAssetShrinkRequest : Tea.TeaModel {
    public var assetsShrink: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetsShrink != nil {
            map["Assets"] = self.assetsShrink!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Assets") {
            self.assetsShrink = dict["Assets"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class BatchCreateVodPackagingAssetResponseBody : Tea.TeaModel {
    public class ResultList : Tea.TeaModel {
        public var asset: VodPackagingAsset?

        public var code: String?

        public var message: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.asset?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asset != nil {
                map["Asset"] = self.asset?.toMap()
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Asset") {
                var model = VodPackagingAsset()
                model.fromMap(dict["Asset"] as! [String: Any])
                self.asset = model
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
        }
    }
    public var groupName: String?

    public var requestId: String?

    public var resultList: [BatchCreateVodPackagingAssetResponseBody.ResultList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultList != nil {
            var tmp : [Any] = []
            for k in self.resultList! {
                tmp.append(k.toMap())
            }
            map["ResultList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultList") {
            var tmp : [BatchCreateVodPackagingAssetResponseBody.ResultList] = []
            for v in dict["ResultList"] as! [Any] {
                var model = BatchCreateVodPackagingAssetResponseBody.ResultList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultList = tmp
        }
    }
}

public class BatchCreateVodPackagingAssetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchCreateVodPackagingAssetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchCreateVodPackagingAssetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchGetMediaInfosRequest : Tea.TeaModel {
    public var additionType: String?

    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionType != nil {
            map["AdditionType"] = self.additionType!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionType") {
            self.additionType = dict["AdditionType"] as! String
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class BatchGetMediaInfosResponseBody : Tea.TeaModel {
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: BatchGetMediaInfosResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                var tmp : [BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = BatchGetMediaInfosResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = BatchGetMediaInfosResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var mediaInfos: [BatchGetMediaInfosResponseBody.MediaInfos]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfos") {
            var tmp : [BatchGetMediaInfosResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = BatchGetMediaInfosResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchGetMediaInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchGetMediaInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchGetMediaInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelDNAJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CancelDNAJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelDNAJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelDNAJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelDNAJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelFavoritePublicMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class CancelFavoritePublicMediaResponseBody : Tea.TeaModel {
    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IgnoredList") {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelFavoritePublicMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelFavoritePublicMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelFavoritePublicMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAuditRequest : Tea.TeaModel {
    public var auditContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.auditContent != nil {
            map["AuditContent"] = self.auditContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuditContent") {
            self.auditContent = dict["AuditContent"] as! String
        }
    }
}

public class CreateAuditResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAuditResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAuditResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAuditResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAvatarTrainingJobRequest : Tea.TeaModel {
    public var avatarDescription: String?

    public var avatarName: String?

    public var avatarType: String?

    public var portrait: String?

    public var thumbnail: String?

    public var transparent: Bool?

    public var video: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarDescription != nil {
            map["AvatarDescription"] = self.avatarDescription!
        }
        if self.avatarName != nil {
            map["AvatarName"] = self.avatarName!
        }
        if self.avatarType != nil {
            map["AvatarType"] = self.avatarType!
        }
        if self.portrait != nil {
            map["Portrait"] = self.portrait!
        }
        if self.thumbnail != nil {
            map["Thumbnail"] = self.thumbnail!
        }
        if self.transparent != nil {
            map["Transparent"] = self.transparent!
        }
        if self.video != nil {
            map["Video"] = self.video!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarDescription") {
            self.avatarDescription = dict["AvatarDescription"] as! String
        }
        if dict.keys.contains("AvatarName") {
            self.avatarName = dict["AvatarName"] as! String
        }
        if dict.keys.contains("AvatarType") {
            self.avatarType = dict["AvatarType"] as! String
        }
        if dict.keys.contains("Portrait") {
            self.portrait = dict["Portrait"] as! String
        }
        if dict.keys.contains("Thumbnail") {
            self.thumbnail = dict["Thumbnail"] as! String
        }
        if dict.keys.contains("Transparent") {
            self.transparent = dict["Transparent"] as! Bool
        }
        if dict.keys.contains("Video") {
            self.video = dict["Video"] as! String
        }
    }
}

public class CreateAvatarTrainingJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: CreateAvatarTrainingJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateAvatarTrainingJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateAvatarTrainingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAvatarTrainingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAvatarTrainingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateChannelRequest : Tea.TeaModel {
    public var accessPolicy: Bool?

    public var accessToken: String?

    public var channelName: String?

    public var channelTier: String?

    public var fillerSourceLocationName: String?

    public var fillerSourceName: String?

    public var outPutConfigList: String?

    public var playbackMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPolicy != nil {
            map["AccessPolicy"] = self.accessPolicy!
        }
        if self.accessToken != nil {
            map["AccessToken"] = self.accessToken!
        }
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.channelTier != nil {
            map["ChannelTier"] = self.channelTier!
        }
        if self.fillerSourceLocationName != nil {
            map["FillerSourceLocationName"] = self.fillerSourceLocationName!
        }
        if self.fillerSourceName != nil {
            map["FillerSourceName"] = self.fillerSourceName!
        }
        if self.outPutConfigList != nil {
            map["OutPutConfigList"] = self.outPutConfigList!
        }
        if self.playbackMode != nil {
            map["PlaybackMode"] = self.playbackMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessPolicy") {
            self.accessPolicy = dict["AccessPolicy"] as! Bool
        }
        if dict.keys.contains("AccessToken") {
            self.accessToken = dict["AccessToken"] as! String
        }
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ChannelTier") {
            self.channelTier = dict["ChannelTier"] as! String
        }
        if dict.keys.contains("FillerSourceLocationName") {
            self.fillerSourceLocationName = dict["FillerSourceLocationName"] as! String
        }
        if dict.keys.contains("FillerSourceName") {
            self.fillerSourceName = dict["FillerSourceName"] as! String
        }
        if dict.keys.contains("OutPutConfigList") {
            self.outPutConfigList = dict["OutPutConfigList"] as! String
        }
        if dict.keys.contains("PlaybackMode") {
            self.playbackMode = dict["PlaybackMode"] as! String
        }
    }
}

public class CreateChannelResponseBody : Tea.TeaModel {
    public var channel: ChannelAssemblyChannel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.channel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channel != nil {
            map["Channel"] = self.channel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Channel") {
            var model = ChannelAssemblyChannel()
            model.fromMap(dict["Channel"] as! [String: Any])
            self.channel = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomTemplateRequest : Tea.TeaModel {
    public var name: String?

    public var subtype: Int32?

    public var templateConfig: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Subtype") {
            self.subtype = dict["Subtype"] as! Int32
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class CreateCustomTemplateResponseBody : Tea.TeaModel {
    public class CustomTemplate : Tea.TeaModel {
        public var createTime: String?

        public var isDefault: Bool?

        public var modifiedTime: String?

        public var status: String?

        public var subtype: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var customTemplate: CreateCustomTemplateResponseBody.CustomTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplate != nil {
            map["CustomTemplate"] = self.customTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplate") {
            var model = CreateCustomTemplateResponseBody.CustomTemplate()
            model.fromMap(dict["CustomTemplate"] as! [String: Any])
            self.customTemplate = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomizedVoiceJobRequest : Tea.TeaModel {
    public var gender: String?

    public var scenario: String?

    public var voiceDesc: String?

    public var voiceId: String?

    public var voiceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gender != nil {
            map["Gender"] = self.gender!
        }
        if self.scenario != nil {
            map["Scenario"] = self.scenario!
        }
        if self.voiceDesc != nil {
            map["VoiceDesc"] = self.voiceDesc!
        }
        if self.voiceId != nil {
            map["VoiceId"] = self.voiceId!
        }
        if self.voiceName != nil {
            map["VoiceName"] = self.voiceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Gender") {
            self.gender = dict["Gender"] as! String
        }
        if dict.keys.contains("Scenario") {
            self.scenario = dict["Scenario"] as! String
        }
        if dict.keys.contains("VoiceDesc") {
            self.voiceDesc = dict["VoiceDesc"] as! String
        }
        if dict.keys.contains("VoiceId") {
            self.voiceId = dict["VoiceId"] as! String
        }
        if dict.keys.contains("VoiceName") {
            self.voiceName = dict["VoiceName"] as! String
        }
    }
}

public class CreateCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public var voiceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.voiceId != nil {
                map["VoiceId"] = self.voiceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("VoiceId") {
                self.voiceId = dict["VoiceId"] as! String
            }
        }
    }
    public var data: CreateCustomizedVoiceJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateCustomizedVoiceJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDNADBRequest : Tea.TeaModel {
    public var description_: String?

    public var model: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Model") {
            self.model = dict["Model"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateDNADBResponseBody : Tea.TeaModel {
    public class DBInfo : Tea.TeaModel {
        public var DBId: String?

        public var description_: String?

        public var model: String?

        public var name: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBId != nil {
                map["DBId"] = self.DBId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.model != nil {
                map["Model"] = self.model!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DBId") {
                self.DBId = dict["DBId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Model") {
                self.model = dict["Model"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var DBInfo: CreateDNADBResponseBody.DBInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DBInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInfo != nil {
            map["DBInfo"] = self.DBInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBInfo") {
            var model = CreateDNADBResponseBody.DBInfo()
            model.fromMap(dict["DBInfo"] as! [String: Any])
            self.DBInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDNADBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDNADBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDNADBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEditingProjectRequest : Tea.TeaModel {
    public var businessConfig: String?

    public var clipsParam: String?

    public var coverURL: String?

    public var description_: String?

    public var materialMaps: String?

    public var projectType: String?

    public var templateId: String?

    public var templateType: String?

    public var timeline: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessConfig != nil {
            map["BusinessConfig"] = self.businessConfig!
        }
        if self.clipsParam != nil {
            map["ClipsParam"] = self.clipsParam!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.materialMaps != nil {
            map["MaterialMaps"] = self.materialMaps!
        }
        if self.projectType != nil {
            map["ProjectType"] = self.projectType!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessConfig") {
            self.businessConfig = dict["BusinessConfig"] as! String
        }
        if dict.keys.contains("ClipsParam") {
            self.clipsParam = dict["ClipsParam"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MaterialMaps") {
            self.materialMaps = dict["MaterialMaps"] as! String
        }
        if dict.keys.contains("ProjectType") {
            self.projectType = dict["ProjectType"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateEditingProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var clipsParam: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var duration: Double?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: Int64?

        public var statusName: String?

        public var templateId: String?

        public var templateType: String?

        public var timeline: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusName != nil {
                map["StatusName"] = self.statusName!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("StatusName") {
                self.statusName = dict["StatusName"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var project: CreateEditingProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") {
            var model = CreateEditingProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLivePackageChannelRequest : Tea.TeaModel {
    public var channelName: String?

    public var clientToken: String?

    public var description_: String?

    public var groupName: String?

    public var protocol_: String?

    public var segmentCount: Int32?

    public var segmentDuration: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.segmentCount != nil {
            map["SegmentCount"] = self.segmentCount!
        }
        if self.segmentDuration != nil {
            map["SegmentDuration"] = self.segmentDuration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("SegmentCount") {
            self.segmentCount = dict["SegmentCount"] as! Int32
        }
        if dict.keys.contains("SegmentDuration") {
            self.segmentDuration = dict["SegmentDuration"] as! Int32
        }
    }
}

public class CreateLivePackageChannelResponseBody : Tea.TeaModel {
    public class LivePackageChannel : Tea.TeaModel {
        public class IngestEndpoints : Tea.TeaModel {
            public var id: String?

            public var password: String?

            public var url: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public var channelName: String?

        public var createTime: String?

        public var description_: String?

        public var groupName: String?

        public var ingestEndpoints: [CreateLivePackageChannelResponseBody.LivePackageChannel.IngestEndpoints]?

        public var lastModified: String?

        public var protocol_: String?

        public var segmentCount: Int32?

        public var segmentDuration: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.ingestEndpoints != nil {
                var tmp : [Any] = []
                for k in self.ingestEndpoints! {
                    tmp.append(k.toMap())
                }
                map["IngestEndpoints"] = tmp
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.segmentCount != nil {
                map["SegmentCount"] = self.segmentCount!
            }
            if self.segmentDuration != nil {
                map["SegmentDuration"] = self.segmentDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("IngestEndpoints") {
                var tmp : [CreateLivePackageChannelResponseBody.LivePackageChannel.IngestEndpoints] = []
                for v in dict["IngestEndpoints"] as! [Any] {
                    var model = CreateLivePackageChannelResponseBody.LivePackageChannel.IngestEndpoints()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ingestEndpoints = tmp
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("SegmentCount") {
                self.segmentCount = dict["SegmentCount"] as! Int32
            }
            if dict.keys.contains("SegmentDuration") {
                self.segmentDuration = dict["SegmentDuration"] as! Int32
            }
        }
    }
    public var livePackageChannel: CreateLivePackageChannelResponseBody.LivePackageChannel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.livePackageChannel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageChannel != nil {
            map["LivePackageChannel"] = self.livePackageChannel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LivePackageChannel") {
            var model = CreateLivePackageChannelResponseBody.LivePackageChannel()
            model.fromMap(dict["LivePackageChannel"] as! [String: Any])
            self.livePackageChannel = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLivePackageChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLivePackageChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLivePackageChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLivePackageChannelGroupRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class CreateLivePackageChannelGroupResponseBody : Tea.TeaModel {
    public class LivePackageChannelGroup : Tea.TeaModel {
        public var createTime: String?

        public var description_: String?

        public var groupName: String?

        public var lastModified: String?

        public var originDomain: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.originDomain != nil {
                map["OriginDomain"] = self.originDomain!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("OriginDomain") {
                self.originDomain = dict["OriginDomain"] as! String
            }
        }
    }
    public var livePackageChannelGroup: CreateLivePackageChannelGroupResponseBody.LivePackageChannelGroup?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.livePackageChannelGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageChannelGroup != nil {
            map["LivePackageChannelGroup"] = self.livePackageChannelGroup?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LivePackageChannelGroup") {
            var model = CreateLivePackageChannelGroupResponseBody.LivePackageChannelGroup()
            model.fromMap(dict["LivePackageChannelGroup"] as! [String: Any])
            self.livePackageChannelGroup = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLivePackageChannelGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLivePackageChannelGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLivePackageChannelGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLivePackageOriginEndpointRequest : Tea.TeaModel {
    public var authorizationCode: String?

    public var channelName: String?

    public var clientToken: String?

    public var description_: String?

    public var endpointName: String?

    public var groupName: String?

    public var ipBlacklist: String?

    public var ipWhitelist: String?

    public var manifestName: String?

    public var protocol_: String?

    public var timeshiftVision: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizationCode != nil {
            map["AuthorizationCode"] = self.authorizationCode!
        }
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.ipBlacklist != nil {
            map["IpBlacklist"] = self.ipBlacklist!
        }
        if self.ipWhitelist != nil {
            map["IpWhitelist"] = self.ipWhitelist!
        }
        if self.manifestName != nil {
            map["ManifestName"] = self.manifestName!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.timeshiftVision != nil {
            map["TimeshiftVision"] = self.timeshiftVision!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizationCode") {
            self.authorizationCode = dict["AuthorizationCode"] as! String
        }
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndpointName") {
            self.endpointName = dict["EndpointName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("IpBlacklist") {
            self.ipBlacklist = dict["IpBlacklist"] as! String
        }
        if dict.keys.contains("IpWhitelist") {
            self.ipWhitelist = dict["IpWhitelist"] as! String
        }
        if dict.keys.contains("ManifestName") {
            self.manifestName = dict["ManifestName"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("TimeshiftVision") {
            self.timeshiftVision = dict["TimeshiftVision"] as! Int32
        }
    }
}

public class CreateLivePackageOriginEndpointResponseBody : Tea.TeaModel {
    public class LivePackageOriginEndpoint : Tea.TeaModel {
        public var authorizationCode: String?

        public var channelName: String?

        public var createTime: String?

        public var description_: String?

        public var endpointName: String?

        public var endpointUrl: String?

        public var groupName: String?

        public var ipBlacklist: String?

        public var ipWhitelist: String?

        public var lastModified: String?

        public var manifestName: String?

        public var protocol_: String?

        public var timeshiftVision: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizationCode != nil {
                map["AuthorizationCode"] = self.authorizationCode!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.endpointName != nil {
                map["EndpointName"] = self.endpointName!
            }
            if self.endpointUrl != nil {
                map["EndpointUrl"] = self.endpointUrl!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.ipBlacklist != nil {
                map["IpBlacklist"] = self.ipBlacklist!
            }
            if self.ipWhitelist != nil {
                map["IpWhitelist"] = self.ipWhitelist!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.manifestName != nil {
                map["ManifestName"] = self.manifestName!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.timeshiftVision != nil {
                map["TimeshiftVision"] = self.timeshiftVision!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizationCode") {
                self.authorizationCode = dict["AuthorizationCode"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EndpointName") {
                self.endpointName = dict["EndpointName"] as! String
            }
            if dict.keys.contains("EndpointUrl") {
                self.endpointUrl = dict["EndpointUrl"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("IpBlacklist") {
                self.ipBlacklist = dict["IpBlacklist"] as! String
            }
            if dict.keys.contains("IpWhitelist") {
                self.ipWhitelist = dict["IpWhitelist"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("ManifestName") {
                self.manifestName = dict["ManifestName"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("TimeshiftVision") {
                self.timeshiftVision = dict["TimeshiftVision"] as! Int32
            }
        }
    }
    public var livePackageOriginEndpoint: CreateLivePackageOriginEndpointResponseBody.LivePackageOriginEndpoint?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.livePackageOriginEndpoint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageOriginEndpoint != nil {
            map["LivePackageOriginEndpoint"] = self.livePackageOriginEndpoint?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LivePackageOriginEndpoint") {
            var model = CreateLivePackageOriginEndpointResponseBody.LivePackageOriginEndpoint()
            model.fromMap(dict["LivePackageOriginEndpoint"] as! [String: Any])
            self.livePackageOriginEndpoint = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLivePackageOriginEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLivePackageOriginEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLivePackageOriginEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveRecordTemplateRequest : Tea.TeaModel {
    public class RecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var ossObjectPrefix: String?

        public var sliceDuration: Int32?

        public var sliceOssObjectPrefix: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.ossObjectPrefix != nil {
                map["OssObjectPrefix"] = self.ossObjectPrefix!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            if self.sliceOssObjectPrefix != nil {
                map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CycleDuration") {
                self.cycleDuration = dict["CycleDuration"] as! Int32
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("OssObjectPrefix") {
                self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
            }
            if dict.keys.contains("SliceDuration") {
                self.sliceDuration = dict["SliceDuration"] as! Int32
            }
            if dict.keys.contains("SliceOssObjectPrefix") {
                self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
            }
        }
    }
    public var name: String?

    public var recordFormat: [CreateLiveRecordTemplateRequest.RecordFormat]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormat != nil {
            var tmp : [Any] = []
            for k in self.recordFormat! {
                tmp.append(k.toMap())
            }
            map["RecordFormat"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") {
            var tmp : [CreateLiveRecordTemplateRequest.RecordFormat] = []
            for v in dict["RecordFormat"] as! [Any] {
                var model = CreateLiveRecordTemplateRequest.RecordFormat()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordFormat = tmp
        }
    }
}

public class CreateLiveRecordTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var recordFormatShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormatShrink != nil {
            map["RecordFormat"] = self.recordFormatShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") {
            self.recordFormatShrink = dict["RecordFormat"] as! String
        }
    }
}

public class CreateLiveRecordTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var overwriteFormat: String?

    public var sequenceFormat: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OverwriteFormat") {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("SequenceFormat") {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class CreateLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveTranscodeTemplateRequest : Tea.TeaModel {
    public class TemplateConfig : Tea.TeaModel {
        public class AudioParams : Tea.TeaModel {
            public var bitrate: String?

            public var channels: String?

            public var codec: String?

            public var profile: String?

            public var samplerate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.samplerate != nil {
                    map["Samplerate"] = self.samplerate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Samplerate") {
                    self.samplerate = dict["Samplerate"] as! String
                }
            }
        }
        public class VideoParams : Tea.TeaModel {
            public var bitrate: String?

            public var codec: String?

            public var fps: String?

            public var gop: String?

            public var height: String?

            public var profile: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Gop") {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audioParams: CreateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams?

        public var videoParams: CreateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audioParams?.validate()
            try self.videoParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioParams != nil {
                map["AudioParams"] = self.audioParams?.toMap()
            }
            if self.videoParams != nil {
                map["VideoParams"] = self.videoParams?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioParams") {
                var model = CreateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams()
                model.fromMap(dict["AudioParams"] as! [String: Any])
                self.audioParams = model
            }
            if dict.keys.contains("VideoParams") {
                var model = CreateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams()
                model.fromMap(dict["VideoParams"] as! [String: Any])
                self.videoParams = model
            }
        }
    }
    public var name: String?

    public var templateConfig: CreateLiveTranscodeTemplateRequest.TemplateConfig?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            var model = CreateLiveTranscodeTemplateRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfigShrink: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMediaConnectFlowRequest : Tea.TeaModel {
    public var flowName: String?

    public var flowRegion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowName != nil {
            map["FlowName"] = self.flowName!
        }
        if self.flowRegion != nil {
            map["FlowRegion"] = self.flowRegion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowName") {
            self.flowName = dict["FlowName"] as! String
        }
        if dict.keys.contains("FlowRegion") {
            self.flowRegion = dict["FlowRegion"] as! String
        }
    }
}

public class CreateMediaConnectFlowResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var flowId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flowId != nil {
                map["FlowId"] = self.flowId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FlowId") {
                self.flowId = dict["FlowId"] as! String
            }
        }
    }
    public var content: CreateMediaConnectFlowResponseBody.Content?

    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            var model = CreateMediaConnectFlowResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetCode") {
            self.retCode = dict["RetCode"] as! Int32
        }
    }
}

public class CreateMediaConnectFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMediaConnectFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMediaConnectFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMediaLiveChannelRequest : Tea.TeaModel {
    public class AudioSettings : Tea.TeaModel {
        public class AudioCodecSetting : Tea.TeaModel {
            public var bitrate: Int32?

            public var profile: String?

            public var sampleRate: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.sampleRate != nil {
                    map["SampleRate"] = self.sampleRate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! Int32
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("SampleRate") {
                    self.sampleRate = dict["SampleRate"] as! Int32
                }
            }
        }
        public var audioCodec: String?

        public var audioCodecSetting: CreateMediaLiveChannelRequest.AudioSettings.AudioCodecSetting?

        public var audioSelectorName: String?

        public var languageCode: String?

        public var languageName: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audioCodecSetting?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioCodec != nil {
                map["AudioCodec"] = self.audioCodec!
            }
            if self.audioCodecSetting != nil {
                map["AudioCodecSetting"] = self.audioCodecSetting?.toMap()
            }
            if self.audioSelectorName != nil {
                map["AudioSelectorName"] = self.audioSelectorName!
            }
            if self.languageCode != nil {
                map["LanguageCode"] = self.languageCode!
            }
            if self.languageName != nil {
                map["LanguageName"] = self.languageName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioCodec") {
                self.audioCodec = dict["AudioCodec"] as! String
            }
            if dict.keys.contains("AudioCodecSetting") {
                var model = CreateMediaLiveChannelRequest.AudioSettings.AudioCodecSetting()
                model.fromMap(dict["AudioCodecSetting"] as! [String: Any])
                self.audioCodecSetting = model
            }
            if dict.keys.contains("AudioSelectorName") {
                self.audioSelectorName = dict["AudioSelectorName"] as! String
            }
            if dict.keys.contains("LanguageCode") {
                self.languageCode = dict["LanguageCode"] as! String
            }
            if dict.keys.contains("LanguageName") {
                self.languageName = dict["LanguageName"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public class InputAttachments : Tea.TeaModel {
        public class AudioSelectors : Tea.TeaModel {
            public class AudioLanguageSelection : Tea.TeaModel {
                public var languageCode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.languageCode != nil {
                        map["LanguageCode"] = self.languageCode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LanguageCode") {
                        self.languageCode = dict["LanguageCode"] as! String
                    }
                }
            }
            public class AudioPidSelection : Tea.TeaModel {
                public var pid: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pid != nil {
                        map["Pid"] = self.pid!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Pid") {
                        self.pid = dict["Pid"] as! Int64
                    }
                }
            }
            public class AudioTrackSelection : Tea.TeaModel {
                public var trackId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.trackId != nil {
                        map["TrackId"] = self.trackId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TrackId") {
                        self.trackId = dict["TrackId"] as! Int64
                    }
                }
            }
            public var audioLanguageSelection: CreateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioLanguageSelection?

            public var audioPidSelection: CreateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioPidSelection?

            public var audioTrackSelection: [CreateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioTrackSelection]?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioLanguageSelection?.validate()
                try self.audioPidSelection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioLanguageSelection != nil {
                    map["AudioLanguageSelection"] = self.audioLanguageSelection?.toMap()
                }
                if self.audioPidSelection != nil {
                    map["AudioPidSelection"] = self.audioPidSelection?.toMap()
                }
                if self.audioTrackSelection != nil {
                    var tmp : [Any] = []
                    for k in self.audioTrackSelection! {
                        tmp.append(k.toMap())
                    }
                    map["AudioTrackSelection"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioLanguageSelection") {
                    var model = CreateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioLanguageSelection()
                    model.fromMap(dict["AudioLanguageSelection"] as! [String: Any])
                    self.audioLanguageSelection = model
                }
                if dict.keys.contains("AudioPidSelection") {
                    var model = CreateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioPidSelection()
                    model.fromMap(dict["AudioPidSelection"] as! [String: Any])
                    self.audioPidSelection = model
                }
                if dict.keys.contains("AudioTrackSelection") {
                    var tmp : [CreateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioTrackSelection] = []
                    for v in dict["AudioTrackSelection"] as! [Any] {
                        var model = CreateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioTrackSelection()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioTrackSelection = tmp
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var audioSelectors: [CreateMediaLiveChannelRequest.InputAttachments.AudioSelectors]?

        public var inputId: String?

        public var languageName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioSelectors != nil {
                var tmp : [Any] = []
                for k in self.audioSelectors! {
                    tmp.append(k.toMap())
                }
                map["AudioSelectors"] = tmp
            }
            if self.inputId != nil {
                map["InputId"] = self.inputId!
            }
            if self.languageName != nil {
                map["LanguageName"] = self.languageName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioSelectors") {
                var tmp : [CreateMediaLiveChannelRequest.InputAttachments.AudioSelectors] = []
                for v in dict["AudioSelectors"] as! [Any] {
                    var model = CreateMediaLiveChannelRequest.InputAttachments.AudioSelectors()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.audioSelectors = tmp
            }
            if dict.keys.contains("InputId") {
                self.inputId = dict["InputId"] as! String
            }
            if dict.keys.contains("LanguageName") {
                self.languageName = dict["LanguageName"] as! String
            }
        }
    }
    public class OutputGroups : Tea.TeaModel {
        public class MediaPackageGroupSetting : Tea.TeaModel {
            public var channelName: String?

            public var groupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelName != nil {
                    map["ChannelName"] = self.channelName!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelName") {
                    self.channelName = dict["ChannelName"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
            }
        }
        public class Outputs : Tea.TeaModel {
            public class MediaPackageOutputSetting : Tea.TeaModel {
                public var audioGroupId: String?

                public var nameModifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioGroupId != nil {
                        map["AudioGroupId"] = self.audioGroupId!
                    }
                    if self.nameModifier != nil {
                        map["NameModifier"] = self.nameModifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioGroupId") {
                        self.audioGroupId = dict["AudioGroupId"] as! String
                    }
                    if dict.keys.contains("NameModifier") {
                        self.nameModifier = dict["NameModifier"] as! String
                    }
                }
            }
            public var audioSettingNames: [String]?

            public var mediaPackageOutputSetting: CreateMediaLiveChannelRequest.OutputGroups.Outputs.MediaPackageOutputSetting?

            public var mediaType: Int32?

            public var name: String?

            public var videoSettingName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.mediaPackageOutputSetting?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioSettingNames != nil {
                    map["AudioSettingNames"] = self.audioSettingNames!
                }
                if self.mediaPackageOutputSetting != nil {
                    map["MediaPackageOutputSetting"] = self.mediaPackageOutputSetting?.toMap()
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.videoSettingName != nil {
                    map["VideoSettingName"] = self.videoSettingName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioSettingNames") {
                    self.audioSettingNames = dict["AudioSettingNames"] as! [String]
                }
                if dict.keys.contains("MediaPackageOutputSetting") {
                    var model = CreateMediaLiveChannelRequest.OutputGroups.Outputs.MediaPackageOutputSetting()
                    model.fromMap(dict["MediaPackageOutputSetting"] as! [String: Any])
                    self.mediaPackageOutputSetting = model
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("VideoSettingName") {
                    self.videoSettingName = dict["VideoSettingName"] as! String
                }
            }
        }
        public var mediaPackageGroupSetting: CreateMediaLiveChannelRequest.OutputGroups.MediaPackageGroupSetting?

        public var name: String?

        public var outputs: [CreateMediaLiveChannelRequest.OutputGroups.Outputs]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaPackageGroupSetting?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaPackageGroupSetting != nil {
                map["MediaPackageGroupSetting"] = self.mediaPackageGroupSetting?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputs != nil {
                var tmp : [Any] = []
                for k in self.outputs! {
                    tmp.append(k.toMap())
                }
                map["Outputs"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaPackageGroupSetting") {
                var model = CreateMediaLiveChannelRequest.OutputGroups.MediaPackageGroupSetting()
                model.fromMap(dict["MediaPackageGroupSetting"] as! [String: Any])
                self.mediaPackageGroupSetting = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Outputs") {
                var tmp : [CreateMediaLiveChannelRequest.OutputGroups.Outputs] = []
                for v in dict["Outputs"] as! [Any] {
                    var model = CreateMediaLiveChannelRequest.OutputGroups.Outputs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputs = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class VideoSettings : Tea.TeaModel {
        public class VideoCodecSetting : Tea.TeaModel {
            public class CodecDetail : Tea.TeaModel {
                public var level: String?

                public var profile: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                }
            }
            public class Framerate : Tea.TeaModel {
                public var framerateControl: String?

                public var framerateDenominator: Int32?

                public var framerateNumerator: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.framerateControl != nil {
                        map["FramerateControl"] = self.framerateControl!
                    }
                    if self.framerateDenominator != nil {
                        map["FramerateDenominator"] = self.framerateDenominator!
                    }
                    if self.framerateNumerator != nil {
                        map["FramerateNumerator"] = self.framerateNumerator!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FramerateControl") {
                        self.framerateControl = dict["FramerateControl"] as! String
                    }
                    if dict.keys.contains("FramerateDenominator") {
                        self.framerateDenominator = dict["FramerateDenominator"] as! Int32
                    }
                    if dict.keys.contains("FramerateNumerator") {
                        self.framerateNumerator = dict["FramerateNumerator"] as! Int32
                    }
                }
            }
            public class Gop : Tea.TeaModel {
                public var bframesNum: Int32?

                public var gopSize: Int32?

                public var gopSizeUnits: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bframesNum != nil {
                        map["BframesNum"] = self.bframesNum!
                    }
                    if self.gopSize != nil {
                        map["GopSize"] = self.gopSize!
                    }
                    if self.gopSizeUnits != nil {
                        map["GopSizeUnits"] = self.gopSizeUnits!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BframesNum") {
                        self.bframesNum = dict["BframesNum"] as! Int32
                    }
                    if dict.keys.contains("GopSize") {
                        self.gopSize = dict["GopSize"] as! Int32
                    }
                    if dict.keys.contains("GopSizeUnits") {
                        self.gopSizeUnits = dict["GopSizeUnits"] as! String
                    }
                }
            }
            public class Rate : Tea.TeaModel {
                public var bitrate: Int32?

                public var bufferSize: Int32?

                public var maxBitrate: Int32?

                public var rateControlMode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.bufferSize != nil {
                        map["BufferSize"] = self.bufferSize!
                    }
                    if self.maxBitrate != nil {
                        map["MaxBitrate"] = self.maxBitrate!
                    }
                    if self.rateControlMode != nil {
                        map["RateControlMode"] = self.rateControlMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! Int32
                    }
                    if dict.keys.contains("BufferSize") {
                        self.bufferSize = dict["BufferSize"] as! Int32
                    }
                    if dict.keys.contains("MaxBitrate") {
                        self.maxBitrate = dict["MaxBitrate"] as! Int32
                    }
                    if dict.keys.contains("RateControlMode") {
                        self.rateControlMode = dict["RateControlMode"] as! String
                    }
                }
            }
            public var codecDetail: CreateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.CodecDetail?

            public var framerate: CreateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.Framerate?

            public var gop: CreateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.Gop?

            public var rate: CreateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.Rate?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.codecDetail?.validate()
                try self.framerate?.validate()
                try self.gop?.validate()
                try self.rate?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.codecDetail != nil {
                    map["CodecDetail"] = self.codecDetail?.toMap()
                }
                if self.framerate != nil {
                    map["Framerate"] = self.framerate?.toMap()
                }
                if self.gop != nil {
                    map["Gop"] = self.gop?.toMap()
                }
                if self.rate != nil {
                    map["Rate"] = self.rate?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CodecDetail") {
                    var model = CreateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.CodecDetail()
                    model.fromMap(dict["CodecDetail"] as! [String: Any])
                    self.codecDetail = model
                }
                if dict.keys.contains("Framerate") {
                    var model = CreateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.Framerate()
                    model.fromMap(dict["Framerate"] as! [String: Any])
                    self.framerate = model
                }
                if dict.keys.contains("Gop") {
                    var model = CreateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.Gop()
                    model.fromMap(dict["Gop"] as! [String: Any])
                    self.gop = model
                }
                if dict.keys.contains("Rate") {
                    var model = CreateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.Rate()
                    model.fromMap(dict["Rate"] as! [String: Any])
                    self.rate = model
                }
            }
        }
        public var height: Int32?

        public var name: String?

        public var videoCodec: String?

        public var videoCodecSetting: CreateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting?

        public var width: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.videoCodecSetting?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.videoCodec != nil {
                map["VideoCodec"] = self.videoCodec!
            }
            if self.videoCodecSetting != nil {
                map["VideoCodecSetting"] = self.videoCodecSetting?.toMap()
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("VideoCodec") {
                self.videoCodec = dict["VideoCodec"] as! String
            }
            if dict.keys.contains("VideoCodecSetting") {
                var model = CreateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting()
                model.fromMap(dict["VideoCodecSetting"] as! [String: Any])
                self.videoCodecSetting = model
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int32
            }
        }
    }
    public var audioSettings: [CreateMediaLiveChannelRequest.AudioSettings]?

    public var inputAttachments: [CreateMediaLiveChannelRequest.InputAttachments]?

    public var name: String?

    public var outputGroups: [CreateMediaLiveChannelRequest.OutputGroups]?

    public var videoSettings: [CreateMediaLiveChannelRequest.VideoSettings]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioSettings != nil {
            var tmp : [Any] = []
            for k in self.audioSettings! {
                tmp.append(k.toMap())
            }
            map["AudioSettings"] = tmp
        }
        if self.inputAttachments != nil {
            var tmp : [Any] = []
            for k in self.inputAttachments! {
                tmp.append(k.toMap())
            }
            map["InputAttachments"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputGroups != nil {
            var tmp : [Any] = []
            for k in self.outputGroups! {
                tmp.append(k.toMap())
            }
            map["OutputGroups"] = tmp
        }
        if self.videoSettings != nil {
            var tmp : [Any] = []
            for k in self.videoSettings! {
                tmp.append(k.toMap())
            }
            map["VideoSettings"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioSettings") {
            var tmp : [CreateMediaLiveChannelRequest.AudioSettings] = []
            for v in dict["AudioSettings"] as! [Any] {
                var model = CreateMediaLiveChannelRequest.AudioSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.audioSettings = tmp
        }
        if dict.keys.contains("InputAttachments") {
            var tmp : [CreateMediaLiveChannelRequest.InputAttachments] = []
            for v in dict["InputAttachments"] as! [Any] {
                var model = CreateMediaLiveChannelRequest.InputAttachments()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inputAttachments = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputGroups") {
            var tmp : [CreateMediaLiveChannelRequest.OutputGroups] = []
            for v in dict["OutputGroups"] as! [Any] {
                var model = CreateMediaLiveChannelRequest.OutputGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outputGroups = tmp
        }
        if dict.keys.contains("VideoSettings") {
            var tmp : [CreateMediaLiveChannelRequest.VideoSettings] = []
            for v in dict["VideoSettings"] as! [Any] {
                var model = CreateMediaLiveChannelRequest.VideoSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.videoSettings = tmp
        }
    }
}

public class CreateMediaLiveChannelShrinkRequest : Tea.TeaModel {
    public var audioSettingsShrink: String?

    public var inputAttachmentsShrink: String?

    public var name: String?

    public var outputGroupsShrink: String?

    public var videoSettingsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioSettingsShrink != nil {
            map["AudioSettings"] = self.audioSettingsShrink!
        }
        if self.inputAttachmentsShrink != nil {
            map["InputAttachments"] = self.inputAttachmentsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputGroupsShrink != nil {
            map["OutputGroups"] = self.outputGroupsShrink!
        }
        if self.videoSettingsShrink != nil {
            map["VideoSettings"] = self.videoSettingsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioSettings") {
            self.audioSettingsShrink = dict["AudioSettings"] as! String
        }
        if dict.keys.contains("InputAttachments") {
            self.inputAttachmentsShrink = dict["InputAttachments"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputGroups") {
            self.outputGroupsShrink = dict["OutputGroups"] as! String
        }
        if dict.keys.contains("VideoSettings") {
            self.videoSettingsShrink = dict["VideoSettings"] as! String
        }
    }
}

public class CreateMediaLiveChannelResponseBody : Tea.TeaModel {
    public var channelId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateMediaLiveChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMediaLiveChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMediaLiveChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMediaLiveInputRequest : Tea.TeaModel {
    public class InputSettings : Tea.TeaModel {
        public var flowId: String?

        public var flowOutputName: String?

        public var sourceUrl: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flowId != nil {
                map["FlowId"] = self.flowId!
            }
            if self.flowOutputName != nil {
                map["FlowOutputName"] = self.flowOutputName!
            }
            if self.sourceUrl != nil {
                map["SourceUrl"] = self.sourceUrl!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FlowId") {
                self.flowId = dict["FlowId"] as! String
            }
            if dict.keys.contains("FlowOutputName") {
                self.flowOutputName = dict["FlowOutputName"] as! String
            }
            if dict.keys.contains("SourceUrl") {
                self.sourceUrl = dict["SourceUrl"] as! String
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
        }
    }
    public var inputSettings: [CreateMediaLiveInputRequest.InputSettings]?

    public var name: String?

    public var securityGroupIds: [String]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputSettings != nil {
            var tmp : [Any] = []
            for k in self.inputSettings! {
                tmp.append(k.toMap())
            }
            map["InputSettings"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputSettings") {
            var tmp : [CreateMediaLiveInputRequest.InputSettings] = []
            for v in dict["InputSettings"] as! [Any] {
                var model = CreateMediaLiveInputRequest.InputSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inputSettings = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateMediaLiveInputShrinkRequest : Tea.TeaModel {
    public var inputSettingsShrink: String?

    public var name: String?

    public var securityGroupIdsShrink: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputSettingsShrink != nil {
            map["InputSettings"] = self.inputSettingsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.securityGroupIdsShrink != nil {
            map["SecurityGroupIds"] = self.securityGroupIdsShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputSettings") {
            self.inputSettingsShrink = dict["InputSettings"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIdsShrink = dict["SecurityGroupIds"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateMediaLiveInputResponseBody : Tea.TeaModel {
    public var inputId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputId != nil {
            map["InputId"] = self.inputId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputId") {
            self.inputId = dict["InputId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateMediaLiveInputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMediaLiveInputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMediaLiveInputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMediaLiveInputSecurityGroupRequest : Tea.TeaModel {
    public var name: String?

    public var whitelistRules: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.whitelistRules != nil {
            map["WhitelistRules"] = self.whitelistRules!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("WhitelistRules") {
            self.whitelistRules = dict["WhitelistRules"] as! [String]
        }
    }
}

public class CreateMediaLiveInputSecurityGroupShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var whitelistRulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.whitelistRulesShrink != nil {
            map["WhitelistRules"] = self.whitelistRulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("WhitelistRules") {
            self.whitelistRulesShrink = dict["WhitelistRules"] as! String
        }
    }
}

public class CreateMediaLiveInputSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class CreateMediaLiveInputSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMediaLiveInputSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMediaLiveInputSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePipelineRequest : Tea.TeaModel {
    public var name: String?

    public var priority: Int32?

    public var speed: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.speed != nil {
            map["Speed"] = self.speed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Speed") {
            self.speed = dict["Speed"] as! String
        }
    }
}

public class CreatePipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public var createTime: String?

        public var modifiedTime: String?

        public var name: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var speed: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipeline: CreatePipelineResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") {
            var model = CreatePipelineResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProgramRequest : Tea.TeaModel {
    public var adBreaks: String?

    public var channelName: String?

    public var clipRange: String?

    public var programName: String?

    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public var transition: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adBreaks != nil {
            map["AdBreaks"] = self.adBreaks!
        }
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.clipRange != nil {
            map["ClipRange"] = self.clipRange!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.transition != nil {
            map["Transition"] = self.transition!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdBreaks") {
            self.adBreaks = dict["AdBreaks"] as! String
        }
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ClipRange") {
            self.clipRange = dict["ClipRange"] as! String
        }
        if dict.keys.contains("ProgramName") {
            self.programName = dict["ProgramName"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("Transition") {
            self.transition = dict["Transition"] as! String
        }
    }
}

public class CreateProgramResponseBody : Tea.TeaModel {
    public var program: ChannelAssemblyProgram?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.program?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.program != nil {
            map["Program"] = self.program?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Program") {
            var model = ChannelAssemblyProgram()
            model.fromMap(dict["Program"] as! [String: Any])
            self.program = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateProgramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProgramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProgramResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSearchIndexRequest : Tea.TeaModel {
    public var indexConfig: String?

    public var indexStatus: String?

    public var indexType: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexConfig != nil {
            map["IndexConfig"] = self.indexConfig!
        }
        if self.indexStatus != nil {
            map["IndexStatus"] = self.indexStatus!
        }
        if self.indexType != nil {
            map["IndexType"] = self.indexType!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndexConfig") {
            self.indexConfig = dict["IndexConfig"] as! String
        }
        if dict.keys.contains("IndexStatus") {
            self.indexStatus = dict["IndexStatus"] as! String
        }
        if dict.keys.contains("IndexType") {
            self.indexType = dict["IndexType"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class CreateSearchIndexResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateSearchIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSearchIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSearchIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSearchLibRequest : Tea.TeaModel {
    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class CreateSearchLibResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var searchLibName: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateSearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSourceRequest : Tea.TeaModel {
    public var httpPackageConfigurations: String?

    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.httpPackageConfigurations != nil {
            map["HttpPackageConfigurations"] = self.httpPackageConfigurations!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HttpPackageConfigurations") {
            self.httpPackageConfigurations = dict["HttpPackageConfigurations"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class CreateSourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var source: ChannelAssemblySource?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.source?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.source != nil {
            map["Source"] = self.source?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Source") {
            var model = ChannelAssemblySource()
            model.fromMap(dict["Source"] as! [String: Any])
            self.source = model
        }
    }
}

public class CreateSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSourceLocationRequest : Tea.TeaModel {
    public var baseUrl: String?

    public var enableSegmentDelivery: Bool?

    public var segmentDeliveryUrl: String?

    public var sourceLocationName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseUrl != nil {
            map["BaseUrl"] = self.baseUrl!
        }
        if self.enableSegmentDelivery != nil {
            map["EnableSegmentDelivery"] = self.enableSegmentDelivery!
        }
        if self.segmentDeliveryUrl != nil {
            map["SegmentDeliveryUrl"] = self.segmentDeliveryUrl!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseUrl") {
            self.baseUrl = dict["BaseUrl"] as! String
        }
        if dict.keys.contains("EnableSegmentDelivery") {
            self.enableSegmentDelivery = dict["EnableSegmentDelivery"] as! Bool
        }
        if dict.keys.contains("SegmentDeliveryUrl") {
            self.segmentDeliveryUrl = dict["SegmentDeliveryUrl"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
    }
}

public class CreateSourceLocationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var sourceLocation: ChannelAssemblySourceLocation?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sourceLocation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceLocation != nil {
            map["SourceLocation"] = self.sourceLocation?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceLocation") {
            var model = ChannelAssemblySourceLocation()
            model.fromMap(dict["SourceLocation"] as! [String: Any])
            self.sourceLocation = model
        }
    }
}

public class CreateSourceLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSourceLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSourceLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadMediaRequest : Tea.TeaModel {
    public var appId: String?

    public var entityId: String?

    public var fileInfo: String?

    public var mediaMetaData: String?

    public var postProcessConfig: String?

    public var uploadTargetConfig: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.fileInfo != nil {
            map["FileInfo"] = self.fileInfo!
        }
        if self.mediaMetaData != nil {
            map["MediaMetaData"] = self.mediaMetaData!
        }
        if self.postProcessConfig != nil {
            map["PostProcessConfig"] = self.postProcessConfig!
        }
        if self.uploadTargetConfig != nil {
            map["UploadTargetConfig"] = self.uploadTargetConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("FileInfo") {
            self.fileInfo = dict["FileInfo"] as! String
        }
        if dict.keys.contains("MediaMetaData") {
            self.mediaMetaData = dict["MediaMetaData"] as! String
        }
        if dict.keys.contains("PostProcessConfig") {
            self.postProcessConfig = dict["PostProcessConfig"] as! String
        }
        if dict.keys.contains("UploadTargetConfig") {
            self.uploadTargetConfig = dict["UploadTargetConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class CreateUploadMediaResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var mediaId: String?

    public var mediaURL: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaURL != nil {
            map["MediaURL"] = self.mediaURL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaURL") {
            self.mediaURL = dict["MediaURL"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class CreateUploadMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUploadMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadStreamRequest : Tea.TeaModel {
    public var definition: String?

    public var fileExtension: String?

    public var HDRType: String?

    public var mediaId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.fileExtension != nil {
            map["FileExtension"] = self.fileExtension!
        }
        if self.HDRType != nil {
            map["HDRType"] = self.HDRType!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("FileExtension") {
            self.fileExtension = dict["FileExtension"] as! String
        }
        if dict.keys.contains("HDRType") {
            self.HDRType = dict["HDRType"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class CreateUploadStreamResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var mediaId: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class CreateUploadStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUploadStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVodPackagingAssetRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var assetName: String?

    public var contentId: String?

    public var description_: String?

    public var groupName: String?

    public var input: CreateVodPackagingAssetRequest.Input?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetName != nil {
            map["AssetName"] = self.assetName!
        }
        if self.contentId != nil {
            map["ContentId"] = self.contentId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetName") {
            self.assetName = dict["AssetName"] as! String
        }
        if dict.keys.contains("ContentId") {
            self.contentId = dict["ContentId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Input") {
            var model = CreateVodPackagingAssetRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
    }
}

public class CreateVodPackagingAssetShrinkRequest : Tea.TeaModel {
    public var assetName: String?

    public var contentId: String?

    public var description_: String?

    public var groupName: String?

    public var inputShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetName != nil {
            map["AssetName"] = self.assetName!
        }
        if self.contentId != nil {
            map["ContentId"] = self.contentId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetName") {
            self.assetName = dict["AssetName"] as! String
        }
        if dict.keys.contains("ContentId") {
            self.contentId = dict["ContentId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
    }
}

public class CreateVodPackagingAssetResponseBody : Tea.TeaModel {
    public var asset: VodPackagingAsset?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.asset?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asset != nil {
            map["Asset"] = self.asset?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asset") {
            var model = VodPackagingAsset()
            model.fromMap(dict["Asset"] as! [String: Any])
            self.asset = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateVodPackagingAssetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVodPackagingAssetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVodPackagingAssetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVodPackagingConfigurationRequest : Tea.TeaModel {
    public class PackageConfig : Tea.TeaModel {
        public class DrmProvider : Tea.TeaModel {
            public var encryptionMethod: String?

            public var IV: String?

            public var systemIds: [String]?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.encryptionMethod != nil {
                    map["EncryptionMethod"] = self.encryptionMethod!
                }
                if self.IV != nil {
                    map["IV"] = self.IV!
                }
                if self.systemIds != nil {
                    map["SystemIds"] = self.systemIds!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EncryptionMethod") {
                    self.encryptionMethod = dict["EncryptionMethod"] as! String
                }
                if dict.keys.contains("IV") {
                    self.IV = dict["IV"] as! String
                }
                if dict.keys.contains("SystemIds") {
                    self.systemIds = dict["SystemIds"] as! [String]
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public class StreamSelection : Tea.TeaModel {
            public var maxVideoBitsPerSecond: Int64?

            public var minVideoBitsPerSecond: Int64?

            public var streamOrder: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxVideoBitsPerSecond != nil {
                    map["MaxVideoBitsPerSecond"] = self.maxVideoBitsPerSecond!
                }
                if self.minVideoBitsPerSecond != nil {
                    map["MinVideoBitsPerSecond"] = self.minVideoBitsPerSecond!
                }
                if self.streamOrder != nil {
                    map["StreamOrder"] = self.streamOrder!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxVideoBitsPerSecond") {
                    self.maxVideoBitsPerSecond = dict["MaxVideoBitsPerSecond"] as! Int64
                }
                if dict.keys.contains("MinVideoBitsPerSecond") {
                    self.minVideoBitsPerSecond = dict["MinVideoBitsPerSecond"] as! Int64
                }
                if dict.keys.contains("StreamOrder") {
                    self.streamOrder = dict["StreamOrder"] as! String
                }
            }
        }
        public var drmProvider: CreateVodPackagingConfigurationRequest.PackageConfig.DrmProvider?

        public var manifestName: String?

        public var segmentDuration: Int64?

        public var streamSelection: CreateVodPackagingConfigurationRequest.PackageConfig.StreamSelection?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.drmProvider?.validate()
            try self.streamSelection?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.drmProvider != nil {
                map["DrmProvider"] = self.drmProvider?.toMap()
            }
            if self.manifestName != nil {
                map["ManifestName"] = self.manifestName!
            }
            if self.segmentDuration != nil {
                map["SegmentDuration"] = self.segmentDuration!
            }
            if self.streamSelection != nil {
                map["StreamSelection"] = self.streamSelection?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DrmProvider") {
                var model = CreateVodPackagingConfigurationRequest.PackageConfig.DrmProvider()
                model.fromMap(dict["DrmProvider"] as! [String: Any])
                self.drmProvider = model
            }
            if dict.keys.contains("ManifestName") {
                self.manifestName = dict["ManifestName"] as! String
            }
            if dict.keys.contains("SegmentDuration") {
                self.segmentDuration = dict["SegmentDuration"] as! Int64
            }
            if dict.keys.contains("StreamSelection") {
                var model = CreateVodPackagingConfigurationRequest.PackageConfig.StreamSelection()
                model.fromMap(dict["StreamSelection"] as! [String: Any])
                self.streamSelection = model
            }
        }
    }
    public var configurationName: String?

    public var description_: String?

    public var groupName: String?

    public var packageConfig: CreateVodPackagingConfigurationRequest.PackageConfig?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packageConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configurationName != nil {
            map["ConfigurationName"] = self.configurationName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.packageConfig != nil {
            map["PackageConfig"] = self.packageConfig?.toMap()
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigurationName") {
            self.configurationName = dict["ConfigurationName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("PackageConfig") {
            var model = CreateVodPackagingConfigurationRequest.PackageConfig()
            model.fromMap(dict["PackageConfig"] as! [String: Any])
            self.packageConfig = model
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
    }
}

public class CreateVodPackagingConfigurationShrinkRequest : Tea.TeaModel {
    public var configurationName: String?

    public var description_: String?

    public var groupName: String?

    public var packageConfigShrink: String?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configurationName != nil {
            map["ConfigurationName"] = self.configurationName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.packageConfigShrink != nil {
            map["PackageConfig"] = self.packageConfigShrink!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigurationName") {
            self.configurationName = dict["ConfigurationName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("PackageConfig") {
            self.packageConfigShrink = dict["PackageConfig"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
    }
}

public class CreateVodPackagingConfigurationResponseBody : Tea.TeaModel {
    public var packagingConfiguration: VodPackagingConfiguration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packagingConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packagingConfiguration != nil {
            map["PackagingConfiguration"] = self.packagingConfiguration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackagingConfiguration") {
            var model = VodPackagingConfiguration()
            model.fromMap(dict["PackagingConfiguration"] as! [String: Any])
            self.packagingConfiguration = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateVodPackagingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVodPackagingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVodPackagingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVodPackagingGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class CreateVodPackagingGroupResponseBody : Tea.TeaModel {
    public var packagingGroup: VodPackagingGroup?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packagingGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packagingGroup != nil {
            map["PackagingGroup"] = self.packagingGroup?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackagingGroup") {
            var model = VodPackagingGroup()
            model.fromMap(dict["PackagingGroup"] as! [String: Any])
            self.packagingGroup = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateVodPackagingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVodPackagingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVodPackagingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DecryptKMSDataKeyRequest : Tea.TeaModel {
    public var ciphertextBlob: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ciphertextBlob != nil {
            map["CiphertextBlob"] = self.ciphertextBlob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CiphertextBlob") {
            self.ciphertextBlob = dict["CiphertextBlob"] as! String
        }
    }
}

public class DecryptKMSDataKeyResponseBody : Tea.TeaModel {
    public class DataKey : Tea.TeaModel {
        public var keyId: String?

        public var plaintext: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.keyId != nil {
                map["KeyId"] = self.keyId!
            }
            if self.plaintext != nil {
                map["Plaintext"] = self.plaintext!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("KeyId") {
                self.keyId = dict["KeyId"] as! String
            }
            if dict.keys.contains("Plaintext") {
                self.plaintext = dict["Plaintext"] as! String
            }
        }
    }
    public var dataKey: DecryptKMSDataKeyResponseBody.DataKey?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataKey?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataKey != nil {
            map["DataKey"] = self.dataKey?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataKey") {
            var model = DecryptKMSDataKeyResponseBody.DataKey()
            model.fromMap(dict["DataKey"] as! [String: Any])
            self.dataKey = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DecryptKMSDataKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DecryptKMSDataKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DecryptKMSDataKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAIAgentDialogueRequest : Tea.TeaModel {
    public var dialogueId: String?

    public var nodeId: String?

    public var sessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dialogueId != nil {
            map["DialogueId"] = self.dialogueId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DialogueId") {
            self.dialogueId = dict["DialogueId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
    }
}

public class DeleteAIAgentDialogueResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAIAgentDialogueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAIAgentDialogueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAIAgentDialogueResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAdInsertionRequest : Tea.TeaModel {
    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class DeleteAdInsertionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAdInsertionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAdInsertionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAdInsertionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAvatarTrainingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteAvatarTrainingJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: DeleteAvatarTrainingJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DeleteAvatarTrainingJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAvatarTrainingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAvatarTrainingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAvatarTrainingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
    }
}

public class DeleteCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteChannelRequest : Tea.TeaModel {
    public var channelName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
    }
}

public class DeleteChannelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomizedVoiceJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDNADBRequest : Tea.TeaModel {
    public var DBId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBId") {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteDNADBResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDNADBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDNADBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDNADBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDNAFilesRequest : Tea.TeaModel {
    public var DBId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var primaryKeys: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.primaryKeys != nil {
            map["PrimaryKeys"] = self.primaryKeys!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBId") {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrimaryKeys") {
            self.primaryKeys = dict["PrimaryKeys"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteDNAFilesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDNAFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDNAFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDNAFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialIds: String?

    public var materialType: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialIds != nil {
            map["MaterialIds"] = self.materialIds!
        }
        if self.materialType != nil {
            map["MaterialType"] = self.materialType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialIds") {
            self.materialIds = dict["MaterialIds"] as! String
        }
        if dict.keys.contains("MaterialType") {
            self.materialType = dict["MaterialType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DeleteEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEditingProjectsRequest : Tea.TeaModel {
    public var projectIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectIds != nil {
            map["ProjectIds"] = self.projectIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectIds") {
            self.projectIds = dict["ProjectIds"] as! String
        }
    }
}

public class DeleteEditingProjectsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEditingProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEditingProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEditingProjectsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLivePackageChannelRequest : Tea.TeaModel {
    public var channelName: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class DeleteLivePackageChannelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLivePackageChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLivePackageChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLivePackageChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLivePackageChannelGroupRequest : Tea.TeaModel {
    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class DeleteLivePackageChannelGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLivePackageChannelGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLivePackageChannelGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLivePackageChannelGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLivePackageOriginEndpointRequest : Tea.TeaModel {
    public var channelName: String?

    public var endpointName: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("EndpointName") {
            self.endpointName = dict["EndpointName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class DeleteLivePackageOriginEndpointResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLivePackageOriginEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLivePackageOriginEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLivePackageOriginEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveRecordFilesRequest : Tea.TeaModel {
    public var recordIds: [String]?

    public var removeFile: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordIds != nil {
            map["RecordIds"] = self.recordIds!
        }
        if self.removeFile != nil {
            map["RemoveFile"] = self.removeFile!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordIds") {
            self.recordIds = dict["RecordIds"] as! [String]
        }
        if dict.keys.contains("RemoveFile") {
            self.removeFile = dict["RemoveFile"] as! Bool
        }
    }
}

public class DeleteLiveRecordFilesResponseBody : Tea.TeaModel {
    public class DeleteFileInfoList : Tea.TeaModel {
        public var code: String?

        public var message: String?

        public var recordId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! String
            }
        }
    }
    public var deleteFileInfoList: [DeleteLiveRecordFilesResponseBody.DeleteFileInfoList]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFileInfoList != nil {
            var tmp : [Any] = []
            for k in self.deleteFileInfoList! {
                tmp.append(k.toMap())
            }
            map["DeleteFileInfoList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteFileInfoList") {
            var tmp : [DeleteLiveRecordFilesResponseBody.DeleteFileInfoList] = []
            for v in dict["DeleteFileInfoList"] as! [Any] {
                var model = DeleteLiveRecordFilesResponseBody.DeleteFileInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deleteFileInfoList = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveRecordFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRecordFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveRecordFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveRecordTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveRecordTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveSnapshotFilesRequest : Tea.TeaModel {
    public var createTimestampList: [Int64]?

    public var deleteOriginalFile: Bool?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimestampList != nil {
            map["CreateTimestampList"] = self.createTimestampList!
        }
        if self.deleteOriginalFile != nil {
            map["DeleteOriginalFile"] = self.deleteOriginalFile!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimestampList") {
            self.createTimestampList = dict["CreateTimestampList"] as! [Int64]
        }
        if dict.keys.contains("DeleteOriginalFile") {
            self.deleteOriginalFile = dict["DeleteOriginalFile"] as! Bool
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteLiveSnapshotFilesShrinkRequest : Tea.TeaModel {
    public var createTimestampListShrink: String?

    public var deleteOriginalFile: Bool?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimestampListShrink != nil {
            map["CreateTimestampList"] = self.createTimestampListShrink!
        }
        if self.deleteOriginalFile != nil {
            map["DeleteOriginalFile"] = self.deleteOriginalFile!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimestampList") {
            self.createTimestampListShrink = dict["CreateTimestampList"] as! String
        }
        if dict.keys.contains("DeleteOriginalFile") {
            self.deleteOriginalFile = dict["DeleteOriginalFile"] as! Bool
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteLiveSnapshotFilesResponseBody : Tea.TeaModel {
    public class DeleteFileResultList : Tea.TeaModel {
        public var createTimestamp: Int64?

        public var result: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! String
            }
        }
    }
    public var deleteFileResultList: [DeleteLiveSnapshotFilesResponseBody.DeleteFileResultList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFileResultList != nil {
            var tmp : [Any] = []
            for k in self.deleteFileResultList! {
                tmp.append(k.toMap())
            }
            map["DeleteFileResultList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteFileResultList") {
            var tmp : [DeleteLiveSnapshotFilesResponseBody.DeleteFileResultList] = []
            for v in dict["DeleteFileResultList"] as! [Any] {
                var model = DeleteLiveSnapshotFilesResponseBody.DeleteFileResultList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deleteFileResultList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveSnapshotFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSnapshotFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveSnapshotFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveTranscodeJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteLiveTranscodeJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveTranscodeTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaConnectFlowRequest : Tea.TeaModel {
    public var flowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
    }
}

public class DeleteMediaConnectFlowResponseBody : Tea.TeaModel {
    public var content: String?

    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetCode") {
            self.retCode = dict["RetCode"] as! Int32
        }
    }
}

public class DeleteMediaConnectFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaConnectFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaConnectFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaConnectFlowInputRequest : Tea.TeaModel {
    public var flowId: String?

    public var inputName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.inputName != nil {
            map["InputName"] = self.inputName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
        if dict.keys.contains("InputName") {
            self.inputName = dict["InputName"] as! String
        }
    }
}

public class DeleteMediaConnectFlowInputResponseBody : Tea.TeaModel {
    public var content: String?

    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetCode") {
            self.retCode = dict["RetCode"] as! Int32
        }
    }
}

public class DeleteMediaConnectFlowInputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaConnectFlowInputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaConnectFlowInputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaConnectFlowOutputRequest : Tea.TeaModel {
    public var flowId: String?

    public var outputName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.outputName != nil {
            map["OutputName"] = self.outputName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
        if dict.keys.contains("OutputName") {
            self.outputName = dict["OutputName"] as! String
        }
    }
}

public class DeleteMediaConnectFlowOutputResponseBody : Tea.TeaModel {
    public var content: String?

    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetCode") {
            self.retCode = dict["RetCode"] as! Int32
        }
    }
}

public class DeleteMediaConnectFlowOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaConnectFlowOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaConnectFlowOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaFromSearchLibRequest : Tea.TeaModel {
    public var mediaId: String?

    public var msgBody: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.msgBody != nil {
            map["MsgBody"] = self.msgBody!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MsgBody") {
            self.msgBody = dict["MsgBody"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class DeleteMediaFromSearchLibResponseBody : Tea.TeaModel {
    public var code: String?

    public var mediaId: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteMediaFromSearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaFromSearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaFromSearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaInfosRequest : Tea.TeaModel {
    public var deletePhysicalFiles: Bool?

    public var inputURLs: String?

    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deletePhysicalFiles != nil {
            map["DeletePhysicalFiles"] = self.deletePhysicalFiles!
        }
        if self.inputURLs != nil {
            map["InputURLs"] = self.inputURLs!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeletePhysicalFiles") {
            self.deletePhysicalFiles = dict["DeletePhysicalFiles"] as! Bool
        }
        if dict.keys.contains("InputURLs") {
            self.inputURLs = dict["InputURLs"] as! String
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class DeleteMediaInfosResponseBody : Tea.TeaModel {
    public var forbiddenList: [String]?

    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenList != nil {
            map["ForbiddenList"] = self.forbiddenList!
        }
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenList") {
            self.forbiddenList = dict["ForbiddenList"] as! [String]
        }
        if dict.keys.contains("IgnoredList") {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaLiveChannelRequest : Tea.TeaModel {
    public var channelId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
    }
}

public class DeleteMediaLiveChannelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaLiveChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaLiveChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaLiveChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaLiveInputRequest : Tea.TeaModel {
    public var inputId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputId != nil {
            map["InputId"] = self.inputId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputId") {
            self.inputId = dict["InputId"] as! String
        }
    }
}

public class DeleteMediaLiveInputResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaLiveInputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaLiveInputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaLiveInputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaLiveInputSecurityGroupRequest : Tea.TeaModel {
    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class DeleteMediaLiveInputSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaLiveInputSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaLiveInputSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaLiveInputSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
    }
}

public class DeleteMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePipelineRequest : Tea.TeaModel {
    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
    }
}

public class DeletePipelineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeletePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePlayInfoRequest : Tea.TeaModel {
    public var deletePhysicalFiles: Bool?

    public var fileURLs: String?

    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deletePhysicalFiles != nil {
            map["DeletePhysicalFiles"] = self.deletePhysicalFiles!
        }
        if self.fileURLs != nil {
            map["FileURLs"] = self.fileURLs!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeletePhysicalFiles") {
            self.deletePhysicalFiles = dict["DeletePhysicalFiles"] as! Bool
        }
        if dict.keys.contains("FileURLs") {
            self.fileURLs = dict["FileURLs"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class DeletePlayInfoResponseBody : Tea.TeaModel {
    public var forbiddenList: [String]?

    public var ignoredList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenList != nil {
            map["ForbiddenList"] = self.forbiddenList!
        }
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenList") {
            self.forbiddenList = dict["ForbiddenList"] as! [String]
        }
        if dict.keys.contains("IgnoredList") {
            self.ignoredList = dict["IgnoredList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProgramRequest : Tea.TeaModel {
    public var channelName: String?

    public var programName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ProgramName") {
            self.programName = dict["ProgramName"] as! String
        }
    }
}

public class DeleteProgramResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteProgramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProgramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProgramResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSmartJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteSmartJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSmartJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSmartJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSmartJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSourceRequest : Tea.TeaModel {
    public var softDelete: Bool?

    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.softDelete != nil {
            map["SoftDelete"] = self.softDelete!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SoftDelete") {
            self.softDelete = dict["SoftDelete"] as! Bool
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class DeleteSourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSourceLocationRequest : Tea.TeaModel {
    public var softDelete: Bool?

    public var sourceLocationName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.softDelete != nil {
            map["SoftDelete"] = self.softDelete!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SoftDelete") {
            self.softDelete = dict["SoftDelete"] as! Bool
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
    }
}

public class DeleteSourceLocationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteSourceLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSourceLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSourceLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTemplateRequest : Tea.TeaModel {
    public var templateIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateIds") {
            self.templateIds = dict["TemplateIds"] as! String
        }
    }
}

public class DeleteTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVodPackagingAssetRequest : Tea.TeaModel {
    public var assetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetName != nil {
            map["AssetName"] = self.assetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetName") {
            self.assetName = dict["AssetName"] as! String
        }
    }
}

public class DeleteVodPackagingAssetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVodPackagingAssetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVodPackagingAssetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVodPackagingAssetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVodPackagingConfigurationRequest : Tea.TeaModel {
    public var configurationName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configurationName != nil {
            map["ConfigurationName"] = self.configurationName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigurationName") {
            self.configurationName = dict["ConfigurationName"] as! String
        }
    }
}

public class DeleteVodPackagingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVodPackagingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVodPackagingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVodPackagingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVodPackagingGroupRequest : Tea.TeaModel {
    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class DeleteVodPackagingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVodPackagingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVodPackagingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVodPackagingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAIAgentInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeAIAgentInstanceResponseBody : Tea.TeaModel {
    public class Instance : Tea.TeaModel {
        public var callLogUrl: String?

        public var runtimeConfig: AIAgentRuntimeConfig?

        public var sessionId: String?

        public var status: String?

        public var templateConfig: AIAgentTemplateConfig?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.runtimeConfig?.validate()
            try self.templateConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callLogUrl != nil {
                map["CallLogUrl"] = self.callLogUrl!
            }
            if self.runtimeConfig != nil {
                map["RuntimeConfig"] = self.runtimeConfig?.toMap()
            }
            if self.sessionId != nil {
                map["SessionId"] = self.sessionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig?.toMap()
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallLogUrl") {
                self.callLogUrl = dict["CallLogUrl"] as! String
            }
            if dict.keys.contains("RuntimeConfig") {
                var model = AIAgentRuntimeConfig()
                model.fromMap(dict["RuntimeConfig"] as! [String: Any])
                self.runtimeConfig = model
            }
            if dict.keys.contains("SessionId") {
                self.sessionId = dict["SessionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                var model = AIAgentTemplateConfig()
                model.fromMap(dict["TemplateConfig"] as! [String: Any])
                self.templateConfig = model
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var instance: DescribeAIAgentInstanceResponseBody.Instance?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instance != nil {
            map["Instance"] = self.instance?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instance") {
            var model = DescribeAIAgentInstanceResponseBody.Instance()
            model.fromMap(dict["Instance"] as! [String: Any])
            self.instance = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAIAgentInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAIAgentInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAIAgentInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsEditUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsEditUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var profile: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.profile != nil {
                map["Profile"] = self.profile!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Profile") {
                self.profile = dict["Profile"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsEditUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeMeterImsEditUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsEditUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsEditUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsEditUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsEditUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsMediaConvertUHDUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: String?

    public var regionId: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsMediaConvertUHDUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsMediaConvertUHDUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeMeterImsMediaConvertUHDUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsMediaConvertUHDUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsMediaConvertUHDUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsMediaConvertUHDUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsMediaConvertUHDUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsMediaConvertUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsMediaConvertUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var specification: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.specification != nil {
                map["Specification"] = self.specification!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Specification") {
                self.specification = dict["Specification"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsMediaConvertUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeMeterImsMediaConvertUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsMediaConvertUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsMediaConvertUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsMediaConvertUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsMediaConvertUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsMpsAiUsageRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var interval: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsMpsAiUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var time: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [DescribeMeterImsMpsAiUsageResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeMeterImsMpsAiUsageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsMpsAiUsageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsMpsAiUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsMpsAiUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsMpsAiUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterImsSummaryRequest : Tea.TeaModel {
    public var endTs: Int64?

    public var region: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class DescribeMeterImsSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var editingDuration: String?

        public var liveEditDuration: String?

        public var liveRecordDuration: String?

        public var liveSnapshotCount: String?

        public var liveTranscodeDuration: Int64?

        public var mpsAiDuration: Int64?

        public var mpsTranscodeDuration: Int64?

        public var mpsTranscodeUHDDuration: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.editingDuration != nil {
                map["EditingDuration"] = self.editingDuration!
            }
            if self.liveEditDuration != nil {
                map["LiveEditDuration"] = self.liveEditDuration!
            }
            if self.liveRecordDuration != nil {
                map["LiveRecordDuration"] = self.liveRecordDuration!
            }
            if self.liveSnapshotCount != nil {
                map["LiveSnapshotCount"] = self.liveSnapshotCount!
            }
            if self.liveTranscodeDuration != nil {
                map["LiveTranscodeDuration"] = self.liveTranscodeDuration!
            }
            if self.mpsAiDuration != nil {
                map["MpsAiDuration"] = self.mpsAiDuration!
            }
            if self.mpsTranscodeDuration != nil {
                map["MpsTranscodeDuration"] = self.mpsTranscodeDuration!
            }
            if self.mpsTranscodeUHDDuration != nil {
                map["MpsTranscodeUHDDuration"] = self.mpsTranscodeUHDDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EditingDuration") {
                self.editingDuration = dict["EditingDuration"] as! String
            }
            if dict.keys.contains("LiveEditDuration") {
                self.liveEditDuration = dict["LiveEditDuration"] as! String
            }
            if dict.keys.contains("LiveRecordDuration") {
                self.liveRecordDuration = dict["LiveRecordDuration"] as! String
            }
            if dict.keys.contains("LiveSnapshotCount") {
                self.liveSnapshotCount = dict["LiveSnapshotCount"] as! String
            }
            if dict.keys.contains("LiveTranscodeDuration") {
                self.liveTranscodeDuration = dict["LiveTranscodeDuration"] as! Int64
            }
            if dict.keys.contains("MpsAiDuration") {
                self.mpsAiDuration = dict["MpsAiDuration"] as! Int64
            }
            if dict.keys.contains("MpsTranscodeDuration") {
                self.mpsTranscodeDuration = dict["MpsTranscodeDuration"] as! Int64
            }
            if dict.keys.contains("MpsTranscodeUHDDuration") {
                self.mpsTranscodeUHDDuration = dict["MpsTranscodeUHDDuration"] as! Int64
            }
        }
    }
    public var data: [DescribeMeterImsSummaryResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeMeterImsSummaryResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeMeterImsSummaryResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeterImsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterImsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterImsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNotifyConfigRequest : Tea.TeaModel {
    public var AIAgentId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIAgentId != nil {
            map["AIAgentId"] = self.AIAgentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIAgentId") {
            self.AIAgentId = dict["AIAgentId"] as! String
        }
    }
}

public class DescribeNotifyConfigResponseBody : Tea.TeaModel {
    public var audioOssPath: String?

    public var callbackUrl: String?

    public var enableAudioRecording: Bool?

    public var enableNotify: Bool?

    public var eventTypes: String?

    public var requestId: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioOssPath != nil {
            map["AudioOssPath"] = self.audioOssPath!
        }
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.enableAudioRecording != nil {
            map["EnableAudioRecording"] = self.enableAudioRecording!
        }
        if self.enableNotify != nil {
            map["EnableNotify"] = self.enableNotify!
        }
        if self.eventTypes != nil {
            map["EventTypes"] = self.eventTypes!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioOssPath") {
            self.audioOssPath = dict["AudioOssPath"] as! String
        }
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("EnableAudioRecording") {
            self.enableAudioRecording = dict["EnableAudioRecording"] as! Bool
        }
        if dict.keys.contains("EnableNotify") {
            self.enableNotify = dict["EnableNotify"] as! Bool
        }
        if dict.keys.contains("EventTypes") {
            self.eventTypes = dict["EventTypes"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class DescribeNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayListRequest : Tea.TeaModel {
    public var beginTs: String?

    public var endTs: String?

    public var orderName: String?

    public var orderType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var playType: String?

    public var status: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playType != nil {
            map["PlayType"] = self.playType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTs") {
            self.beginTs = dict["BeginTs"] as! String
        }
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! String
        }
        if dict.keys.contains("OrderName") {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PlayType") {
            self.playType = dict["PlayType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribePlayListResponseBody : Tea.TeaModel {
    public class PlayList : Tea.TeaModel {
        public var firstFrameDuration: String?

        public var playDuration: String?

        public var playTs: String?

        public var playType: String?

        public var sessionId: String?

        public var status: String?

        public var stuckDuration: String?

        public var traceId: String?

        public var videoDuration: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.firstFrameDuration != nil {
                map["FirstFrameDuration"] = self.firstFrameDuration!
            }
            if self.playDuration != nil {
                map["PlayDuration"] = self.playDuration!
            }
            if self.playTs != nil {
                map["PlayTs"] = self.playTs!
            }
            if self.playType != nil {
                map["PlayType"] = self.playType!
            }
            if self.sessionId != nil {
                map["SessionId"] = self.sessionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stuckDuration != nil {
                map["StuckDuration"] = self.stuckDuration!
            }
            if self.traceId != nil {
                map["TraceId"] = self.traceId!
            }
            if self.videoDuration != nil {
                map["VideoDuration"] = self.videoDuration!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FirstFrameDuration") {
                self.firstFrameDuration = dict["FirstFrameDuration"] as! String
            }
            if dict.keys.contains("PlayDuration") {
                self.playDuration = dict["PlayDuration"] as! String
            }
            if dict.keys.contains("PlayTs") {
                self.playTs = dict["PlayTs"] as! String
            }
            if dict.keys.contains("PlayType") {
                self.playType = dict["PlayType"] as! String
            }
            if dict.keys.contains("SessionId") {
                self.sessionId = dict["SessionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StuckDuration") {
                self.stuckDuration = dict["StuckDuration"] as! String
            }
            if dict.keys.contains("TraceId") {
                self.traceId = dict["TraceId"] as! String
            }
            if dict.keys.contains("VideoDuration") {
                self.videoDuration = dict["VideoDuration"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var pageNum: Int64?

    public var pageSize: Int64?

    public var playList: [DescribePlayListResponseBody.PlayList]?

    public var requestId: String?

    public var totalNum: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playList != nil {
            var tmp : [Any] = []
            for k in self.playList! {
                tmp.append(k.toMap())
            }
            map["PlayList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PlayList") {
            var tmp : [DescribePlayListResponseBody.PlayList] = []
            for v in dict["PlayList"] as! [Any] {
                var model = DescribePlayListResponseBody.PlayList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.playList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int64
        }
    }
}

public class DescribePlayListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRtcRobotInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeRtcRobotInstanceResponseBody : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public var enableVoiceInterrupt: Bool?

        public var greeting: String?

        public var voiceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableVoiceInterrupt != nil {
                map["EnableVoiceInterrupt"] = self.enableVoiceInterrupt!
            }
            if self.greeting != nil {
                map["Greeting"] = self.greeting!
            }
            if self.voiceId != nil {
                map["VoiceId"] = self.voiceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableVoiceInterrupt") {
                self.enableVoiceInterrupt = dict["EnableVoiceInterrupt"] as! Bool
            }
            if dict.keys.contains("Greeting") {
                self.greeting = dict["Greeting"] as! String
            }
            if dict.keys.contains("VoiceId") {
                self.voiceId = dict["VoiceId"] as! String
            }
        }
    }
    public var authToken: String?

    public var channelId: String?

    public var config: DescribeRtcRobotInstanceResponseBody.Config?

    public var requestId: String?

    public var status: String?

    public var userData: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.config?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authToken != nil {
            map["AuthToken"] = self.authToken!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.config != nil {
            map["Config"] = self.config?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthToken") {
            self.authToken = dict["AuthToken"] as! String
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Config") {
            var model = DescribeRtcRobotInstanceResponseBody.Config()
            model.fromMap(dict["Config"] as! [String: Any])
            self.config = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class DescribeRtcRobotInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRtcRobotInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRtcRobotInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetectAudioForCustomizedVoiceJobRequest : Tea.TeaModel {
    public var audioRecordId: Int32?

    public var recordUrl: String?

    public var voiceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioRecordId != nil {
            map["AudioRecordId"] = self.audioRecordId!
        }
        if self.recordUrl != nil {
            map["RecordUrl"] = self.recordUrl!
        }
        if self.voiceId != nil {
            map["VoiceId"] = self.voiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioRecordId") {
            self.audioRecordId = dict["AudioRecordId"] as! Int32
        }
        if dict.keys.contains("RecordUrl") {
            self.recordUrl = dict["RecordUrl"] as! String
        }
        if dict.keys.contains("VoiceId") {
            self.voiceId = dict["VoiceId"] as! String
        }
    }
}

public class DetectAudioForCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var pass: Bool?

        public var reason: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pass != nil {
                map["Pass"] = self.pass!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pass") {
                self.pass = dict["Pass"] as! Bool
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
        }
    }
    public var data: DetectAudioForCustomizedVoiceJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DetectAudioForCustomizedVoiceJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DetectAudioForCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetectAudioForCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetectAudioForCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DropSearchIndexRequest : Tea.TeaModel {
    public var indexType: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexType != nil {
            map["IndexType"] = self.indexType!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndexType") {
            self.indexType = dict["IndexType"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class DropSearchIndexResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DropSearchIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DropSearchIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DropSearchIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DropSearchLibRequest : Tea.TeaModel {
    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class DropSearchLibResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DropSearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DropSearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DropSearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateAIAgentCallRequest : Tea.TeaModel {
    public class ChatSyncConfig : Tea.TeaModel {
        public var IMAIAgentId: String?

        public var receiverId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.IMAIAgentId != nil {
                map["IMAIAgentId"] = self.IMAIAgentId!
            }
            if self.receiverId != nil {
                map["ReceiverId"] = self.receiverId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IMAIAgentId") {
                self.IMAIAgentId = dict["IMAIAgentId"] as! String
            }
            if dict.keys.contains("ReceiverId") {
                self.receiverId = dict["ReceiverId"] as! String
            }
        }
    }
    public var AIAgentId: String?

    public var chatSyncConfig: GenerateAIAgentCallRequest.ChatSyncConfig?

    public var expire: Int64?

    public var sessionId: String?

    public var templateConfig: AIAgentTemplateConfig?

    public var userData: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.chatSyncConfig?.validate()
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIAgentId != nil {
            map["AIAgentId"] = self.AIAgentId!
        }
        if self.chatSyncConfig != nil {
            map["ChatSyncConfig"] = self.chatSyncConfig?.toMap()
        }
        if self.expire != nil {
            map["Expire"] = self.expire!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIAgentId") {
            self.AIAgentId = dict["AIAgentId"] as! String
        }
        if dict.keys.contains("ChatSyncConfig") {
            var model = GenerateAIAgentCallRequest.ChatSyncConfig()
            model.fromMap(dict["ChatSyncConfig"] as! [String: Any])
            self.chatSyncConfig = model
        }
        if dict.keys.contains("Expire") {
            self.expire = dict["Expire"] as! Int64
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            var model = AIAgentTemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GenerateAIAgentCallShrinkRequest : Tea.TeaModel {
    public var AIAgentId: String?

    public var chatSyncConfigShrink: String?

    public var expire: Int64?

    public var sessionId: String?

    public var templateConfigShrink: String?

    public var userData: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIAgentId != nil {
            map["AIAgentId"] = self.AIAgentId!
        }
        if self.chatSyncConfigShrink != nil {
            map["ChatSyncConfig"] = self.chatSyncConfigShrink!
        }
        if self.expire != nil {
            map["Expire"] = self.expire!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIAgentId") {
            self.AIAgentId = dict["AIAgentId"] as! String
        }
        if dict.keys.contains("ChatSyncConfig") {
            self.chatSyncConfigShrink = dict["ChatSyncConfig"] as! String
        }
        if dict.keys.contains("Expire") {
            self.expire = dict["Expire"] as! Int64
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GenerateAIAgentCallResponseBody : Tea.TeaModel {
    public var AIAgentUserId: String?

    public var channelId: String?

    public var instanceId: String?

    public var requestId: String?

    public var token: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIAgentUserId != nil {
            map["AIAgentUserId"] = self.AIAgentUserId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIAgentUserId") {
            self.AIAgentUserId = dict["AIAgentUserId"] as! String
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GenerateAIAgentCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateAIAgentCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GenerateAIAgentCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateKMSDataKeyResponseBody : Tea.TeaModel {
    public class DataKey : Tea.TeaModel {
        public var ciphertextBlob: String?

        public var keyId: String?

        public var plaintext: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ciphertextBlob != nil {
                map["CiphertextBlob"] = self.ciphertextBlob!
            }
            if self.keyId != nil {
                map["KeyId"] = self.keyId!
            }
            if self.plaintext != nil {
                map["Plaintext"] = self.plaintext!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CiphertextBlob") {
                self.ciphertextBlob = dict["CiphertextBlob"] as! String
            }
            if dict.keys.contains("KeyId") {
                self.keyId = dict["KeyId"] as! String
            }
            if dict.keys.contains("Plaintext") {
                self.plaintext = dict["Plaintext"] as! String
            }
        }
    }
    public var dataKey: GenerateKMSDataKeyResponseBody.DataKey?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataKey?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataKey != nil {
            map["DataKey"] = self.dataKey?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataKey") {
            var model = GenerateKMSDataKeyResponseBody.DataKey()
            model.fromMap(dict["DataKey"] as! [String: Any])
            self.dataKey = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GenerateKMSDataKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateKMSDataKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GenerateKMSDataKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateMessageChatTokenRequest : Tea.TeaModel {
    public var AIAgentId: String?

    public var expire: Int32?

    public var role: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIAgentId != nil {
            map["AIAgentId"] = self.AIAgentId!
        }
        if self.expire != nil {
            map["Expire"] = self.expire!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIAgentId") {
            self.AIAgentId = dict["AIAgentId"] as! String
        }
        if dict.keys.contains("Expire") {
            self.expire = dict["Expire"] as! Int32
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GenerateMessageChatTokenResponseBody : Tea.TeaModel {
    public var appId: String?

    public var appSign: String?

    public var nonce: String?

    public var requestId: String?

    public var role: String?

    public var timeStamp: Int64?

    public var token: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appSign != nil {
            map["AppSign"] = self.appSign!
        }
        if self.nonce != nil {
            map["Nonce"] = self.nonce!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppSign") {
            self.appSign = dict["AppSign"] as! String
        }
        if dict.keys.contains("Nonce") {
            self.nonce = dict["Nonce"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("TimeStamp") {
            self.timeStamp = dict["TimeStamp"] as! Int64
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GenerateMessageChatTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateMessageChatTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GenerateMessageChatTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAdInsertionRequest : Tea.TeaModel {
    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class GetAdInsertionResponseBody : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public class CdnConfig : Tea.TeaModel {
            public var adSegmentUrlPrefix: String?

            public var contentSegmentUrlPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adSegmentUrlPrefix != nil {
                    map["AdSegmentUrlPrefix"] = self.adSegmentUrlPrefix!
                }
                if self.contentSegmentUrlPrefix != nil {
                    map["ContentSegmentUrlPrefix"] = self.contentSegmentUrlPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdSegmentUrlPrefix") {
                    self.adSegmentUrlPrefix = dict["AdSegmentUrlPrefix"] as! String
                }
                if dict.keys.contains("ContentSegmentUrlPrefix") {
                    self.contentSegmentUrlPrefix = dict["ContentSegmentUrlPrefix"] as! String
                }
            }
        }
        public class ManifestEndpointConfig : Tea.TeaModel {
            public var hlsPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hlsPrefix != nil {
                    map["HlsPrefix"] = self.hlsPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HlsPrefix") {
                    self.hlsPrefix = dict["HlsPrefix"] as! String
                }
            }
        }
        public var adMarkerPassthrough: String?

        public var adsUrl: String?

        public var cdnConfig: GetAdInsertionResponseBody.Config.CdnConfig?

        public var configAliases: String?

        public var contentUrlPrefix: String?

        public var createTime: String?

        public var lastModified: String?

        public var manifestEndpointConfig: GetAdInsertionResponseBody.Config.ManifestEndpointConfig?

        public var name: String?

        public var personalizationThreshold: Int32?

        public var slateAdUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cdnConfig?.validate()
            try self.manifestEndpointConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adMarkerPassthrough != nil {
                map["AdMarkerPassthrough"] = self.adMarkerPassthrough!
            }
            if self.adsUrl != nil {
                map["AdsUrl"] = self.adsUrl!
            }
            if self.cdnConfig != nil {
                map["CdnConfig"] = self.cdnConfig?.toMap()
            }
            if self.configAliases != nil {
                map["ConfigAliases"] = self.configAliases!
            }
            if self.contentUrlPrefix != nil {
                map["ContentUrlPrefix"] = self.contentUrlPrefix!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.manifestEndpointConfig != nil {
                map["ManifestEndpointConfig"] = self.manifestEndpointConfig?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.personalizationThreshold != nil {
                map["PersonalizationThreshold"] = self.personalizationThreshold!
            }
            if self.slateAdUrl != nil {
                map["SlateAdUrl"] = self.slateAdUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AdMarkerPassthrough") {
                self.adMarkerPassthrough = dict["AdMarkerPassthrough"] as! String
            }
            if dict.keys.contains("AdsUrl") {
                self.adsUrl = dict["AdsUrl"] as! String
            }
            if dict.keys.contains("CdnConfig") {
                var model = GetAdInsertionResponseBody.Config.CdnConfig()
                model.fromMap(dict["CdnConfig"] as! [String: Any])
                self.cdnConfig = model
            }
            if dict.keys.contains("ConfigAliases") {
                self.configAliases = dict["ConfigAliases"] as! String
            }
            if dict.keys.contains("ContentUrlPrefix") {
                self.contentUrlPrefix = dict["ContentUrlPrefix"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("ManifestEndpointConfig") {
                var model = GetAdInsertionResponseBody.Config.ManifestEndpointConfig()
                model.fromMap(dict["ManifestEndpointConfig"] as! [String: Any])
                self.manifestEndpointConfig = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PersonalizationThreshold") {
                self.personalizationThreshold = dict["PersonalizationThreshold"] as! Int32
            }
            if dict.keys.contains("SlateAdUrl") {
                self.slateAdUrl = dict["SlateAdUrl"] as! String
            }
        }
    }
    public var config: GetAdInsertionResponseBody.Config?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.config?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            var model = GetAdInsertionResponseBody.Config()
            model.fromMap(dict["Config"] as! [String: Any])
            self.config = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAdInsertionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAdInsertionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAdInsertionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAvatarRequest : Tea.TeaModel {
    public var avatarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarId != nil {
            map["AvatarId"] = self.avatarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarId") {
            self.avatarId = dict["AvatarId"] as! String
        }
    }
}

public class GetAvatarResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Avatar : Tea.TeaModel {
            public var avatarDescription: String?

            public var avatarId: String?

            public var avatarName: String?

            public var avatarType: String?

            public var height: Int32?

            public var portrait: String?

            public var thumbnail: String?

            public var transparent: Bool?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarDescription != nil {
                    map["AvatarDescription"] = self.avatarDescription!
                }
                if self.avatarId != nil {
                    map["AvatarId"] = self.avatarId!
                }
                if self.avatarName != nil {
                    map["AvatarName"] = self.avatarName!
                }
                if self.avatarType != nil {
                    map["AvatarType"] = self.avatarType!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.portrait != nil {
                    map["Portrait"] = self.portrait!
                }
                if self.thumbnail != nil {
                    map["Thumbnail"] = self.thumbnail!
                }
                if self.transparent != nil {
                    map["Transparent"] = self.transparent!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvatarDescription") {
                    self.avatarDescription = dict["AvatarDescription"] as! String
                }
                if dict.keys.contains("AvatarId") {
                    self.avatarId = dict["AvatarId"] as! String
                }
                if dict.keys.contains("AvatarName") {
                    self.avatarName = dict["AvatarName"] as! String
                }
                if dict.keys.contains("AvatarType") {
                    self.avatarType = dict["AvatarType"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Portrait") {
                    self.portrait = dict["Portrait"] as! String
                }
                if dict.keys.contains("Thumbnail") {
                    self.thumbnail = dict["Thumbnail"] as! String
                }
                if dict.keys.contains("Transparent") {
                    self.transparent = dict["Transparent"] as! Bool
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var avatar: GetAvatarResponseBody.Data.Avatar?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.avatar?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatar != nil {
                map["Avatar"] = self.avatar?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Avatar") {
                var model = GetAvatarResponseBody.Data.Avatar()
                model.fromMap(dict["Avatar"] as! [String: Any])
                self.avatar = model
            }
        }
    }
    public var data: GetAvatarResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetAvatarResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAvatarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAvatarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAvatarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAvatarTrainingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetAvatarTrainingJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AvatarTrainingJob : Tea.TeaModel {
            public var avatarDescription: String?

            public var avatarId: String?

            public var avatarName: String?

            public var avatarType: String?

            public var firstTrainingTime: String?

            public var jobId: String?

            public var lastTrainingTime: String?

            public var message: String?

            public var portrait: String?

            public var status: String?

            public var thumbnail: String?

            public var transparent: Bool?

            public var video: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarDescription != nil {
                    map["AvatarDescription"] = self.avatarDescription!
                }
                if self.avatarId != nil {
                    map["AvatarId"] = self.avatarId!
                }
                if self.avatarName != nil {
                    map["AvatarName"] = self.avatarName!
                }
                if self.avatarType != nil {
                    map["AvatarType"] = self.avatarType!
                }
                if self.firstTrainingTime != nil {
                    map["FirstTrainingTime"] = self.firstTrainingTime!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.lastTrainingTime != nil {
                    map["LastTrainingTime"] = self.lastTrainingTime!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.portrait != nil {
                    map["Portrait"] = self.portrait!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.thumbnail != nil {
                    map["Thumbnail"] = self.thumbnail!
                }
                if self.transparent != nil {
                    map["Transparent"] = self.transparent!
                }
                if self.video != nil {
                    map["Video"] = self.video!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvatarDescription") {
                    self.avatarDescription = dict["AvatarDescription"] as! String
                }
                if dict.keys.contains("AvatarId") {
                    self.avatarId = dict["AvatarId"] as! String
                }
                if dict.keys.contains("AvatarName") {
                    self.avatarName = dict["AvatarName"] as! String
                }
                if dict.keys.contains("AvatarType") {
                    self.avatarType = dict["AvatarType"] as! String
                }
                if dict.keys.contains("FirstTrainingTime") {
                    self.firstTrainingTime = dict["FirstTrainingTime"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("LastTrainingTime") {
                    self.lastTrainingTime = dict["LastTrainingTime"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Portrait") {
                    self.portrait = dict["Portrait"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Thumbnail") {
                    self.thumbnail = dict["Thumbnail"] as! String
                }
                if dict.keys.contains("Transparent") {
                    self.transparent = dict["Transparent"] as! Bool
                }
                if dict.keys.contains("Video") {
                    self.video = dict["Video"] as! String
                }
            }
        }
        public var avatarTrainingJob: GetAvatarTrainingJobResponseBody.Data.AvatarTrainingJob?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.avatarTrainingJob?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarTrainingJob != nil {
                map["AvatarTrainingJob"] = self.avatarTrainingJob?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarTrainingJob") {
                var model = GetAvatarTrainingJobResponseBody.Data.AvatarTrainingJob()
                model.fromMap(dict["AvatarTrainingJob"] as! [String: Any])
                self.avatarTrainingJob = model
            }
        }
    }
    public var data: GetAvatarTrainingJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetAvatarTrainingJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAvatarTrainingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAvatarTrainingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAvatarTrainingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBatchMediaProducingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetBatchMediaProducingJobResponseBody : Tea.TeaModel {
    public class EditingBatchJob : Tea.TeaModel {
        public class SubJobList : Tea.TeaModel {
            public var duration: Double?

            public var errorCode: String?

            public var errorMessage: String?

            public var jobId: String?

            public var mediaId: String?

            public var mediaURL: String?

            public var projectId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaURL != nil {
                    map["MediaURL"] = self.mediaURL!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaURL") {
                    self.mediaURL = dict["MediaURL"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var completeTime: String?

        public var createTime: String?

        public var editingConfig: String?

        public var extend: String?

        public var inputConfig: String?

        public var jobId: String?

        public var jobType: String?

        public var modifiedTime: String?

        public var outputConfig: String?

        public var status: String?

        public var subJobList: [GetBatchMediaProducingJobResponseBody.EditingBatchJob.SubJobList]?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.editingConfig != nil {
                map["EditingConfig"] = self.editingConfig!
            }
            if self.extend != nil {
                map["Extend"] = self.extend!
            }
            if self.inputConfig != nil {
                map["InputConfig"] = self.inputConfig!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputConfig != nil {
                map["OutputConfig"] = self.outputConfig!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subJobList != nil {
                var tmp : [Any] = []
                for k in self.subJobList! {
                    tmp.append(k.toMap())
                }
                map["SubJobList"] = tmp
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EditingConfig") {
                self.editingConfig = dict["EditingConfig"] as! String
            }
            if dict.keys.contains("Extend") {
                self.extend = dict["Extend"] as! String
            }
            if dict.keys.contains("InputConfig") {
                self.inputConfig = dict["InputConfig"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputConfig") {
                self.outputConfig = dict["OutputConfig"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubJobList") {
                var tmp : [GetBatchMediaProducingJobResponseBody.EditingBatchJob.SubJobList] = []
                for v in dict["SubJobList"] as! [Any] {
                    var model = GetBatchMediaProducingJobResponseBody.EditingBatchJob.SubJobList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.subJobList = tmp
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var editingBatchJob: GetBatchMediaProducingJobResponseBody.EditingBatchJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.editingBatchJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.editingBatchJob != nil {
            map["EditingBatchJob"] = self.editingBatchJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EditingBatchJob") {
            var model = GetBatchMediaProducingJobResponseBody.EditingBatchJob()
            model.fromMap(dict["EditingBatchJob"] as! [String: Any])
            self.editingBatchJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetBatchMediaProducingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBatchMediaProducingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBatchMediaProducingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCategoriesRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetCategoriesResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: Int64?

        public var cateName: String?

        public var level: Int64?

        public var parentId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SubCategories : Tea.TeaModel {
        public class Category : Tea.TeaModel {
            public var cateId: Int64?

            public var cateName: String?

            public var level: Int64?

            public var parentId: Int64?

            public var subTotal: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.subTotal != nil {
                    map["SubTotal"] = self.subTotal!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! Int64
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! Int64
                }
                if dict.keys.contains("SubTotal") {
                    self.subTotal = dict["SubTotal"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var category: [GetCategoriesResponseBody.SubCategories.Category]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                var tmp : [Any] = []
                for k in self.category! {
                    tmp.append(k.toMap())
                }
                map["Category"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                var tmp : [GetCategoriesResponseBody.SubCategories.Category] = []
                for v in dict["Category"] as! [Any] {
                    var model = GetCategoriesResponseBody.SubCategories.Category()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.category = tmp
            }
        }
    }
    public var category: GetCategoriesResponseBody.Category?

    public var requestId: String?

    public var subCategories: GetCategoriesResponseBody.SubCategories?

    public var subTotal: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
        try self.subCategories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCategories != nil {
            map["SubCategories"] = self.subCategories?.toMap()
        }
        if self.subTotal != nil {
            map["SubTotal"] = self.subTotal!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            var model = GetCategoriesResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCategories") {
            var model = GetCategoriesResponseBody.SubCategories()
            model.fromMap(dict["SubCategories"] as! [String: Any])
            self.subCategories = model
        }
        if dict.keys.contains("SubTotal") {
            self.subTotal = dict["SubTotal"] as! Int64
        }
    }
}

public class GetCategoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCategoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCategoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetChannelRequest : Tea.TeaModel {
    public var channelName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
    }
}

public class GetChannelResponseBody : Tea.TeaModel {
    public var channel: ChannelAssemblyChannel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.channel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channel != nil {
            map["Channel"] = self.channel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Channel") {
            var model = ChannelAssemblyChannel()
            model.fromMap(dict["Channel"] as! [String: Any])
            self.channel = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetContentAnalyzeConfigResponseBody : Tea.TeaModel {
    public class ContentAnalyzeConfig : Tea.TeaModel {
        public var auto: Bool?

        public var saveType: String?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auto != nil {
                map["Auto"] = self.auto!
            }
            if self.saveType != nil {
                map["SaveType"] = self.saveType!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Auto") {
                self.auto = dict["Auto"] as! Bool
            }
            if dict.keys.contains("SaveType") {
                self.saveType = dict["SaveType"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var contentAnalyzeConfig: GetContentAnalyzeConfigResponseBody.ContentAnalyzeConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.contentAnalyzeConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentAnalyzeConfig != nil {
            map["ContentAnalyzeConfig"] = self.contentAnalyzeConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContentAnalyzeConfig") {
            var model = GetContentAnalyzeConfigResponseBody.ContentAnalyzeConfig()
            model.fromMap(dict["ContentAnalyzeConfig"] as! [String: Any])
            self.contentAnalyzeConfig = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetContentAnalyzeConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetContentAnalyzeConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetContentAnalyzeConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCustomTemplateRequest : Tea.TeaModel {
    public var subtype: Int32?

    public var templateId: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Subtype") {
            self.subtype = dict["Subtype"] as! Int32
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class GetCustomTemplateResponseBody : Tea.TeaModel {
    public class CustomTemplate : Tea.TeaModel {
        public class FrontendHint : Tea.TeaModel {
            public class TranscodeTemplateHint : Tea.TeaModel {
                public var bitrateControlType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrateControlType != nil {
                        map["BitrateControlType"] = self.bitrateControlType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BitrateControlType") {
                        self.bitrateControlType = dict["BitrateControlType"] as! String
                    }
                }
            }
            public var transcodeTemplateHint: GetCustomTemplateResponseBody.CustomTemplate.FrontendHint.TranscodeTemplateHint?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.transcodeTemplateHint?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.transcodeTemplateHint != nil {
                    map["TranscodeTemplateHint"] = self.transcodeTemplateHint?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TranscodeTemplateHint") {
                    var model = GetCustomTemplateResponseBody.CustomTemplate.FrontendHint.TranscodeTemplateHint()
                    model.fromMap(dict["TranscodeTemplateHint"] as! [String: Any])
                    self.transcodeTemplateHint = model
                }
            }
        }
        public var createTime: String?

        public var frontendHint: GetCustomTemplateResponseBody.CustomTemplate.FrontendHint?

        public var isDefault: Bool?

        public var modifiedTime: String?

        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.frontendHint?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.frontendHint != nil {
                map["FrontendHint"] = self.frontendHint?.toMap()
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FrontendHint") {
                var model = GetCustomTemplateResponseBody.CustomTemplate.FrontendHint()
                model.fromMap(dict["FrontendHint"] as! [String: Any])
                self.frontendHint = model
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var customTemplate: GetCustomTemplateResponseBody.CustomTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplate != nil {
            map["CustomTemplate"] = self.customTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplate") {
            var model = GetCustomTemplateResponseBody.CustomTemplate()
            model.fromMap(dict["CustomTemplate"] as! [String: Any])
            self.customTemplate = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCustomizedVoiceRequest : Tea.TeaModel {
    public var voiceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.voiceId != nil {
            map["VoiceId"] = self.voiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VoiceId") {
            self.voiceId = dict["VoiceId"] as! String
        }
    }
}

public class GetCustomizedVoiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CustomizedVoice : Tea.TeaModel {
            public var demoAudioMediaId: String?

            public var gender: String?

            public var scenario: String?

            public var voiceDesc: String?

            public var voiceId: String?

            public var voiceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoAudioMediaId != nil {
                    map["DemoAudioMediaId"] = self.demoAudioMediaId!
                }
                if self.gender != nil {
                    map["Gender"] = self.gender!
                }
                if self.scenario != nil {
                    map["Scenario"] = self.scenario!
                }
                if self.voiceDesc != nil {
                    map["VoiceDesc"] = self.voiceDesc!
                }
                if self.voiceId != nil {
                    map["VoiceId"] = self.voiceId!
                }
                if self.voiceName != nil {
                    map["VoiceName"] = self.voiceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoAudioMediaId") {
                    self.demoAudioMediaId = dict["DemoAudioMediaId"] as! String
                }
                if dict.keys.contains("Gender") {
                    self.gender = dict["Gender"] as! String
                }
                if dict.keys.contains("Scenario") {
                    self.scenario = dict["Scenario"] as! String
                }
                if dict.keys.contains("VoiceDesc") {
                    self.voiceDesc = dict["VoiceDesc"] as! String
                }
                if dict.keys.contains("VoiceId") {
                    self.voiceId = dict["VoiceId"] as! String
                }
                if dict.keys.contains("VoiceName") {
                    self.voiceName = dict["VoiceName"] as! String
                }
            }
        }
        public var customizedVoice: GetCustomizedVoiceResponseBody.Data.CustomizedVoice?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.customizedVoice?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customizedVoice != nil {
                map["CustomizedVoice"] = self.customizedVoice?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomizedVoice") {
                var model = GetCustomizedVoiceResponseBody.Data.CustomizedVoice()
                model.fromMap(dict["CustomizedVoice"] as! [String: Any])
                self.customizedVoice = model
            }
        }
    }
    public var data: GetCustomizedVoiceResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetCustomizedVoiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetCustomizedVoiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomizedVoiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCustomizedVoiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCustomizedVoiceJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CustomizedVoiceJob : Tea.TeaModel {
            public var createTime: String?

            public var gender: String?

            public var jobId: String?

            public var message: String?

            public var scenario: String?

            public var status: String?

            public var type: String?

            public var voiceDesc: String?

            public var voiceId: String?

            public var voiceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.gender != nil {
                    map["Gender"] = self.gender!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.scenario != nil {
                    map["Scenario"] = self.scenario!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.voiceDesc != nil {
                    map["VoiceDesc"] = self.voiceDesc!
                }
                if self.voiceId != nil {
                    map["VoiceId"] = self.voiceId!
                }
                if self.voiceName != nil {
                    map["VoiceName"] = self.voiceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Gender") {
                    self.gender = dict["Gender"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Scenario") {
                    self.scenario = dict["Scenario"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VoiceDesc") {
                    self.voiceDesc = dict["VoiceDesc"] as! String
                }
                if dict.keys.contains("VoiceId") {
                    self.voiceId = dict["VoiceId"] as! String
                }
                if dict.keys.contains("VoiceName") {
                    self.voiceName = dict["VoiceName"] as! String
                }
            }
        }
        public var customizedVoiceJob: GetCustomizedVoiceJobResponseBody.Data.CustomizedVoiceJob?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.customizedVoiceJob?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customizedVoiceJob != nil {
                map["CustomizedVoiceJob"] = self.customizedVoiceJob?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomizedVoiceJob") {
                var model = GetCustomizedVoiceJobResponseBody.Data.CustomizedVoiceJob()
                model.fromMap(dict["CustomizedVoiceJob"] as! [String: Any])
                self.customizedVoiceJob = model
            }
        }
    }
    public var data: GetCustomizedVoiceJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetCustomizedVoiceJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDefaultStorageLocationResponseBody : Tea.TeaModel {
    public var bucket: String?

    public var path: String?

    public var requestId: String?

    public var status: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class GetDefaultStorageLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDefaultStorageLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDefaultStorageLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDemonstrationForCustomizedVoiceJobRequest : Tea.TeaModel {
    public var scenario: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scenario != nil {
            map["Scenario"] = self.scenario!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Scenario") {
            self.scenario = dict["Scenario"] as! String
        }
    }
}

public class GetDemonstrationForCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DemonstrationList : Tea.TeaModel {
            public var audioId: Int32?

            public var demoAudio: String?

            public var text: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioId != nil {
                    map["AudioId"] = self.audioId!
                }
                if self.demoAudio != nil {
                    map["DemoAudio"] = self.demoAudio!
                }
                if self.text != nil {
                    map["Text"] = self.text!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioId") {
                    self.audioId = dict["AudioId"] as! Int32
                }
                if dict.keys.contains("DemoAudio") {
                    self.demoAudio = dict["DemoAudio"] as! String
                }
                if dict.keys.contains("Text") {
                    self.text = dict["Text"] as! String
                }
            }
        }
        public var demonstrationList: [GetDemonstrationForCustomizedVoiceJobResponseBody.Data.DemonstrationList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.demonstrationList != nil {
                var tmp : [Any] = []
                for k in self.demonstrationList! {
                    tmp.append(k.toMap())
                }
                map["DemonstrationList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DemonstrationList") {
                var tmp : [GetDemonstrationForCustomizedVoiceJobResponseBody.Data.DemonstrationList] = []
                for v in dict["DemonstrationList"] as! [Any] {
                    var model = GetDemonstrationForCustomizedVoiceJobResponseBody.Data.DemonstrationList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.demonstrationList = tmp
            }
        }
    }
    public var data: GetDemonstrationForCustomizedVoiceJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDemonstrationForCustomizedVoiceJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDemonstrationForCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDemonstrationForCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDemonstrationForCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDynamicImageJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetDynamicImageJobResponseBody : Tea.TeaModel {
    public class DynamicImageJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetDynamicImageJobResponseBody.DynamicImageJob.Input.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") {
                    var model = GetDynamicImageJobResponseBody.DynamicImageJob.Input.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetDynamicImageJobResponseBody.DynamicImageJob.Output.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") {
                    var model = GetDynamicImageJobResponseBody.DynamicImageJob.Output.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var code: String?

        public var createTime: String?

        public var finishTime: String?

        public var input: GetDynamicImageJobResponseBody.DynamicImageJob.Input?

        public var jobId: String?

        public var message: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: GetDynamicImageJobResponseBody.DynamicImageJob.Output?

        public var outputUrl: String?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateConfig: String?

        public var templateId: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.outputUrl != nil {
                map["OutputUrl"] = self.outputUrl!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = GetDynamicImageJobResponseBody.DynamicImageJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = GetDynamicImageJobResponseBody.DynamicImageJob.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("OutputUrl") {
                self.outputUrl = dict["OutputUrl"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var dynamicImageJob: GetDynamicImageJobResponseBody.DynamicImageJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dynamicImageJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicImageJob != nil {
            map["DynamicImageJob"] = self.dynamicImageJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicImageJob") {
            var model = GetDynamicImageJobResponseBody.DynamicImageJob()
            model.fromMap(dict["DynamicImageJob"] as! [String: Any])
            self.dynamicImageJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDynamicImageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDynamicImageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDynamicImageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingProjectRequest : Tea.TeaModel {
    public var projectId: String?

    public var requestSource: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestSource != nil {
            map["RequestSource"] = self.requestSource!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestSource") {
            self.requestSource = dict["RequestSource"] as! String
        }
    }
}

public class GetEditingProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var clipsParam: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var duration: Int64?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: String?

        public var templateId: String?

        public var templateType: String?

        public var timeline: String?

        public var timelineConvertErrorMessage: String?

        public var timelineConvertStatus: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.timelineConvertErrorMessage != nil {
                map["TimelineConvertErrorMessage"] = self.timelineConvertErrorMessage!
            }
            if self.timelineConvertStatus != nil {
                map["TimelineConvertStatus"] = self.timelineConvertStatus!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("TimelineConvertErrorMessage") {
                self.timelineConvertErrorMessage = dict["TimelineConvertErrorMessage"] as! String
            }
            if dict.keys.contains("TimelineConvertStatus") {
                self.timelineConvertStatus = dict["TimelineConvertStatus"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var project: GetEditingProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") {
            var model = GetEditingProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingProjectMaterialsRequest : Tea.TeaModel {
    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class GetEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public class LiveMaterials : Tea.TeaModel {
        public var appName: String?

        public var domainName: String?

        public var liveUrl: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.liveUrl != nil {
                map["LiveUrl"] = self.liveUrl!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("LiveUrl") {
                self.liveUrl = dict["LiveUrl"] as! String
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
        }
    }
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: GetEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                var tmp : [GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = GetEditingProjectMaterialsResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = GetEditingProjectMaterialsResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var liveMaterials: [GetEditingProjectMaterialsResponseBody.LiveMaterials]?

    public var mediaInfos: [GetEditingProjectMaterialsResponseBody.MediaInfos]?

    public var projectId: String?

    public var projectMaterials: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveMaterials != nil {
            var tmp : [Any] = []
            for k in self.liveMaterials! {
                tmp.append(k.toMap())
            }
            map["LiveMaterials"] = tmp
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectMaterials != nil {
            map["ProjectMaterials"] = self.projectMaterials!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveMaterials") {
            var tmp : [GetEditingProjectMaterialsResponseBody.LiveMaterials] = []
            for v in dict["LiveMaterials"] as! [Any] {
                var model = GetEditingProjectMaterialsResponseBody.LiveMaterials()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.liveMaterials = tmp
        }
        if dict.keys.contains("MediaInfos") {
            var tmp : [GetEditingProjectMaterialsResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = GetEditingProjectMaterialsResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectMaterials") {
            self.projectMaterials = dict["ProjectMaterials"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEventCallbackResponseBody : Tea.TeaModel {
    public var authKey: String?

    public var authSwitch: String?

    public var callbackQueueName: String?

    public var callbackType: String?

    public var callbackURL: String?

    public var eventTypeList: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.authSwitch != nil {
            map["AuthSwitch"] = self.authSwitch!
        }
        if self.callbackQueueName != nil {
            map["CallbackQueueName"] = self.callbackQueueName!
        }
        if self.callbackType != nil {
            map["CallbackType"] = self.callbackType!
        }
        if self.callbackURL != nil {
            map["CallbackURL"] = self.callbackURL!
        }
        if self.eventTypeList != nil {
            map["EventTypeList"] = self.eventTypeList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthKey") {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("AuthSwitch") {
            self.authSwitch = dict["AuthSwitch"] as! String
        }
        if dict.keys.contains("CallbackQueueName") {
            self.callbackQueueName = dict["CallbackQueueName"] as! String
        }
        if dict.keys.contains("CallbackType") {
            self.callbackType = dict["CallbackType"] as! String
        }
        if dict.keys.contains("CallbackURL") {
            self.callbackURL = dict["CallbackURL"] as! String
        }
        if dict.keys.contains("EventTypeList") {
            self.eventTypeList = dict["EventTypeList"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEventCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEventCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEventCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveEditingIndexFileRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var projectId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class GetLiveEditingIndexFileResponseBody : Tea.TeaModel {
    public var indexFile: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexFile != nil {
            map["IndexFile"] = self.indexFile!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndexFile") {
            self.indexFile = dict["IndexFile"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveEditingIndexFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveEditingIndexFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveEditingIndexFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveEditingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveEditingJobResponseBody : Tea.TeaModel {
    public class LiveEditingJob : Tea.TeaModel {
        public class LiveStreamConfig : Tea.TeaModel {
            public var appName: String?

            public var domainName: String?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
            }
        }
        public class MediaProduceConfig : Tea.TeaModel {
            public var mode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! String
                }
            }
        }
        public class OutputMediaConfig : Tea.TeaModel {
            public var bitrate: Int64?

            public var fileName: String?

            public var height: Int32?

            public var mediaURL: String?

            public var storageLocation: String?

            public var vodTemplateGroupId: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.mediaURL != nil {
                    map["MediaURL"] = self.mediaURL!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.vodTemplateGroupId != nil {
                    map["VodTemplateGroupId"] = self.vodTemplateGroupId!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! Int64
                }
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("MediaURL") {
                    self.mediaURL = dict["MediaURL"] as! String
                }
                if dict.keys.contains("StorageLocation") {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("VodTemplateGroupId") {
                    self.vodTemplateGroupId = dict["VodTemplateGroupId"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var clips: String?

        public var code: String?

        public var completeTime: String?

        public var creationTime: String?

        public var jobId: String?

        public var liveStreamConfig: GetLiveEditingJobResponseBody.LiveEditingJob.LiveStreamConfig?

        public var mediaId: String?

        public var mediaProduceConfig: GetLiveEditingJobResponseBody.LiveEditingJob.MediaProduceConfig?

        public var mediaURL: String?

        public var message: String?

        public var modifiedTime: String?

        public var outputMediaConfig: GetLiveEditingJobResponseBody.LiveEditingJob.OutputMediaConfig?

        public var projectId: String?

        public var status: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.liveStreamConfig?.validate()
            try self.mediaProduceConfig?.validate()
            try self.outputMediaConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clips != nil {
                map["Clips"] = self.clips!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.liveStreamConfig != nil {
                map["LiveStreamConfig"] = self.liveStreamConfig?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaProduceConfig != nil {
                map["MediaProduceConfig"] = self.mediaProduceConfig?.toMap()
            }
            if self.mediaURL != nil {
                map["MediaURL"] = self.mediaURL!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputMediaConfig != nil {
                map["OutputMediaConfig"] = self.outputMediaConfig?.toMap()
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Clips") {
                self.clips = dict["Clips"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("LiveStreamConfig") {
                var model = GetLiveEditingJobResponseBody.LiveEditingJob.LiveStreamConfig()
                model.fromMap(dict["LiveStreamConfig"] as! [String: Any])
                self.liveStreamConfig = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaProduceConfig") {
                var model = GetLiveEditingJobResponseBody.LiveEditingJob.MediaProduceConfig()
                model.fromMap(dict["MediaProduceConfig"] as! [String: Any])
                self.mediaProduceConfig = model
            }
            if dict.keys.contains("MediaURL") {
                self.mediaURL = dict["MediaURL"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputMediaConfig") {
                var model = GetLiveEditingJobResponseBody.LiveEditingJob.OutputMediaConfig()
                model.fromMap(dict["OutputMediaConfig"] as! [String: Any])
                self.outputMediaConfig = model
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var liveEditingJob: GetLiveEditingJobResponseBody.LiveEditingJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveEditingJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveEditingJob != nil {
            map["LiveEditingJob"] = self.liveEditingJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveEditingJob") {
            var model = GetLiveEditingJobResponseBody.LiveEditingJob()
            model.fromMap(dict["LiveEditingJob"] as! [String: Any])
            self.liveEditingJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveEditingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveEditingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveEditingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLivePackageChannelRequest : Tea.TeaModel {
    public var channelName: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class GetLivePackageChannelResponseBody : Tea.TeaModel {
    public class LivePackageChannel : Tea.TeaModel {
        public class IngestEndpoints : Tea.TeaModel {
            public var id: String?

            public var password: String?

            public var url: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public var channelName: String?

        public var createTime: String?

        public var description_: String?

        public var groupName: String?

        public var ingestEndpoints: [GetLivePackageChannelResponseBody.LivePackageChannel.IngestEndpoints]?

        public var lastModified: String?

        public var protocol_: String?

        public var segmentCount: Int32?

        public var segmentDuration: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.ingestEndpoints != nil {
                var tmp : [Any] = []
                for k in self.ingestEndpoints! {
                    tmp.append(k.toMap())
                }
                map["IngestEndpoints"] = tmp
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.segmentCount != nil {
                map["SegmentCount"] = self.segmentCount!
            }
            if self.segmentDuration != nil {
                map["SegmentDuration"] = self.segmentDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("IngestEndpoints") {
                var tmp : [GetLivePackageChannelResponseBody.LivePackageChannel.IngestEndpoints] = []
                for v in dict["IngestEndpoints"] as! [Any] {
                    var model = GetLivePackageChannelResponseBody.LivePackageChannel.IngestEndpoints()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ingestEndpoints = tmp
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("SegmentCount") {
                self.segmentCount = dict["SegmentCount"] as! Int32
            }
            if dict.keys.contains("SegmentDuration") {
                self.segmentDuration = dict["SegmentDuration"] as! Int32
            }
        }
    }
    public var livePackageChannel: GetLivePackageChannelResponseBody.LivePackageChannel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.livePackageChannel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageChannel != nil {
            map["LivePackageChannel"] = self.livePackageChannel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LivePackageChannel") {
            var model = GetLivePackageChannelResponseBody.LivePackageChannel()
            model.fromMap(dict["LivePackageChannel"] as! [String: Any])
            self.livePackageChannel = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLivePackageChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLivePackageChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLivePackageChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLivePackageChannelGroupRequest : Tea.TeaModel {
    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class GetLivePackageChannelGroupResponseBody : Tea.TeaModel {
    public class LivePackageChannelGroup : Tea.TeaModel {
        public var createTime: String?

        public var description_: String?

        public var groupName: String?

        public var lastModified: String?

        public var originDomain: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.originDomain != nil {
                map["OriginDomain"] = self.originDomain!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("OriginDomain") {
                self.originDomain = dict["OriginDomain"] as! String
            }
        }
    }
    public var livePackageChannelGroup: GetLivePackageChannelGroupResponseBody.LivePackageChannelGroup?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.livePackageChannelGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageChannelGroup != nil {
            map["LivePackageChannelGroup"] = self.livePackageChannelGroup?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LivePackageChannelGroup") {
            var model = GetLivePackageChannelGroupResponseBody.LivePackageChannelGroup()
            model.fromMap(dict["LivePackageChannelGroup"] as! [String: Any])
            self.livePackageChannelGroup = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLivePackageChannelGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLivePackageChannelGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLivePackageChannelGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLivePackageOriginEndpointRequest : Tea.TeaModel {
    public var channelName: String?

    public var endpointName: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("EndpointName") {
            self.endpointName = dict["EndpointName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class GetLivePackageOriginEndpointResponseBody : Tea.TeaModel {
    public class LivePackageOriginEndpoint : Tea.TeaModel {
        public var authorizationCode: String?

        public var channelName: String?

        public var createTime: String?

        public var description_: String?

        public var endpointName: String?

        public var endpointUrl: String?

        public var groupName: String?

        public var ipBlacklist: String?

        public var ipWhitelist: String?

        public var lastModified: String?

        public var manifestName: String?

        public var protocol_: String?

        public var timeshiftVision: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizationCode != nil {
                map["AuthorizationCode"] = self.authorizationCode!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.endpointName != nil {
                map["EndpointName"] = self.endpointName!
            }
            if self.endpointUrl != nil {
                map["EndpointUrl"] = self.endpointUrl!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.ipBlacklist != nil {
                map["IpBlacklist"] = self.ipBlacklist!
            }
            if self.ipWhitelist != nil {
                map["IpWhitelist"] = self.ipWhitelist!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.manifestName != nil {
                map["ManifestName"] = self.manifestName!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.timeshiftVision != nil {
                map["TimeshiftVision"] = self.timeshiftVision!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizationCode") {
                self.authorizationCode = dict["AuthorizationCode"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EndpointName") {
                self.endpointName = dict["EndpointName"] as! String
            }
            if dict.keys.contains("EndpointUrl") {
                self.endpointUrl = dict["EndpointUrl"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("IpBlacklist") {
                self.ipBlacklist = dict["IpBlacklist"] as! String
            }
            if dict.keys.contains("IpWhitelist") {
                self.ipWhitelist = dict["IpWhitelist"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("ManifestName") {
                self.manifestName = dict["ManifestName"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("TimeshiftVision") {
                self.timeshiftVision = dict["TimeshiftVision"] as! Int32
            }
        }
    }
    public var livePackageOriginEndpoint: GetLivePackageOriginEndpointResponseBody.LivePackageOriginEndpoint?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.livePackageOriginEndpoint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageOriginEndpoint != nil {
            map["LivePackageOriginEndpoint"] = self.livePackageOriginEndpoint?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LivePackageOriginEndpoint") {
            var model = GetLivePackageOriginEndpointResponseBody.LivePackageOriginEndpoint()
            model.fromMap(dict["LivePackageOriginEndpoint"] as! [String: Any])
            self.livePackageOriginEndpoint = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLivePackageOriginEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLivePackageOriginEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLivePackageOriginEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveRecordJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveRecordJobResponseBody : Tea.TeaModel {
    public class RecordJob : Tea.TeaModel {
        public class RecordOutput : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var notifyUrl: String?

        public var recordOutput: GetLiveRecordJobResponseBody.RecordJob.RecordOutput?

        public var status: String?

        public var streamInput: GetLiveRecordJobResponseBody.RecordJob.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordOutput?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            if self.recordOutput != nil {
                map["RecordOutput"] = self.recordOutput?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyUrl") {
                self.notifyUrl = dict["NotifyUrl"] as! String
            }
            if dict.keys.contains("RecordOutput") {
                var model = GetLiveRecordJobResponseBody.RecordJob.RecordOutput()
                model.fromMap(dict["RecordOutput"] as! [String: Any])
                self.recordOutput = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StreamInput") {
                var model = GetLiveRecordJobResponseBody.RecordJob.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var recordJob: GetLiveRecordJobResponseBody.RecordJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordJob != nil {
            map["RecordJob"] = self.recordJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordJob") {
            var model = GetLiveRecordJobResponseBody.RecordJob()
            model.fromMap(dict["RecordJob"] as! [String: Any])
            self.recordJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveRecordJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveRecordJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveRecordJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveRecordTemplateRequest : Tea.TeaModel {
    public var jobId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetLiveRecordTemplateResponseBody : Tea.TeaModel {
    public class RecordTemplate : Tea.TeaModel {
        public class RecordFormatList : Tea.TeaModel {
            public var cycleDuration: Int32?

            public var format: String?

            public var ossObjectPrefix: String?

            public var sliceDuration: Int32?

            public var sliceOssObjectPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleDuration != nil {
                    map["CycleDuration"] = self.cycleDuration!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.ossObjectPrefix != nil {
                    map["OssObjectPrefix"] = self.ossObjectPrefix!
                }
                if self.sliceDuration != nil {
                    map["SliceDuration"] = self.sliceDuration!
                }
                if self.sliceOssObjectPrefix != nil {
                    map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CycleDuration") {
                    self.cycleDuration = dict["CycleDuration"] as! Int32
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("OssObjectPrefix") {
                    self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
                }
                if dict.keys.contains("SliceDuration") {
                    self.sliceDuration = dict["SliceDuration"] as! Int32
                }
                if dict.keys.contains("SliceOssObjectPrefix") {
                    self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
                }
            }
        }
        public var createTime: String?

        public var lastModified: String?

        public var name: String?

        public var recordFormatList: [GetLiveRecordTemplateResponseBody.RecordTemplate.RecordFormatList]?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordFormatList != nil {
                var tmp : [Any] = []
                for k in self.recordFormatList! {
                    tmp.append(k.toMap())
                }
                map["RecordFormatList"] = tmp
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordFormatList") {
                var tmp : [GetLiveRecordTemplateResponseBody.RecordTemplate.RecordFormatList] = []
                for v in dict["RecordFormatList"] as! [Any] {
                    var model = GetLiveRecordTemplateResponseBody.RecordTemplate.RecordFormatList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recordFormatList = tmp
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var recordTemplate: GetLiveRecordTemplateResponseBody.RecordTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordTemplate != nil {
            map["RecordTemplate"] = self.recordTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordTemplate") {
            var model = GetLiveRecordTemplateResponseBody.RecordTemplate()
            model.fromMap(dict["RecordTemplate"] as! [String: Any])
            self.recordTemplate = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveSnapshotJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveSnapshotJobResponseBody : Tea.TeaModel {
    public class SnapshotOutput : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("StorageType") {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public class StreamInput : Tea.TeaModel {
        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var callbackUrl: String?

    public var createTime: String?

    public var jobId: String?

    public var jobName: String?

    public var lastModified: String?

    public var overwriteFormat: String?

    public var requestId: String?

    public var sequenceFormat: String?

    public var snapshotOutput: GetLiveSnapshotJobResponseBody.SnapshotOutput?

    public var status: String?

    public var streamInput: GetLiveSnapshotJobResponseBody.StreamInput?

    public var templateId: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotOutput?.validate()
        try self.streamInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.lastModified != nil {
            map["LastModified"] = self.lastModified!
        }
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.snapshotOutput != nil {
            map["SnapshotOutput"] = self.snapshotOutput?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("LastModified") {
            self.lastModified = dict["LastModified"] as! String
        }
        if dict.keys.contains("OverwriteFormat") {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SequenceFormat") {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("SnapshotOutput") {
            var model = GetLiveSnapshotJobResponseBody.SnapshotOutput()
            model.fromMap(dict["SnapshotOutput"] as! [String: Any])
            self.snapshotOutput = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StreamInput") {
            var model = GetLiveSnapshotJobResponseBody.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class GetLiveSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var createTime: String?

    public var lastModified: String?

    public var overwriteFormat: String?

    public var requestId: String?

    public var sequenceFormat: String?

    public var templateId: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.lastModified != nil {
            map["LastModified"] = self.lastModified!
        }
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("LastModified") {
            self.lastModified = dict["LastModified"] as! String
        }
        if dict.keys.contains("OverwriteFormat") {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SequenceFormat") {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveTranscodeJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetLiveTranscodeJobResponseBody : Tea.TeaModel {
    public class Job : Tea.TeaModel {
        public class OutputStream : Tea.TeaModel {
            public class StreamInfos : Tea.TeaModel {
                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var streamInfos: [GetLiveTranscodeJobResponseBody.Job.OutputStream.StreamInfos]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.streamInfos != nil {
                    var tmp : [Any] = []
                    for k in self.streamInfos! {
                        tmp.append(k.toMap())
                    }
                    map["StreamInfos"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("StreamInfos") {
                    var tmp : [GetLiveTranscodeJobResponseBody.Job.OutputStream.StreamInfos] = []
                    for v in dict["StreamInfos"] as! [Any] {
                        var model = GetLiveTranscodeJobResponseBody.Job.OutputStream.StreamInfos()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.streamInfos = tmp
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var inputUrl: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputUrl") {
                    self.inputUrl = dict["InputUrl"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var outputStream: GetLiveTranscodeJobResponseBody.Job.OutputStream?

        public var startMode: Int32?

        public var status: Int32?

        public var streamInput: GetLiveTranscodeJobResponseBody.Job.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.outputStream?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputStream != nil {
                map["OutputStream"] = self.outputStream?.toMap()
            }
            if self.startMode != nil {
                map["StartMode"] = self.startMode!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputStream") {
                var model = GetLiveTranscodeJobResponseBody.Job.OutputStream()
                model.fromMap(dict["OutputStream"] as! [String: Any])
                self.outputStream = model
            }
            if dict.keys.contains("StartMode") {
                self.startMode = dict["StartMode"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StreamInput") {
                var model = GetLiveTranscodeJobResponseBody.Job.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var job: GetLiveTranscodeJobResponseBody.Job?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.job?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.job != nil {
            map["Job"] = self.job?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Job") {
            var model = GetLiveTranscodeJobResponseBody.Job()
            model.fromMap(dict["Job"] as! [String: Any])
            self.job = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveTranscodeTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public class TemplateContent : Tea.TeaModel {
        public class TemplateConfig : Tea.TeaModel {
            public class AudioParams : Tea.TeaModel {
                public var bitrate: String?

                public var channels: String?

                public var codec: String?

                public var profile: String?

                public var samplerate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.samplerate != nil {
                        map["Samplerate"] = self.samplerate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Samplerate") {
                        self.samplerate = dict["Samplerate"] as! String
                    }
                }
            }
            public class VideoParams : Tea.TeaModel {
                public var bitrate: String?

                public var codec: String?

                public var fps: String?

                public var gop: String?

                public var height: String?

                public var profile: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Gop") {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioParams: GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.AudioParams?

            public var videoParams: GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.VideoParams?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioParams?.validate()
                try self.videoParams?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioParams != nil {
                    map["AudioParams"] = self.audioParams?.toMap()
                }
                if self.videoParams != nil {
                    map["VideoParams"] = self.videoParams?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioParams") {
                    var model = GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.AudioParams()
                    model.fromMap(dict["AudioParams"] as! [String: Any])
                    self.audioParams = model
                }
                if dict.keys.contains("VideoParams") {
                    var model = GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig.VideoParams()
                    model.fromMap(dict["VideoParams"] as! [String: Any])
                    self.videoParams = model
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var name: String?

        public var templateConfig: GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.templateConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                var model = GetLiveTranscodeTemplateResponseBody.TemplateContent.TemplateConfig()
                model.fromMap(dict["TemplateConfig"] as! [String: Any])
                self.templateConfig = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateContent: GetLiveTranscodeTemplateResponseBody.TemplateContent?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateContent != nil {
            map["TemplateContent"] = self.templateContent?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateContent") {
            var model = GetLiveTranscodeTemplateResponseBody.TemplateContent()
            model.fromMap(dict["TemplateContent"] as! [String: Any])
            self.templateContent = model
        }
    }
}

public class GetLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaConnectFlowRequest : Tea.TeaModel {
    public var flowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
    }
}

public class GetMediaConnectFlowResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var createTime: String?

        public var flowFailover: String?

        public var flowId: String?

        public var flowName: String?

        public var flowStatus: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.flowFailover != nil {
                map["FlowFailover"] = self.flowFailover!
            }
            if self.flowId != nil {
                map["FlowId"] = self.flowId!
            }
            if self.flowName != nil {
                map["FlowName"] = self.flowName!
            }
            if self.flowStatus != nil {
                map["FlowStatus"] = self.flowStatus!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FlowFailover") {
                self.flowFailover = dict["FlowFailover"] as! String
            }
            if dict.keys.contains("FlowId") {
                self.flowId = dict["FlowId"] as! String
            }
            if dict.keys.contains("FlowName") {
                self.flowName = dict["FlowName"] as! String
            }
            if dict.keys.contains("FlowStatus") {
                self.flowStatus = dict["FlowStatus"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public var content: GetMediaConnectFlowResponseBody.Content?

    public var description_: String?

    public var requestId: String?

    public var retcode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retcode != nil {
            map["Retcode"] = self.retcode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            var model = GetMediaConnectFlowResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Retcode") {
            self.retcode = dict["Retcode"] as! Int32
        }
    }
}

public class GetMediaConnectFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaConnectFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaConnectFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaConnectFlowInputRequest : Tea.TeaModel {
    public var flowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
    }
}

public class GetMediaConnectFlowInputResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var backupCidrs: String?

        public var backupCreateTime: String?

        public var backupInputName: String?

        public var backupInputStatus: String?

        public var backupInputUrl: String?

        public var backupMaxBitrate: Int32?

        public var backupSrtLatency: Int32?

        public var backupSrtPassphrase: String?

        public var backupSrtPbkeyLen: Int32?

        public var cidrs: String?

        public var createTime: String?

        public var inputName: String?

        public var inputProtocol: String?

        public var inputStatus: String?

        public var inputUrl: String?

        public var maxBitrate: Int32?

        public var pairFlowId: String?

        public var pairOutputName: String?

        public var srtLatency: Int32?

        public var srtPassphrase: String?

        public var srtPbkeyLen: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backupCidrs != nil {
                map["BackupCidrs"] = self.backupCidrs!
            }
            if self.backupCreateTime != nil {
                map["BackupCreateTime"] = self.backupCreateTime!
            }
            if self.backupInputName != nil {
                map["BackupInputName"] = self.backupInputName!
            }
            if self.backupInputStatus != nil {
                map["BackupInputStatus"] = self.backupInputStatus!
            }
            if self.backupInputUrl != nil {
                map["BackupInputUrl"] = self.backupInputUrl!
            }
            if self.backupMaxBitrate != nil {
                map["BackupMaxBitrate"] = self.backupMaxBitrate!
            }
            if self.backupSrtLatency != nil {
                map["BackupSrtLatency"] = self.backupSrtLatency!
            }
            if self.backupSrtPassphrase != nil {
                map["BackupSrtPassphrase"] = self.backupSrtPassphrase!
            }
            if self.backupSrtPbkeyLen != nil {
                map["BackupSrtPbkeyLen"] = self.backupSrtPbkeyLen!
            }
            if self.cidrs != nil {
                map["Cidrs"] = self.cidrs!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.inputName != nil {
                map["InputName"] = self.inputName!
            }
            if self.inputProtocol != nil {
                map["InputProtocol"] = self.inputProtocol!
            }
            if self.inputStatus != nil {
                map["InputStatus"] = self.inputStatus!
            }
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            if self.maxBitrate != nil {
                map["MaxBitrate"] = self.maxBitrate!
            }
            if self.pairFlowId != nil {
                map["PairFlowId"] = self.pairFlowId!
            }
            if self.pairOutputName != nil {
                map["PairOutputName"] = self.pairOutputName!
            }
            if self.srtLatency != nil {
                map["SrtLatency"] = self.srtLatency!
            }
            if self.srtPassphrase != nil {
                map["SrtPassphrase"] = self.srtPassphrase!
            }
            if self.srtPbkeyLen != nil {
                map["SrtPbkeyLen"] = self.srtPbkeyLen!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackupCidrs") {
                self.backupCidrs = dict["BackupCidrs"] as! String
            }
            if dict.keys.contains("BackupCreateTime") {
                self.backupCreateTime = dict["BackupCreateTime"] as! String
            }
            if dict.keys.contains("BackupInputName") {
                self.backupInputName = dict["BackupInputName"] as! String
            }
            if dict.keys.contains("BackupInputStatus") {
                self.backupInputStatus = dict["BackupInputStatus"] as! String
            }
            if dict.keys.contains("BackupInputUrl") {
                self.backupInputUrl = dict["BackupInputUrl"] as! String
            }
            if dict.keys.contains("BackupMaxBitrate") {
                self.backupMaxBitrate = dict["BackupMaxBitrate"] as! Int32
            }
            if dict.keys.contains("BackupSrtLatency") {
                self.backupSrtLatency = dict["BackupSrtLatency"] as! Int32
            }
            if dict.keys.contains("BackupSrtPassphrase") {
                self.backupSrtPassphrase = dict["BackupSrtPassphrase"] as! String
            }
            if dict.keys.contains("BackupSrtPbkeyLen") {
                self.backupSrtPbkeyLen = dict["BackupSrtPbkeyLen"] as! Int32
            }
            if dict.keys.contains("Cidrs") {
                self.cidrs = dict["Cidrs"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("InputName") {
                self.inputName = dict["InputName"] as! String
            }
            if dict.keys.contains("InputProtocol") {
                self.inputProtocol = dict["InputProtocol"] as! String
            }
            if dict.keys.contains("InputStatus") {
                self.inputStatus = dict["InputStatus"] as! String
            }
            if dict.keys.contains("InputUrl") {
                self.inputUrl = dict["InputUrl"] as! String
            }
            if dict.keys.contains("MaxBitrate") {
                self.maxBitrate = dict["MaxBitrate"] as! Int32
            }
            if dict.keys.contains("PairFlowId") {
                self.pairFlowId = dict["PairFlowId"] as! String
            }
            if dict.keys.contains("PairOutputName") {
                self.pairOutputName = dict["PairOutputName"] as! String
            }
            if dict.keys.contains("SrtLatency") {
                self.srtLatency = dict["SrtLatency"] as! Int32
            }
            if dict.keys.contains("SrtPassphrase") {
                self.srtPassphrase = dict["SrtPassphrase"] as! String
            }
            if dict.keys.contains("SrtPbkeyLen") {
                self.srtPbkeyLen = dict["SrtPbkeyLen"] as! Int32
            }
        }
    }
    public var content: GetMediaConnectFlowInputResponseBody.Content?

    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            var model = GetMediaConnectFlowInputResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetCode") {
            self.retCode = dict["RetCode"] as! Int32
        }
    }
}

public class GetMediaConnectFlowInputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaConnectFlowInputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaConnectFlowInputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaConnectFlowOutputRequest : Tea.TeaModel {
    public var flowId: String?

    public var outputName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.outputName != nil {
            map["OutputName"] = self.outputName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
        if dict.keys.contains("OutputName") {
            self.outputName = dict["OutputName"] as! String
        }
    }
}

public class GetMediaConnectFlowOutputResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var cidrs: String?

        public var createTime: String?

        public var forbid: String?

        public var outputName: String?

        public var outputProtocol: String?

        public var outputUrl: String?

        public var pairFlowId: String?

        public var pairInputName: String?

        public var playerLimit: Int32?

        public var srtLatency: Int32?

        public var srtPassphrase: String?

        public var srtPbkeyLen: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrs != nil {
                map["Cidrs"] = self.cidrs!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.forbid != nil {
                map["Forbid"] = self.forbid!
            }
            if self.outputName != nil {
                map["OutputName"] = self.outputName!
            }
            if self.outputProtocol != nil {
                map["OutputProtocol"] = self.outputProtocol!
            }
            if self.outputUrl != nil {
                map["OutputUrl"] = self.outputUrl!
            }
            if self.pairFlowId != nil {
                map["PairFlowId"] = self.pairFlowId!
            }
            if self.pairInputName != nil {
                map["PairInputName"] = self.pairInputName!
            }
            if self.playerLimit != nil {
                map["PlayerLimit"] = self.playerLimit!
            }
            if self.srtLatency != nil {
                map["SrtLatency"] = self.srtLatency!
            }
            if self.srtPassphrase != nil {
                map["SrtPassphrase"] = self.srtPassphrase!
            }
            if self.srtPbkeyLen != nil {
                map["SrtPbkeyLen"] = self.srtPbkeyLen!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cidrs") {
                self.cidrs = dict["Cidrs"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Forbid") {
                self.forbid = dict["Forbid"] as! String
            }
            if dict.keys.contains("OutputName") {
                self.outputName = dict["OutputName"] as! String
            }
            if dict.keys.contains("OutputProtocol") {
                self.outputProtocol = dict["OutputProtocol"] as! String
            }
            if dict.keys.contains("OutputUrl") {
                self.outputUrl = dict["OutputUrl"] as! String
            }
            if dict.keys.contains("PairFlowId") {
                self.pairFlowId = dict["PairFlowId"] as! String
            }
            if dict.keys.contains("PairInputName") {
                self.pairInputName = dict["PairInputName"] as! String
            }
            if dict.keys.contains("PlayerLimit") {
                self.playerLimit = dict["PlayerLimit"] as! Int32
            }
            if dict.keys.contains("SrtLatency") {
                self.srtLatency = dict["SrtLatency"] as! Int32
            }
            if dict.keys.contains("SrtPassphrase") {
                self.srtPassphrase = dict["SrtPassphrase"] as! String
            }
            if dict.keys.contains("SrtPbkeyLen") {
                self.srtPbkeyLen = dict["SrtPbkeyLen"] as! Int32
            }
        }
    }
    public var content: GetMediaConnectFlowOutputResponseBody.Content?

    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            var model = GetMediaConnectFlowOutputResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetCode") {
            self.retCode = dict["RetCode"] as! Int32
        }
    }
}

public class GetMediaConnectFlowOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaConnectFlowOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaConnectFlowOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaConvertJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetMediaConvertJobResponseBody : Tea.TeaModel {
    public class Job : Tea.TeaModel {
        public class Config : Tea.TeaModel {
            public var inputs: [MediaConvertInput]?

            public var outputGroups: [MediaConvertOutputGroup]?

            public var outputs: [MediaConvertOutput]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputs != nil {
                    var tmp : [Any] = []
                    for k in self.inputs! {
                        tmp.append(k.toMap())
                    }
                    map["Inputs"] = tmp
                }
                if self.outputGroups != nil {
                    var tmp : [Any] = []
                    for k in self.outputGroups! {
                        tmp.append(k.toMap())
                    }
                    map["OutputGroups"] = tmp
                }
                if self.outputs != nil {
                    var tmp : [Any] = []
                    for k in self.outputs! {
                        tmp.append(k.toMap())
                    }
                    map["Outputs"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Inputs") {
                    var tmp : [MediaConvertInput] = []
                    for v in dict["Inputs"] as! [Any] {
                        var model = MediaConvertInput()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputs = tmp
                }
                if dict.keys.contains("OutputGroups") {
                    var tmp : [MediaConvertOutputGroup] = []
                    for v in dict["OutputGroups"] as! [Any] {
                        var model = MediaConvertOutputGroup()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.outputGroups = tmp
                }
                if dict.keys.contains("Outputs") {
                    var tmp : [MediaConvertOutput] = []
                    for v in dict["Outputs"] as! [Any] {
                        var model = MediaConvertOutput()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.outputs = tmp
                }
            }
        }
        public var clientToken: String?

        public var code: String?

        public var config: GetMediaConvertJobResponseBody.Job.Config?

        public var jobId: String?

        public var message: String?

        public var outputDetails: [MediaConvertOutputDetail]?

        public var outputGroupDetails: [MediaConvertOutputGroupDetail]?

        public var pipelineId: String?

        public var requestId: String?

        public var state: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.config?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientToken != nil {
                map["ClientToken"] = self.clientToken!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.config != nil {
                map["Config"] = self.config?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.outputDetails != nil {
                var tmp : [Any] = []
                for k in self.outputDetails! {
                    tmp.append(k.toMap())
                }
                map["OutputDetails"] = tmp
            }
            if self.outputGroupDetails != nil {
                var tmp : [Any] = []
                for k in self.outputGroupDetails! {
                    tmp.append(k.toMap())
                }
                map["OutputGroupDetails"] = tmp
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientToken") {
                self.clientToken = dict["ClientToken"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Config") {
                var model = GetMediaConvertJobResponseBody.Job.Config()
                model.fromMap(dict["Config"] as! [String: Any])
                self.config = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("OutputDetails") {
                var tmp : [MediaConvertOutputDetail] = []
                for v in dict["OutputDetails"] as! [Any] {
                    var model = MediaConvertOutputDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputDetails = tmp
            }
            if dict.keys.contains("OutputGroupDetails") {
                var tmp : [MediaConvertOutputGroupDetail] = []
                for v in dict["OutputGroupDetails"] as! [Any] {
                    var model = MediaConvertOutputGroupDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroupDetails = tmp
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var job: GetMediaConvertJobResponseBody.Job?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.job?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.job != nil {
            map["Job"] = self.job?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Job") {
            var model = GetMediaConvertJobResponseBody.Job()
            model.fromMap(dict["Job"] as! [String: Any])
            self.job = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaConvertJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaConvertJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaConvertJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaInfoRequest : Tea.TeaModel {
    public var inputURL: String?

    public var mediaId: String?

    public var outputType: String?

    public var returnDetailedInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        if self.returnDetailedInfo != nil {
            map["ReturnDetailedInfo"] = self.returnDetailedInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OutputType") {
            self.outputType = dict["OutputType"] as! String
        }
        if dict.keys.contains("ReturnDetailedInfo") {
            self.returnDetailedInfo = dict["ReturnDetailedInfo"] as! String
        }
    }
}

public class GetMediaInfoResponseBody : Tea.TeaModel {
    public class MediaInfo : Tea.TeaModel {
        public class AiRoughData : Tea.TeaModel {
            public class StandardSmartTagJob : Tea.TeaModel {
                public class Results : Tea.TeaModel {
                    public var data: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.data != nil {
                            map["Data"] = self.data!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Data") {
                            self.data = dict["Data"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var aiJobId: String?

                public var resultUrl: String?

                public var results: [GetMediaInfoResponseBody.MediaInfo.AiRoughData.StandardSmartTagJob.Results]?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aiJobId != nil {
                        map["AiJobId"] = self.aiJobId!
                    }
                    if self.resultUrl != nil {
                        map["ResultUrl"] = self.resultUrl!
                    }
                    if self.results != nil {
                        var tmp : [Any] = []
                        for k in self.results! {
                            tmp.append(k.toMap())
                        }
                        map["Results"] = tmp
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AiJobId") {
                        self.aiJobId = dict["AiJobId"] as! String
                    }
                    if dict.keys.contains("ResultUrl") {
                        self.resultUrl = dict["ResultUrl"] as! String
                    }
                    if dict.keys.contains("Results") {
                        var tmp : [GetMediaInfoResponseBody.MediaInfo.AiRoughData.StandardSmartTagJob.Results] = []
                        for v in dict["Results"] as! [Any] {
                            var model = GetMediaInfoResponseBody.MediaInfo.AiRoughData.StandardSmartTagJob.Results()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.results = tmp
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public var aiCategory: String?

            public var aiJobId: String?

            public var result: String?

            public var saveType: String?

            public var standardSmartTagJob: GetMediaInfoResponseBody.MediaInfo.AiRoughData.StandardSmartTagJob?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.standardSmartTagJob?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiCategory != nil {
                    map["AiCategory"] = self.aiCategory!
                }
                if self.aiJobId != nil {
                    map["AiJobId"] = self.aiJobId!
                }
                if self.result != nil {
                    map["Result"] = self.result!
                }
                if self.saveType != nil {
                    map["SaveType"] = self.saveType!
                }
                if self.standardSmartTagJob != nil {
                    map["StandardSmartTagJob"] = self.standardSmartTagJob?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiCategory") {
                    self.aiCategory = dict["AiCategory"] as! String
                }
                if dict.keys.contains("AiJobId") {
                    self.aiJobId = dict["AiJobId"] as! String
                }
                if dict.keys.contains("Result") {
                    self.result = dict["Result"] as! String
                }
                if dict.keys.contains("SaveType") {
                    self.saveType = dict["SaveType"] as! String
                }
                if dict.keys.contains("StandardSmartTagJob") {
                    var model = GetMediaInfoResponseBody.MediaInfo.AiRoughData.StandardSmartTagJob()
                    model.fromMap(dict["StandardSmartTagJob"] as! [String: Any])
                    self.standardSmartTagJob = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class FileInfoList : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var fps: String?

                public var index: String?

                public var lang: String?

                public var numFrames: String?

                public var profile: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var createTime: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var modifiedTime: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class SubtitleStreamInfoList : Tea.TeaModel {
                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFPS: String?

                public var bitrate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var nbFrames: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timebase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFPS != nil {
                        map["AvgFPS"] = self.avgFPS!
                    }
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["HasBFrames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.nbFrames != nil {
                        map["Nb_frames"] = self.nbFrames!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvgFPS") {
                        self.avgFPS = dict["AvgFPS"] as! String
                    }
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("HasBFrames") {
                        self.hasBFrames = dict["HasBFrames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Nb_frames") {
                        self.nbFrames = dict["Nb_frames"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList]?

            public var fileBasicInfo: GetMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo?

            public var subtitleStreamInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList]?

            public var videoStreamInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.subtitleStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.subtitleStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["SubtitleStreamInfoList"] = tmp
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    var tmp : [GetMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("SubtitleStreamInfoList") {
                    var tmp : [GetMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList] = []
                    for v in dict["SubtitleStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subtitleStreamInfoList = tmp
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    var tmp : [GetMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var cateId: Int64?

            public var cateName: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var referenceId: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var uploadSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.uploadSource != nil {
                    map["UploadSource"] = self.uploadSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UploadSource") {
                    self.uploadSource = dict["UploadSource"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var aiRoughData: GetMediaInfoResponseBody.MediaInfo.AiRoughData?

        public var fileInfoList: [GetMediaInfoResponseBody.MediaInfo.FileInfoList]?

        public var mediaBasicInfo: GetMediaInfoResponseBody.MediaInfo.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.aiRoughData?.validate()
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiRoughData != nil {
                map["AiRoughData"] = self.aiRoughData?.toMap()
            }
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiRoughData") {
                var model = GetMediaInfoResponseBody.MediaInfo.AiRoughData()
                model.fromMap(dict["AiRoughData"] as! [String: Any])
                self.aiRoughData = model
            }
            if dict.keys.contains("FileInfoList") {
                var tmp : [GetMediaInfoResponseBody.MediaInfo.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = GetMediaInfoResponseBody.MediaInfo.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = GetMediaInfoResponseBody.MediaInfo.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var mediaInfo: GetMediaInfoResponseBody.MediaInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfo != nil {
            map["MediaInfo"] = self.mediaInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfo") {
            var model = GetMediaInfoResponseBody.MediaInfo()
            model.fromMap(dict["MediaInfo"] as! [String: Any])
            self.mediaInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaInfoJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    var tmp : [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    var tmp : [GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: GetMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var mediaInfoProperty: GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: GetMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = GetMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") {
                var model = GetMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = GetMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: GetMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") {
            var model = GetMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaLiveChannelRequest : Tea.TeaModel {
    public var channelId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
    }
}

public class GetMediaLiveChannelResponseBody : Tea.TeaModel {
    public class Channel : Tea.TeaModel {
        public class AudioSettings : Tea.TeaModel {
            public class AudioCodecSetting : Tea.TeaModel {
                public var bitrate: Int32?

                public var profile: String?

                public var sampleRate: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! Int32
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! Int32
                    }
                }
            }
            public var audioCodec: String?

            public var audioCodecSetting: GetMediaLiveChannelResponseBody.Channel.AudioSettings.AudioCodecSetting?

            public var audioSelectorName: String?

            public var languageCode: String?

            public var languageName: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioCodecSetting?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioCodec != nil {
                    map["AudioCodec"] = self.audioCodec!
                }
                if self.audioCodecSetting != nil {
                    map["AudioCodecSetting"] = self.audioCodecSetting?.toMap()
                }
                if self.audioSelectorName != nil {
                    map["AudioSelectorName"] = self.audioSelectorName!
                }
                if self.languageCode != nil {
                    map["LanguageCode"] = self.languageCode!
                }
                if self.languageName != nil {
                    map["LanguageName"] = self.languageName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioCodec") {
                    self.audioCodec = dict["AudioCodec"] as! String
                }
                if dict.keys.contains("AudioCodecSetting") {
                    var model = GetMediaLiveChannelResponseBody.Channel.AudioSettings.AudioCodecSetting()
                    model.fromMap(dict["AudioCodecSetting"] as! [String: Any])
                    self.audioCodecSetting = model
                }
                if dict.keys.contains("AudioSelectorName") {
                    self.audioSelectorName = dict["AudioSelectorName"] as! String
                }
                if dict.keys.contains("LanguageCode") {
                    self.languageCode = dict["LanguageCode"] as! String
                }
                if dict.keys.contains("LanguageName") {
                    self.languageName = dict["LanguageName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public class InputAttachments : Tea.TeaModel {
            public class AudioSelectors : Tea.TeaModel {
                public class AudioLanguageSelection : Tea.TeaModel {
                    public var languageCode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.languageCode != nil {
                            map["LanguageCode"] = self.languageCode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LanguageCode") {
                            self.languageCode = dict["LanguageCode"] as! String
                        }
                    }
                }
                public class AudioPidSelection : Tea.TeaModel {
                    public var pid: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.pid != nil {
                            map["Pid"] = self.pid!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Pid") {
                            self.pid = dict["Pid"] as! Int64
                        }
                    }
                }
                public class AudioTrackSelection : Tea.TeaModel {
                    public var trackId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.trackId != nil {
                            map["TrackId"] = self.trackId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TrackId") {
                            self.trackId = dict["TrackId"] as! Int64
                        }
                    }
                }
                public var audioLanguageSelection: GetMediaLiveChannelResponseBody.Channel.InputAttachments.AudioSelectors.AudioLanguageSelection?

                public var audioPidSelection: GetMediaLiveChannelResponseBody.Channel.InputAttachments.AudioSelectors.AudioPidSelection?

                public var audioTrackSelection: [GetMediaLiveChannelResponseBody.Channel.InputAttachments.AudioSelectors.AudioTrackSelection]?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.audioLanguageSelection?.validate()
                    try self.audioPidSelection?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioLanguageSelection != nil {
                        map["AudioLanguageSelection"] = self.audioLanguageSelection?.toMap()
                    }
                    if self.audioPidSelection != nil {
                        map["AudioPidSelection"] = self.audioPidSelection?.toMap()
                    }
                    if self.audioTrackSelection != nil {
                        var tmp : [Any] = []
                        for k in self.audioTrackSelection! {
                            tmp.append(k.toMap())
                        }
                        map["AudioTrackSelection"] = tmp
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioLanguageSelection") {
                        var model = GetMediaLiveChannelResponseBody.Channel.InputAttachments.AudioSelectors.AudioLanguageSelection()
                        model.fromMap(dict["AudioLanguageSelection"] as! [String: Any])
                        self.audioLanguageSelection = model
                    }
                    if dict.keys.contains("AudioPidSelection") {
                        var model = GetMediaLiveChannelResponseBody.Channel.InputAttachments.AudioSelectors.AudioPidSelection()
                        model.fromMap(dict["AudioPidSelection"] as! [String: Any])
                        self.audioPidSelection = model
                    }
                    if dict.keys.contains("AudioTrackSelection") {
                        var tmp : [GetMediaLiveChannelResponseBody.Channel.InputAttachments.AudioSelectors.AudioTrackSelection] = []
                        for v in dict["AudioTrackSelection"] as! [Any] {
                            var model = GetMediaLiveChannelResponseBody.Channel.InputAttachments.AudioSelectors.AudioTrackSelection()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.audioTrackSelection = tmp
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var audioSelectors: [GetMediaLiveChannelResponseBody.Channel.InputAttachments.AudioSelectors]?

            public var inputId: String?

            public var inputName: String?

            public var languageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioSelectors != nil {
                    var tmp : [Any] = []
                    for k in self.audioSelectors! {
                        tmp.append(k.toMap())
                    }
                    map["AudioSelectors"] = tmp
                }
                if self.inputId != nil {
                    map["InputId"] = self.inputId!
                }
                if self.inputName != nil {
                    map["InputName"] = self.inputName!
                }
                if self.languageName != nil {
                    map["LanguageName"] = self.languageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioSelectors") {
                    var tmp : [GetMediaLiveChannelResponseBody.Channel.InputAttachments.AudioSelectors] = []
                    for v in dict["AudioSelectors"] as! [Any] {
                        var model = GetMediaLiveChannelResponseBody.Channel.InputAttachments.AudioSelectors()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioSelectors = tmp
                }
                if dict.keys.contains("InputId") {
                    self.inputId = dict["InputId"] as! String
                }
                if dict.keys.contains("InputName") {
                    self.inputName = dict["InputName"] as! String
                }
                if dict.keys.contains("LanguageName") {
                    self.languageName = dict["LanguageName"] as! String
                }
            }
        }
        public class OutputGroups : Tea.TeaModel {
            public class MediaPackageGroupSetting : Tea.TeaModel {
                public var channelName: String?

                public var groupName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channelName != nil {
                        map["ChannelName"] = self.channelName!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ChannelName") {
                        self.channelName = dict["ChannelName"] as! String
                    }
                    if dict.keys.contains("GroupName") {
                        self.groupName = dict["GroupName"] as! String
                    }
                }
            }
            public class Outputs : Tea.TeaModel {
                public class MediaPackageOutputSetting : Tea.TeaModel {
                    public var audioGroupId: String?

                    public var nameModifier: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioGroupId != nil {
                            map["AudioGroupId"] = self.audioGroupId!
                        }
                        if self.nameModifier != nil {
                            map["NameModifier"] = self.nameModifier!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioGroupId") {
                            self.audioGroupId = dict["AudioGroupId"] as! String
                        }
                        if dict.keys.contains("NameModifier") {
                            self.nameModifier = dict["NameModifier"] as! String
                        }
                    }
                }
                public var audioSettingNames: [String]?

                public var mediaPackageOutputSetting: GetMediaLiveChannelResponseBody.Channel.OutputGroups.Outputs.MediaPackageOutputSetting?

                public var mediaType: Int32?

                public var name: String?

                public var videoSettingName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.mediaPackageOutputSetting?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioSettingNames != nil {
                        map["AudioSettingNames"] = self.audioSettingNames!
                    }
                    if self.mediaPackageOutputSetting != nil {
                        map["MediaPackageOutputSetting"] = self.mediaPackageOutputSetting?.toMap()
                    }
                    if self.mediaType != nil {
                        map["MediaType"] = self.mediaType!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.videoSettingName != nil {
                        map["VideoSettingName"] = self.videoSettingName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioSettingNames") {
                        self.audioSettingNames = dict["AudioSettingNames"] as! [String]
                    }
                    if dict.keys.contains("MediaPackageOutputSetting") {
                        var model = GetMediaLiveChannelResponseBody.Channel.OutputGroups.Outputs.MediaPackageOutputSetting()
                        model.fromMap(dict["MediaPackageOutputSetting"] as! [String: Any])
                        self.mediaPackageOutputSetting = model
                    }
                    if dict.keys.contains("MediaType") {
                        self.mediaType = dict["MediaType"] as! Int32
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("VideoSettingName") {
                        self.videoSettingName = dict["VideoSettingName"] as! String
                    }
                }
            }
            public var mediaPackageGroupSetting: GetMediaLiveChannelResponseBody.Channel.OutputGroups.MediaPackageGroupSetting?

            public var monitorUrl: String?

            public var name: String?

            public var outputs: [GetMediaLiveChannelResponseBody.Channel.OutputGroups.Outputs]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.mediaPackageGroupSetting?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mediaPackageGroupSetting != nil {
                    map["MediaPackageGroupSetting"] = self.mediaPackageGroupSetting?.toMap()
                }
                if self.monitorUrl != nil {
                    map["MonitorUrl"] = self.monitorUrl!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outputs != nil {
                    var tmp : [Any] = []
                    for k in self.outputs! {
                        tmp.append(k.toMap())
                    }
                    map["Outputs"] = tmp
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MediaPackageGroupSetting") {
                    var model = GetMediaLiveChannelResponseBody.Channel.OutputGroups.MediaPackageGroupSetting()
                    model.fromMap(dict["MediaPackageGroupSetting"] as! [String: Any])
                    self.mediaPackageGroupSetting = model
                }
                if dict.keys.contains("MonitorUrl") {
                    self.monitorUrl = dict["MonitorUrl"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Outputs") {
                    var tmp : [GetMediaLiveChannelResponseBody.Channel.OutputGroups.Outputs] = []
                    for v in dict["Outputs"] as! [Any] {
                        var model = GetMediaLiveChannelResponseBody.Channel.OutputGroups.Outputs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.outputs = tmp
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class VideoSettings : Tea.TeaModel {
            public class VideoCodecSetting : Tea.TeaModel {
                public class CodecDetail : Tea.TeaModel {
                    public var level: String?

                    public var profile: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Level") {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                    }
                }
                public class Framerate : Tea.TeaModel {
                    public var framerateControl: String?

                    public var framerateDenominator: Int32?

                    public var framerateNumerator: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.framerateControl != nil {
                            map["FramerateControl"] = self.framerateControl!
                        }
                        if self.framerateDenominator != nil {
                            map["FramerateDenominator"] = self.framerateDenominator!
                        }
                        if self.framerateNumerator != nil {
                            map["FramerateNumerator"] = self.framerateNumerator!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FramerateControl") {
                            self.framerateControl = dict["FramerateControl"] as! String
                        }
                        if dict.keys.contains("FramerateDenominator") {
                            self.framerateDenominator = dict["FramerateDenominator"] as! Int32
                        }
                        if dict.keys.contains("FramerateNumerator") {
                            self.framerateNumerator = dict["FramerateNumerator"] as! Int32
                        }
                    }
                }
                public class Gop : Tea.TeaModel {
                    public var bframesNum: Int32?

                    public var gopSize: Int32?

                    public var gopSizeUnits: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bframesNum != nil {
                            map["BframesNum"] = self.bframesNum!
                        }
                        if self.gopSize != nil {
                            map["GopSize"] = self.gopSize!
                        }
                        if self.gopSizeUnits != nil {
                            map["GopSizeUnits"] = self.gopSizeUnits!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BframesNum") {
                            self.bframesNum = dict["BframesNum"] as! Int32
                        }
                        if dict.keys.contains("GopSize") {
                            self.gopSize = dict["GopSize"] as! Int32
                        }
                        if dict.keys.contains("GopSizeUnits") {
                            self.gopSizeUnits = dict["GopSizeUnits"] as! String
                        }
                    }
                }
                public class Rate : Tea.TeaModel {
                    public var bitrate: Int32?

                    public var bufferSize: Int32?

                    public var maxBitrate: Int32?

                    public var rateControlMode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.bufferSize != nil {
                            map["BufferSize"] = self.bufferSize!
                        }
                        if self.maxBitrate != nil {
                            map["MaxBitrate"] = self.maxBitrate!
                        }
                        if self.rateControlMode != nil {
                            map["RateControlMode"] = self.rateControlMode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! Int32
                        }
                        if dict.keys.contains("BufferSize") {
                            self.bufferSize = dict["BufferSize"] as! Int32
                        }
                        if dict.keys.contains("MaxBitrate") {
                            self.maxBitrate = dict["MaxBitrate"] as! Int32
                        }
                        if dict.keys.contains("RateControlMode") {
                            self.rateControlMode = dict["RateControlMode"] as! String
                        }
                    }
                }
                public var codecDetail: GetMediaLiveChannelResponseBody.Channel.VideoSettings.VideoCodecSetting.CodecDetail?

                public var framerate: GetMediaLiveChannelResponseBody.Channel.VideoSettings.VideoCodecSetting.Framerate?

                public var gop: GetMediaLiveChannelResponseBody.Channel.VideoSettings.VideoCodecSetting.Gop?

                public var rate: GetMediaLiveChannelResponseBody.Channel.VideoSettings.VideoCodecSetting.Rate?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.codecDetail?.validate()
                    try self.framerate?.validate()
                    try self.gop?.validate()
                    try self.rate?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.codecDetail != nil {
                        map["CodecDetail"] = self.codecDetail?.toMap()
                    }
                    if self.framerate != nil {
                        map["Framerate"] = self.framerate?.toMap()
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop?.toMap()
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CodecDetail") {
                        var model = GetMediaLiveChannelResponseBody.Channel.VideoSettings.VideoCodecSetting.CodecDetail()
                        model.fromMap(dict["CodecDetail"] as! [String: Any])
                        self.codecDetail = model
                    }
                    if dict.keys.contains("Framerate") {
                        var model = GetMediaLiveChannelResponseBody.Channel.VideoSettings.VideoCodecSetting.Framerate()
                        model.fromMap(dict["Framerate"] as! [String: Any])
                        self.framerate = model
                    }
                    if dict.keys.contains("Gop") {
                        var model = GetMediaLiveChannelResponseBody.Channel.VideoSettings.VideoCodecSetting.Gop()
                        model.fromMap(dict["Gop"] as! [String: Any])
                        self.gop = model
                    }
                    if dict.keys.contains("Rate") {
                        var model = GetMediaLiveChannelResponseBody.Channel.VideoSettings.VideoCodecSetting.Rate()
                        model.fromMap(dict["Rate"] as! [String: Any])
                        self.rate = model
                    }
                }
            }
            public var height: Int32?

            public var name: String?

            public var videoCodec: String?

            public var videoCodecSetting: GetMediaLiveChannelResponseBody.Channel.VideoSettings.VideoCodecSetting?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.videoCodecSetting?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.videoCodec != nil {
                    map["VideoCodec"] = self.videoCodec!
                }
                if self.videoCodecSetting != nil {
                    map["VideoCodecSetting"] = self.videoCodecSetting?.toMap()
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("VideoCodec") {
                    self.videoCodec = dict["VideoCodec"] as! String
                }
                if dict.keys.contains("VideoCodecSetting") {
                    var model = GetMediaLiveChannelResponseBody.Channel.VideoSettings.VideoCodecSetting()
                    model.fromMap(dict["VideoCodecSetting"] as! [String: Any])
                    self.videoCodecSetting = model
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var audioSettings: [GetMediaLiveChannelResponseBody.Channel.AudioSettings]?

        public var channelId: String?

        public var createTime: String?

        public var inputAttachments: [GetMediaLiveChannelResponseBody.Channel.InputAttachments]?

        public var lastStartTime: String?

        public var lastStopTime: String?

        public var name: String?

        public var outputGroups: [GetMediaLiveChannelResponseBody.Channel.OutputGroups]?

        public var state: String?

        public var videoSettings: [GetMediaLiveChannelResponseBody.Channel.VideoSettings]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioSettings != nil {
                var tmp : [Any] = []
                for k in self.audioSettings! {
                    tmp.append(k.toMap())
                }
                map["AudioSettings"] = tmp
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.inputAttachments != nil {
                var tmp : [Any] = []
                for k in self.inputAttachments! {
                    tmp.append(k.toMap())
                }
                map["InputAttachments"] = tmp
            }
            if self.lastStartTime != nil {
                map["LastStartTime"] = self.lastStartTime!
            }
            if self.lastStopTime != nil {
                map["LastStopTime"] = self.lastStopTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroups != nil {
                var tmp : [Any] = []
                for k in self.outputGroups! {
                    tmp.append(k.toMap())
                }
                map["OutputGroups"] = tmp
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.videoSettings != nil {
                var tmp : [Any] = []
                for k in self.videoSettings! {
                    tmp.append(k.toMap())
                }
                map["VideoSettings"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioSettings") {
                var tmp : [GetMediaLiveChannelResponseBody.Channel.AudioSettings] = []
                for v in dict["AudioSettings"] as! [Any] {
                    var model = GetMediaLiveChannelResponseBody.Channel.AudioSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.audioSettings = tmp
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("InputAttachments") {
                var tmp : [GetMediaLiveChannelResponseBody.Channel.InputAttachments] = []
                for v in dict["InputAttachments"] as! [Any] {
                    var model = GetMediaLiveChannelResponseBody.Channel.InputAttachments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputAttachments = tmp
            }
            if dict.keys.contains("LastStartTime") {
                self.lastStartTime = dict["LastStartTime"] as! String
            }
            if dict.keys.contains("LastStopTime") {
                self.lastStopTime = dict["LastStopTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroups") {
                var tmp : [GetMediaLiveChannelResponseBody.Channel.OutputGroups] = []
                for v in dict["OutputGroups"] as! [Any] {
                    var model = GetMediaLiveChannelResponseBody.Channel.OutputGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroups = tmp
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("VideoSettings") {
                var tmp : [GetMediaLiveChannelResponseBody.Channel.VideoSettings] = []
                for v in dict["VideoSettings"] as! [Any] {
                    var model = GetMediaLiveChannelResponseBody.Channel.VideoSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.videoSettings = tmp
            }
        }
    }
    public var channel: GetMediaLiveChannelResponseBody.Channel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.channel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channel != nil {
            map["Channel"] = self.channel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Channel") {
            var model = GetMediaLiveChannelResponseBody.Channel()
            model.fromMap(dict["Channel"] as! [String: Any])
            self.channel = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaLiveChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaLiveChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaLiveChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaLiveInputRequest : Tea.TeaModel {
    public var inputId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputId != nil {
            map["InputId"] = self.inputId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputId") {
            self.inputId = dict["InputId"] as! String
        }
    }
}

public class GetMediaLiveInputResponseBody : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public class InputInfos : Tea.TeaModel {
            public var destHost: String?

            public var flowId: String?

            public var flowOutputName: String?

            public var monitorUrl: String?

            public var sourceUrl: String?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destHost != nil {
                    map["DestHost"] = self.destHost!
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.flowOutputName != nil {
                    map["FlowOutputName"] = self.flowOutputName!
                }
                if self.monitorUrl != nil {
                    map["MonitorUrl"] = self.monitorUrl!
                }
                if self.sourceUrl != nil {
                    map["SourceUrl"] = self.sourceUrl!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DestHost") {
                    self.destHost = dict["DestHost"] as! String
                }
                if dict.keys.contains("FlowId") {
                    self.flowId = dict["FlowId"] as! String
                }
                if dict.keys.contains("FlowOutputName") {
                    self.flowOutputName = dict["FlowOutputName"] as! String
                }
                if dict.keys.contains("MonitorUrl") {
                    self.monitorUrl = dict["MonitorUrl"] as! String
                }
                if dict.keys.contains("SourceUrl") {
                    self.sourceUrl = dict["SourceUrl"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
            }
        }
        public var channelIds: [String]?

        public var createTime: String?

        public var inputId: String?

        public var inputInfos: [GetMediaLiveInputResponseBody.Input.InputInfos]?

        public var name: String?

        public var securityGroupIds: [String]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelIds != nil {
                map["ChannelIds"] = self.channelIds!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.inputId != nil {
                map["InputId"] = self.inputId!
            }
            if self.inputInfos != nil {
                var tmp : [Any] = []
                for k in self.inputInfos! {
                    tmp.append(k.toMap())
                }
                map["InputInfos"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelIds") {
                self.channelIds = dict["ChannelIds"] as! [String]
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("InputId") {
                self.inputId = dict["InputId"] as! String
            }
            if dict.keys.contains("InputInfos") {
                var tmp : [GetMediaLiveInputResponseBody.Input.InputInfos] = []
                for v in dict["InputInfos"] as! [Any] {
                    var model = GetMediaLiveInputResponseBody.Input.InputInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputInfos = tmp
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var input: GetMediaLiveInputResponseBody.Input?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = GetMediaLiveInputResponseBody.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaLiveInputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaLiveInputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaLiveInputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaLiveInputSecurityGroupRequest : Tea.TeaModel {
    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class GetMediaLiveInputSecurityGroupResponseBody : Tea.TeaModel {
    public class SecurityGroup : Tea.TeaModel {
        public var createTime: String?

        public var inputIds: [String]?

        public var name: String?

        public var securityGroupId: String?

        public var whitelistRules: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.inputIds != nil {
                map["InputIds"] = self.inputIds!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.whitelistRules != nil {
                map["WhitelistRules"] = self.whitelistRules!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("InputIds") {
                self.inputIds = dict["InputIds"] as! [String]
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("WhitelistRules") {
                self.whitelistRules = dict["WhitelistRules"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var securityGroup: GetMediaLiveInputSecurityGroupResponseBody.SecurityGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroup != nil {
            map["SecurityGroup"] = self.securityGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroup") {
            var model = GetMediaLiveInputSecurityGroupResponseBody.SecurityGroup()
            model.fromMap(dict["SecurityGroup"] as! [String: Any])
            self.securityGroup = model
        }
    }
}

public class GetMediaLiveInputSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaLiveInputSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaLiveInputSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
    }
}

public class GetMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaProducingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetMediaProducingJobResponseBody : Tea.TeaModel {
    public class MediaProducingJob : Tea.TeaModel {
        public var clipsParam: String?

        public var code: String?

        public var completeTime: String?

        public var createTime: String?

        public var duration: Double?

        public var jobId: String?

        public var mediaId: String?

        public var mediaURL: String?

        public var message: String?

        public var modifiedTime: String?

        public var progress: Int32?

        public var projectId: String?

        public var status: String?

        public var subJobMaterials: String?

        public var templateId: String?

        public var timeline: String?

        public var userData: String?

        public var vodMediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaURL != nil {
                map["MediaURL"] = self.mediaURL!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subJobMaterials != nil {
                map["SubJobMaterials"] = self.subJobMaterials!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.vodMediaId != nil {
                map["VodMediaId"] = self.vodMediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaURL") {
                self.mediaURL = dict["MediaURL"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubJobMaterials") {
                self.subJobMaterials = dict["SubJobMaterials"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("VodMediaId") {
                self.vodMediaId = dict["VodMediaId"] as! String
            }
        }
    }
    public var mediaProducingJob: GetMediaProducingJobResponseBody.MediaProducingJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaProducingJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaProducingJob != nil {
            map["MediaProducingJob"] = self.mediaProducingJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaProducingJob") {
            var model = GetMediaProducingJobResponseBody.MediaProducingJob()
            model.fromMap(dict["MediaProducingJob"] as! [String: Any])
            self.mediaProducingJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaProducingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaProducingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaProducingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPackageJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetPackageJobResponseBody : Tea.TeaModel {
    public class PackageJob : Tea.TeaModel {
        public class Inputs : Tea.TeaModel {
            public class Input : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var input: GetPackageJobResponseBody.PackageJob.Inputs.Input?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.input?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Input") {
                    var model = GetPackageJobResponseBody.PackageJob.Inputs.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var code: String?

        public var createTime: String?

        public var finishTime: String?

        public var inputs: [GetPackageJobResponseBody.PackageJob.Inputs]?

        public var jobId: String?

        public var message: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: GetPackageJobResponseBody.PackageJob.Output?

        public var outputUrl: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var status: String?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputs != nil {
                var tmp : [Any] = []
                for k in self.inputs! {
                    tmp.append(k.toMap())
                }
                map["Inputs"] = tmp
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.outputUrl != nil {
                map["OutputUrl"] = self.outputUrl!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Inputs") {
                var tmp : [GetPackageJobResponseBody.PackageJob.Inputs] = []
                for v in dict["Inputs"] as! [Any] {
                    var model = GetPackageJobResponseBody.PackageJob.Inputs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputs = tmp
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = GetPackageJobResponseBody.PackageJob.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("OutputUrl") {
                self.outputUrl = dict["OutputUrl"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var packageJob: GetPackageJobResponseBody.PackageJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packageJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packageJob != nil {
            map["PackageJob"] = self.packageJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackageJob") {
            var model = GetPackageJobResponseBody.PackageJob()
            model.fromMap(dict["PackageJob"] as! [String: Any])
            self.packageJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPackageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPackageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPackageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPipelineRequest : Tea.TeaModel {
    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
    }
}

public class GetPipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public var createTime: String?

        public var modifiedTime: String?

        public var name: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var speed: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipeline: GetPipelineResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") {
            var model = GetPipelineResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPlayInfoRequest : Tea.TeaModel {
    public var inputURL: String?

    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class GetPlayInfoResponseBody : Tea.TeaModel {
    public class MediaBase : Tea.TeaModel {
        public var cateId: Int64?

        public var coverURL: String?

        public var creationTime: String?

        public var description_: String?

        public var mediaId: String?

        public var mediaTags: String?

        public var mediaType: String?

        public var status: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaTags != nil {
                map["MediaTags"] = self.mediaTags!
            }
            if self.mediaType != nil {
                map["MediaType"] = self.mediaType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaTags") {
                self.mediaTags = dict["MediaTags"] as! String
            }
            if dict.keys.contains("MediaType") {
                self.mediaType = dict["MediaType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class PlayInfoList : Tea.TeaModel {
        public var bitDepth: Int32?

        public var bitrate: String?

        public var creationTime: String?

        public var definition: String?

        public var duration: String?

        public var encrypt: Int64?

        public var encryptType: String?

        public var fileURL: String?

        public var format: String?

        public var fps: String?

        public var HDRType: String?

        public var height: Int64?

        public var jobId: String?

        public var modificationTime: String?

        public var narrowBandType: String?

        public var playURL: String?

        public var size: Int64?

        public var status: String?

        public var streamTags: String?

        public var streamType: String?

        public var transTemplateType: String?

        public var watermarkId: String?

        public var width: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitDepth != nil {
                map["BitDepth"] = self.bitDepth!
            }
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.definition != nil {
                map["Definition"] = self.definition!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.encrypt != nil {
                map["Encrypt"] = self.encrypt!
            }
            if self.encryptType != nil {
                map["EncryptType"] = self.encryptType!
            }
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.HDRType != nil {
                map["HDRType"] = self.HDRType!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.narrowBandType != nil {
                map["NarrowBandType"] = self.narrowBandType!
            }
            if self.playURL != nil {
                map["PlayURL"] = self.playURL!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamTags != nil {
                map["StreamTags"] = self.streamTags!
            }
            if self.streamType != nil {
                map["StreamType"] = self.streamType!
            }
            if self.transTemplateType != nil {
                map["TransTemplateType"] = self.transTemplateType!
            }
            if self.watermarkId != nil {
                map["WatermarkId"] = self.watermarkId!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BitDepth") {
                self.bitDepth = dict["BitDepth"] as! Int32
            }
            if dict.keys.contains("Bitrate") {
                self.bitrate = dict["Bitrate"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Definition") {
                self.definition = dict["Definition"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Encrypt") {
                self.encrypt = dict["Encrypt"] as! Int64
            }
            if dict.keys.contains("EncryptType") {
                self.encryptType = dict["EncryptType"] as! String
            }
            if dict.keys.contains("FileURL") {
                self.fileURL = dict["FileURL"] as! String
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Fps") {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("HDRType") {
                self.HDRType = dict["HDRType"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int64
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("NarrowBandType") {
                self.narrowBandType = dict["NarrowBandType"] as! String
            }
            if dict.keys.contains("PlayURL") {
                self.playURL = dict["PlayURL"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StreamTags") {
                self.streamTags = dict["StreamTags"] as! String
            }
            if dict.keys.contains("StreamType") {
                self.streamType = dict["StreamType"] as! String
            }
            if dict.keys.contains("TransTemplateType") {
                self.transTemplateType = dict["TransTemplateType"] as! String
            }
            if dict.keys.contains("WatermarkId") {
                self.watermarkId = dict["WatermarkId"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int64
            }
        }
    }
    public var mediaBase: GetPlayInfoResponseBody.MediaBase?

    public var playInfoList: [GetPlayInfoResponseBody.PlayInfoList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaBase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaBase != nil {
            map["MediaBase"] = self.mediaBase?.toMap()
        }
        if self.playInfoList != nil {
            var tmp : [Any] = []
            for k in self.playInfoList! {
                tmp.append(k.toMap())
            }
            map["PlayInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaBase") {
            var model = GetPlayInfoResponseBody.MediaBase()
            model.fromMap(dict["MediaBase"] as! [String: Any])
            self.mediaBase = model
        }
        if dict.keys.contains("PlayInfoList") {
            var tmp : [GetPlayInfoResponseBody.PlayInfoList] = []
            for v in dict["PlayInfoList"] as! [Any] {
                var model = GetPlayInfoResponseBody.PlayInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.playInfoList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProgramRequest : Tea.TeaModel {
    public var channelName: String?

    public var programName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ProgramName") {
            self.programName = dict["ProgramName"] as! String
        }
    }
}

public class GetProgramResponseBody : Tea.TeaModel {
    public var program: ChannelAssemblyProgram?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.program?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.program != nil {
            map["Program"] = self.program?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Program") {
            var model = ChannelAssemblyProgram()
            model.fromMap(dict["Program"] as! [String: Any])
            self.program = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetProgramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProgramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProgramResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProjectExportJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetProjectExportJobResponseBody : Tea.TeaModel {
    public class ProjectExportJob : Tea.TeaModel {
        public class ExportResult : Tea.TeaModel {
            public var timeline: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeline != nil {
                    map["Timeline"] = self.timeline!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Timeline") {
                    self.timeline = dict["Timeline"] as! String
                }
            }
        }
        public var code: String?

        public var exportResult: GetProjectExportJobResponseBody.ProjectExportJob.ExportResult?

        public var exportType: String?

        public var jobId: String?

        public var message: String?

        public var projectId: String?

        public var status: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.exportResult?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.exportResult != nil {
                map["ExportResult"] = self.exportResult?.toMap()
            }
            if self.exportType != nil {
                map["ExportType"] = self.exportType!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExportResult") {
                var model = GetProjectExportJobResponseBody.ProjectExportJob.ExportResult()
                model.fromMap(dict["ExportResult"] as! [String: Any])
                self.exportResult = model
            }
            if dict.keys.contains("ExportType") {
                self.exportType = dict["ExportType"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var projectExportJob: GetProjectExportJobResponseBody.ProjectExportJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.projectExportJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectExportJob != nil {
            map["ProjectExportJob"] = self.projectExportJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectExportJob") {
            var model = GetProjectExportJobResponseBody.ProjectExportJob()
            model.fromMap(dict["ProjectExportJob"] as! [String: Any])
            self.projectExportJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetProjectExportJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectExportJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProjectExportJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPublicMediaInfoRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class GetPublicMediaInfoResponseBody : Tea.TeaModel {
    public class MediaInfo : Tea.TeaModel {
        public class DynamicMetaData : Tea.TeaModel {
            public var data: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class FileInfoList : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var fps: String?

                public var index: String?

                public var lang: String?

                public var numFrames: String?

                public var profile: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class SubtitleStreamInfoList : Tea.TeaModel {
                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFPS: String?

                public var bitrate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var nbFrames: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timebase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFPS != nil {
                        map["AvgFPS"] = self.avgFPS!
                    }
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["HasBFrames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.nbFrames != nil {
                        map["Nb_frames"] = self.nbFrames!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvgFPS") {
                        self.avgFPS = dict["AvgFPS"] as! String
                    }
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("HasBFrames") {
                        self.hasBFrames = dict["HasBFrames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Nb_frames") {
                        self.nbFrames = dict["Nb_frames"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList]?

            public var fileBasicInfo: GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo?

            public var subtitleStreamInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList]?

            public var videoStreamInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.subtitleStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.subtitleStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["SubtitleStreamInfoList"] = tmp
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    var tmp : [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("SubtitleStreamInfoList") {
                    var tmp : [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList] = []
                    for v in dict["SubtitleStreamInfoList"] as! [Any] {
                        var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.SubtitleStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subtitleStreamInfoList = tmp
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    var tmp : [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var dynamicMetaData: GetPublicMediaInfoResponseBody.MediaInfo.DynamicMetaData?

        public var fileInfoList: [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList]?

        public var mediaBasicInfo: GetPublicMediaInfoResponseBody.MediaInfo.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dynamicMetaData?.validate()
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dynamicMetaData != nil {
                map["DynamicMetaData"] = self.dynamicMetaData?.toMap()
            }
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DynamicMetaData") {
                var model = GetPublicMediaInfoResponseBody.MediaInfo.DynamicMetaData()
                model.fromMap(dict["DynamicMetaData"] as! [String: Any])
                self.dynamicMetaData = model
            }
            if dict.keys.contains("FileInfoList") {
                var tmp : [GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = GetPublicMediaInfoResponseBody.MediaInfo.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = GetPublicMediaInfoResponseBody.MediaInfo.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var mediaInfo: GetPublicMediaInfoResponseBody.MediaInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfo != nil {
            map["MediaInfo"] = self.mediaInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfo") {
            var model = GetPublicMediaInfoResponseBody.MediaInfo()
            model.fromMap(dict["MediaInfo"] as! [String: Any])
            self.mediaInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPublicMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPublicMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPublicMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSmartHandleJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetSmartHandleJobResponseBody : Tea.TeaModel {
    public class JobResult : Tea.TeaModel {
        public var aiResult: String?

        public var mediaId: String?

        public var mediaUrl: String?

        public var usage: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiResult != nil {
                map["AiResult"] = self.aiResult!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaUrl != nil {
                map["MediaUrl"] = self.mediaUrl!
            }
            if self.usage != nil {
                map["Usage"] = self.usage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiResult") {
                self.aiResult = dict["AiResult"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaUrl") {
                self.mediaUrl = dict["MediaUrl"] as! String
            }
            if dict.keys.contains("Usage") {
                self.usage = dict["Usage"] as! String
            }
        }
    }
    public class SmartJobInfo : Tea.TeaModel {
        public class InputConfig : Tea.TeaModel {
            public var inputFile: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputFile != nil {
                    map["InputFile"] = self.inputFile!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputFile") {
                    self.inputFile = dict["InputFile"] as! String
                }
            }
        }
        public class OutputConfig : Tea.TeaModel {
            public var bucket: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public var createTime: String?

        public var description_: String?

        public var inputConfig: GetSmartHandleJobResponseBody.SmartJobInfo.InputConfig?

        public var jobType: String?

        public var modifiedTime: String?

        public var outputConfig: GetSmartHandleJobResponseBody.SmartJobInfo.OutputConfig?

        public var title: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inputConfig?.validate()
            try self.outputConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.inputConfig != nil {
                map["InputConfig"] = self.inputConfig?.toMap()
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputConfig != nil {
                map["OutputConfig"] = self.outputConfig?.toMap()
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InputConfig") {
                var model = GetSmartHandleJobResponseBody.SmartJobInfo.InputConfig()
                model.fromMap(dict["InputConfig"] as! [String: Any])
                self.inputConfig = model
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputConfig") {
                var model = GetSmartHandleJobResponseBody.SmartJobInfo.OutputConfig()
                model.fromMap(dict["OutputConfig"] as! [String: Any])
                self.outputConfig = model
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var jobId: String?

    public var jobResult: GetSmartHandleJobResponseBody.JobResult?

    public var output: String?

    public var requestId: String?

    public var smartJobInfo: GetSmartHandleJobResponseBody.SmartJobInfo?

    public var state: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobResult?.validate()
        try self.smartJobInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobResult != nil {
            map["JobResult"] = self.jobResult?.toMap()
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.smartJobInfo != nil {
            map["SmartJobInfo"] = self.smartJobInfo?.toMap()
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobResult") {
            var model = GetSmartHandleJobResponseBody.JobResult()
            model.fromMap(dict["JobResult"] as! [String: Any])
            self.jobResult = model
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SmartJobInfo") {
            var model = GetSmartHandleJobResponseBody.SmartJobInfo()
            model.fromMap(dict["SmartJobInfo"] as! [String: Any])
            self.smartJobInfo = model
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class GetSmartHandleJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSmartHandleJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSmartHandleJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSnapshotJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetSnapshotJobResponseBody : Tea.TeaModel {
    public class SnapshotJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetSnapshotJobResponseBody.SnapshotJob.Input.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") {
                    var model = GetSnapshotJobResponseBody.SnapshotJob.Input.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class OssFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var media: String?

            public var ossFile: GetSnapshotJobResponseBody.SnapshotJob.Output.OssFile?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ossFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.ossFile != nil {
                    map["OssFile"] = self.ossFile?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OssFile") {
                    var model = GetSnapshotJobResponseBody.SnapshotJob.Output.OssFile()
                    model.fromMap(dict["OssFile"] as! [String: Any])
                    self.ossFile = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var async: Bool?

        public var code: String?

        public var count: Int32?

        public var createTime: String?

        public var finishTime: String?

        public var input: GetSnapshotJobResponseBody.SnapshotJob.Input?

        public var jobId: String?

        public var message: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: GetSnapshotJobResponseBody.SnapshotJob.Output?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateConfig: String?

        public var templateId: String?

        public var triggerSource: String?

        public var type: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = GetSnapshotJobResponseBody.SnapshotJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = GetSnapshotJobResponseBody.SnapshotJob.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var snapshotJob: GetSnapshotJobResponseBody.SnapshotJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotJob != nil {
            map["SnapshotJob"] = self.snapshotJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotJob") {
            var model = GetSnapshotJobResponseBody.SnapshotJob()
            model.fromMap(dict["SnapshotJob"] as! [String: Any])
            self.snapshotJob = model
        }
    }
}

public class GetSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSnapshotUrlsRequest : Tea.TeaModel {
    public var jobId: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
    }
}

public class GetSnapshotUrlsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotUrls: [String]?

    public var total: Int32?

    public var webVTTUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotUrls != nil {
            map["SnapshotUrls"] = self.snapshotUrls!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.webVTTUrl != nil {
            map["WebVTTUrl"] = self.webVTTUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotUrls") {
            self.snapshotUrls = dict["SnapshotUrls"] as! [String]
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
        if dict.keys.contains("WebVTTUrl") {
            self.webVTTUrl = dict["WebVTTUrl"] as! String
        }
    }
}

public class GetSnapshotUrlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSnapshotUrlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSnapshotUrlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSourceRequest : Tea.TeaModel {
    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class GetSourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var source: ChannelAssemblySource?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.source?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.source != nil {
            map["Source"] = self.source?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Source") {
            var model = ChannelAssemblySource()
            model.fromMap(dict["Source"] as! [String: Any])
            self.source = model
        }
    }
}

public class GetSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSourceLocationRequest : Tea.TeaModel {
    public var sourceLocationName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
    }
}

public class GetSourceLocationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var sourceLocation: ChannelAssemblySourceLocation?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sourceLocation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceLocation != nil {
            map["SourceLocation"] = self.sourceLocation?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceLocation") {
            var model = ChannelAssemblySourceLocation()
            model.fromMap(dict["SourceLocation"] as! [String: Any])
            self.sourceLocation = model
        }
    }
}

public class GetSourceLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSourceLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSourceLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStorageListRequest : Tea.TeaModel {
    public var appId: String?

    public var status: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class GetStorageListResponseBody : Tea.TeaModel {
    public class StorageInfoList : Tea.TeaModel {
        public var appId: String?

        public var creationTime: String?

        public var defaultStorage: Bool?

        public var editingTempFileStorage: Bool?

        public var modifiedTime: String?

        public var path: String?

        public var status: String?

        public var storageLocation: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.defaultStorage != nil {
                map["DefaultStorage"] = self.defaultStorage!
            }
            if self.editingTempFileStorage != nil {
                map["EditingTempFileStorage"] = self.editingTempFileStorage!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DefaultStorage") {
                self.defaultStorage = dict["DefaultStorage"] as! Bool
            }
            if dict.keys.contains("EditingTempFileStorage") {
                self.editingTempFileStorage = dict["EditingTempFileStorage"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("StorageType") {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public var requestId: String?

    public var storageInfoList: [GetStorageListResponseBody.StorageInfoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageInfoList != nil {
            var tmp : [Any] = []
            for k in self.storageInfoList! {
                tmp.append(k.toMap())
            }
            map["StorageInfoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageInfoList") {
            var tmp : [GetStorageListResponseBody.StorageInfoList] = []
            for v in dict["StorageInfoList"] as! [Any] {
                var model = GetStorageListResponseBody.StorageInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.storageInfoList = tmp
        }
    }
}

public class GetStorageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStorageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetStorageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSystemTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetSystemTemplateResponseBody : Tea.TeaModel {
    public class SystemTemplate : Tea.TeaModel {
        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var requestId: String?

    public var systemTemplate: GetSystemTemplateResponseBody.SystemTemplate?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemTemplate != nil {
            map["SystemTemplate"] = self.systemTemplate?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemTemplate") {
            var model = GetSystemTemplateResponseBody.SystemTemplate()
            model.fromMap(dict["SystemTemplate"] as! [String: Any])
            self.systemTemplate = model
        }
    }
}

public class GetSystemTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSystemTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSystemTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateRequest : Tea.TeaModel {
    public var relatedMediaidFlag: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.relatedMediaidFlag != nil {
            map["RelatedMediaidFlag"] = self.relatedMediaidFlag!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RelatedMediaidFlag") {
            self.relatedMediaidFlag = dict["RelatedMediaidFlag"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var clipsParam: String?

        public var config: String?

        public var coverURL: String?

        public var createSource: String?

        public var creationTime: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var name: String?

        public var previewMedia: String?

        public var previewMediaStatus: String?

        public var relatedMediaids: String?

        public var status: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.previewMedia != nil {
                map["PreviewMedia"] = self.previewMedia!
            }
            if self.previewMediaStatus != nil {
                map["PreviewMediaStatus"] = self.previewMediaStatus!
            }
            if self.relatedMediaids != nil {
                map["RelatedMediaids"] = self.relatedMediaids!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PreviewMedia") {
                self.previewMedia = dict["PreviewMedia"] as! String
            }
            if dict.keys.contains("PreviewMediaStatus") {
                self.previewMediaStatus = dict["PreviewMediaStatus"] as! String
            }
            if dict.keys.contains("RelatedMediaids") {
                self.relatedMediaids = dict["RelatedMediaids"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var template: GetTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") {
            var model = GetTemplateResponseBody.Template()
            model.fromMap(dict["Template"] as! [String: Any])
            self.template = model
        }
    }
}

public class GetTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateMaterialsRequest : Tea.TeaModel {
    public var fileList: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileList != nil {
            map["FileList"] = self.fileList!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileList") {
            self.fileList = dict["FileList"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateMaterialsResponseBody : Tea.TeaModel {
    public var materialUrls: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialUrls != nil {
            map["MaterialUrls"] = self.materialUrls!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialUrls") {
            self.materialUrls = dict["MaterialUrls"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTemplateMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTemplateMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateParamsRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateParamsResponseBody : Tea.TeaModel {
    public class ParamList : Tea.TeaModel {
        public var content: String?

        public var coverUrl: String?

        public var key: String?

        public var mediaUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.mediaUrl != nil {
                map["MediaUrl"] = self.mediaUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("CoverUrl") {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("MediaUrl") {
                self.mediaUrl = dict["MediaUrl"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var paramList: [GetTemplateParamsResponseBody.ParamList]?

    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.paramList != nil {
            var tmp : [Any] = []
            for k in self.paramList! {
                tmp.append(k.toMap())
            }
            map["ParamList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ParamList") {
            var tmp : [GetTemplateParamsResponseBody.ParamList] = []
            for v in dict["ParamList"] as! [Any] {
                var model = GetTemplateParamsResponseBody.ParamList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.paramList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetTemplateParamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateParamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTemplateParamsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTranscodeJobRequest : Tea.TeaModel {
    public var parentJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.parentJobId != nil {
            map["ParentJobId"] = self.parentJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ParentJobId") {
            self.parentJobId = dict["ParentJobId"] as! String
        }
    }
}

public class GetTranscodeJobResponseBody : Tea.TeaModel {
    public class TranscodeParentJob : Tea.TeaModel {
        public class InputGroup : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class OutputGroup : Tea.TeaModel {
            public class Output : Tea.TeaModel {
                public var media: String?

                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public var keyServiceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        if self.keyServiceType != nil {
                            map["KeyServiceType"] = self.keyServiceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                        if dict.keys.contains("KeyServiceType") {
                            self.keyServiceType = dict["KeyServiceType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class TransConfig : Tea.TeaModel {
                            public var adjDarMethod: String?

                            public var isCheckAudioBitrate: String?

                            public var isCheckAudioBitrateFail: String?

                            public var isCheckReso: String?

                            public var isCheckResoFail: String?

                            public var isCheckVideoBitrate: String?

                            public var isCheckVideoBitrateFail: String?

                            public var transMode: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.adjDarMethod != nil {
                                    map["AdjDarMethod"] = self.adjDarMethod!
                                }
                                if self.isCheckAudioBitrate != nil {
                                    map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                                }
                                if self.isCheckAudioBitrateFail != nil {
                                    map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                                }
                                if self.isCheckReso != nil {
                                    map["IsCheckReso"] = self.isCheckReso!
                                }
                                if self.isCheckResoFail != nil {
                                    map["IsCheckResoFail"] = self.isCheckResoFail!
                                }
                                if self.isCheckVideoBitrate != nil {
                                    map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                                }
                                if self.isCheckVideoBitrateFail != nil {
                                    map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                                }
                                if self.transMode != nil {
                                    map["TransMode"] = self.transMode!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AdjDarMethod") {
                                    self.adjDarMethod = dict["AdjDarMethod"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrate") {
                                    self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrateFail") {
                                    self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                                }
                                if dict.keys.contains("IsCheckReso") {
                                    self.isCheckReso = dict["IsCheckReso"] as! String
                                }
                                if dict.keys.contains("IsCheckResoFail") {
                                    self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrate") {
                                    self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrateFail") {
                                    self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                                }
                                if dict.keys.contains("TransMode") {
                                    self.transMode = dict["TransMode"] as! String
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var transConfig: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.TransConfig?

                        public var video: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.transConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.transConfig != nil {
                                map["TransConfig"] = self.transConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("TransConfig") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.TransConfig()
                                model.fromMap(dict["TransConfig"] as! [String: Any])
                                self.transConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs]?

                public var encryption: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption?

                public var imageWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks]?

                public var subtitles: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles]?

                public var textWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks]?

                public var transcode: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("Subtitles") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public var output: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output?

            public var processConfig: GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
                try self.processConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Output") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public class TranscodeJobList : Tea.TeaModel {
            public class InputGroup : Tea.TeaModel {
                public var inputUrl: String?

                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inputUrl != nil {
                        map["InputUrl"] = self.inputUrl!
                    }
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InputUrl") {
                        self.inputUrl = dict["InputUrl"] as! String
                    }
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class OutFileMeta : Tea.TeaModel {
                public class AudioStreamInfoList : Tea.TeaModel {
                    public var bitrate: String?

                    public var channelLayout: String?

                    public var channels: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var duration: String?

                    public var index: String?

                    public var lang: String?

                    public var sampleFmt: String?

                    public var sampleRate: String?

                    public var startTime: String?

                    public var timebase: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channelLayout != nil {
                            map["ChannelLayout"] = self.channelLayout!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codecLongName != nil {
                            map["CodecLongName"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["CodecName"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["CodecTag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["CodecTagString"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["CodecTimeBase"] = self.codecTimeBase!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.sampleFmt != nil {
                            map["SampleFmt"] = self.sampleFmt!
                        }
                        if self.sampleRate != nil {
                            map["SampleRate"] = self.sampleRate!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.timebase != nil {
                            map["Timebase"] = self.timebase!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("ChannelLayout") {
                            self.channelLayout = dict["ChannelLayout"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("CodecLongName") {
                            self.codecLongName = dict["CodecLongName"] as! String
                        }
                        if dict.keys.contains("CodecName") {
                            self.codecName = dict["CodecName"] as! String
                        }
                        if dict.keys.contains("CodecTag") {
                            self.codecTag = dict["CodecTag"] as! String
                        }
                        if dict.keys.contains("CodecTagString") {
                            self.codecTagString = dict["CodecTagString"] as! String
                        }
                        if dict.keys.contains("CodecTimeBase") {
                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Index") {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("SampleFmt") {
                            self.sampleFmt = dict["SampleFmt"] as! String
                        }
                        if dict.keys.contains("SampleRate") {
                            self.sampleRate = dict["SampleRate"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("Timebase") {
                            self.timebase = dict["Timebase"] as! String
                        }
                    }
                }
                public class FileBasicInfo : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var fileName: String?

                    public var fileSize: String?

                    public var fileStatus: String?

                    public var fileType: String?

                    public var fileUrl: String?

                    public var formatName: String?

                    public var height: String?

                    public var mediaId: String?

                    public var region: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileName != nil {
                            map["FileName"] = self.fileName!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.fileStatus != nil {
                            map["FileStatus"] = self.fileStatus!
                        }
                        if self.fileType != nil {
                            map["FileType"] = self.fileType!
                        }
                        if self.fileUrl != nil {
                            map["FileUrl"] = self.fileUrl!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.mediaId != nil {
                            map["MediaId"] = self.mediaId!
                        }
                        if self.region != nil {
                            map["Region"] = self.region!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileName") {
                            self.fileName = dict["FileName"] as! String
                        }
                        if dict.keys.contains("FileSize") {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("FileStatus") {
                            self.fileStatus = dict["FileStatus"] as! String
                        }
                        if dict.keys.contains("FileType") {
                            self.fileType = dict["FileType"] as! String
                        }
                        if dict.keys.contains("FileUrl") {
                            self.fileUrl = dict["FileUrl"] as! String
                        }
                        if dict.keys.contains("FormatName") {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MediaId") {
                            self.mediaId = dict["MediaId"] as! String
                        }
                        if dict.keys.contains("Region") {
                            self.region = dict["Region"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class VideoStreamInfoList : Tea.TeaModel {
                    public var avgFps: String?

                    public var bitRate: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var dar: String?

                    public var duration: String?

                    public var fps: String?

                    public var hasBFrames: String?

                    public var height: String?

                    public var index: String?

                    public var lang: String?

                    public var level: String?

                    public var numFrames: String?

                    public var pixFmt: String?

                    public var profile: String?

                    public var rotate: String?

                    public var sar: String?

                    public var startTime: String?

                    public var timeBase: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgFps != nil {
                            map["Avg_fps"] = self.avgFps!
                        }
                        if self.bitRate != nil {
                            map["Bit_rate"] = self.bitRate!
                        }
                        if self.codecLongName != nil {
                            map["Codec_long_name"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["Codec_name"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["Codec_tag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["Codec_tag_string"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["Codec_time_base"] = self.codecTimeBase!
                        }
                        if self.dar != nil {
                            map["Dar"] = self.dar!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.hasBFrames != nil {
                            map["Has_b_frames"] = self.hasBFrames!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.numFrames != nil {
                            map["NumFrames"] = self.numFrames!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.rotate != nil {
                            map["Rotate"] = self.rotate!
                        }
                        if self.sar != nil {
                            map["Sar"] = self.sar!
                        }
                        if self.startTime != nil {
                            map["Start_time"] = self.startTime!
                        }
                        if self.timeBase != nil {
                            map["Time_base"] = self.timeBase!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Avg_fps") {
                            self.avgFps = dict["Avg_fps"] as! String
                        }
                        if dict.keys.contains("Bit_rate") {
                            self.bitRate = dict["Bit_rate"] as! String
                        }
                        if dict.keys.contains("Codec_long_name") {
                            self.codecLongName = dict["Codec_long_name"] as! String
                        }
                        if dict.keys.contains("Codec_name") {
                            self.codecName = dict["Codec_name"] as! String
                        }
                        if dict.keys.contains("Codec_tag") {
                            self.codecTag = dict["Codec_tag"] as! String
                        }
                        if dict.keys.contains("Codec_tag_string") {
                            self.codecTagString = dict["Codec_tag_string"] as! String
                        }
                        if dict.keys.contains("Codec_time_base") {
                            self.codecTimeBase = dict["Codec_time_base"] as! String
                        }
                        if dict.keys.contains("Dar") {
                            self.dar = dict["Dar"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Has_b_frames") {
                            self.hasBFrames = dict["Has_b_frames"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Index") {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("Level") {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("NumFrames") {
                            self.numFrames = dict["NumFrames"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Rotate") {
                            self.rotate = dict["Rotate"] as! String
                        }
                        if dict.keys.contains("Sar") {
                            self.sar = dict["Sar"] as! String
                        }
                        if dict.keys.contains("Start_time") {
                            self.startTime = dict["Start_time"] as! String
                        }
                        if dict.keys.contains("Time_base") {
                            self.timeBase = dict["Time_base"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var audioStreamInfoList: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList]?

                public var fileBasicInfo: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo?

                public var videoStreamInfoList: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.fileBasicInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.audioStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["AudioStreamInfoList"] = tmp
                    }
                    if self.fileBasicInfo != nil {
                        map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                    }
                    if self.videoStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.videoStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["VideoStreamInfoList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioStreamInfoList") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList] = []
                        for v in dict["AudioStreamInfoList"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.audioStreamInfoList = tmp
                    }
                    if dict.keys.contains("FileBasicInfo") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo()
                        model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                        self.fileBasicInfo = model
                    }
                    if dict.keys.contains("VideoStreamInfoList") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList] = []
                        for v in dict["VideoStreamInfoList"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.videoStreamInfoList = tmp
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public var media: String?

                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public var keyServiceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        if self.keyServiceType != nil {
                            map["KeyServiceType"] = self.keyServiceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                        if dict.keys.contains("KeyServiceType") {
                            self.keyServiceType = dict["KeyServiceType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class TransConfig : Tea.TeaModel {
                            public var adjDarMethod: String?

                            public var isCheckAudioBitrate: String?

                            public var isCheckAudioBitrateFail: String?

                            public var isCheckReso: String?

                            public var isCheckResoFail: String?

                            public var isCheckVideoBitrate: String?

                            public var isCheckVideoBitrateFail: String?

                            public var transMode: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.adjDarMethod != nil {
                                    map["AdjDarMethod"] = self.adjDarMethod!
                                }
                                if self.isCheckAudioBitrate != nil {
                                    map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                                }
                                if self.isCheckAudioBitrateFail != nil {
                                    map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                                }
                                if self.isCheckReso != nil {
                                    map["IsCheckReso"] = self.isCheckReso!
                                }
                                if self.isCheckResoFail != nil {
                                    map["IsCheckResoFail"] = self.isCheckResoFail!
                                }
                                if self.isCheckVideoBitrate != nil {
                                    map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                                }
                                if self.isCheckVideoBitrateFail != nil {
                                    map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                                }
                                if self.transMode != nil {
                                    map["TransMode"] = self.transMode!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AdjDarMethod") {
                                    self.adjDarMethod = dict["AdjDarMethod"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrate") {
                                    self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrateFail") {
                                    self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                                }
                                if dict.keys.contains("IsCheckReso") {
                                    self.isCheckReso = dict["IsCheckReso"] as! String
                                }
                                if dict.keys.contains("IsCheckResoFail") {
                                    self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrate") {
                                    self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrateFail") {
                                    self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                                }
                                if dict.keys.contains("TransMode") {
                                    self.transMode = dict["TransMode"] as! String
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var tags: [String: String]?

                        public var transConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.TransConfig?

                        public var video: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.transConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.tags != nil {
                                map["Tags"] = self.tags!
                            }
                            if self.transConfig != nil {
                                map["TransConfig"] = self.transConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Tags") {
                                self.tags = dict["Tags"] as! [String: String]
                            }
                            if dict.keys.contains("TransConfig") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.TransConfig()
                                model.fromMap(dict["TransConfig"] as! [String: Any])
                                self.transConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs]?

                public var encryption: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption?

                public var imageWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks]?

                public var isInheritTags: Bool?

                public var subtitles: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles]?

                public var textWatermarks: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks]?

                public var transcode: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.isInheritTags != nil {
                        map["IsInheritTags"] = self.isInheritTags!
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("IsInheritTags") {
                        self.isInheritTags = dict["IsInheritTags"] as! Bool
                    }
                    if dict.keys.contains("Subtitles") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") {
                        var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public class ScheduleConfig : Tea.TeaModel {
                public var pipelineId: String?

                public var priority: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PipelineId") {
                        self.pipelineId = dict["PipelineId"] as! String
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! Int32
                    }
                }
            }
            public var createTime: String?

            public var finishTime: String?

            public var inputGroup: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup]?

            public var jobId: String?

            public var jobIndex: Int32?

            public var name: String?

            public var outFileMeta: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta?

            public var output: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output?

            public var parentJobId: String?

            public var processConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig?

            public var requestId: String?

            public var scheduleConfig: GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig?

            public var status: String?

            public var submitResultJson: [String: Any]?

            public var submitTime: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outFileMeta?.validate()
                try self.output?.validate()
                try self.processConfig?.validate()
                try self.scheduleConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inputGroup != nil {
                    var tmp : [Any] = []
                    for k in self.inputGroup! {
                        tmp.append(k.toMap())
                    }
                    map["InputGroup"] = tmp
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobIndex != nil {
                    map["JobIndex"] = self.jobIndex!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outFileMeta != nil {
                    map["OutFileMeta"] = self.outFileMeta?.toMap()
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.parentJobId != nil {
                    map["ParentJobId"] = self.parentJobId!
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.scheduleConfig != nil {
                    map["ScheduleConfig"] = self.scheduleConfig?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitResultJson != nil {
                    map["SubmitResultJson"] = self.submitResultJson!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("InputGroup") {
                    var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup] = []
                    for v in dict["InputGroup"] as! [Any] {
                        var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputGroup = tmp
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobIndex") {
                    self.jobIndex = dict["JobIndex"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OutFileMeta") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta()
                    model.fromMap(dict["OutFileMeta"] as! [String: Any])
                    self.outFileMeta = model
                }
                if dict.keys.contains("Output") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ParentJobId") {
                    self.parentJobId = dict["ParentJobId"] as! String
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
                if dict.keys.contains("RequestId") {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ScheduleConfig") {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig()
                    model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                    self.scheduleConfig = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitResultJson") {
                    self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
                }
                if dict.keys.contains("SubmitTime") {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var inputGroup: [GetTranscodeJobResponseBody.TranscodeParentJob.InputGroup]?

        public var jobCount: Int32?

        public var name: String?

        public var outputGroup: [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup]?

        public var parentJobId: String?

        public var percent: Int32?

        public var requestId: String?

        public var scheduleConfig: GetTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig?

        public var status: String?

        public var submitTime: String?

        public var transcodeJobList: [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList]?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputGroup != nil {
                var tmp : [Any] = []
                for k in self.inputGroup! {
                    tmp.append(k.toMap())
                }
                map["InputGroup"] = tmp
            }
            if self.jobCount != nil {
                map["JobCount"] = self.jobCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroup != nil {
                var tmp : [Any] = []
                for k in self.outputGroup! {
                    tmp.append(k.toMap())
                }
                map["OutputGroup"] = tmp
            }
            if self.parentJobId != nil {
                map["ParentJobId"] = self.parentJobId!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.transcodeJobList != nil {
                var tmp : [Any] = []
                for k in self.transcodeJobList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJobList"] = tmp
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("InputGroup") {
                var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.InputGroup] = []
                for v in dict["InputGroup"] as! [Any] {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.InputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputGroup = tmp
            }
            if dict.keys.contains("JobCount") {
                self.jobCount = dict["JobCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroup") {
                var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup] = []
                for v in dict["OutputGroup"] as! [Any] {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.OutputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroup = tmp
            }
            if dict.keys.contains("ParentJobId") {
                self.parentJobId = dict["ParentJobId"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = GetTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TranscodeJobList") {
                var tmp : [GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList] = []
                for v in dict["TranscodeJobList"] as! [Any] {
                    var model = GetTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeJobList = tmp
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeParentJob: GetTranscodeJobResponseBody.TranscodeParentJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeParentJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeParentJob != nil {
            map["TranscodeParentJob"] = self.transcodeParentJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeParentJob") {
            var model = GetTranscodeJobResponseBody.TranscodeParentJob()
            model.fromMap(dict["TranscodeParentJob"] as! [String: Any])
            self.transcodeParentJob = model
        }
    }
}

public class GetTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUrlUploadInfosRequest : Tea.TeaModel {
    public var jobIds: String?

    public var uploadURLs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.uploadURLs != nil {
            map["UploadURLs"] = self.uploadURLs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("UploadURLs") {
            self.uploadURLs = dict["UploadURLs"] as! String
        }
    }
}

public class GetUrlUploadInfosResponseBody : Tea.TeaModel {
    public class URLUploadInfoList : Tea.TeaModel {
        public var completeTime: String?

        public var creationTime: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var fileSize: String?

        public var jobId: String?

        public var mediaId: String?

        public var status: String?

        public var uploadURL: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uploadURL != nil {
                map["UploadURL"] = self.uploadURL!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("FileSize") {
                self.fileSize = dict["FileSize"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UploadURL") {
                self.uploadURL = dict["UploadURL"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var nonExists: [String]?

    public var requestId: String?

    public var URLUploadInfoList: [GetUrlUploadInfosResponseBody.URLUploadInfoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExists != nil {
            map["NonExists"] = self.nonExists!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.URLUploadInfoList != nil {
            var tmp : [Any] = []
            for k in self.URLUploadInfoList! {
                tmp.append(k.toMap())
            }
            map["URLUploadInfoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExists") {
            self.nonExists = dict["NonExists"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("URLUploadInfoList") {
            var tmp : [GetUrlUploadInfosResponseBody.URLUploadInfoList] = []
            for v in dict["URLUploadInfoList"] as! [Any] {
                var model = GetUrlUploadInfosResponseBody.URLUploadInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.URLUploadInfoList = tmp
        }
    }
}

public class GetUrlUploadInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUrlUploadInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUrlUploadInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoListRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class GetVideoListResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public var appId: String?

        public var cateId: Int64?

        public var cateName: String?

        public var coverUrl: String?

        public var creationTime: String?

        public var description_: String?

        public var duration: Double?

        public var mediaId: String?

        public var modificationTime: String?

        public var size: Int64?

        public var snapshots: [String]?

        public var status: String?

        public var storageLocation: String?

        public var tags: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshots != nil {
                map["Snapshots"] = self.snapshots!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("CoverUrl") {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Snapshots") {
                self.snapshots = dict["Snapshots"] as! [String]
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var code: String?

    public var mediaList: [GetVideoListResponseBody.MediaList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaList != nil {
            var tmp : [Any] = []
            for k in self.mediaList! {
                tmp.append(k.toMap())
            }
            map["MediaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaList") {
            var tmp : [GetVideoListResponseBody.MediaList] = []
            for v in dict["MediaList"] as! [Any] {
                var model = GetVideoListResponseBody.MediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class GetVideoListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVideoListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVodPackagingAssetRequest : Tea.TeaModel {
    public var assetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetName != nil {
            map["AssetName"] = self.assetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetName") {
            self.assetName = dict["AssetName"] as! String
        }
    }
}

public class GetVodPackagingAssetResponseBody : Tea.TeaModel {
    public class Asset : Tea.TeaModel {
        public class EgressEndpoints : Tea.TeaModel {
            public var configurationName: String?

            public var status: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configurationName != nil {
                    map["ConfigurationName"] = self.configurationName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigurationName") {
                    self.configurationName = dict["ConfigurationName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var assetName: String?

        public var contentId: String?

        public var createTime: String?

        public var egressEndpoints: [GetVodPackagingAssetResponseBody.Asset.EgressEndpoints]?

        public var groupName: String?

        public var input: GetVodPackagingAssetResponseBody.Asset.Input?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assetName != nil {
                map["AssetName"] = self.assetName!
            }
            if self.contentId != nil {
                map["ContentId"] = self.contentId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.egressEndpoints != nil {
                var tmp : [Any] = []
                for k in self.egressEndpoints! {
                    tmp.append(k.toMap())
                }
                map["EgressEndpoints"] = tmp
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssetName") {
                self.assetName = dict["AssetName"] as! String
            }
            if dict.keys.contains("ContentId") {
                self.contentId = dict["ContentId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EgressEndpoints") {
                var tmp : [GetVodPackagingAssetResponseBody.Asset.EgressEndpoints] = []
                for v in dict["EgressEndpoints"] as! [Any] {
                    var model = GetVodPackagingAssetResponseBody.Asset.EgressEndpoints()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.egressEndpoints = tmp
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Input") {
                var model = GetVodPackagingAssetResponseBody.Asset.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
        }
    }
    public var asset: GetVodPackagingAssetResponseBody.Asset?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.asset?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asset != nil {
            map["Asset"] = self.asset?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asset") {
            var model = GetVodPackagingAssetResponseBody.Asset()
            model.fromMap(dict["Asset"] as! [String: Any])
            self.asset = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetVodPackagingAssetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVodPackagingAssetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVodPackagingAssetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVodPackagingConfigurationRequest : Tea.TeaModel {
    public var configurationName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configurationName != nil {
            map["ConfigurationName"] = self.configurationName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigurationName") {
            self.configurationName = dict["ConfigurationName"] as! String
        }
    }
}

public class GetVodPackagingConfigurationResponseBody : Tea.TeaModel {
    public var packagingConfiguration: VodPackagingConfiguration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packagingConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packagingConfiguration != nil {
            map["PackagingConfiguration"] = self.packagingConfiguration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackagingConfiguration") {
            var model = VodPackagingConfiguration()
            model.fromMap(dict["PackagingConfiguration"] as! [String: Any])
            self.packagingConfiguration = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetVodPackagingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVodPackagingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVodPackagingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVodPackagingGroupRequest : Tea.TeaModel {
    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class GetVodPackagingGroupResponseBody : Tea.TeaModel {
    public var packagingGroup: VodPackagingGroup?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packagingGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packagingGroup != nil {
            map["PackagingGroup"] = self.packagingGroup?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackagingGroup") {
            var model = VodPackagingGroup()
            model.fromMap(dict["PackagingGroup"] as! [String: Any])
            self.packagingGroup = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetVodPackagingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVodPackagingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVodPackagingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkflowTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetWorkflowTaskResponseBody : Tea.TeaModel {
    public class WorkflowTask : Tea.TeaModel {
        public class Workflow : Tea.TeaModel {
            public var createTime: String?

            public var modifiedTime: String?

            public var name: String?

            public var status: String?

            public var type: String?

            public var workflowId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("WorkflowId") {
                    self.workflowId = dict["WorkflowId"] as! String
                }
            }
        }
        public var activityResults: String?

        public var createTime: String?

        public var finishTime: String?

        public var status: String?

        public var taskId: String?

        public var taskInput: String?

        public var userData: String?

        public var workflow: GetWorkflowTaskResponseBody.WorkflowTask.Workflow?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.workflow?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityResults != nil {
                map["ActivityResults"] = self.activityResults!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskInput != nil {
                map["TaskInput"] = self.taskInput!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.workflow != nil {
                map["Workflow"] = self.workflow?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityResults") {
                self.activityResults = dict["ActivityResults"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskInput") {
                self.taskInput = dict["TaskInput"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("Workflow") {
                var model = GetWorkflowTaskResponseBody.WorkflowTask.Workflow()
                model.fromMap(dict["Workflow"] as! [String: Any])
                self.workflow = model
            }
        }
    }
    public var requestId: String?

    public var workflowTask: GetWorkflowTaskResponseBody.WorkflowTask?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workflowTask?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.workflowTask != nil {
            map["WorkflowTask"] = self.workflowTask?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WorkflowTask") {
            var model = GetWorkflowTaskResponseBody.WorkflowTask()
            model.fromMap(dict["WorkflowTask"] as! [String: Any])
            self.workflowTask = model
        }
    }
}

public class GetWorkflowTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkflowTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkflowTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertMediaToSearchLibRequest : Tea.TeaModel {
    public var input: String?

    public var mediaId: String?

    public var mediaType: String?

    public var msgBody: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.msgBody != nil {
            map["MsgBody"] = self.msgBody!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("MsgBody") {
            self.msgBody = dict["MsgBody"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class InsertMediaToSearchLibResponseBody : Tea.TeaModel {
    public var code: String?

    public var mediaId: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class InsertMediaToSearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertMediaToSearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InsertMediaToSearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAIAgentDialoguesRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var order: String?

    public var pageNumber: Int64?

    public var pageSize: Int32?

    public var roundLimit: String?

    public var sessionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.roundLimit != nil {
            map["RoundLimit"] = self.roundLimit!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RoundLimit") {
            self.roundLimit = dict["RoundLimit"] as! String
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListAIAgentDialoguesResponseBody : Tea.TeaModel {
    public class Dialogues : Tea.TeaModel {
        public class AttachedFileList : Tea.TeaModel {
            public var format: String?

            public var id: String?

            public var name: String?

            public var type: Int32?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var attachedFileList: [ListAIAgentDialoguesResponseBody.Dialogues.AttachedFileList]?

        public var dialogueId: String?

        public var extend: String?

        public var nodeId: String?

        public var producer: String?

        public var reasoningText: String?

        public var roundId: String?

        public var source: String?

        public var text: String?

        public var time: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachedFileList != nil {
                var tmp : [Any] = []
                for k in self.attachedFileList! {
                    tmp.append(k.toMap())
                }
                map["AttachedFileList"] = tmp
            }
            if self.dialogueId != nil {
                map["DialogueId"] = self.dialogueId!
            }
            if self.extend != nil {
                map["Extend"] = self.extend!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.producer != nil {
                map["Producer"] = self.producer!
            }
            if self.reasoningText != nil {
                map["ReasoningText"] = self.reasoningText!
            }
            if self.roundId != nil {
                map["RoundId"] = self.roundId!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.text != nil {
                map["Text"] = self.text!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachedFileList") {
                var tmp : [ListAIAgentDialoguesResponseBody.Dialogues.AttachedFileList] = []
                for v in dict["AttachedFileList"] as! [Any] {
                    var model = ListAIAgentDialoguesResponseBody.Dialogues.AttachedFileList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attachedFileList = tmp
            }
            if dict.keys.contains("DialogueId") {
                self.dialogueId = dict["DialogueId"] as! String
            }
            if dict.keys.contains("Extend") {
                self.extend = dict["Extend"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("Producer") {
                self.producer = dict["Producer"] as! String
            }
            if dict.keys.contains("ReasoningText") {
                self.reasoningText = dict["ReasoningText"] as! String
            }
            if dict.keys.contains("RoundId") {
                self.roundId = dict["RoundId"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Text") {
                self.text = dict["Text"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var dialogues: [ListAIAgentDialoguesResponseBody.Dialogues]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dialogues != nil {
            var tmp : [Any] = []
            for k in self.dialogues! {
                tmp.append(k.toMap())
            }
            map["Dialogues"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Dialogues") {
            var tmp : [ListAIAgentDialoguesResponseBody.Dialogues] = []
            for v in dict["Dialogues"] as! [Any] {
                var model = ListAIAgentDialoguesResponseBody.Dialogues()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dialogues = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAIAgentDialoguesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAIAgentDialoguesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAIAgentDialoguesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAIAgentInstanceRequest : Tea.TeaModel {
    public var AIAgentId: String?

    public var endTime: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIAgentId != nil {
            map["AIAgentId"] = self.AIAgentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIAgentId") {
            self.AIAgentId = dict["AIAgentId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListAIAgentInstanceResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var callLogUrl: String?

        public var runtimeConfig: AIAgentRuntimeConfig?

        public var status: String?

        public var templateConfig: AIAgentTemplateConfig?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.runtimeConfig?.validate()
            try self.templateConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callLogUrl != nil {
                map["CallLogUrl"] = self.callLogUrl!
            }
            if self.runtimeConfig != nil {
                map["RuntimeConfig"] = self.runtimeConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig?.toMap()
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallLogUrl") {
                self.callLogUrl = dict["CallLogUrl"] as! String
            }
            if dict.keys.contains("RuntimeConfig") {
                var model = AIAgentRuntimeConfig()
                model.fromMap(dict["RuntimeConfig"] as! [String: Any])
                self.runtimeConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                var model = AIAgentTemplateConfig()
                model.fromMap(dict["TemplateConfig"] as! [String: Any])
                self.templateConfig = model
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var instances: [ListAIAgentInstanceResponseBody.Instances]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var tmp : [ListAIAgentInstanceResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = ListAIAgentInstanceResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAIAgentInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAIAgentInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAIAgentInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAdInsertionsRequest : Tea.TeaModel {
    public var keyword: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class ListAdInsertionsResponseBody : Tea.TeaModel {
    public class Configs : Tea.TeaModel {
        public class CdnConfig : Tea.TeaModel {
            public var adSegmentUrlPrefix: String?

            public var contentSegmentUrlPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adSegmentUrlPrefix != nil {
                    map["AdSegmentUrlPrefix"] = self.adSegmentUrlPrefix!
                }
                if self.contentSegmentUrlPrefix != nil {
                    map["ContentSegmentUrlPrefix"] = self.contentSegmentUrlPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdSegmentUrlPrefix") {
                    self.adSegmentUrlPrefix = dict["AdSegmentUrlPrefix"] as! String
                }
                if dict.keys.contains("ContentSegmentUrlPrefix") {
                    self.contentSegmentUrlPrefix = dict["ContentSegmentUrlPrefix"] as! String
                }
            }
        }
        public class ManifestEndpointConfig : Tea.TeaModel {
            public var hlsPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hlsPrefix != nil {
                    map["HlsPrefix"] = self.hlsPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HlsPrefix") {
                    self.hlsPrefix = dict["HlsPrefix"] as! String
                }
            }
        }
        public var adMarkerPassthrough: String?

        public var adsUrl: String?

        public var cdnConfig: ListAdInsertionsResponseBody.Configs.CdnConfig?

        public var configAliases: String?

        public var contentUrlPrefix: String?

        public var createTime: String?

        public var lastModified: String?

        public var manifestEndpointConfig: ListAdInsertionsResponseBody.Configs.ManifestEndpointConfig?

        public var name: String?

        public var personalizationThreshold: Int32?

        public var slateAdUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cdnConfig?.validate()
            try self.manifestEndpointConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adMarkerPassthrough != nil {
                map["AdMarkerPassthrough"] = self.adMarkerPassthrough!
            }
            if self.adsUrl != nil {
                map["AdsUrl"] = self.adsUrl!
            }
            if self.cdnConfig != nil {
                map["CdnConfig"] = self.cdnConfig?.toMap()
            }
            if self.configAliases != nil {
                map["ConfigAliases"] = self.configAliases!
            }
            if self.contentUrlPrefix != nil {
                map["ContentUrlPrefix"] = self.contentUrlPrefix!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.manifestEndpointConfig != nil {
                map["ManifestEndpointConfig"] = self.manifestEndpointConfig?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.personalizationThreshold != nil {
                map["PersonalizationThreshold"] = self.personalizationThreshold!
            }
            if self.slateAdUrl != nil {
                map["SlateAdUrl"] = self.slateAdUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AdMarkerPassthrough") {
                self.adMarkerPassthrough = dict["AdMarkerPassthrough"] as! String
            }
            if dict.keys.contains("AdsUrl") {
                self.adsUrl = dict["AdsUrl"] as! String
            }
            if dict.keys.contains("CdnConfig") {
                var model = ListAdInsertionsResponseBody.Configs.CdnConfig()
                model.fromMap(dict["CdnConfig"] as! [String: Any])
                self.cdnConfig = model
            }
            if dict.keys.contains("ConfigAliases") {
                self.configAliases = dict["ConfigAliases"] as! String
            }
            if dict.keys.contains("ContentUrlPrefix") {
                self.contentUrlPrefix = dict["ContentUrlPrefix"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("ManifestEndpointConfig") {
                var model = ListAdInsertionsResponseBody.Configs.ManifestEndpointConfig()
                model.fromMap(dict["ManifestEndpointConfig"] as! [String: Any])
                self.manifestEndpointConfig = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PersonalizationThreshold") {
                self.personalizationThreshold = dict["PersonalizationThreshold"] as! Int32
            }
            if dict.keys.contains("SlateAdUrl") {
                self.slateAdUrl = dict["SlateAdUrl"] as! String
            }
        }
    }
    public var configs: [ListAdInsertionsResponseBody.Configs]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configs != nil {
            var tmp : [Any] = []
            for k in self.configs! {
                tmp.append(k.toMap())
            }
            map["Configs"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Configs") {
            var tmp : [ListAdInsertionsResponseBody.Configs] = []
            for v in dict["Configs"] as! [Any] {
                var model = ListAdInsertionsResponseBody.Configs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configs = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListAdInsertionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAdInsertionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAdInsertionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAlertsRequest : Tea.TeaModel {
    public var category: String?

    public var gmtEnd: String?

    public var gmtStart: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var resourceArn: String?

    public var sortBy: String?

    public var sortByModifiedTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.gmtEnd != nil {
            map["GmtEnd"] = self.gmtEnd!
        }
        if self.gmtStart != nil {
            map["GmtStart"] = self.gmtStart!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceArn != nil {
            map["ResourceArn"] = self.resourceArn!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.sortByModifiedTime != nil {
            map["SortByModifiedTime"] = self.sortByModifiedTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("GmtEnd") {
            self.gmtEnd = dict["GmtEnd"] as! String
        }
        if dict.keys.contains("GmtStart") {
            self.gmtStart = dict["GmtStart"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceArn") {
            self.resourceArn = dict["ResourceArn"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("SortByModifiedTime") {
            self.sortByModifiedTime = dict["SortByModifiedTime"] as! String
        }
    }
}

public class ListAlertsResponseBody : Tea.TeaModel {
    public class Alerts : Tea.TeaModel {
        public var category: String?

        public var code: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var message: String?

        public var relatedResourceArns: String?

        public var resourceArn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.relatedResourceArns != nil {
                map["RelatedResourceArns"] = self.relatedResourceArns!
            }
            if self.resourceArn != nil {
                map["ResourceArn"] = self.resourceArn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("RelatedResourceArns") {
                self.relatedResourceArns = dict["RelatedResourceArns"] as! String
            }
            if dict.keys.contains("ResourceArn") {
                self.resourceArn = dict["ResourceArn"] as! String
            }
        }
    }
    public var alerts: [ListAlertsResponseBody.Alerts]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alerts != nil {
            var tmp : [Any] = []
            for k in self.alerts! {
                tmp.append(k.toMap())
            }
            map["Alerts"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Alerts") {
            var tmp : [ListAlertsResponseBody.Alerts] = []
            for v in dict["Alerts"] as! [Any] {
                var model = ListAlertsResponseBody.Alerts()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alerts = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListAlertsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlertsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAlertsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAllPublicMediaTagsRequest : Tea.TeaModel {
    public var businessType: String?

    public var entityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
    }
}

public class ListAllPublicMediaTagsResponseBody : Tea.TeaModel {
    public class MediaTagList : Tea.TeaModel {
        public class Options : Tea.TeaModel {
            public var optionChineseName: String?

            public var optionEnglishName: String?

            public var optionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.optionChineseName != nil {
                    map["OptionChineseName"] = self.optionChineseName!
                }
                if self.optionEnglishName != nil {
                    map["OptionEnglishName"] = self.optionEnglishName!
                }
                if self.optionId != nil {
                    map["OptionId"] = self.optionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OptionChineseName") {
                    self.optionChineseName = dict["OptionChineseName"] as! String
                }
                if dict.keys.contains("OptionEnglishName") {
                    self.optionEnglishName = dict["OptionEnglishName"] as! String
                }
                if dict.keys.contains("OptionId") {
                    self.optionId = dict["OptionId"] as! String
                }
            }
        }
        public var mediaTagId: String?

        public var mediaTagNameChinese: String?

        public var mediaTagNameEnglish: String?

        public var options: [ListAllPublicMediaTagsResponseBody.MediaTagList.Options]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaTagId != nil {
                map["MediaTagId"] = self.mediaTagId!
            }
            if self.mediaTagNameChinese != nil {
                map["MediaTagNameChinese"] = self.mediaTagNameChinese!
            }
            if self.mediaTagNameEnglish != nil {
                map["MediaTagNameEnglish"] = self.mediaTagNameEnglish!
            }
            if self.options != nil {
                var tmp : [Any] = []
                for k in self.options! {
                    tmp.append(k.toMap())
                }
                map["Options"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaTagId") {
                self.mediaTagId = dict["MediaTagId"] as! String
            }
            if dict.keys.contains("MediaTagNameChinese") {
                self.mediaTagNameChinese = dict["MediaTagNameChinese"] as! String
            }
            if dict.keys.contains("MediaTagNameEnglish") {
                self.mediaTagNameEnglish = dict["MediaTagNameEnglish"] as! String
            }
            if dict.keys.contains("Options") {
                var tmp : [ListAllPublicMediaTagsResponseBody.MediaTagList.Options] = []
                for v in dict["Options"] as! [Any] {
                    var model = ListAllPublicMediaTagsResponseBody.MediaTagList.Options()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.options = tmp
            }
        }
    }
    public var mediaTagList: [ListAllPublicMediaTagsResponseBody.MediaTagList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaTagList != nil {
            var tmp : [Any] = []
            for k in self.mediaTagList! {
                tmp.append(k.toMap())
            }
            map["MediaTagList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaTagList") {
            var tmp : [ListAllPublicMediaTagsResponseBody.MediaTagList] = []
            for v in dict["MediaTagList"] as! [Any] {
                var model = ListAllPublicMediaTagsResponseBody.MediaTagList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaTagList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAllPublicMediaTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllPublicMediaTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAllPublicMediaTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAvatarTrainingJobsRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListAvatarTrainingJobsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AvatarTrainingJobList : Tea.TeaModel {
            public var avatarDescription: String?

            public var avatarId: String?

            public var avatarName: String?

            public var avatarType: String?

            public var createTime: String?

            public var firstTrainingTime: String?

            public var jobId: String?

            public var lastTrainingTime: String?

            public var message: String?

            public var portrait: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarDescription != nil {
                    map["AvatarDescription"] = self.avatarDescription!
                }
                if self.avatarId != nil {
                    map["AvatarId"] = self.avatarId!
                }
                if self.avatarName != nil {
                    map["AvatarName"] = self.avatarName!
                }
                if self.avatarType != nil {
                    map["AvatarType"] = self.avatarType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.firstTrainingTime != nil {
                    map["FirstTrainingTime"] = self.firstTrainingTime!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.lastTrainingTime != nil {
                    map["LastTrainingTime"] = self.lastTrainingTime!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.portrait != nil {
                    map["Portrait"] = self.portrait!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvatarDescription") {
                    self.avatarDescription = dict["AvatarDescription"] as! String
                }
                if dict.keys.contains("AvatarId") {
                    self.avatarId = dict["AvatarId"] as! String
                }
                if dict.keys.contains("AvatarName") {
                    self.avatarName = dict["AvatarName"] as! String
                }
                if dict.keys.contains("AvatarType") {
                    self.avatarType = dict["AvatarType"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FirstTrainingTime") {
                    self.firstTrainingTime = dict["FirstTrainingTime"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("LastTrainingTime") {
                    self.lastTrainingTime = dict["LastTrainingTime"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Portrait") {
                    self.portrait = dict["Portrait"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var avatarTrainingJobList: [ListAvatarTrainingJobsResponseBody.Data.AvatarTrainingJobList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarTrainingJobList != nil {
                var tmp : [Any] = []
                for k in self.avatarTrainingJobList! {
                    tmp.append(k.toMap())
                }
                map["AvatarTrainingJobList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarTrainingJobList") {
                var tmp : [ListAvatarTrainingJobsResponseBody.Data.AvatarTrainingJobList] = []
                for v in dict["AvatarTrainingJobList"] as! [Any] {
                    var model = ListAvatarTrainingJobsResponseBody.Data.AvatarTrainingJobList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.avatarTrainingJobList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: ListAvatarTrainingJobsResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListAvatarTrainingJobsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAvatarTrainingJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAvatarTrainingJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAvatarTrainingJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAvatarsRequest : Tea.TeaModel {
    public var avatarType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarType != nil {
            map["AvatarType"] = self.avatarType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarType") {
            self.avatarType = dict["AvatarType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListAvatarsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AvatarList : Tea.TeaModel {
            public var avatarDescription: String?

            public var avatarId: String?

            public var avatarName: String?

            public var avatarType: String?

            public var portrait: String?

            public var thumbnail: String?

            public var transparent: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarDescription != nil {
                    map["AvatarDescription"] = self.avatarDescription!
                }
                if self.avatarId != nil {
                    map["AvatarId"] = self.avatarId!
                }
                if self.avatarName != nil {
                    map["AvatarName"] = self.avatarName!
                }
                if self.avatarType != nil {
                    map["AvatarType"] = self.avatarType!
                }
                if self.portrait != nil {
                    map["Portrait"] = self.portrait!
                }
                if self.thumbnail != nil {
                    map["Thumbnail"] = self.thumbnail!
                }
                if self.transparent != nil {
                    map["Transparent"] = self.transparent!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvatarDescription") {
                    self.avatarDescription = dict["AvatarDescription"] as! String
                }
                if dict.keys.contains("AvatarId") {
                    self.avatarId = dict["AvatarId"] as! String
                }
                if dict.keys.contains("AvatarName") {
                    self.avatarName = dict["AvatarName"] as! String
                }
                if dict.keys.contains("AvatarType") {
                    self.avatarType = dict["AvatarType"] as! String
                }
                if dict.keys.contains("Portrait") {
                    self.portrait = dict["Portrait"] as! String
                }
                if dict.keys.contains("Thumbnail") {
                    self.thumbnail = dict["Thumbnail"] as! String
                }
                if dict.keys.contains("Transparent") {
                    self.transparent = dict["Transparent"] as! Bool
                }
            }
        }
        public var avatarList: [ListAvatarsResponseBody.Data.AvatarList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarList != nil {
                var tmp : [Any] = []
                for k in self.avatarList! {
                    tmp.append(k.toMap())
                }
                map["AvatarList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarList") {
                var tmp : [ListAvatarsResponseBody.Data.AvatarList] = []
                for v in dict["AvatarList"] as! [Any] {
                    var model = ListAvatarsResponseBody.Data.AvatarList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.avatarList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: ListAvatarsResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListAvatarsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAvatarsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAvatarsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAvatarsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBatchMediaProducingJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var jobId: String?

    public var jobType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListBatchMediaProducingJobsResponseBody : Tea.TeaModel {
    public class EditingBatchJobList : Tea.TeaModel {
        public var completeTime: String?

        public var createTime: String?

        public var editingConfig: String?

        public var extend: String?

        public var inputConfig: String?

        public var jobId: String?

        public var jobType: String?

        public var modifiedTime: String?

        public var outputConfig: String?

        public var status: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.editingConfig != nil {
                map["EditingConfig"] = self.editingConfig!
            }
            if self.extend != nil {
                map["Extend"] = self.extend!
            }
            if self.inputConfig != nil {
                map["InputConfig"] = self.inputConfig!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputConfig != nil {
                map["OutputConfig"] = self.outputConfig!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EditingConfig") {
                self.editingConfig = dict["EditingConfig"] as! String
            }
            if dict.keys.contains("Extend") {
                self.extend = dict["Extend"] as! String
            }
            if dict.keys.contains("InputConfig") {
                self.inputConfig = dict["InputConfig"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputConfig") {
                self.outputConfig = dict["OutputConfig"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var editingBatchJobList: [ListBatchMediaProducingJobsResponseBody.EditingBatchJobList]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.editingBatchJobList != nil {
            var tmp : [Any] = []
            for k in self.editingBatchJobList! {
                tmp.append(k.toMap())
            }
            map["EditingBatchJobList"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EditingBatchJobList") {
            var tmp : [ListBatchMediaProducingJobsResponseBody.EditingBatchJobList] = []
            for v in dict["EditingBatchJobList"] as! [Any] {
                var model = ListBatchMediaProducingJobsResponseBody.EditingBatchJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.editingBatchJobList = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListBatchMediaProducingJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBatchMediaProducingJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListBatchMediaProducingJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListChannelAlertsRequest : Tea.TeaModel {
    public var category: String?

    public var gmtEnd: String?

    public var gmtStart: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var resourceArn: String?

    public var sortByModifiedTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.gmtEnd != nil {
            map["GmtEnd"] = self.gmtEnd!
        }
        if self.gmtStart != nil {
            map["GmtStart"] = self.gmtStart!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceArn != nil {
            map["ResourceArn"] = self.resourceArn!
        }
        if self.sortByModifiedTime != nil {
            map["SortByModifiedTime"] = self.sortByModifiedTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("GmtEnd") {
            self.gmtEnd = dict["GmtEnd"] as! String
        }
        if dict.keys.contains("GmtStart") {
            self.gmtStart = dict["GmtStart"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceArn") {
            self.resourceArn = dict["ResourceArn"] as! String
        }
        if dict.keys.contains("SortByModifiedTime") {
            self.sortByModifiedTime = dict["SortByModifiedTime"] as! String
        }
    }
}

public class ListChannelAlertsResponseBody : Tea.TeaModel {
    public class ProgramAlerts : Tea.TeaModel {
        public var arn: String?

        public var category: String?

        public var count: Int32?

        public var gmtModified: String?

        public var programName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                map["Arn"] = self.arn!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.programName != nil {
                map["ProgramName"] = self.programName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arn") {
                self.arn = dict["Arn"] as! String
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("ProgramName") {
                self.programName = dict["ProgramName"] as! String
            }
        }
    }
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var programAlerts: [ListChannelAlertsResponseBody.ProgramAlerts]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.programAlerts != nil {
            var tmp : [Any] = []
            for k in self.programAlerts! {
                tmp.append(k.toMap())
            }
            map["ProgramAlerts"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProgramAlerts") {
            var tmp : [ListChannelAlertsResponseBody.ProgramAlerts] = []
            for v in dict["ProgramAlerts"] as! [Any] {
                var model = ListChannelAlertsResponseBody.ProgramAlerts()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.programAlerts = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListChannelAlertsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListChannelAlertsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListChannelAlertsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListChannelsRequest : Tea.TeaModel {
    public var channelName: String?

    public var channelTier: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var playbackMode: String?

    public var sortBy: String?

    public var sortByModifiedTime: String?

    public var state: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.channelTier != nil {
            map["ChannelTier"] = self.channelTier!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playbackMode != nil {
            map["PlaybackMode"] = self.playbackMode!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.sortByModifiedTime != nil {
            map["SortByModifiedTime"] = self.sortByModifiedTime!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ChannelTier") {
            self.channelTier = dict["ChannelTier"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PlaybackMode") {
            self.playbackMode = dict["PlaybackMode"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("SortByModifiedTime") {
            self.sortByModifiedTime = dict["SortByModifiedTime"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! Int32
        }
    }
}

public class ListChannelsResponseBody : Tea.TeaModel {
    public var channelList: [ChannelAssemblyChannel]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelList != nil {
            var tmp : [Any] = []
            for k in self.channelList! {
                tmp.append(k.toMap())
            }
            map["ChannelList"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelList") {
            var tmp : [ChannelAssemblyChannel] = []
            for v in dict["ChannelList"] as! [Any] {
                var model = ChannelAssemblyChannel()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.channelList = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListChannelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListChannelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListChannelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomTemplatesRequest : Tea.TeaModel {
    public var name: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var subtype: String?

    public var templateId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Subtype") {
            self.subtype = dict["Subtype"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListCustomTemplatesResponseBody : Tea.TeaModel {
    public class CustomTemplateList : Tea.TeaModel {
        public class FrontendHint : Tea.TeaModel {
            public class TranscodeTemplateHint : Tea.TeaModel {
                public var bitrateControlType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrateControlType != nil {
                        map["BitrateControlType"] = self.bitrateControlType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BitrateControlType") {
                        self.bitrateControlType = dict["BitrateControlType"] as! String
                    }
                }
            }
            public var transcodeTemplateHint: ListCustomTemplatesResponseBody.CustomTemplateList.FrontendHint.TranscodeTemplateHint?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.transcodeTemplateHint?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.transcodeTemplateHint != nil {
                    map["TranscodeTemplateHint"] = self.transcodeTemplateHint?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TranscodeTemplateHint") {
                    var model = ListCustomTemplatesResponseBody.CustomTemplateList.FrontendHint.TranscodeTemplateHint()
                    model.fromMap(dict["TranscodeTemplateHint"] as! [String: Any])
                    self.transcodeTemplateHint = model
                }
            }
        }
        public var createTime: String?

        public var frontendHint: ListCustomTemplatesResponseBody.CustomTemplateList.FrontendHint?

        public var isDefault: Bool?

        public var modifiedTime: String?

        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.frontendHint?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.frontendHint != nil {
                map["FrontendHint"] = self.frontendHint?.toMap()
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FrontendHint") {
                var model = ListCustomTemplatesResponseBody.CustomTemplateList.FrontendHint()
                model.fromMap(dict["FrontendHint"] as! [String: Any])
                self.frontendHint = model
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var customTemplateList: [ListCustomTemplatesResponseBody.CustomTemplateList]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplateList != nil {
            var tmp : [Any] = []
            for k in self.customTemplateList! {
                tmp.append(k.toMap())
            }
            map["CustomTemplateList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplateList") {
            var tmp : [ListCustomTemplatesResponseBody.CustomTemplateList] = []
            for v in dict["CustomTemplateList"] as! [Any] {
                var model = ListCustomTemplatesResponseBody.CustomTemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customTemplateList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListCustomTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCustomTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomizedVoiceJobsRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListCustomizedVoiceJobsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CustomizedVoiceJobList : Tea.TeaModel {
            public var createTime: String?

            public var gender: String?

            public var gmtCreate: String?

            public var jobId: String?

            public var message: String?

            public var scenario: String?

            public var status: String?

            public var type: String?

            public var voiceDesc: String?

            public var voiceId: String?

            public var voiceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.gender != nil {
                    map["Gender"] = self.gender!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.scenario != nil {
                    map["Scenario"] = self.scenario!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.voiceDesc != nil {
                    map["VoiceDesc"] = self.voiceDesc!
                }
                if self.voiceId != nil {
                    map["VoiceId"] = self.voiceId!
                }
                if self.voiceName != nil {
                    map["VoiceName"] = self.voiceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Gender") {
                    self.gender = dict["Gender"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Scenario") {
                    self.scenario = dict["Scenario"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VoiceDesc") {
                    self.voiceDesc = dict["VoiceDesc"] as! String
                }
                if dict.keys.contains("VoiceId") {
                    self.voiceId = dict["VoiceId"] as! String
                }
                if dict.keys.contains("VoiceName") {
                    self.voiceName = dict["VoiceName"] as! String
                }
            }
        }
        public var customizedVoiceJobList: [ListCustomizedVoiceJobsResponseBody.Data.CustomizedVoiceJobList]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customizedVoiceJobList != nil {
                var tmp : [Any] = []
                for k in self.customizedVoiceJobList! {
                    tmp.append(k.toMap())
                }
                map["CustomizedVoiceJobList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomizedVoiceJobList") {
                var tmp : [ListCustomizedVoiceJobsResponseBody.Data.CustomizedVoiceJobList] = []
                for v in dict["CustomizedVoiceJobList"] as! [Any] {
                    var model = ListCustomizedVoiceJobsResponseBody.Data.CustomizedVoiceJobList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customizedVoiceJobList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListCustomizedVoiceJobsResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListCustomizedVoiceJobsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCustomizedVoiceJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomizedVoiceJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCustomizedVoiceJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomizedVoicesRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListCustomizedVoicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CustomizedVoiceList : Tea.TeaModel {
            public var demoAudioMediaId: String?

            public var gender: String?

            public var scenario: String?

            public var type: String?

            public var voiceDesc: String?

            public var voiceId: String?

            public var voiceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoAudioMediaId != nil {
                    map["DemoAudioMediaId"] = self.demoAudioMediaId!
                }
                if self.gender != nil {
                    map["Gender"] = self.gender!
                }
                if self.scenario != nil {
                    map["Scenario"] = self.scenario!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.voiceDesc != nil {
                    map["VoiceDesc"] = self.voiceDesc!
                }
                if self.voiceId != nil {
                    map["VoiceId"] = self.voiceId!
                }
                if self.voiceName != nil {
                    map["VoiceName"] = self.voiceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoAudioMediaId") {
                    self.demoAudioMediaId = dict["DemoAudioMediaId"] as! String
                }
                if dict.keys.contains("Gender") {
                    self.gender = dict["Gender"] as! String
                }
                if dict.keys.contains("Scenario") {
                    self.scenario = dict["Scenario"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VoiceDesc") {
                    self.voiceDesc = dict["VoiceDesc"] as! String
                }
                if dict.keys.contains("VoiceId") {
                    self.voiceId = dict["VoiceId"] as! String
                }
                if dict.keys.contains("VoiceName") {
                    self.voiceName = dict["VoiceName"] as! String
                }
            }
        }
        public var customizedVoiceList: [ListCustomizedVoicesResponseBody.Data.CustomizedVoiceList]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customizedVoiceList != nil {
                var tmp : [Any] = []
                for k in self.customizedVoiceList! {
                    tmp.append(k.toMap())
                }
                map["CustomizedVoiceList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomizedVoiceList") {
                var tmp : [ListCustomizedVoicesResponseBody.Data.CustomizedVoiceList] = []
                for v in dict["CustomizedVoiceList"] as! [Any] {
                    var model = ListCustomizedVoicesResponseBody.Data.CustomizedVoiceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customizedVoiceList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListCustomizedVoicesResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListCustomizedVoicesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCustomizedVoicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomizedVoicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCustomizedVoicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDNADBRequest : Tea.TeaModel {
    public var DBIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBIds != nil {
            map["DBIds"] = self.DBIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBIds") {
            self.DBIds = dict["DBIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListDNADBResponseBody : Tea.TeaModel {
    public class DBList : Tea.TeaModel {
        public var DBId: String?

        public var description_: String?

        public var model: String?

        public var name: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBId != nil {
                map["DBId"] = self.DBId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.model != nil {
                map["Model"] = self.model!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DBId") {
                self.DBId = dict["DBId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Model") {
                self.model = dict["Model"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var DBList: [ListDNADBResponseBody.DBList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBList != nil {
            var tmp : [Any] = []
            for k in self.DBList! {
                tmp.append(k.toMap())
            }
            map["DBList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBList") {
            var tmp : [ListDNADBResponseBody.DBList] = []
            for v in dict["DBList"] as! [Any] {
                var model = ListDNADBResponseBody.DBList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.DBList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDNADBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDNADBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDNADBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDNAFilesRequest : Tea.TeaModel {
    public var DBId: String?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBId") {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListDNAFilesResponseBody : Tea.TeaModel {
    public class FileList : Tea.TeaModel {
        public class InputFile : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public var inputFile: ListDNAFilesResponseBody.FileList.InputFile?

        public var primaryKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inputFile?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputFile != nil {
                map["InputFile"] = self.inputFile?.toMap()
            }
            if self.primaryKey != nil {
                map["PrimaryKey"] = self.primaryKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputFile") {
                var model = ListDNAFilesResponseBody.FileList.InputFile()
                model.fromMap(dict["InputFile"] as! [String: Any])
                self.inputFile = model
            }
            if dict.keys.contains("PrimaryKey") {
                self.primaryKey = dict["PrimaryKey"] as! String
            }
        }
    }
    public var fileList: [ListDNAFilesResponseBody.FileList]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileList != nil {
            var tmp : [Any] = []
            for k in self.fileList! {
                tmp.append(k.toMap())
            }
            map["FileList"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileList") {
            var tmp : [ListDNAFilesResponseBody.FileList] = []
            for v in dict["FileList"] as! [Any] {
                var model = ListDNAFilesResponseBody.FileList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fileList = tmp
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDNAFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDNAFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDNAFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDynamicImageJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListDynamicImageJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var input: ListDynamicImageJobsResponseBody.Jobs.Input?

        public var jobId: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: ListDynamicImageJobsResponseBody.Jobs.Output?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateId: String?

        public var triggerSource: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = ListDynamicImageJobsResponseBody.Jobs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = ListDynamicImageJobsResponseBody.Jobs.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
        }
    }
    public var jobs: [ListDynamicImageJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            var tmp : [ListDynamicImageJobsResponseBody.Jobs] = []
            for v in dict["Jobs"] as! [Any] {
                var model = ListDynamicImageJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDynamicImageJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDynamicImageJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDynamicImageJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEditingProjectsRequest : Tea.TeaModel {
    public var createSource: String?

    public var endTime: String?

    public var keyword: String?

    public var maxResults: String?

    public var nextToken: String?

    public var projectType: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createSource != nil {
            map["CreateSource"] = self.createSource!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.projectType != nil {
            map["ProjectType"] = self.projectType!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateSource") {
            self.createSource = dict["CreateSource"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ProjectType") {
            self.projectType = dict["ProjectType"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class ListEditingProjectsResponseBody : Tea.TeaModel {
    public class ProjectList : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: String?

        public var templateType: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var projectList: [ListEditingProjectsResponseBody.ProjectList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.projectList != nil {
            var tmp : [Any] = []
            for k in self.projectList! {
                tmp.append(k.toMap())
            }
            map["ProjectList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ProjectList") {
            var tmp : [ListEditingProjectsResponseBody.ProjectList] = []
            for v in dict["ProjectList"] as! [Any] {
                var model = ListEditingProjectsResponseBody.ProjectList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.projectList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEditingProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEditingProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEditingProjectsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLivePackageChannelGroupsRequest : Tea.TeaModel {
    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class ListLivePackageChannelGroupsResponseBody : Tea.TeaModel {
    public class LivePackageChannelGroups : Tea.TeaModel {
        public var createTime: String?

        public var description_: String?

        public var groupName: String?

        public var lastModified: String?

        public var originDomain: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.originDomain != nil {
                map["OriginDomain"] = self.originDomain!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("OriginDomain") {
                self.originDomain = dict["OriginDomain"] as! String
            }
        }
    }
    public var livePackageChannelGroups: [ListLivePackageChannelGroupsResponseBody.LivePackageChannelGroups]?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageChannelGroups != nil {
            var tmp : [Any] = []
            for k in self.livePackageChannelGroups! {
                tmp.append(k.toMap())
            }
            map["LivePackageChannelGroups"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LivePackageChannelGroups") {
            var tmp : [ListLivePackageChannelGroupsResponseBody.LivePackageChannelGroups] = []
            for v in dict["LivePackageChannelGroups"] as! [Any] {
                var model = ListLivePackageChannelGroupsResponseBody.LivePackageChannelGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.livePackageChannelGroups = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLivePackageChannelGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLivePackageChannelGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLivePackageChannelGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLivePackageChannelsRequest : Tea.TeaModel {
    public var groupName: String?

    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class ListLivePackageChannelsResponseBody : Tea.TeaModel {
    public class LivePackageChannels : Tea.TeaModel {
        public class IngestEndpoints : Tea.TeaModel {
            public var id: String?

            public var password: String?

            public var url: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public var channelName: String?

        public var createTime: String?

        public var description_: String?

        public var groupName: String?

        public var ingestEndpoints: [ListLivePackageChannelsResponseBody.LivePackageChannels.IngestEndpoints]?

        public var lastModified: String?

        public var protocol_: String?

        public var segmentCount: Int32?

        public var segmentDuration: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.ingestEndpoints != nil {
                var tmp : [Any] = []
                for k in self.ingestEndpoints! {
                    tmp.append(k.toMap())
                }
                map["IngestEndpoints"] = tmp
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.segmentCount != nil {
                map["SegmentCount"] = self.segmentCount!
            }
            if self.segmentDuration != nil {
                map["SegmentDuration"] = self.segmentDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("IngestEndpoints") {
                var tmp : [ListLivePackageChannelsResponseBody.LivePackageChannels.IngestEndpoints] = []
                for v in dict["IngestEndpoints"] as! [Any] {
                    var model = ListLivePackageChannelsResponseBody.LivePackageChannels.IngestEndpoints()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ingestEndpoints = tmp
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("SegmentCount") {
                self.segmentCount = dict["SegmentCount"] as! Int32
            }
            if dict.keys.contains("SegmentDuration") {
                self.segmentDuration = dict["SegmentDuration"] as! Int32
            }
        }
    }
    public var livePackageChannels: [ListLivePackageChannelsResponseBody.LivePackageChannels]?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageChannels != nil {
            var tmp : [Any] = []
            for k in self.livePackageChannels! {
                tmp.append(k.toMap())
            }
            map["LivePackageChannels"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LivePackageChannels") {
            var tmp : [ListLivePackageChannelsResponseBody.LivePackageChannels] = []
            for v in dict["LivePackageChannels"] as! [Any] {
                var model = ListLivePackageChannelsResponseBody.LivePackageChannels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.livePackageChannels = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLivePackageChannelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLivePackageChannelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLivePackageChannelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLivePackageOriginEndpointsRequest : Tea.TeaModel {
    public var channelName: String?

    public var groupName: String?

    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class ListLivePackageOriginEndpointsResponseBody : Tea.TeaModel {
    public class LivePackageOriginEndpoints : Tea.TeaModel {
        public var authorizationCode: String?

        public var channelName: String?

        public var createTime: String?

        public var description_: String?

        public var endpointName: String?

        public var endpointUrl: String?

        public var groupName: String?

        public var ipBlacklist: String?

        public var ipWhitelist: String?

        public var lastModified: String?

        public var manifestName: String?

        public var protocol_: String?

        public var timeshiftVision: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizationCode != nil {
                map["AuthorizationCode"] = self.authorizationCode!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.endpointName != nil {
                map["EndpointName"] = self.endpointName!
            }
            if self.endpointUrl != nil {
                map["EndpointUrl"] = self.endpointUrl!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.ipBlacklist != nil {
                map["IpBlacklist"] = self.ipBlacklist!
            }
            if self.ipWhitelist != nil {
                map["IpWhitelist"] = self.ipWhitelist!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.manifestName != nil {
                map["ManifestName"] = self.manifestName!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.timeshiftVision != nil {
                map["TimeshiftVision"] = self.timeshiftVision!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizationCode") {
                self.authorizationCode = dict["AuthorizationCode"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EndpointName") {
                self.endpointName = dict["EndpointName"] as! String
            }
            if dict.keys.contains("EndpointUrl") {
                self.endpointUrl = dict["EndpointUrl"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("IpBlacklist") {
                self.ipBlacklist = dict["IpBlacklist"] as! String
            }
            if dict.keys.contains("IpWhitelist") {
                self.ipWhitelist = dict["IpWhitelist"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("ManifestName") {
                self.manifestName = dict["ManifestName"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("TimeshiftVision") {
                self.timeshiftVision = dict["TimeshiftVision"] as! Int32
            }
        }
    }
    public var livePackageOriginEndpoints: [ListLivePackageOriginEndpointsResponseBody.LivePackageOriginEndpoints]?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageOriginEndpoints != nil {
            var tmp : [Any] = []
            for k in self.livePackageOriginEndpoints! {
                tmp.append(k.toMap())
            }
            map["LivePackageOriginEndpoints"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LivePackageOriginEndpoints") {
            var tmp : [ListLivePackageOriginEndpointsResponseBody.LivePackageOriginEndpoints] = []
            for v in dict["LivePackageOriginEndpoints"] as! [Any] {
                var model = ListLivePackageOriginEndpointsResponseBody.LivePackageOriginEndpoints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.livePackageOriginEndpoints = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLivePackageOriginEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLivePackageOriginEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLivePackageOriginEndpointsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordFilesRequest : Tea.TeaModel {
    public var endTime: String?

    public var jobIds: [String]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var recordFormat: String?

    public var sortBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordFormat != nil {
            map["RecordFormat"] = self.recordFormat!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! [String]
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecordFormat") {
            self.recordFormat = dict["RecordFormat"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListLiveRecordFilesResponseBody : Tea.TeaModel {
    public class Files : Tea.TeaModel {
        public var createTime: String?

        public var duration: Double?

        public var endTime: String?

        public var format: String?

        public var height: Int32?

        public var jobId: String?

        public var jobName: String?

        public var recordId: String?

        public var recordOutput: String?

        public var recordUrl: String?

        public var startTime: String?

        public var streamUrl: String?

        public var width: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.recordOutput != nil {
                map["RecordOutput"] = self.recordOutput!
            }
            if self.recordUrl != nil {
                map["RecordUrl"] = self.recordUrl!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.streamUrl != nil {
                map["StreamUrl"] = self.streamUrl!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobName") {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("RecordOutput") {
                self.recordOutput = dict["RecordOutput"] as! String
            }
            if dict.keys.contains("RecordUrl") {
                self.recordUrl = dict["RecordUrl"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("StreamUrl") {
                self.streamUrl = dict["StreamUrl"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int32
            }
        }
    }
    public var files: [ListLiveRecordFilesResponseBody.Files]?

    public var pageNo: Int64?

    public var pageSize: String?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.files != nil {
            var tmp : [Any] = []
            for k in self.files! {
                tmp.append(k.toMap())
            }
            map["Files"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Files") {
            var tmp : [ListLiveRecordFilesResponseBody.Files] = []
            for v in dict["Files"] as! [Any] {
                var model = ListLiveRecordFilesResponseBody.Files()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.files = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListLiveRecordFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRecordFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListLiveRecordJobsResponseBody : Tea.TeaModel {
    public class LiveRecordJobs : Tea.TeaModel {
        public class RecordOutput : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var notifyUrl: String?

        public var recordOutput: ListLiveRecordJobsResponseBody.LiveRecordJobs.RecordOutput?

        public var status: String?

        public var streamInput: ListLiveRecordJobsResponseBody.LiveRecordJobs.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordOutput?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            if self.recordOutput != nil {
                map["RecordOutput"] = self.recordOutput?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyUrl") {
                self.notifyUrl = dict["NotifyUrl"] as! String
            }
            if dict.keys.contains("RecordOutput") {
                var model = ListLiveRecordJobsResponseBody.LiveRecordJobs.RecordOutput()
                model.fromMap(dict["RecordOutput"] as! [String: Any])
                self.recordOutput = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StreamInput") {
                var model = ListLiveRecordJobsResponseBody.LiveRecordJobs.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var liveRecordJobs: [ListLiveRecordJobsResponseBody.LiveRecordJobs]?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveRecordJobs != nil {
            var tmp : [Any] = []
            for k in self.liveRecordJobs! {
                tmp.append(k.toMap())
            }
            map["LiveRecordJobs"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveRecordJobs") {
            var tmp : [ListLiveRecordJobsResponseBody.LiveRecordJobs] = []
            for v in dict["LiveRecordJobs"] as! [Any] {
                var model = ListLiveRecordJobsResponseBody.LiveRecordJobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.liveRecordJobs = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveRecordJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRecordJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordTemplatesRequest : Tea.TeaModel {
    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var templateIds: [String]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TemplateIds") {
            self.templateIds = dict["TemplateIds"] as! [String]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListLiveRecordTemplatesResponseBody : Tea.TeaModel {
    public class RecordTemplateList : Tea.TeaModel {
        public class RecordFormatList : Tea.TeaModel {
            public var cycleDuration: Int32?

            public var format: String?

            public var ossObjectPrefix: String?

            public var sliceDuration: Int32?

            public var sliceOssObjectPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleDuration != nil {
                    map["CycleDuration"] = self.cycleDuration!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.ossObjectPrefix != nil {
                    map["OssObjectPrefix"] = self.ossObjectPrefix!
                }
                if self.sliceDuration != nil {
                    map["SliceDuration"] = self.sliceDuration!
                }
                if self.sliceOssObjectPrefix != nil {
                    map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CycleDuration") {
                    self.cycleDuration = dict["CycleDuration"] as! Int32
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("OssObjectPrefix") {
                    self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
                }
                if dict.keys.contains("SliceDuration") {
                    self.sliceDuration = dict["SliceDuration"] as! Int32
                }
                if dict.keys.contains("SliceOssObjectPrefix") {
                    self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
                }
            }
        }
        public var createTime: String?

        public var lastModified: String?

        public var name: String?

        public var recordFormatList: [ListLiveRecordTemplatesResponseBody.RecordTemplateList.RecordFormatList]?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordFormatList != nil {
                var tmp : [Any] = []
                for k in self.recordFormatList! {
                    tmp.append(k.toMap())
                }
                map["RecordFormatList"] = tmp
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordFormatList") {
                var tmp : [ListLiveRecordTemplatesResponseBody.RecordTemplateList.RecordFormatList] = []
                for v in dict["RecordFormatList"] as! [Any] {
                    var model = ListLiveRecordTemplatesResponseBody.RecordTemplateList.RecordFormatList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recordFormatList = tmp
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var recordTemplateList: [ListLiveRecordTemplatesResponseBody.RecordTemplateList]?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordTemplateList != nil {
            var tmp : [Any] = []
            for k in self.recordTemplateList! {
                tmp.append(k.toMap())
            }
            map["RecordTemplateList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RecordTemplateList") {
            var tmp : [ListLiveRecordTemplatesResponseBody.RecordTemplateList] = []
            for v in dict["RecordTemplateList"] as! [Any] {
                var model = ListLiveRecordTemplatesResponseBody.RecordTemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordTemplateList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveRecordTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRecordTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveSnapshotFilesRequest : Tea.TeaModel {
    public var endTime: String?

    public var jobId: String?

    public var limit: Int32?

    public var sortBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListLiveSnapshotFilesResponseBody : Tea.TeaModel {
    public class FileList : Tea.TeaModel {
        public var createTime: String?

        public var createTimestamp: Int64?

        public var isOverlay: Bool?

        public var ossBucket: String?

        public var ossEndpoint: String?

        public var ossObject: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.isOverlay != nil {
                map["IsOverlay"] = self.isOverlay!
            }
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossEndpoint != nil {
                map["OssEndpoint"] = self.ossEndpoint!
            }
            if self.ossObject != nil {
                map["OssObject"] = self.ossObject!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("IsOverlay") {
                self.isOverlay = dict["IsOverlay"] as! Bool
            }
            if dict.keys.contains("OssBucket") {
                self.ossBucket = dict["OssBucket"] as! String
            }
            if dict.keys.contains("OssEndpoint") {
                self.ossEndpoint = dict["OssEndpoint"] as! String
            }
            if dict.keys.contains("OssObject") {
                self.ossObject = dict["OssObject"] as! String
            }
        }
    }
    public var fileList: [ListLiveSnapshotFilesResponseBody.FileList]?

    public var nextStartTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileList != nil {
            var tmp : [Any] = []
            for k in self.fileList! {
                tmp.append(k.toMap())
            }
            map["FileList"] = tmp
        }
        if self.nextStartTime != nil {
            map["NextStartTime"] = self.nextStartTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileList") {
            var tmp : [ListLiveSnapshotFilesResponseBody.FileList] = []
            for v in dict["FileList"] as! [Any] {
                var model = ListLiveSnapshotFilesResponseBody.FileList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fileList = tmp
        }
        if dict.keys.contains("NextStartTime") {
            self.nextStartTime = dict["NextStartTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListLiveSnapshotFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveSnapshotFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveSnapshotFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveSnapshotJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchKeyWord: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListLiveSnapshotJobsResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class SnapshotOutput : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var storageType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.storageType != nil {
                    map["StorageType"] = self.storageType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("StorageType") {
                    self.storageType = dict["StorageType"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var jobName: String?

        public var snapshotOutput: ListLiveSnapshotJobsResponseBody.JobList.SnapshotOutput?

        public var status: String?

        public var templateId: String?

        public var templateName: String?

        public var timeInterval: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.snapshotOutput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.snapshotOutput != nil {
                map["SnapshotOutput"] = self.snapshotOutput?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.timeInterval != nil {
                map["TimeInterval"] = self.timeInterval!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobName") {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("SnapshotOutput") {
                var model = ListLiveSnapshotJobsResponseBody.JobList.SnapshotOutput()
                model.fromMap(dict["SnapshotOutput"] as! [String: Any])
                self.snapshotOutput = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TimeInterval") {
                self.timeInterval = dict["TimeInterval"] as! Int32
            }
        }
    }
    public var jobList: [ListLiveSnapshotJobsResponseBody.JobList]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            var tmp : [Any] = []
            for k in self.jobList! {
                tmp.append(k.toMap())
            }
            map["JobList"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            var tmp : [ListLiveSnapshotJobsResponseBody.JobList] = []
            for v in dict["JobList"] as! [Any] {
                var model = ListLiveSnapshotJobsResponseBody.JobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobList = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveSnapshotJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveSnapshotJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveSnapshotJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveSnapshotTemplatesRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchKeyWord: String?

    public var sortBy: String?

    public var templateIds: [String]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TemplateIds") {
            self.templateIds = dict["TemplateIds"] as! [String]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListLiveSnapshotTemplatesResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public var createTime: String?

        public var templateId: String?

        public var templateName: String?

        public var timeInterval: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.timeInterval != nil {
                map["TimeInterval"] = self.timeInterval!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TimeInterval") {
                self.timeInterval = dict["TimeInterval"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sortBy: String?

    public var templateList: [ListLiveSnapshotTemplatesResponseBody.TemplateList]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.templateList != nil {
            var tmp : [Any] = []
            for k in self.templateList! {
                tmp.append(k.toMap())
            }
            map["TemplateList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TemplateList") {
            var tmp : [ListLiveSnapshotTemplatesResponseBody.TemplateList] = []
            for v in dict["TemplateList"] as! [Any] {
                var model = ListLiveSnapshotTemplatesResponseBody.TemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLiveSnapshotTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveSnapshotTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveSnapshotTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveTranscodeJobsRequest : Tea.TeaModel {
    public var keyWord: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var startMode: Int32?

    public var status: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startMode != nil {
            map["StartMode"] = self.startMode!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartMode") {
            self.startMode = dict["StartMode"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListLiveTranscodeJobsResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class OutputStream : Tea.TeaModel {
            public class StreamInfos : Tea.TeaModel {
                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var streamInfos: [ListLiveTranscodeJobsResponseBody.JobList.OutputStream.StreamInfos]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.streamInfos != nil {
                    var tmp : [Any] = []
                    for k in self.streamInfos! {
                        tmp.append(k.toMap())
                    }
                    map["StreamInfos"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("StreamInfos") {
                    var tmp : [ListLiveTranscodeJobsResponseBody.JobList.OutputStream.StreamInfos] = []
                    for v in dict["StreamInfos"] as! [Any] {
                        var model = ListLiveTranscodeJobsResponseBody.JobList.OutputStream.StreamInfos()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.streamInfos = tmp
                }
            }
        }
        public class StreamInput : Tea.TeaModel {
            public var inputUrl: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputUrl") {
                    self.inputUrl = dict["InputUrl"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: String?

        public var jobId: String?

        public var name: String?

        public var outputStream: ListLiveTranscodeJobsResponseBody.JobList.OutputStream?

        public var startMode: Int32?

        public var status: Int32?

        public var streamInput: ListLiveTranscodeJobsResponseBody.JobList.StreamInput?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.outputStream?.validate()
            try self.streamInput?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputStream != nil {
                map["OutputStream"] = self.outputStream?.toMap()
            }
            if self.startMode != nil {
                map["StartMode"] = self.startMode!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputStream") {
                var model = ListLiveTranscodeJobsResponseBody.JobList.OutputStream()
                model.fromMap(dict["OutputStream"] as! [String: Any])
                self.outputStream = model
            }
            if dict.keys.contains("StartMode") {
                self.startMode = dict["StartMode"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StreamInput") {
                var model = ListLiveTranscodeJobsResponseBody.JobList.StreamInput()
                model.fromMap(dict["StreamInput"] as! [String: Any])
                self.streamInput = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var jobList: [ListLiveTranscodeJobsResponseBody.JobList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            var tmp : [Any] = []
            for k in self.jobList! {
                tmp.append(k.toMap())
            }
            map["JobList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            var tmp : [ListLiveTranscodeJobsResponseBody.JobList] = []
            for v in dict["JobList"] as! [Any] {
                var model = ListLiveTranscodeJobsResponseBody.JobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListLiveTranscodeJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveTranscodeJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveTranscodeJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveTranscodeTemplatesRequest : Tea.TeaModel {
    public var category: String?

    public var keyWord: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var type: String?

    public var videoCodec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.videoCodec != nil {
            map["VideoCodec"] = self.videoCodec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VideoCodec") {
            self.videoCodec = dict["VideoCodec"] as! String
        }
    }
}

public class ListLiveTranscodeTemplatesResponseBody : Tea.TeaModel {
    public class TemplateContentList : Tea.TeaModel {
        public class TemplateConfig : Tea.TeaModel {
            public class AudioParams : Tea.TeaModel {
                public var bitrate: String?

                public var channels: String?

                public var codec: String?

                public var profile: String?

                public var samplerate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.samplerate != nil {
                        map["Samplerate"] = self.samplerate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Samplerate") {
                        self.samplerate = dict["Samplerate"] as! String
                    }
                }
            }
            public class VideoParams : Tea.TeaModel {
                public var bitrate: String?

                public var codec: String?

                public var fps: String?

                public var gop: String?

                public var height: String?

                public var profile: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Gop") {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioParams: ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.AudioParams?

            public var videoParams: ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.VideoParams?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioParams?.validate()
                try self.videoParams?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioParams != nil {
                    map["AudioParams"] = self.audioParams?.toMap()
                }
                if self.videoParams != nil {
                    map["VideoParams"] = self.videoParams?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioParams") {
                    var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.AudioParams()
                    model.fromMap(dict["AudioParams"] as! [String: Any])
                    self.audioParams = model
                }
                if dict.keys.contains("VideoParams") {
                    var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig.VideoParams()
                    model.fromMap(dict["VideoParams"] as! [String: Any])
                    self.videoParams = model
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var name: String?

        public var templateConfig: ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.templateConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList.TemplateConfig()
                model.fromMap(dict["TemplateConfig"] as! [String: Any])
                self.templateConfig = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateContentList: [ListLiveTranscodeTemplatesResponseBody.TemplateContentList]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateContentList != nil {
            var tmp : [Any] = []
            for k in self.templateContentList! {
                tmp.append(k.toMap())
            }
            map["TemplateContentList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateContentList") {
            var tmp : [ListLiveTranscodeTemplatesResponseBody.TemplateContentList] = []
            for v in dict["TemplateContentList"] as! [Any] {
                var model = ListLiveTranscodeTemplatesResponseBody.TemplateContentList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateContentList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListLiveTranscodeTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveTranscodeTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveTranscodeTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaBasicInfosRequest : Tea.TeaModel {
    public var businessType: String?

    public var endTime: String?

    public var includeFileBasicInfo: Bool?

    public var maxResults: Int32?

    public var mediaId: String?

    public var mediaType: String?

    public var nextToken: String?

    public var sortBy: String?

    public var source: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.includeFileBasicInfo != nil {
            map["IncludeFileBasicInfo"] = self.includeFileBasicInfo!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IncludeFileBasicInfo") {
            self.includeFileBasicInfo = dict["IncludeFileBasicInfo"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListMediaBasicInfosResponseBody : Tea.TeaModel {
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var createTime: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var modifiedTime: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var cateId: Int64?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var referenceId: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var uploadSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.uploadSource != nil {
                    map["UploadSource"] = self.uploadSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UploadSource") {
                    self.uploadSource = dict["UploadSource"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: ListMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                var tmp : [ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = ListMediaBasicInfosResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = ListMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var mediaInfos: [ListMediaBasicInfosResponseBody.MediaInfos]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaInfos") {
            var tmp : [ListMediaBasicInfosResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = ListMediaBasicInfosResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListMediaBasicInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaBasicInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaBasicInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaInfoJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListMediaInfoJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    var tmp : [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    var tmp : [ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: ListMediaInfoJobsResponseBody.Jobs.Input?

        public var jobId: String?

        public var mediaInfoProperty: ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: ListMediaInfoJobsResponseBody.Jobs.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = ListMediaInfoJobsResponseBody.Jobs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") {
                var model = ListMediaInfoJobsResponseBody.Jobs.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = ListMediaInfoJobsResponseBody.Jobs.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var jobs: [ListMediaInfoJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            var tmp : [ListMediaInfoJobsResponseBody.Jobs] = []
            for v in dict["Jobs"] as! [Any] {
                var model = ListMediaInfoJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaInfoJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaInfoJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaInfoJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaLiveChannelsRequest : Tea.TeaModel {
    public var keyword: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var skip: Int32?

    public var sortOrder: String?

    public var states: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.skip != nil {
            map["Skip"] = self.skip!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.states != nil {
            map["States"] = self.states!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Skip") {
            self.skip = dict["Skip"] as! Int32
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("States") {
            self.states = dict["States"] as! String
        }
    }
}

public class ListMediaLiveChannelsResponseBody : Tea.TeaModel {
    public class Channels : Tea.TeaModel {
        public class AudioSettings : Tea.TeaModel {
            public class AudioCodecSetting : Tea.TeaModel {
                public var bitrate: Int32?

                public var profile: String?

                public var sampleRate: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! Int32
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! Int32
                    }
                }
            }
            public var audioCodec: String?

            public var audioCodecSetting: ListMediaLiveChannelsResponseBody.Channels.AudioSettings.AudioCodecSetting?

            public var audioSelectorName: String?

            public var languageCode: String?

            public var languageName: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioCodecSetting?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioCodec != nil {
                    map["AudioCodec"] = self.audioCodec!
                }
                if self.audioCodecSetting != nil {
                    map["AudioCodecSetting"] = self.audioCodecSetting?.toMap()
                }
                if self.audioSelectorName != nil {
                    map["AudioSelectorName"] = self.audioSelectorName!
                }
                if self.languageCode != nil {
                    map["LanguageCode"] = self.languageCode!
                }
                if self.languageName != nil {
                    map["LanguageName"] = self.languageName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioCodec") {
                    self.audioCodec = dict["AudioCodec"] as! String
                }
                if dict.keys.contains("AudioCodecSetting") {
                    var model = ListMediaLiveChannelsResponseBody.Channels.AudioSettings.AudioCodecSetting()
                    model.fromMap(dict["AudioCodecSetting"] as! [String: Any])
                    self.audioCodecSetting = model
                }
                if dict.keys.contains("AudioSelectorName") {
                    self.audioSelectorName = dict["AudioSelectorName"] as! String
                }
                if dict.keys.contains("LanguageCode") {
                    self.languageCode = dict["LanguageCode"] as! String
                }
                if dict.keys.contains("LanguageName") {
                    self.languageName = dict["LanguageName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public class InputAttachments : Tea.TeaModel {
            public class AudioSelectors : Tea.TeaModel {
                public class AudioLanguageSelection : Tea.TeaModel {
                    public var languageCode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.languageCode != nil {
                            map["LanguageCode"] = self.languageCode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LanguageCode") {
                            self.languageCode = dict["LanguageCode"] as! String
                        }
                    }
                }
                public class AudioPidSelection : Tea.TeaModel {
                    public var pid: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.pid != nil {
                            map["Pid"] = self.pid!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Pid") {
                            self.pid = dict["Pid"] as! Int64
                        }
                    }
                }
                public class AudioTrackSelection : Tea.TeaModel {
                    public var trackId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.trackId != nil {
                            map["TrackId"] = self.trackId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TrackId") {
                            self.trackId = dict["TrackId"] as! Int64
                        }
                    }
                }
                public var audioLanguageSelection: ListMediaLiveChannelsResponseBody.Channels.InputAttachments.AudioSelectors.AudioLanguageSelection?

                public var audioPidSelection: ListMediaLiveChannelsResponseBody.Channels.InputAttachments.AudioSelectors.AudioPidSelection?

                public var audioTrackSelection: [ListMediaLiveChannelsResponseBody.Channels.InputAttachments.AudioSelectors.AudioTrackSelection]?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.audioLanguageSelection?.validate()
                    try self.audioPidSelection?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioLanguageSelection != nil {
                        map["AudioLanguageSelection"] = self.audioLanguageSelection?.toMap()
                    }
                    if self.audioPidSelection != nil {
                        map["AudioPidSelection"] = self.audioPidSelection?.toMap()
                    }
                    if self.audioTrackSelection != nil {
                        var tmp : [Any] = []
                        for k in self.audioTrackSelection! {
                            tmp.append(k.toMap())
                        }
                        map["AudioTrackSelection"] = tmp
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioLanguageSelection") {
                        var model = ListMediaLiveChannelsResponseBody.Channels.InputAttachments.AudioSelectors.AudioLanguageSelection()
                        model.fromMap(dict["AudioLanguageSelection"] as! [String: Any])
                        self.audioLanguageSelection = model
                    }
                    if dict.keys.contains("AudioPidSelection") {
                        var model = ListMediaLiveChannelsResponseBody.Channels.InputAttachments.AudioSelectors.AudioPidSelection()
                        model.fromMap(dict["AudioPidSelection"] as! [String: Any])
                        self.audioPidSelection = model
                    }
                    if dict.keys.contains("AudioTrackSelection") {
                        var tmp : [ListMediaLiveChannelsResponseBody.Channels.InputAttachments.AudioSelectors.AudioTrackSelection] = []
                        for v in dict["AudioTrackSelection"] as! [Any] {
                            var model = ListMediaLiveChannelsResponseBody.Channels.InputAttachments.AudioSelectors.AudioTrackSelection()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.audioTrackSelection = tmp
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var audioSelectors: [ListMediaLiveChannelsResponseBody.Channels.InputAttachments.AudioSelectors]?

            public var inputId: String?

            public var inputName: String?

            public var languageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioSelectors != nil {
                    var tmp : [Any] = []
                    for k in self.audioSelectors! {
                        tmp.append(k.toMap())
                    }
                    map["AudioSelectors"] = tmp
                }
                if self.inputId != nil {
                    map["InputId"] = self.inputId!
                }
                if self.inputName != nil {
                    map["InputName"] = self.inputName!
                }
                if self.languageName != nil {
                    map["LanguageName"] = self.languageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioSelectors") {
                    var tmp : [ListMediaLiveChannelsResponseBody.Channels.InputAttachments.AudioSelectors] = []
                    for v in dict["AudioSelectors"] as! [Any] {
                        var model = ListMediaLiveChannelsResponseBody.Channels.InputAttachments.AudioSelectors()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioSelectors = tmp
                }
                if dict.keys.contains("InputId") {
                    self.inputId = dict["InputId"] as! String
                }
                if dict.keys.contains("InputName") {
                    self.inputName = dict["InputName"] as! String
                }
                if dict.keys.contains("LanguageName") {
                    self.languageName = dict["LanguageName"] as! String
                }
            }
        }
        public class OutputGroups : Tea.TeaModel {
            public class MediaPackageGroupSetting : Tea.TeaModel {
                public var channelName: String?

                public var groupName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channelName != nil {
                        map["ChannelName"] = self.channelName!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ChannelName") {
                        self.channelName = dict["ChannelName"] as! String
                    }
                    if dict.keys.contains("GroupName") {
                        self.groupName = dict["GroupName"] as! String
                    }
                }
            }
            public class Outputs : Tea.TeaModel {
                public class MediaPackageOutputSetting : Tea.TeaModel {
                    public var audioGroupId: String?

                    public var nameModifier: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioGroupId != nil {
                            map["AudioGroupId"] = self.audioGroupId!
                        }
                        if self.nameModifier != nil {
                            map["NameModifier"] = self.nameModifier!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioGroupId") {
                            self.audioGroupId = dict["AudioGroupId"] as! String
                        }
                        if dict.keys.contains("NameModifier") {
                            self.nameModifier = dict["NameModifier"] as! String
                        }
                    }
                }
                public var audioSettingNames: [String]?

                public var mediaPackageOutputSetting: ListMediaLiveChannelsResponseBody.Channels.OutputGroups.Outputs.MediaPackageOutputSetting?

                public var mediaType: Int32?

                public var name: String?

                public var videoSettingName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.mediaPackageOutputSetting?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioSettingNames != nil {
                        map["AudioSettingNames"] = self.audioSettingNames!
                    }
                    if self.mediaPackageOutputSetting != nil {
                        map["MediaPackageOutputSetting"] = self.mediaPackageOutputSetting?.toMap()
                    }
                    if self.mediaType != nil {
                        map["MediaType"] = self.mediaType!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.videoSettingName != nil {
                        map["VideoSettingName"] = self.videoSettingName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioSettingNames") {
                        self.audioSettingNames = dict["AudioSettingNames"] as! [String]
                    }
                    if dict.keys.contains("MediaPackageOutputSetting") {
                        var model = ListMediaLiveChannelsResponseBody.Channels.OutputGroups.Outputs.MediaPackageOutputSetting()
                        model.fromMap(dict["MediaPackageOutputSetting"] as! [String: Any])
                        self.mediaPackageOutputSetting = model
                    }
                    if dict.keys.contains("MediaType") {
                        self.mediaType = dict["MediaType"] as! Int32
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("VideoSettingName") {
                        self.videoSettingName = dict["VideoSettingName"] as! String
                    }
                }
            }
            public var mediaPackageGroupSetting: ListMediaLiveChannelsResponseBody.Channels.OutputGroups.MediaPackageGroupSetting?

            public var monitorUrl: String?

            public var name: String?

            public var outputs: [ListMediaLiveChannelsResponseBody.Channels.OutputGroups.Outputs]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.mediaPackageGroupSetting?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mediaPackageGroupSetting != nil {
                    map["MediaPackageGroupSetting"] = self.mediaPackageGroupSetting?.toMap()
                }
                if self.monitorUrl != nil {
                    map["MonitorUrl"] = self.monitorUrl!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outputs != nil {
                    var tmp : [Any] = []
                    for k in self.outputs! {
                        tmp.append(k.toMap())
                    }
                    map["Outputs"] = tmp
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MediaPackageGroupSetting") {
                    var model = ListMediaLiveChannelsResponseBody.Channels.OutputGroups.MediaPackageGroupSetting()
                    model.fromMap(dict["MediaPackageGroupSetting"] as! [String: Any])
                    self.mediaPackageGroupSetting = model
                }
                if dict.keys.contains("MonitorUrl") {
                    self.monitorUrl = dict["MonitorUrl"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Outputs") {
                    var tmp : [ListMediaLiveChannelsResponseBody.Channels.OutputGroups.Outputs] = []
                    for v in dict["Outputs"] as! [Any] {
                        var model = ListMediaLiveChannelsResponseBody.Channels.OutputGroups.Outputs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.outputs = tmp
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class VideoSettings : Tea.TeaModel {
            public class VideoCodecSetting : Tea.TeaModel {
                public class CodecDetail : Tea.TeaModel {
                    public var level: String?

                    public var profile: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Level") {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                    }
                }
                public class Framerate : Tea.TeaModel {
                    public var framerateControl: String?

                    public var framerateDenominator: Int32?

                    public var framerateNumerator: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.framerateControl != nil {
                            map["FramerateControl"] = self.framerateControl!
                        }
                        if self.framerateDenominator != nil {
                            map["FramerateDenominator"] = self.framerateDenominator!
                        }
                        if self.framerateNumerator != nil {
                            map["FramerateNumerator"] = self.framerateNumerator!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FramerateControl") {
                            self.framerateControl = dict["FramerateControl"] as! String
                        }
                        if dict.keys.contains("FramerateDenominator") {
                            self.framerateDenominator = dict["FramerateDenominator"] as! Int32
                        }
                        if dict.keys.contains("FramerateNumerator") {
                            self.framerateNumerator = dict["FramerateNumerator"] as! Int32
                        }
                    }
                }
                public class Gop : Tea.TeaModel {
                    public var bframesNum: Int32?

                    public var gopSize: Int32?

                    public var gopSizeUnits: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bframesNum != nil {
                            map["BframesNum"] = self.bframesNum!
                        }
                        if self.gopSize != nil {
                            map["GopSize"] = self.gopSize!
                        }
                        if self.gopSizeUnits != nil {
                            map["GopSizeUnits"] = self.gopSizeUnits!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BframesNum") {
                            self.bframesNum = dict["BframesNum"] as! Int32
                        }
                        if dict.keys.contains("GopSize") {
                            self.gopSize = dict["GopSize"] as! Int32
                        }
                        if dict.keys.contains("GopSizeUnits") {
                            self.gopSizeUnits = dict["GopSizeUnits"] as! String
                        }
                    }
                }
                public class Rate : Tea.TeaModel {
                    public var bitrate: Int32?

                    public var bufferSize: Int32?

                    public var maxBitrate: Int32?

                    public var rateControlMode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.bufferSize != nil {
                            map["BufferSize"] = self.bufferSize!
                        }
                        if self.maxBitrate != nil {
                            map["MaxBitrate"] = self.maxBitrate!
                        }
                        if self.rateControlMode != nil {
                            map["RateControlMode"] = self.rateControlMode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! Int32
                        }
                        if dict.keys.contains("BufferSize") {
                            self.bufferSize = dict["BufferSize"] as! Int32
                        }
                        if dict.keys.contains("MaxBitrate") {
                            self.maxBitrate = dict["MaxBitrate"] as! Int32
                        }
                        if dict.keys.contains("RateControlMode") {
                            self.rateControlMode = dict["RateControlMode"] as! String
                        }
                    }
                }
                public var codecDetail: ListMediaLiveChannelsResponseBody.Channels.VideoSettings.VideoCodecSetting.CodecDetail?

                public var framerate: ListMediaLiveChannelsResponseBody.Channels.VideoSettings.VideoCodecSetting.Framerate?

                public var gop: ListMediaLiveChannelsResponseBody.Channels.VideoSettings.VideoCodecSetting.Gop?

                public var rate: ListMediaLiveChannelsResponseBody.Channels.VideoSettings.VideoCodecSetting.Rate?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.codecDetail?.validate()
                    try self.framerate?.validate()
                    try self.gop?.validate()
                    try self.rate?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.codecDetail != nil {
                        map["CodecDetail"] = self.codecDetail?.toMap()
                    }
                    if self.framerate != nil {
                        map["Framerate"] = self.framerate?.toMap()
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop?.toMap()
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CodecDetail") {
                        var model = ListMediaLiveChannelsResponseBody.Channels.VideoSettings.VideoCodecSetting.CodecDetail()
                        model.fromMap(dict["CodecDetail"] as! [String: Any])
                        self.codecDetail = model
                    }
                    if dict.keys.contains("Framerate") {
                        var model = ListMediaLiveChannelsResponseBody.Channels.VideoSettings.VideoCodecSetting.Framerate()
                        model.fromMap(dict["Framerate"] as! [String: Any])
                        self.framerate = model
                    }
                    if dict.keys.contains("Gop") {
                        var model = ListMediaLiveChannelsResponseBody.Channels.VideoSettings.VideoCodecSetting.Gop()
                        model.fromMap(dict["Gop"] as! [String: Any])
                        self.gop = model
                    }
                    if dict.keys.contains("Rate") {
                        var model = ListMediaLiveChannelsResponseBody.Channels.VideoSettings.VideoCodecSetting.Rate()
                        model.fromMap(dict["Rate"] as! [String: Any])
                        self.rate = model
                    }
                }
            }
            public var height: Int32?

            public var name: String?

            public var videoCodec: String?

            public var videoCodecSetting: ListMediaLiveChannelsResponseBody.Channels.VideoSettings.VideoCodecSetting?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.videoCodecSetting?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.videoCodec != nil {
                    map["VideoCodec"] = self.videoCodec!
                }
                if self.videoCodecSetting != nil {
                    map["VideoCodecSetting"] = self.videoCodecSetting?.toMap()
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("VideoCodec") {
                    self.videoCodec = dict["VideoCodec"] as! String
                }
                if dict.keys.contains("VideoCodecSetting") {
                    var model = ListMediaLiveChannelsResponseBody.Channels.VideoSettings.VideoCodecSetting()
                    model.fromMap(dict["VideoCodecSetting"] as! [String: Any])
                    self.videoCodecSetting = model
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var audioSettings: [ListMediaLiveChannelsResponseBody.Channels.AudioSettings]?

        public var channelId: String?

        public var createTime: String?

        public var inputAttachments: [ListMediaLiveChannelsResponseBody.Channels.InputAttachments]?

        public var lastStartTime: String?

        public var lastStopTime: String?

        public var name: String?

        public var outputGroups: [ListMediaLiveChannelsResponseBody.Channels.OutputGroups]?

        public var state: String?

        public var videoSettings: [ListMediaLiveChannelsResponseBody.Channels.VideoSettings]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioSettings != nil {
                var tmp : [Any] = []
                for k in self.audioSettings! {
                    tmp.append(k.toMap())
                }
                map["AudioSettings"] = tmp
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.inputAttachments != nil {
                var tmp : [Any] = []
                for k in self.inputAttachments! {
                    tmp.append(k.toMap())
                }
                map["InputAttachments"] = tmp
            }
            if self.lastStartTime != nil {
                map["LastStartTime"] = self.lastStartTime!
            }
            if self.lastStopTime != nil {
                map["LastStopTime"] = self.lastStopTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroups != nil {
                var tmp : [Any] = []
                for k in self.outputGroups! {
                    tmp.append(k.toMap())
                }
                map["OutputGroups"] = tmp
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.videoSettings != nil {
                var tmp : [Any] = []
                for k in self.videoSettings! {
                    tmp.append(k.toMap())
                }
                map["VideoSettings"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioSettings") {
                var tmp : [ListMediaLiveChannelsResponseBody.Channels.AudioSettings] = []
                for v in dict["AudioSettings"] as! [Any] {
                    var model = ListMediaLiveChannelsResponseBody.Channels.AudioSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.audioSettings = tmp
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("InputAttachments") {
                var tmp : [ListMediaLiveChannelsResponseBody.Channels.InputAttachments] = []
                for v in dict["InputAttachments"] as! [Any] {
                    var model = ListMediaLiveChannelsResponseBody.Channels.InputAttachments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputAttachments = tmp
            }
            if dict.keys.contains("LastStartTime") {
                self.lastStartTime = dict["LastStartTime"] as! String
            }
            if dict.keys.contains("LastStopTime") {
                self.lastStopTime = dict["LastStopTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroups") {
                var tmp : [ListMediaLiveChannelsResponseBody.Channels.OutputGroups] = []
                for v in dict["OutputGroups"] as! [Any] {
                    var model = ListMediaLiveChannelsResponseBody.Channels.OutputGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroups = tmp
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("VideoSettings") {
                var tmp : [ListMediaLiveChannelsResponseBody.Channels.VideoSettings] = []
                for v in dict["VideoSettings"] as! [Any] {
                    var model = ListMediaLiveChannelsResponseBody.Channels.VideoSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.videoSettings = tmp
            }
        }
    }
    public var channels: [ListMediaLiveChannelsResponseBody.Channels]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channels != nil {
            var tmp : [Any] = []
            for k in self.channels! {
                tmp.append(k.toMap())
            }
            map["Channels"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Channels") {
            var tmp : [ListMediaLiveChannelsResponseBody.Channels] = []
            for v in dict["Channels"] as! [Any] {
                var model = ListMediaLiveChannelsResponseBody.Channels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.channels = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListMediaLiveChannelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaLiveChannelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaLiveChannelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaLiveInputSecurityGroupsRequest : Tea.TeaModel {
    public var keyword: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var skip: Int32?

    public var sortOrder: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.skip != nil {
            map["Skip"] = self.skip!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Skip") {
            self.skip = dict["Skip"] as! Int32
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
    }
}

public class ListMediaLiveInputSecurityGroupsResponseBody : Tea.TeaModel {
    public class SecurityGroups : Tea.TeaModel {
        public var createTime: String?

        public var inputIds: [String]?

        public var name: String?

        public var securityGroupId: String?

        public var whitelistRules: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.inputIds != nil {
                map["InputIds"] = self.inputIds!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.whitelistRules != nil {
                map["WhitelistRules"] = self.whitelistRules!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("InputIds") {
                self.inputIds = dict["InputIds"] as! [String]
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("WhitelistRules") {
                self.whitelistRules = dict["WhitelistRules"] as! [String]
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var securityGroups: [ListMediaLiveInputSecurityGroupsResponseBody.SecurityGroups]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroups != nil {
            var tmp : [Any] = []
            for k in self.securityGroups! {
                tmp.append(k.toMap())
            }
            map["SecurityGroups"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroups") {
            var tmp : [ListMediaLiveInputSecurityGroupsResponseBody.SecurityGroups] = []
            for v in dict["SecurityGroups"] as! [Any] {
                var model = ListMediaLiveInputSecurityGroupsResponseBody.SecurityGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityGroups = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListMediaLiveInputSecurityGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaLiveInputSecurityGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaLiveInputSecurityGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaLiveInputsRequest : Tea.TeaModel {
    public var keyword: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var skip: Int32?

    public var sortOrder: String?

    public var types: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.skip != nil {
            map["Skip"] = self.skip!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Skip") {
            self.skip = dict["Skip"] as! Int32
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("Types") {
            self.types = dict["Types"] as! String
        }
    }
}

public class ListMediaLiveInputsResponseBody : Tea.TeaModel {
    public class Inputs : Tea.TeaModel {
        public class InputInfos : Tea.TeaModel {
            public var destHost: String?

            public var flowId: String?

            public var flowOutputName: String?

            public var monitorUrl: String?

            public var sourceUrl: String?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destHost != nil {
                    map["DestHost"] = self.destHost!
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.flowOutputName != nil {
                    map["FlowOutputName"] = self.flowOutputName!
                }
                if self.monitorUrl != nil {
                    map["MonitorUrl"] = self.monitorUrl!
                }
                if self.sourceUrl != nil {
                    map["SourceUrl"] = self.sourceUrl!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DestHost") {
                    self.destHost = dict["DestHost"] as! String
                }
                if dict.keys.contains("FlowId") {
                    self.flowId = dict["FlowId"] as! String
                }
                if dict.keys.contains("FlowOutputName") {
                    self.flowOutputName = dict["FlowOutputName"] as! String
                }
                if dict.keys.contains("MonitorUrl") {
                    self.monitorUrl = dict["MonitorUrl"] as! String
                }
                if dict.keys.contains("SourceUrl") {
                    self.sourceUrl = dict["SourceUrl"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
            }
        }
        public var channelIds: [String]?

        public var createTime: String?

        public var inputId: String?

        public var inputInfos: [ListMediaLiveInputsResponseBody.Inputs.InputInfos]?

        public var name: String?

        public var securityGroupIds: [String]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelIds != nil {
                map["ChannelIds"] = self.channelIds!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.inputId != nil {
                map["InputId"] = self.inputId!
            }
            if self.inputInfos != nil {
                var tmp : [Any] = []
                for k in self.inputInfos! {
                    tmp.append(k.toMap())
                }
                map["InputInfos"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelIds") {
                self.channelIds = dict["ChannelIds"] as! [String]
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("InputId") {
                self.inputId = dict["InputId"] as! String
            }
            if dict.keys.contains("InputInfos") {
                var tmp : [ListMediaLiveInputsResponseBody.Inputs.InputInfos] = []
                for v in dict["InputInfos"] as! [Any] {
                    var model = ListMediaLiveInputsResponseBody.Inputs.InputInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputInfos = tmp
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var inputs: [ListMediaLiveInputsResponseBody.Inputs]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputs != nil {
            var tmp : [Any] = []
            for k in self.inputs! {
                tmp.append(k.toMap())
            }
            map["Inputs"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Inputs") {
            var tmp : [ListMediaLiveInputsResponseBody.Inputs] = []
            for v in dict["Inputs"] as! [Any] {
                var model = ListMediaLiveInputsResponseBody.Inputs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inputs = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListMediaLiveInputsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaLiveInputsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaLiveInputsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
    }
}

public class ListMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaProducingJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var jobType: String?

    public var keyword: String?

    public var masterJobId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var projectId: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.masterJobId != nil {
            map["MasterJobId"] = self.masterJobId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("MasterJobId") {
            self.masterJobId = dict["MasterJobId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListMediaProducingJobsResponseBody : Tea.TeaModel {
    public class MediaProducingJobList : Tea.TeaModel {
        public var clipsParam: String?

        public var code: String?

        public var completeTime: String?

        public var createTime: String?

        public var duration: Double?

        public var jobId: String?

        public var mediaId: String?

        public var mediaURL: String?

        public var message: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var status: String?

        public var templateId: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaURL != nil {
                map["MediaURL"] = self.mediaURL!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaURL") {
                self.mediaURL = dict["MediaURL"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var maxResults: String?

    public var mediaProducingJobList: [ListMediaProducingJobsResponseBody.MediaProducingJobList]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaProducingJobList != nil {
            var tmp : [Any] = []
            for k in self.mediaProducingJobList! {
                tmp.append(k.toMap())
            }
            map["MediaProducingJobList"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! String
        }
        if dict.keys.contains("MediaProducingJobList") {
            var tmp : [ListMediaProducingJobsResponseBody.MediaProducingJobList] = []
            for v in dict["MediaProducingJobList"] as! [Any] {
                var model = ListMediaProducingJobsResponseBody.MediaProducingJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaProducingJobList = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaProducingJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaProducingJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaProducingJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPackageJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListPackageJobsResponseBody : Tea.TeaModel {
    public class PackageJobList : Tea.TeaModel {
        public class PackageJobs : Tea.TeaModel {
            public class Inputs : Tea.TeaModel {
                public class Input : Tea.TeaModel {
                    public var media: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.media != nil {
                            map["Media"] = self.media!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Media") {
                            self.media = dict["Media"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var input: ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs.Input?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.input?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.input != nil {
                        map["Input"] = self.input?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Input") {
                        var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs.Input()
                        model.fromMap(dict["Input"] as! [String: Any])
                        self.input = model
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var code: String?

            public var createTime: String?

            public var finishTime: String?

            public var inputs: [ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs]?

            public var jobId: String?

            public var message: String?

            public var modifiedTime: String?

            public var name: String?

            public var output: ListPackageJobsResponseBody.PackageJobList.PackageJobs.Output?

            public var pipelineId: String?

            public var priority: Int32?

            public var status: String?

            public var submitTime: String?

            public var triggerSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inputs != nil {
                    var tmp : [Any] = []
                    for k in self.inputs! {
                        tmp.append(k.toMap())
                    }
                    map["Inputs"] = tmp
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.triggerSource != nil {
                    map["TriggerSource"] = self.triggerSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Inputs") {
                    var tmp : [ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs] = []
                    for v in dict["Inputs"] as! [Any] {
                        var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs.Inputs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputs = tmp
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Output") {
                    var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitTime") {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("TriggerSource") {
                    self.triggerSource = dict["TriggerSource"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var nextPageToken: String?

        public var packageJobs: [ListPackageJobsResponseBody.PackageJobList.PackageJobs]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextPageToken != nil {
                map["NextPageToken"] = self.nextPageToken!
            }
            if self.packageJobs != nil {
                var tmp : [Any] = []
                for k in self.packageJobs! {
                    tmp.append(k.toMap())
                }
                map["PackageJobs"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextPageToken") {
                self.nextPageToken = dict["NextPageToken"] as! String
            }
            if dict.keys.contains("PackageJobs") {
                var tmp : [ListPackageJobsResponseBody.PackageJobList.PackageJobs] = []
                for v in dict["PackageJobs"] as! [Any] {
                    var model = ListPackageJobsResponseBody.PackageJobList.PackageJobs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.packageJobs = tmp
            }
        }
    }
    public var packageJobList: ListPackageJobsResponseBody.PackageJobList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packageJobList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packageJobList != nil {
            map["PackageJobList"] = self.packageJobList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackageJobList") {
            var model = ListPackageJobsResponseBody.PackageJobList()
            model.fromMap(dict["PackageJobList"] as! [String: Any])
            self.packageJobList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPackageJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPackageJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPackageJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelinesRequest : Tea.TeaModel {
    public var speed: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.speed != nil {
            map["Speed"] = self.speed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Speed") {
            self.speed = dict["Speed"] as! String
        }
    }
}

public class ListPipelinesResponseBody : Tea.TeaModel {
    public class PipelineList : Tea.TeaModel {
        public var createTime: String?

        public var modifiedTime: String?

        public var name: String?

        public var pipelineId: String?

        public var priority: Int32?

        public var speed: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipelineList: [ListPipelinesResponseBody.PipelineList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineList != nil {
            var tmp : [Any] = []
            for k in self.pipelineList! {
                tmp.append(k.toMap())
            }
            map["PipelineList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineList") {
            var tmp : [ListPipelinesResponseBody.PipelineList] = []
            for v in dict["PipelineList"] as! [Any] {
                var model = ListPipelinesResponseBody.PipelineList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.pipelineList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPipelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProgramsRequest : Tea.TeaModel {
    public var channelName: String?

    public var pageNo: String?

    public var pageSize: String?

    public var programName: String?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("ProgramName") {
            self.programName = dict["ProgramName"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class ListProgramsResponseBody : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var programs: [ChannelAssemblyProgram]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.programs != nil {
            var tmp : [Any] = []
            for k in self.programs! {
                tmp.append(k.toMap())
            }
            map["Programs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Programs") {
            var tmp : [ChannelAssemblyProgram] = []
            for v in dict["Programs"] as! [Any] {
                var model = ChannelAssemblyProgram()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.programs = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListProgramsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProgramsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProgramsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPublicMediaBasicInfosRequest : Tea.TeaModel {
    public var businessType: String?

    public var includeFileBasicInfo: Bool?

    public var maxResults: Int32?

    public var mediaTagId: String?

    public var nextToken: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.includeFileBasicInfo != nil {
            map["IncludeFileBasicInfo"] = self.includeFileBasicInfo!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaTagId != nil {
            map["MediaTagId"] = self.mediaTagId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("IncludeFileBasicInfo") {
            self.includeFileBasicInfo = dict["IncludeFileBasicInfo"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaTagId") {
            self.mediaTagId = dict["MediaTagId"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListPublicMediaBasicInfosResponseBody : Tea.TeaModel {
    public class MediaInfos : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var businessType: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var snapshots: String?

            public var source: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fileInfoList: [ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList]?

        public var mediaBasicInfo: ListPublicMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileInfoList") {
                var tmp : [ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = ListPublicMediaBasicInfosResponseBody.MediaInfos.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = ListPublicMediaBasicInfosResponseBody.MediaInfos.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var mediaInfos: [ListPublicMediaBasicInfosResponseBody.MediaInfos]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.mediaInfos != nil {
            var tmp : [Any] = []
            for k in self.mediaInfos! {
                tmp.append(k.toMap())
            }
            map["MediaInfos"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MediaInfos") {
            var tmp : [ListPublicMediaBasicInfosResponseBody.MediaInfos] = []
            for v in dict["MediaInfos"] as! [Any] {
                var model = ListPublicMediaBasicInfosResponseBody.MediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfos = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListPublicMediaBasicInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPublicMediaBasicInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPublicMediaBasicInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSchedulesRequest : Tea.TeaModel {
    public var channelName: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var windowDurationSeconds: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.windowDurationSeconds != nil {
            map["WindowDurationSeconds"] = self.windowDurationSeconds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("WindowDurationSeconds") {
            self.windowDurationSeconds = dict["WindowDurationSeconds"] as! Int64
        }
    }
}

public class ListSchedulesResponseBody : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var programs: [ChannelAssemblyScheduleData]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.programs != nil {
            var tmp : [Any] = []
            for k in self.programs! {
                tmp.append(k.toMap())
            }
            map["Programs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Programs") {
            var tmp : [ChannelAssemblyScheduleData] = []
            for v in dict["Programs"] as! [Any] {
                var model = ChannelAssemblyScheduleData()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.programs = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListSchedulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSchedulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSchedulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSearchLibRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListSearchLibResponseBody : Tea.TeaModel {
    public class SearchLibInfoList : Tea.TeaModel {
        public class IndexInfo : Tea.TeaModel {
            public var indexReadiness: String?

            public var indexStatus: String?

            public var indexType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.indexReadiness != nil {
                    map["IndexReadiness"] = self.indexReadiness!
                }
                if self.indexStatus != nil {
                    map["IndexStatus"] = self.indexStatus!
                }
                if self.indexType != nil {
                    map["IndexType"] = self.indexType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IndexReadiness") {
                    self.indexReadiness = dict["IndexReadiness"] as! String
                }
                if dict.keys.contains("IndexStatus") {
                    self.indexStatus = dict["IndexStatus"] as! String
                }
                if dict.keys.contains("IndexType") {
                    self.indexType = dict["IndexType"] as! String
                }
            }
        }
        public var indexInfo: [ListSearchLibResponseBody.SearchLibInfoList.IndexInfo]?

        public var searchLibName: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.indexInfo != nil {
                var tmp : [Any] = []
                for k in self.indexInfo! {
                    tmp.append(k.toMap())
                }
                map["IndexInfo"] = tmp
            }
            if self.searchLibName != nil {
                map["SearchLibName"] = self.searchLibName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IndexInfo") {
                var tmp : [ListSearchLibResponseBody.SearchLibInfoList.IndexInfo] = []
                for v in dict["IndexInfo"] as! [Any] {
                    var model = ListSearchLibResponseBody.SearchLibInfoList.IndexInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.indexInfo = tmp
            }
            if dict.keys.contains("SearchLibName") {
                self.searchLibName = dict["SearchLibName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var requestId: String?

    public var searchLibInfoList: [ListSearchLibResponseBody.SearchLibInfoList]?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchLibInfoList != nil {
            var tmp : [Any] = []
            for k in self.searchLibInfoList! {
                tmp.append(k.toMap())
            }
            map["SearchLibInfoList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchLibInfoList") {
            var tmp : [ListSearchLibResponseBody.SearchLibInfoList] = []
            for v in dict["SearchLibInfoList"] as! [Any] {
                var model = ListSearchLibResponseBody.SearchLibInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.searchLibInfoList = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class ListSearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSmartJobsRequest : Tea.TeaModel {
    public var jobState: String?

    public var jobType: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobState != nil {
            map["JobState"] = self.jobState!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobState") {
            self.jobState = dict["JobState"] as! String
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class ListSmartJobsResponseBody : Tea.TeaModel {
    public class SmartJobList : Tea.TeaModel {
        public class InputConfig : Tea.TeaModel {
            public var inputFile: String?

            public var keyword: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputFile != nil {
                    map["InputFile"] = self.inputFile!
                }
                if self.keyword != nil {
                    map["Keyword"] = self.keyword!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputFile") {
                    self.inputFile = dict["InputFile"] as! String
                }
                if dict.keys.contains("Keyword") {
                    self.keyword = dict["Keyword"] as! String
                }
            }
        }
        public class OutputConfig : Tea.TeaModel {
            public var bucket: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public var createTime: String?

        public var description_: String?

        public var editingConfig: String?

        public var inputConfig: ListSmartJobsResponseBody.SmartJobList.InputConfig?

        public var jobId: String?

        public var jobState: String?

        public var jobType: String?

        public var modifiedTime: String?

        public var outputConfig: ListSmartJobsResponseBody.SmartJobList.OutputConfig?

        public var title: String?

        public var userData: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inputConfig?.validate()
            try self.outputConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.editingConfig != nil {
                map["EditingConfig"] = self.editingConfig!
            }
            if self.inputConfig != nil {
                map["InputConfig"] = self.inputConfig?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobState != nil {
                map["JobState"] = self.jobState!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.outputConfig != nil {
                map["OutputConfig"] = self.outputConfig?.toMap()
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EditingConfig") {
                self.editingConfig = dict["EditingConfig"] as! String
            }
            if dict.keys.contains("InputConfig") {
                var model = ListSmartJobsResponseBody.SmartJobList.InputConfig()
                model.fromMap(dict["InputConfig"] as! [String: Any])
                self.inputConfig = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobState") {
                self.jobState = dict["JobState"] as! String
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OutputConfig") {
                var model = ListSmartJobsResponseBody.SmartJobList.OutputConfig()
                model.fromMap(dict["OutputConfig"] as! [String: Any])
                self.outputConfig = model
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var maxResults: String?

    public var nextToken: String?

    public var requestId: String?

    public var smartJobList: [ListSmartJobsResponseBody.SmartJobList]?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.smartJobList != nil {
            var tmp : [Any] = []
            for k in self.smartJobList! {
                tmp.append(k.toMap())
            }
            map["SmartJobList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SmartJobList") {
            var tmp : [ListSmartJobsResponseBody.SmartJobList] = []
            for v in dict["SmartJobList"] as! [Any] {
                var model = ListSmartJobsResponseBody.SmartJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.smartJobList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListSmartJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSmartJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSmartJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSmartSysAvatarModelsRequest : Tea.TeaModel {
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sdkVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sdkVersion != nil {
            map["SdkVersion"] = self.sdkVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SdkVersion") {
            self.sdkVersion = dict["SdkVersion"] as! String
        }
    }
}

public class ListSmartSysAvatarModelsResponseBody : Tea.TeaModel {
    public class SmartSysAvatarModelList : Tea.TeaModel {
        public var avatarId: String?

        public var avatarName: String?

        public var bitrate: Int32?

        public var coverUrl: String?

        public var height: Int32?

        public var outputMask: Bool?

        public var videoUrl: String?

        public var width: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarId != nil {
                map["AvatarId"] = self.avatarId!
            }
            if self.avatarName != nil {
                map["AvatarName"] = self.avatarName!
            }
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.outputMask != nil {
                map["OutputMask"] = self.outputMask!
            }
            if self.videoUrl != nil {
                map["VideoUrl"] = self.videoUrl!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarId") {
                self.avatarId = dict["AvatarId"] as! String
            }
            if dict.keys.contains("AvatarName") {
                self.avatarName = dict["AvatarName"] as! String
            }
            if dict.keys.contains("Bitrate") {
                self.bitrate = dict["Bitrate"] as! Int32
            }
            if dict.keys.contains("CoverUrl") {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("OutputMask") {
                self.outputMask = dict["OutputMask"] as! Bool
            }
            if dict.keys.contains("VideoUrl") {
                self.videoUrl = dict["VideoUrl"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var smartSysAvatarModelList: [ListSmartSysAvatarModelsResponseBody.SmartSysAvatarModelList]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.smartSysAvatarModelList != nil {
            var tmp : [Any] = []
            for k in self.smartSysAvatarModelList! {
                tmp.append(k.toMap())
            }
            map["SmartSysAvatarModelList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SmartSysAvatarModelList") {
            var tmp : [ListSmartSysAvatarModelsResponseBody.SmartSysAvatarModelList] = []
            for v in dict["SmartSysAvatarModelList"] as! [Any] {
                var model = ListSmartSysAvatarModelsResponseBody.SmartSysAvatarModelList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.smartSysAvatarModelList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListSmartSysAvatarModelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSmartSysAvatarModelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSmartSysAvatarModelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSmartVoiceGroupsRequest : Tea.TeaModel {
    public var voiceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.voiceType != nil {
            map["VoiceType"] = self.voiceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VoiceType") {
            self.voiceType = dict["VoiceType"] as! String
        }
    }
}

public class ListSmartVoiceGroupsResponseBody : Tea.TeaModel {
    public class VoiceGroups : Tea.TeaModel {
        public class VoiceList : Tea.TeaModel {
            public var desc: String?

            public var name: String?

            public var remark: String?

            public var supportSampleRate: String?

            public var tag: String?

            public var voice: String?

            public var voiceType: String?

            public var voiceUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.supportSampleRate != nil {
                    map["SupportSampleRate"] = self.supportSampleRate!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.voice != nil {
                    map["Voice"] = self.voice!
                }
                if self.voiceType != nil {
                    map["VoiceType"] = self.voiceType!
                }
                if self.voiceUrl != nil {
                    map["VoiceUrl"] = self.voiceUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Desc") {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("SupportSampleRate") {
                    self.supportSampleRate = dict["SupportSampleRate"] as! String
                }
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Voice") {
                    self.voice = dict["Voice"] as! String
                }
                if dict.keys.contains("VoiceType") {
                    self.voiceType = dict["VoiceType"] as! String
                }
                if dict.keys.contains("VoiceUrl") {
                    self.voiceUrl = dict["VoiceUrl"] as! String
                }
            }
        }
        public var type: String?

        public var voiceList: [ListSmartVoiceGroupsResponseBody.VoiceGroups.VoiceList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.voiceList != nil {
                var tmp : [Any] = []
                for k in self.voiceList! {
                    tmp.append(k.toMap())
                }
                map["VoiceList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("VoiceList") {
                var tmp : [ListSmartVoiceGroupsResponseBody.VoiceGroups.VoiceList] = []
                for v in dict["VoiceList"] as! [Any] {
                    var model = ListSmartVoiceGroupsResponseBody.VoiceGroups.VoiceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.voiceList = tmp
            }
        }
    }
    public var requestId: String?

    public var voiceGroups: [ListSmartVoiceGroupsResponseBody.VoiceGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.voiceGroups != nil {
            var tmp : [Any] = []
            for k in self.voiceGroups! {
                tmp.append(k.toMap())
            }
            map["VoiceGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VoiceGroups") {
            var tmp : [ListSmartVoiceGroupsResponseBody.VoiceGroups] = []
            for v in dict["VoiceGroups"] as! [Any] {
                var model = ListSmartVoiceGroupsResponseBody.VoiceGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.voiceGroups = tmp
        }
    }
}

public class ListSmartVoiceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSmartVoiceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSmartVoiceGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSnapshotJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListSnapshotJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var async: Bool?

        public var count: Int32?

        public var createTime: String?

        public var finishTime: String?

        public var input: ListSnapshotJobsResponseBody.Jobs.Input?

        public var jobId: String?

        public var modifiedTime: String?

        public var name: String?

        public var output: ListSnapshotJobsResponseBody.Jobs.Output?

        public var pipelineId: String?

        public var status: String?

        public var submitTime: String?

        public var templateId: String?

        public var triggerSource: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = ListSnapshotJobsResponseBody.Jobs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Output") {
                var model = ListSnapshotJobsResponseBody.Jobs.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var jobs: [ListSnapshotJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            var tmp : [ListSnapshotJobsResponseBody.Jobs] = []
            for v in dict["Jobs"] as! [Any] {
                var model = ListSnapshotJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSnapshotJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSnapshotJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSnapshotJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSourceLocationsRequest : Tea.TeaModel {
    public var filterState: Bool?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var sortByModifiedTime: String?

    public var sourceLocationName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filterState != nil {
            map["FilterState"] = self.filterState!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.sortByModifiedTime != nil {
            map["SortByModifiedTime"] = self.sortByModifiedTime!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilterState") {
            self.filterState = dict["FilterState"] as! Bool
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("SortByModifiedTime") {
            self.sortByModifiedTime = dict["SortByModifiedTime"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
    }
}

public class ListSourceLocationsResponseBody : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sourceLocationList: [ChannelAssemblySourceLocation]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceLocationList != nil {
            var tmp : [Any] = []
            for k in self.sourceLocationList! {
                tmp.append(k.toMap())
            }
            map["SourceLocationList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceLocationList") {
            var tmp : [ChannelAssemblySourceLocation] = []
            for v in dict["SourceLocationList"] as! [Any] {
                var model = ChannelAssemblySourceLocation()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sourceLocationList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListSourceLocationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSourceLocationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSourceLocationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSourcesRequest : Tea.TeaModel {
    public var filterState: Bool?

    public var pageNo: String?

    public var pageSize: String?

    public var sortBy: String?

    public var sortByModifiedTime: String?

    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filterState != nil {
            map["FilterState"] = self.filterState!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.sortByModifiedTime != nil {
            map["SortByModifiedTime"] = self.sortByModifiedTime!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilterState") {
            self.filterState = dict["FilterState"] as! Bool
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("SortByModifiedTime") {
            self.sortByModifiedTime = dict["SortByModifiedTime"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class ListSourcesResponseBody : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sourceList: [ChannelAssemblySource]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceList != nil {
            var tmp : [Any] = []
            for k in self.sourceList! {
                tmp.append(k.toMap())
            }
            map["SourceList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceList") {
            var tmp : [ChannelAssemblySource] = []
            for v in dict["SourceList"] as! [Any] {
                var model = ChannelAssemblySource()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sourceList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSystemTemplatesRequest : Tea.TeaModel {
    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var subtype: String?

    public var templateId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subtype != nil {
            map["Subtype"] = self.subtype!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Subtype") {
            self.subtype = dict["Subtype"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListSystemTemplatesResponseBody : Tea.TeaModel {
    public class SystemTemplateList : Tea.TeaModel {
        public var status: String?

        public var subtype: Int32?

        public var subtypeName: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var type: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subtype != nil {
                map["Subtype"] = self.subtype!
            }
            if self.subtypeName != nil {
                map["SubtypeName"] = self.subtypeName!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Subtype") {
                self.subtype = dict["Subtype"] as! Int32
            }
            if dict.keys.contains("SubtypeName") {
                self.subtypeName = dict["SubtypeName"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var requestId: String?

    public var systemTemplateList: [ListSystemTemplatesResponseBody.SystemTemplateList]?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemTemplateList != nil {
            var tmp : [Any] = []
            for k in self.systemTemplateList! {
                tmp.append(k.toMap())
            }
            map["SystemTemplateList"] = tmp
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemTemplateList") {
            var tmp : [ListSystemTemplatesResponseBody.SystemTemplateList] = []
            for v in dict["SystemTemplateList"] as! [Any] {
                var model = ListSystemTemplatesResponseBody.SystemTemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.systemTemplateList = tmp
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListSystemTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSystemTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSystemTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTemplatesRequest : Tea.TeaModel {
    public var createSource: String?

    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortType: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createSource != nil {
            map["CreateSource"] = self.createSource!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateSource") {
            self.createSource = dict["CreateSource"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortType") {
            self.sortType = dict["SortType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListTemplatesResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public var clipsParam: String?

        public var config: String?

        public var coverURL: String?

        public var createSource: String?

        public var creationTime: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var name: String?

        public var previewMedia: String?

        public var previewMediaStatus: String?

        public var status: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipsParam != nil {
                map["ClipsParam"] = self.clipsParam!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.previewMedia != nil {
                map["PreviewMedia"] = self.previewMedia!
            }
            if self.previewMediaStatus != nil {
                map["PreviewMediaStatus"] = self.previewMediaStatus!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipsParam") {
                self.clipsParam = dict["ClipsParam"] as! String
            }
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PreviewMedia") {
                self.previewMedia = dict["PreviewMedia"] as! String
            }
            if dict.keys.contains("PreviewMediaStatus") {
                self.previewMediaStatus = dict["PreviewMediaStatus"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var templates: [ListTemplatesResponseBody.Templates]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templates != nil {
            var tmp : [Any] = []
            for k in self.templates! {
                tmp.append(k.toMap())
            }
            map["Templates"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Templates") {
            var tmp : [ListTemplatesResponseBody.Templates] = []
            for v in dict["Templates"] as! [Any] {
                var model = ListTemplatesResponseBody.Templates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templates = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTranscodeJobsRequest : Tea.TeaModel {
    public var endOfCreateTime: String?

    public var nextPageToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var parentJobId: String?

    public var startOfCreateTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfCreateTime != nil {
            map["EndOfCreateTime"] = self.endOfCreateTime!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentJobId != nil {
            map["ParentJobId"] = self.parentJobId!
        }
        if self.startOfCreateTime != nil {
            map["StartOfCreateTime"] = self.startOfCreateTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfCreateTime") {
            self.endOfCreateTime = dict["EndOfCreateTime"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ParentJobId") {
            self.parentJobId = dict["ParentJobId"] as! String
        }
        if dict.keys.contains("StartOfCreateTime") {
            self.startOfCreateTime = dict["StartOfCreateTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListTranscodeJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class InputGroup : Tea.TeaModel {
            public var inputUrl: String?

            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InputUrl") {
                    self.inputUrl = dict["InputUrl"] as! String
                }
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class OutputGroup : Tea.TeaModel {
            public class Output : Tea.TeaModel {
                public var media: String?

                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var tags: [String: String]?

                        public var video: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.tags != nil {
                                map["Tags"] = self.tags!
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("Tags") {
                                self.tags = dict["Tags"] as! [String: String]
                            }
                            if dict.keys.contains("Video") {
                                var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.CombineConfigs]?

                public var encryption: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Encryption?

                public var imageWatermarks: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks]?

                public var isInheritTags: Bool?

                public var subtitles: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles]?

                public var textWatermarks: [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks]?

                public var transcode: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.isInheritTags != nil {
                        map["IsInheritTags"] = self.isInheritTags!
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") {
                        var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("IsInheritTags") {
                        self.isInheritTags = dict["IsInheritTags"] as! Bool
                    }
                    if dict.keys.contains("Subtitles") {
                        var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") {
                        var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") {
                        var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public var output: ListTranscodeJobsResponseBody.Jobs.OutputGroup.Output?

            public var processConfig: ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
                try self.processConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Output") {
                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var inputGroup: [ListTranscodeJobsResponseBody.Jobs.InputGroup]?

        public var jobCount: Int32?

        public var name: String?

        public var outputGroup: [ListTranscodeJobsResponseBody.Jobs.OutputGroup]?

        public var parentJobId: String?

        public var percent: Int32?

        public var requestId: String?

        public var scheduleConfig: ListTranscodeJobsResponseBody.Jobs.ScheduleConfig?

        public var status: String?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputGroup != nil {
                var tmp : [Any] = []
                for k in self.inputGroup! {
                    tmp.append(k.toMap())
                }
                map["InputGroup"] = tmp
            }
            if self.jobCount != nil {
                map["JobCount"] = self.jobCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroup != nil {
                var tmp : [Any] = []
                for k in self.outputGroup! {
                    tmp.append(k.toMap())
                }
                map["OutputGroup"] = tmp
            }
            if self.parentJobId != nil {
                map["ParentJobId"] = self.parentJobId!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("InputGroup") {
                var tmp : [ListTranscodeJobsResponseBody.Jobs.InputGroup] = []
                for v in dict["InputGroup"] as! [Any] {
                    var model = ListTranscodeJobsResponseBody.Jobs.InputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputGroup = tmp
            }
            if dict.keys.contains("JobCount") {
                self.jobCount = dict["JobCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroup") {
                var tmp : [ListTranscodeJobsResponseBody.Jobs.OutputGroup] = []
                for v in dict["OutputGroup"] as! [Any] {
                    var model = ListTranscodeJobsResponseBody.Jobs.OutputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroup = tmp
            }
            if dict.keys.contains("ParentJobId") {
                self.parentJobId = dict["ParentJobId"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = ListTranscodeJobsResponseBody.Jobs.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var jobs: [ListTranscodeJobsResponseBody.Jobs]?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Jobs") {
            var tmp : [ListTranscodeJobsResponseBody.Jobs] = []
            for v in dict["Jobs"] as! [Any] {
                var model = ListTranscodeJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTranscodeJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTranscodeJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTranscodeJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVodPackagingAssetsRequest : Tea.TeaModel {
    public var groupName: String?

    public var keyword: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class ListVodPackagingAssetsResponseBody : Tea.TeaModel {
    public class Assets : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var assetName: String?

        public var createTime: String?

        public var description_: String?

        public var groupName: String?

        public var input: ListVodPackagingAssetsResponseBody.Assets.Input?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assetName != nil {
                map["AssetName"] = self.assetName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssetName") {
                self.assetName = dict["AssetName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Input") {
                var model = ListVodPackagingAssetsResponseBody.Assets.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
        }
    }
    public var assets: [ListVodPackagingAssetsResponseBody.Assets]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assets != nil {
            var tmp : [Any] = []
            for k in self.assets! {
                tmp.append(k.toMap())
            }
            map["Assets"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Assets") {
            var tmp : [ListVodPackagingAssetsResponseBody.Assets] = []
            for v in dict["Assets"] as! [Any] {
                var model = ListVodPackagingAssetsResponseBody.Assets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.assets = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListVodPackagingAssetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVodPackagingAssetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVodPackagingAssetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVodPackagingConfigurationsRequest : Tea.TeaModel {
    public var groupName: String?

    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class ListVodPackagingConfigurationsResponseBody : Tea.TeaModel {
    public var packagingConfigurations: [VodPackagingConfiguration]?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packagingConfigurations != nil {
            var tmp : [Any] = []
            for k in self.packagingConfigurations! {
                tmp.append(k.toMap())
            }
            map["PackagingConfigurations"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackagingConfigurations") {
            var tmp : [VodPackagingConfiguration] = []
            for v in dict["PackagingConfigurations"] as! [Any] {
                var model = VodPackagingConfiguration()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.packagingConfigurations = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListVodPackagingConfigurationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVodPackagingConfigurationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVodPackagingConfigurationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVodPackagingGroupsRequest : Tea.TeaModel {
    public var keyword: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class ListVodPackagingGroupsResponseBody : Tea.TeaModel {
    public var packagingGroups: [VodPackagingGroup]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sortBy: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.packagingGroups != nil {
            var tmp : [Any] = []
            for k in self.packagingGroups! {
                tmp.append(k.toMap())
            }
            map["PackagingGroups"] = tmp
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PackagingGroups") {
            var tmp : [VodPackagingGroup] = []
            for v in dict["PackagingGroups"] as! [Any] {
                var model = VodPackagingGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.packagingGroups = tmp
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListVodPackagingGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVodPackagingGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVodPackagingGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCopyrightExtractJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class QueryCopyrightExtractJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
        }
    }
    public var data: QueryCopyrightExtractJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryCopyrightExtractJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class QueryCopyrightExtractJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCopyrightExtractJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryCopyrightExtractJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCopyrightJobListRequest : Tea.TeaModel {
    public var createTimeEnd: Int64?

    public var createTimeStart: Int64?

    public var jobId: String?

    public var level: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimeEnd != nil {
            map["CreateTimeEnd"] = self.createTimeEnd!
        }
        if self.createTimeStart != nil {
            map["CreateTimeStart"] = self.createTimeStart!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimeEnd") {
            self.createTimeEnd = dict["CreateTimeEnd"] as! Int64
        }
        if dict.keys.contains("CreateTimeStart") {
            self.createTimeStart = dict["CreateTimeStart"] as! Int64
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class QueryCopyrightJobListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var input: QueryCopyrightJobListResponseBody.Data.Input?

        public var jobId: String?

        public var level: Int64?

        public var message: String?

        public var output: QueryCopyrightJobListResponseBody.Data.Output?

        public var result: String?

        public var status: String?

        public var userData: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("Input") {
                var model = QueryCopyrightJobListResponseBody.Data.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Output") {
                var model = QueryCopyrightJobListResponseBody.Data.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var data: [QueryCopyrightJobListResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [QueryCopyrightJobListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryCopyrightJobListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class QueryCopyrightJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCopyrightJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryCopyrightJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryDNAJobListRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryDNAJobListResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var code: String?

        public var config: String?

        public var creationTime: String?

        public var DBId: String?

        public var DNAResult: String?

        public var finishTime: String?

        public var id: String?

        public var input: QueryDNAJobListResponseBody.JobList.Input?

        public var message: String?

        public var primaryKey: String?

        public var status: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.DBId != nil {
                map["DBId"] = self.DBId!
            }
            if self.DNAResult != nil {
                map["DNAResult"] = self.DNAResult!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.primaryKey != nil {
                map["PrimaryKey"] = self.primaryKey!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DBId") {
                self.DBId = dict["DBId"] as! String
            }
            if dict.keys.contains("DNAResult") {
                self.DNAResult = dict["DNAResult"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Input") {
                var model = QueryDNAJobListResponseBody.JobList.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PrimaryKey") {
                self.primaryKey = dict["PrimaryKey"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var jobList: [QueryDNAJobListResponseBody.JobList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            var tmp : [Any] = []
            for k in self.jobList! {
                tmp.append(k.toMap())
            }
            map["JobList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            var tmp : [QueryDNAJobListResponseBody.JobList] = []
            for v in dict["JobList"] as! [Any] {
                var model = QueryDNAJobListResponseBody.JobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryDNAJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDNAJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryDNAJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryIProductionJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class QueryIProductionJobResponseBody : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var biz: String?

        public var media: String?

        public var outputUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.biz != nil {
                map["Biz"] = self.biz!
            }
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.outputUrl != nil {
                map["OutputUrl"] = self.outputUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Biz") {
                self.biz = dict["Biz"] as! String
            }
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("OutputUrl") {
                self.outputUrl = dict["OutputUrl"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var createTime: String?

    public var finishTime: String?

    public var functionName: String?

    public var input: QueryIProductionJobResponseBody.Input?

    public var jobId: String?

    public var jobParams: String?

    public var name: String?

    public var output: QueryIProductionJobResponseBody.Output?

    public var outputFiles: [String]?

    public var outputMediaIds: [String]?

    public var outputUrls: [String]?

    public var requestId: String?

    public var result: String?

    public var scheduleConfig: QueryIProductionJobResponseBody.ScheduleConfig?

    public var status: String?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.finishTime != nil {
            map["FinishTime"] = self.finishTime!
        }
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.outputFiles != nil {
            map["OutputFiles"] = self.outputFiles!
        }
        if self.outputMediaIds != nil {
            map["OutputMediaIds"] = self.outputMediaIds!
        }
        if self.outputUrls != nil {
            map["OutputUrls"] = self.outputUrls!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("FinishTime") {
            self.finishTime = dict["FinishTime"] as! String
        }
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") {
            var model = QueryIProductionJobResponseBody.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobParams") {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = QueryIProductionJobResponseBody.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("OutputFiles") {
            self.outputFiles = dict["OutputFiles"] as! [String]
        }
        if dict.keys.contains("OutputMediaIds") {
            self.outputMediaIds = dict["OutputMediaIds"] as! [String]
        }
        if dict.keys.contains("OutputUrls") {
            self.outputUrls = dict["OutputUrls"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = QueryIProductionJobResponseBody.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class QueryIProductionJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryIProductionJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryIProductionJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaCensorJobDetailRequest : Tea.TeaModel {
    public var jobId: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaCensorJobDetailResponseBody : Tea.TeaModel {
    public class MediaCensorJobDetail : Tea.TeaModel {
        public class BarrageCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class CoverImageCensorResults : Tea.TeaModel {
            public class CoverImageCensorResult : Tea.TeaModel {
                public class Results : Tea.TeaModel {
                    public class Result : Tea.TeaModel {
                        public var label: String?

                        public var rate: String?

                        public var scene: String?

                        public var suggestion: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.rate != nil {
                                map["Rate"] = self.rate!
                            }
                            if self.scene != nil {
                                map["Scene"] = self.scene!
                            }
                            if self.suggestion != nil {
                                map["Suggestion"] = self.suggestion!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Rate") {
                                self.rate = dict["Rate"] as! String
                            }
                            if dict.keys.contains("Scene") {
                                self.scene = dict["Scene"] as! String
                            }
                            if dict.keys.contains("Suggestion") {
                                self.suggestion = dict["Suggestion"] as! String
                            }
                        }
                    }
                    public var result: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.result != nil {
                            var tmp : [Any] = []
                            for k in self.result! {
                                tmp.append(k.toMap())
                            }
                            map["Result"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Result") {
                            var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result] = []
                            for v in dict["Result"] as! [Any] {
                                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.result = tmp
                        }
                    }
                }
                public var bucket: String?

                public var location: String?

                public var object: String?

                public var results: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.results?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    if self.results != nil {
                        map["Results"] = self.results?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                    if dict.keys.contains("Results") {
                        var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results()
                        model.fromMap(dict["Results"] as! [String: Any])
                        self.results = model
                    }
                }
            }
            public var coverImageCensorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coverImageCensorResult != nil {
                    var tmp : [Any] = []
                    for k in self.coverImageCensorResult! {
                        tmp.append(k.toMap())
                    }
                    map["CoverImageCensorResult"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CoverImageCensorResult") {
                    var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult] = []
                    for v in dict["CoverImageCensorResult"] as! [Any] {
                        var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.coverImageCensorResult = tmp
                }
            }
        }
        public class DescCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class Input : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public class TitleCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class VensorCensorResult : Tea.TeaModel {
            public class CensorResults : Tea.TeaModel {
                public class CensorResult : Tea.TeaModel {
                    public var label: String?

                    public var rate: String?

                    public var scene: String?

                    public var suggestion: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.rate != nil {
                            map["Rate"] = self.rate!
                        }
                        if self.scene != nil {
                            map["Scene"] = self.scene!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Rate") {
                            self.rate = dict["Rate"] as! String
                        }
                        if dict.keys.contains("Scene") {
                            self.scene = dict["Scene"] as! String
                        }
                        if dict.keys.contains("Suggestion") {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                    }
                }
                public var censorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.censorResult != nil {
                        var tmp : [Any] = []
                        for k in self.censorResult! {
                            tmp.append(k.toMap())
                        }
                        map["CensorResult"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CensorResult") {
                        var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult] = []
                        for v in dict["CensorResult"] as! [Any] {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.censorResult = tmp
                    }
                }
            }
            public class VideoTimelines : Tea.TeaModel {
                public class VideoTimeline : Tea.TeaModel {
                    public class CensorResults : Tea.TeaModel {
                        public class CensorResult : Tea.TeaModel {
                            public var label: String?

                            public var rate: String?

                            public var scene: String?

                            public var suggestion: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.label != nil {
                                    map["Label"] = self.label!
                                }
                                if self.rate != nil {
                                    map["Rate"] = self.rate!
                                }
                                if self.scene != nil {
                                    map["Scene"] = self.scene!
                                }
                                if self.suggestion != nil {
                                    map["Suggestion"] = self.suggestion!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Label") {
                                    self.label = dict["Label"] as! String
                                }
                                if dict.keys.contains("Rate") {
                                    self.rate = dict["Rate"] as! String
                                }
                                if dict.keys.contains("Scene") {
                                    self.scene = dict["Scene"] as! String
                                }
                                if dict.keys.contains("Suggestion") {
                                    self.suggestion = dict["Suggestion"] as! String
                                }
                            }
                        }
                        public var censorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.censorResult != nil {
                                var tmp : [Any] = []
                                for k in self.censorResult! {
                                    tmp.append(k.toMap())
                                }
                                map["CensorResult"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CensorResult") {
                                var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult] = []
                                for v in dict["CensorResult"] as! [Any] {
                                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.censorResult = tmp
                            }
                        }
                    }
                    public var censorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults?

                    public var object: String?

                    public var timestamp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.censorResults?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.censorResults != nil {
                            map["CensorResults"] = self.censorResults?.toMap()
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CensorResults") {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults()
                            model.fromMap(dict["CensorResults"] as! [String: Any])
                            self.censorResults = model
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("Timestamp") {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                    }
                }
                public var videoTimeline: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.videoTimeline != nil {
                        var tmp : [Any] = []
                        for k in self.videoTimeline! {
                            tmp.append(k.toMap())
                        }
                        map["VideoTimeline"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VideoTimeline") {
                        var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline] = []
                        for v in dict["VideoTimeline"] as! [Any] {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.videoTimeline = tmp
                    }
                }
            }
            public var censorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults?

            public var nextPageToken: String?

            public var videoTimelines: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.censorResults?.validate()
                try self.videoTimelines?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.censorResults != nil {
                    map["CensorResults"] = self.censorResults?.toMap()
                }
                if self.nextPageToken != nil {
                    map["NextPageToken"] = self.nextPageToken!
                }
                if self.videoTimelines != nil {
                    map["VideoTimelines"] = self.videoTimelines?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CensorResults") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults()
                    model.fromMap(dict["CensorResults"] as! [String: Any])
                    self.censorResults = model
                }
                if dict.keys.contains("NextPageToken") {
                    self.nextPageToken = dict["NextPageToken"] as! String
                }
                if dict.keys.contains("VideoTimelines") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines()
                    model.fromMap(dict["VideoTimelines"] as! [String: Any])
                    self.videoTimelines = model
                }
            }
        }
        public class VideoCensorConfig : Tea.TeaModel {
            public class OutputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var bizType: String?

            public var outputFile: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig.OutputFile?

            public var videoCensor: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.outputFile != nil {
                    map["OutputFile"] = self.outputFile?.toMap()
                }
                if self.videoCensor != nil {
                    map["VideoCensor"] = self.videoCensor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizType") {
                    self.bizType = dict["BizType"] as! String
                }
                if dict.keys.contains("OutputFile") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig.OutputFile()
                    model.fromMap(dict["OutputFile"] as! [String: Any])
                    self.outputFile = model
                }
                if dict.keys.contains("VideoCensor") {
                    self.videoCensor = dict["VideoCensor"] as! String
                }
            }
        }
        public var barrageCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.BarrageCensorResult?

        public var code: String?

        public var coverImageCensorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults?

        public var creationTime: String?

        public var descCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.DescCensorResult?

        public var finishTime: String?

        public var input: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.Input?

        public var jobId: String?

        public var message: String?

        public var pipelineId: String?

        public var state: String?

        public var suggestion: String?

        public var titleCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.TitleCensorResult?

        public var userData: String?

        public var vensorCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult?

        public var videoCensorConfig: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.barrageCensorResult?.validate()
            try self.coverImageCensorResults?.validate()
            try self.descCensorResult?.validate()
            try self.input?.validate()
            try self.titleCensorResult?.validate()
            try self.vensorCensorResult?.validate()
            try self.videoCensorConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.barrageCensorResult != nil {
                map["BarrageCensorResult"] = self.barrageCensorResult?.toMap()
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.coverImageCensorResults != nil {
                map["CoverImageCensorResults"] = self.coverImageCensorResults?.toMap()
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.descCensorResult != nil {
                map["DescCensorResult"] = self.descCensorResult?.toMap()
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.suggestion != nil {
                map["Suggestion"] = self.suggestion!
            }
            if self.titleCensorResult != nil {
                map["TitleCensorResult"] = self.titleCensorResult?.toMap()
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.vensorCensorResult != nil {
                map["VensorCensorResult"] = self.vensorCensorResult?.toMap()
            }
            if self.videoCensorConfig != nil {
                map["VideoCensorConfig"] = self.videoCensorConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BarrageCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.BarrageCensorResult()
                model.fromMap(dict["BarrageCensorResult"] as! [String: Any])
                self.barrageCensorResult = model
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CoverImageCensorResults") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults()
                model.fromMap(dict["CoverImageCensorResults"] as! [String: Any])
                self.coverImageCensorResults = model
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DescCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.DescCensorResult()
                model.fromMap(dict["DescCensorResult"] as! [String: Any])
                self.descCensorResult = model
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Suggestion") {
                self.suggestion = dict["Suggestion"] as! String
            }
            if dict.keys.contains("TitleCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.TitleCensorResult()
                model.fromMap(dict["TitleCensorResult"] as! [String: Any])
                self.titleCensorResult = model
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("VensorCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult()
                model.fromMap(dict["VensorCensorResult"] as! [String: Any])
                self.vensorCensorResult = model
            }
            if dict.keys.contains("VideoCensorConfig") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig()
                model.fromMap(dict["VideoCensorConfig"] as! [String: Any])
                self.videoCensorConfig = model
            }
        }
    }
    public var mediaCensorJobDetail: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaCensorJobDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaCensorJobDetail != nil {
            map["MediaCensorJobDetail"] = self.mediaCensorJobDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaCensorJobDetail") {
            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail()
            model.fromMap(dict["MediaCensorJobDetail"] as! [String: Any])
            self.mediaCensorJobDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaCensorJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaCensorJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaCensorJobDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaCensorJobListRequest : Tea.TeaModel {
    public var endOfJobCreatedTimeRange: String?

    public var jobIds: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startOfJobCreatedTimeRange: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfJobCreatedTimeRange != nil {
            map["EndOfJobCreatedTimeRange"] = self.endOfJobCreatedTimeRange!
        }
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startOfJobCreatedTimeRange != nil {
            map["StartOfJobCreatedTimeRange"] = self.startOfJobCreatedTimeRange!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfJobCreatedTimeRange") {
            self.endOfJobCreatedTimeRange = dict["EndOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartOfJobCreatedTimeRange") {
            self.startOfJobCreatedTimeRange = dict["StartOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class QueryMediaCensorJobListResponseBody : Tea.TeaModel {
    public class MediaCensorJobList : Tea.TeaModel {
        public class MediaCensorJob : Tea.TeaModel {
            public class BarrageCensorResult : Tea.TeaModel {
                public var label: String?

                public var rate: String?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! String
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class CoverImageCensorResults : Tea.TeaModel {
                public class CoverImageCensorResult : Tea.TeaModel {
                    public class Results : Tea.TeaModel {
                        public class Result : Tea.TeaModel {
                            public var label: String?

                            public var rate: String?

                            public var scene: String?

                            public var suggestion: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.label != nil {
                                    map["Label"] = self.label!
                                }
                                if self.rate != nil {
                                    map["Rate"] = self.rate!
                                }
                                if self.scene != nil {
                                    map["Scene"] = self.scene!
                                }
                                if self.suggestion != nil {
                                    map["Suggestion"] = self.suggestion!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Label") {
                                    self.label = dict["Label"] as! String
                                }
                                if dict.keys.contains("Rate") {
                                    self.rate = dict["Rate"] as! String
                                }
                                if dict.keys.contains("Scene") {
                                    self.scene = dict["Scene"] as! String
                                }
                                if dict.keys.contains("Suggestion") {
                                    self.suggestion = dict["Suggestion"] as! String
                                }
                            }
                        }
                        public var result: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results.Result]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.result != nil {
                                var tmp : [Any] = []
                                for k in self.result! {
                                    tmp.append(k.toMap())
                                }
                                map["Result"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Result") {
                                var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results.Result] = []
                                for v in dict["Result"] as! [Any] {
                                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results.Result()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.result = tmp
                            }
                        }
                    }
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var results: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.results?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.results != nil {
                            map["Results"] = self.results?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("Results") {
                            var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results()
                            model.fromMap(dict["Results"] as! [String: Any])
                            self.results = model
                        }
                    }
                }
                public var coverImageCensorResult: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.coverImageCensorResult != nil {
                        var tmp : [Any] = []
                        for k in self.coverImageCensorResult! {
                            tmp.append(k.toMap())
                        }
                        map["CoverImageCensorResult"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CoverImageCensorResult") {
                        var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult] = []
                        for v in dict["CoverImageCensorResult"] as! [Any] {
                            var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.coverImageCensorResult = tmp
                    }
                }
            }
            public class DescCensorResult : Tea.TeaModel {
                public var label: String?

                public var rate: String?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! String
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public class TitleCensorResult : Tea.TeaModel {
                public var label: String?

                public var rate: String?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! String
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class VensorCensorResult : Tea.TeaModel {
                public class CensorResults : Tea.TeaModel {
                    public class CensorResult : Tea.TeaModel {
                        public var label: String?

                        public var rate: String?

                        public var scene: String?

                        public var suggestion: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.rate != nil {
                                map["Rate"] = self.rate!
                            }
                            if self.scene != nil {
                                map["Scene"] = self.scene!
                            }
                            if self.suggestion != nil {
                                map["Suggestion"] = self.suggestion!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Rate") {
                                self.rate = dict["Rate"] as! String
                            }
                            if dict.keys.contains("Scene") {
                                self.scene = dict["Scene"] as! String
                            }
                            if dict.keys.contains("Suggestion") {
                                self.suggestion = dict["Suggestion"] as! String
                            }
                        }
                    }
                    public var censorResult: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults.CensorResult]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.censorResult != nil {
                            var tmp : [Any] = []
                            for k in self.censorResult! {
                                tmp.append(k.toMap())
                            }
                            map["CensorResult"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CensorResult") {
                            var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults.CensorResult] = []
                            for v in dict["CensorResult"] as! [Any] {
                                var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults.CensorResult()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.censorResult = tmp
                        }
                    }
                }
                public class VideoTimelines : Tea.TeaModel {
                    public class VideoTimeline : Tea.TeaModel {
                        public class CensorResults : Tea.TeaModel {
                            public class CensorResult : Tea.TeaModel {
                                public var label: String?

                                public var rate: String?

                                public var scene: String?

                                public var suggestion: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.label != nil {
                                        map["Label"] = self.label!
                                    }
                                    if self.rate != nil {
                                        map["Rate"] = self.rate!
                                    }
                                    if self.scene != nil {
                                        map["Scene"] = self.scene!
                                    }
                                    if self.suggestion != nil {
                                        map["Suggestion"] = self.suggestion!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Label") {
                                        self.label = dict["Label"] as! String
                                    }
                                    if dict.keys.contains("Rate") {
                                        self.rate = dict["Rate"] as! String
                                    }
                                    if dict.keys.contains("Scene") {
                                        self.scene = dict["Scene"] as! String
                                    }
                                    if dict.keys.contains("Suggestion") {
                                        self.suggestion = dict["Suggestion"] as! String
                                    }
                                }
                            }
                            public var censorResult: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.censorResult != nil {
                                    var tmp : [Any] = []
                                    for k in self.censorResult! {
                                        tmp.append(k.toMap())
                                    }
                                    map["CensorResult"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("CensorResult") {
                                    var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult] = []
                                    for v in dict["CensorResult"] as! [Any] {
                                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.censorResult = tmp
                                }
                            }
                        }
                        public var censorResults: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults?

                        public var object: String?

                        public var timestamp: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.censorResults?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.censorResults != nil {
                                map["CensorResults"] = self.censorResults?.toMap()
                            }
                            if self.object != nil {
                                map["Object"] = self.object!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CensorResults") {
                                var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults()
                                model.fromMap(dict["CensorResults"] as! [String: Any])
                                self.censorResults = model
                            }
                            if dict.keys.contains("Object") {
                                self.object = dict["Object"] as! String
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                        }
                    }
                    public var videoTimeline: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.videoTimeline != nil {
                            var tmp : [Any] = []
                            for k in self.videoTimeline! {
                                tmp.append(k.toMap())
                            }
                            map["VideoTimeline"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("VideoTimeline") {
                            var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline] = []
                            for v in dict["VideoTimeline"] as! [Any] {
                                var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.videoTimeline = tmp
                        }
                    }
                }
                public var censorResults: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults?

                public var nextPageToken: String?

                public var videoTimelines: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.censorResults?.validate()
                    try self.videoTimelines?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.censorResults != nil {
                        map["CensorResults"] = self.censorResults?.toMap()
                    }
                    if self.nextPageToken != nil {
                        map["NextPageToken"] = self.nextPageToken!
                    }
                    if self.videoTimelines != nil {
                        map["VideoTimelines"] = self.videoTimelines?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CensorResults") {
                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults()
                        model.fromMap(dict["CensorResults"] as! [String: Any])
                        self.censorResults = model
                    }
                    if dict.keys.contains("NextPageToken") {
                        self.nextPageToken = dict["NextPageToken"] as! String
                    }
                    if dict.keys.contains("VideoTimelines") {
                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines()
                        model.fromMap(dict["VideoTimelines"] as! [String: Any])
                        self.videoTimelines = model
                    }
                }
            }
            public class VideoCensorConfig : Tea.TeaModel {
                public class OutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                    }
                }
                public var bizType: String?

                public var outputFile: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig.OutputFile?

                public var videoCensor: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.outputFile?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizType != nil {
                        map["BizType"] = self.bizType!
                    }
                    if self.outputFile != nil {
                        map["OutputFile"] = self.outputFile?.toMap()
                    }
                    if self.videoCensor != nil {
                        map["VideoCensor"] = self.videoCensor!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizType") {
                        self.bizType = dict["BizType"] as! String
                    }
                    if dict.keys.contains("OutputFile") {
                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig.OutputFile()
                        model.fromMap(dict["OutputFile"] as! [String: Any])
                        self.outputFile = model
                    }
                    if dict.keys.contains("VideoCensor") {
                        self.videoCensor = dict["VideoCensor"] as! String
                    }
                }
            }
            public var barrageCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.BarrageCensorResult?

            public var code: String?

            public var coverImageCensorResults: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults?

            public var creationTime: String?

            public var descCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.DescCensorResult?

            public var finishTime: String?

            public var input: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.Input?

            public var jobId: String?

            public var message: String?

            public var pipelineId: String?

            public var state: String?

            public var suggestion: String?

            public var titleCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.TitleCensorResult?

            public var userData: String?

            public var vensorCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult?

            public var videoCensorConfig: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.barrageCensorResult?.validate()
                try self.coverImageCensorResults?.validate()
                try self.descCensorResult?.validate()
                try self.input?.validate()
                try self.titleCensorResult?.validate()
                try self.vensorCensorResult?.validate()
                try self.videoCensorConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.barrageCensorResult != nil {
                    map["BarrageCensorResult"] = self.barrageCensorResult?.toMap()
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.coverImageCensorResults != nil {
                    map["CoverImageCensorResults"] = self.coverImageCensorResults?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.descCensorResult != nil {
                    map["DescCensorResult"] = self.descCensorResult?.toMap()
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.titleCensorResult != nil {
                    map["TitleCensorResult"] = self.titleCensorResult?.toMap()
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                if self.vensorCensorResult != nil {
                    map["VensorCensorResult"] = self.vensorCensorResult?.toMap()
                }
                if self.videoCensorConfig != nil {
                    map["VideoCensorConfig"] = self.videoCensorConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BarrageCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.BarrageCensorResult()
                    model.fromMap(dict["BarrageCensorResult"] as! [String: Any])
                    self.barrageCensorResult = model
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CoverImageCensorResults") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults()
                    model.fromMap(dict["CoverImageCensorResults"] as! [String: Any])
                    self.coverImageCensorResults = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DescCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.DescCensorResult()
                    model.fromMap(dict["DescCensorResult"] as! [String: Any])
                    self.descCensorResult = model
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("TitleCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.TitleCensorResult()
                    model.fromMap(dict["TitleCensorResult"] as! [String: Any])
                    self.titleCensorResult = model
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
                if dict.keys.contains("VensorCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult()
                    model.fromMap(dict["VensorCensorResult"] as! [String: Any])
                    self.vensorCensorResult = model
                }
                if dict.keys.contains("VideoCensorConfig") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig()
                    model.fromMap(dict["VideoCensorConfig"] as! [String: Any])
                    self.videoCensorConfig = model
                }
            }
        }
        public var mediaCensorJob: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaCensorJob != nil {
                var tmp : [Any] = []
                for k in self.mediaCensorJob! {
                    tmp.append(k.toMap())
                }
                map["MediaCensorJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaCensorJob") {
                var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob] = []
                for v in dict["MediaCensorJob"] as! [Any] {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaCensorJob = tmp
            }
        }
    }
    public class NonExistIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var mediaCensorJobList: QueryMediaCensorJobListResponseBody.MediaCensorJobList?

    public var nextPageToken: String?

    public var nonExistIds: QueryMediaCensorJobListResponseBody.NonExistIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaCensorJobList?.validate()
        try self.nonExistIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaCensorJobList != nil {
            map["MediaCensorJobList"] = self.mediaCensorJobList?.toMap()
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.nonExistIds != nil {
            map["NonExistIds"] = self.nonExistIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaCensorJobList") {
            var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList()
            model.fromMap(dict["MediaCensorJobList"] as! [String: Any])
            self.mediaCensorJobList = model
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("NonExistIds") {
            var model = QueryMediaCensorJobListResponseBody.NonExistIds()
            model.fromMap(dict["NonExistIds"] as! [String: Any])
            self.nonExistIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaCensorJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaCensorJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaCensorJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaIndexJobRequest : Tea.TeaModel {
    public var mediaId: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class QueryMediaIndexJobResponseBody : Tea.TeaModel {
    public class IndexJobInfoList : Tea.TeaModel {
        public var gmtFinish: String?

        public var gmtSubmit: String?

        public var indexType: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtFinish != nil {
                map["GmtFinish"] = self.gmtFinish!
            }
            if self.gmtSubmit != nil {
                map["GmtSubmit"] = self.gmtSubmit!
            }
            if self.indexType != nil {
                map["IndexType"] = self.indexType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GmtFinish") {
                self.gmtFinish = dict["GmtFinish"] as! String
            }
            if dict.keys.contains("GmtSubmit") {
                self.gmtSubmit = dict["GmtSubmit"] as! String
            }
            if dict.keys.contains("IndexType") {
                self.indexType = dict["IndexType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var indexJobInfoList: [QueryMediaIndexJobResponseBody.IndexJobInfoList]?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.indexJobInfoList != nil {
            var tmp : [Any] = []
            for k in self.indexJobInfoList! {
                tmp.append(k.toMap())
            }
            map["IndexJobInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("IndexJobInfoList") {
            var tmp : [QueryMediaIndexJobResponseBody.IndexJobInfoList] = []
            for v in dict["IndexJobInfoList"] as! [Any] {
                var model = QueryMediaIndexJobResponseBody.IndexJobInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.indexJobInfoList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class QueryMediaIndexJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaIndexJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaIndexJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySearchIndexRequest : Tea.TeaModel {
    public var indexType: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexType != nil {
            map["IndexType"] = self.indexType!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndexType") {
            self.indexType = dict["IndexType"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class QuerySearchIndexResponseBody : Tea.TeaModel {
    public var code: String?

    public var indexStatus: String?

    public var indexType: String?

    public var mediaTotal: String?

    public var requestId: String?

    public var searchLibName: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.indexStatus != nil {
            map["IndexStatus"] = self.indexStatus!
        }
        if self.indexType != nil {
            map["IndexType"] = self.indexType!
        }
        if self.mediaTotal != nil {
            map["MediaTotal"] = self.mediaTotal!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("IndexStatus") {
            self.indexStatus = dict["IndexStatus"] as! String
        }
        if dict.keys.contains("IndexType") {
            self.indexType = dict["IndexType"] as! String
        }
        if dict.keys.contains("MediaTotal") {
            self.mediaTotal = dict["MediaTotal"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class QuerySearchIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySearchIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySearchIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySearchLibRequest : Tea.TeaModel {
    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class QuerySearchLibResponseBody : Tea.TeaModel {
    public class IndexInfo : Tea.TeaModel {
        public var indexReadiness: String?

        public var indexStatus: String?

        public var indexType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.indexReadiness != nil {
                map["IndexReadiness"] = self.indexReadiness!
            }
            if self.indexStatus != nil {
                map["IndexStatus"] = self.indexStatus!
            }
            if self.indexType != nil {
                map["IndexType"] = self.indexType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IndexReadiness") {
                self.indexReadiness = dict["IndexReadiness"] as! String
            }
            if dict.keys.contains("IndexStatus") {
                self.indexStatus = dict["IndexStatus"] as! String
            }
            if dict.keys.contains("IndexType") {
                self.indexType = dict["IndexType"] as! String
            }
        }
    }
    public var code: String?

    public var indexInfo: [QuerySearchLibResponseBody.IndexInfo]?

    public var requestId: String?

    public var searchLibName: String?

    public var status: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.indexInfo != nil {
            var tmp : [Any] = []
            for k in self.indexInfo! {
                tmp.append(k.toMap())
            }
            map["IndexInfo"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("IndexInfo") {
            var tmp : [QuerySearchLibResponseBody.IndexInfo] = []
            for v in dict["IndexInfo"] as! [Any] {
                var model = QuerySearchLibResponseBody.IndexInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.indexInfo = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class QuerySearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySmarttagJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var params: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
    }
}

public class QuerySmarttagJobResponseBody : Tea.TeaModel {
    public class Results : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var data: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var result: [QuerySmarttagJobResponseBody.Results.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Result") {
                var tmp : [QuerySmarttagJobResponseBody.Results.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = QuerySmarttagJobResponseBody.Results.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
        }
    }
    public var jobStatus: String?

    public var requestId: String?

    public var results: QuerySmarttagJobResponseBody.Results?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.results?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobStatus != nil {
            map["JobStatus"] = self.jobStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.results != nil {
            map["Results"] = self.results?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobStatus") {
            self.jobStatus = dict["JobStatus"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Results") {
            var model = QuerySmarttagJobResponseBody.Results()
            model.fromMap(dict["Results"] as! [String: Any])
            self.results = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class QuerySmarttagJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySmarttagJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySmarttagJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTraceAbJobListRequest : Tea.TeaModel {
    public var createTimeEnd: Int64?

    public var createTimeStart: Int64?

    public var jobId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var traceMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimeEnd != nil {
            map["CreateTimeEnd"] = self.createTimeEnd!
        }
        if self.createTimeStart != nil {
            map["CreateTimeStart"] = self.createTimeStart!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.traceMediaId != nil {
            map["TraceMediaId"] = self.traceMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimeEnd") {
            self.createTimeEnd = dict["CreateTimeEnd"] as! Int64
        }
        if dict.keys.contains("CreateTimeStart") {
            self.createTimeStart = dict["CreateTimeStart"] as! Int64
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("TraceMediaId") {
            self.traceMediaId = dict["TraceMediaId"] as! String
        }
    }
}

public class QueryTraceAbJobListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var input: QueryTraceAbJobListResponseBody.Data.Input?

        public var jobId: String?

        public var level: Int64?

        public var output: QueryTraceAbJobListResponseBody.Data.Output?

        public var result: String?

        public var status: String?

        public var traceMediaId: String?

        public var userData: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.traceMediaId != nil {
                map["TraceMediaId"] = self.traceMediaId!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("Input") {
                var model = QueryTraceAbJobListResponseBody.Data.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("Output") {
                var model = QueryTraceAbJobListResponseBody.Data.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TraceMediaId") {
                self.traceMediaId = dict["TraceMediaId"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var data: [QueryTraceAbJobListResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [QueryTraceAbJobListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryTraceAbJobListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class QueryTraceAbJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTraceAbJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryTraceAbJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTraceExtractJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class QueryTraceExtractJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var trace: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.trace != nil {
                map["Trace"] = self.trace!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Trace") {
                self.trace = dict["Trace"] as! String
            }
        }
    }
    public var data: QueryTraceExtractJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryTraceExtractJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class QueryTraceExtractJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTraceExtractJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryTraceExtractJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTraceM3u8JobListRequest : Tea.TeaModel {
    public var createTimeEnd: Int64?

    public var createTimeStart: Int64?

    public var jobId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimeEnd != nil {
            map["CreateTimeEnd"] = self.createTimeEnd!
        }
        if self.createTimeStart != nil {
            map["CreateTimeStart"] = self.createTimeStart!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimeEnd") {
            self.createTimeEnd = dict["CreateTimeEnd"] as! Int64
        }
        if dict.keys.contains("CreateTimeStart") {
            self.createTimeStart = dict["CreateTimeStart"] as! Int64
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class QueryTraceM3u8JobListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Output : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var jobId: String?

        public var output: QueryTraceM3u8JobListResponseBody.Data.Output?

        public var status: String?

        public var trace: String?

        public var traceMediaId: String?

        public var userData: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.output?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.trace != nil {
                map["Trace"] = self.trace!
            }
            if self.traceMediaId != nil {
                map["TraceMediaId"] = self.traceMediaId!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Output") {
                var model = QueryTraceM3u8JobListResponseBody.Data.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Trace") {
                self.trace = dict["Trace"] as! String
            }
            if dict.keys.contains("TraceMediaId") {
                self.traceMediaId = dict["TraceMediaId"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var data: [QueryTraceM3u8JobListResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [QueryTraceM3u8JobListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryTraceM3u8JobListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class QueryTraceM3u8JobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTraceM3u8JobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryTraceM3u8JobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshUploadMediaRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class RefreshUploadMediaResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class RefreshUploadMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshUploadMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RefreshUploadMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterMediaInfoRequest : Tea.TeaModel {
    public var businessType: String?

    public var cateId: Int64?

    public var clientToken: String?

    public var coverURL: String?

    public var description_: String?

    public var inputURL: String?

    public var mediaTags: String?

    public var mediaType: String?

    public var overwrite: Bool?

    public var referenceId: String?

    public var registerConfig: String?

    public var smartTagTemplateId: String?

    public var title: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaTags != nil {
            map["MediaTags"] = self.mediaTags!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.referenceId != nil {
            map["ReferenceId"] = self.referenceId!
        }
        if self.registerConfig != nil {
            map["RegisterConfig"] = self.registerConfig!
        }
        if self.smartTagTemplateId != nil {
            map["SmartTagTemplateId"] = self.smartTagTemplateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaTags") {
            self.mediaTags = dict["MediaTags"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("Overwrite") {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("ReferenceId") {
            self.referenceId = dict["ReferenceId"] as! String
        }
        if dict.keys.contains("RegisterConfig") {
            self.registerConfig = dict["RegisterConfig"] as! String
        }
        if dict.keys.contains("SmartTagTemplateId") {
            self.smartTagTemplateId = dict["SmartTagTemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class RegisterMediaInfoResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterMediaStreamRequest : Tea.TeaModel {
    public var inputURL: String?

    public var mediaId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class RegisterMediaStreamResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterMediaStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterMediaStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterMediaStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchEditingProjectRequest : Tea.TeaModel {
    public var createSource: String?

    public var endTime: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var projectType: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createSource != nil {
            map["CreateSource"] = self.createSource!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectType != nil {
            map["ProjectType"] = self.projectType!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateSource") {
            self.createSource = dict["CreateSource"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ProjectType") {
            self.projectType = dict["ProjectType"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class SearchEditingProjectResponseBody : Tea.TeaModel {
    public class ProjectList : Tea.TeaModel {
        public var businessConfig: String?

        public var businessStatus: String?

        public var coverURL: String?

        public var createSource: String?

        public var createTime: String?

        public var description_: String?

        public var duration: Int64?

        public var errorCode: String?

        public var errorMessage: String?

        public var modifiedSource: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var projectType: String?

        public var status: String?

        public var templateType: String?

        public var timeline: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessConfig != nil {
                map["BusinessConfig"] = self.businessConfig!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.modifiedSource != nil {
                map["ModifiedSource"] = self.modifiedSource!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessConfig") {
                self.businessConfig = dict["BusinessConfig"] as! String
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateSource") {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("ModifiedSource") {
                self.modifiedSource = dict["ModifiedSource"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectType") {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var projectList: [SearchEditingProjectResponseBody.ProjectList]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.projectList != nil {
            var tmp : [Any] = []
            for k in self.projectList! {
                tmp.append(k.toMap())
            }
            map["ProjectList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ProjectList") {
            var tmp : [SearchEditingProjectResponseBody.ProjectList] = []
            for v in dict["ProjectList"] as! [Any] {
                var model = SearchEditingProjectResponseBody.ProjectList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.projectList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchIndexJobRerunRequest : Tea.TeaModel {
    public var mediaIds: String?

    public var searchLibName: String?

    public var task: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.task != nil {
            map["Task"] = self.task!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("Task") {
            self.task = dict["Task"] as! String
        }
    }
}

public class SearchIndexJobRerunResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var mediaIdsNoExist: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaIdsNoExist != nil {
                map["MediaIdsNoExist"] = self.mediaIdsNoExist!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaIdsNoExist") {
                self.mediaIdsNoExist = dict["MediaIdsNoExist"] as! [String]
            }
        }
    }
    public var code: String?

    public var data: SearchIndexJobRerunResponseBody.Data?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = SearchIndexJobRerunResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class SearchIndexJobRerunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchIndexJobRerunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchIndexJobRerunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaRequest : Tea.TeaModel {
    public var entityId: String?

    public var match: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var scrollToken: String?

    public var searchLibName: String?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.match != nil {
            map["Match"] = self.match!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scrollToken != nil {
            map["ScrollToken"] = self.scrollToken!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("Match") {
            self.match = dict["Match"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScrollToken") {
            self.scrollToken = dict["ScrollToken"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class SearchMediaResponseBody : Tea.TeaModel {
    public class MediaInfoList : Tea.TeaModel {
        public class AiData : Tea.TeaModel {
            public class AiLabelInfo : Tea.TeaModel {
                public class Occurrences : Tea.TeaModel {
                    public class Tracks : Tea.TeaModel {
                        public var position: String?

                        public var size: Double?

                        public var timestamp: Double?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.position != nil {
                                map["Position"] = self.position!
                            }
                            if self.size != nil {
                                map["Size"] = self.size!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Position") {
                                self.position = dict["Position"] as! String
                            }
                            if dict.keys.contains("Size") {
                                self.size = dict["Size"] as! Double
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! Double
                            }
                        }
                    }
                    public var content: String?

                    public var finegrainId: String?

                    public var finegrainName: String?

                    public var from: Double?

                    public var image: String?

                    public var score: Double?

                    public var tableBatchSeqId: String?

                    public var to: Double?

                    public var tracks: [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences.Tracks]?

                    public var clipId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.finegrainId != nil {
                            map["FinegrainId"] = self.finegrainId!
                        }
                        if self.finegrainName != nil {
                            map["FinegrainName"] = self.finegrainName!
                        }
                        if self.from != nil {
                            map["From"] = self.from!
                        }
                        if self.image != nil {
                            map["Image"] = self.image!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.tableBatchSeqId != nil {
                            map["TableBatchSeqId"] = self.tableBatchSeqId!
                        }
                        if self.to != nil {
                            map["To"] = self.to!
                        }
                        if self.tracks != nil {
                            var tmp : [Any] = []
                            for k in self.tracks! {
                                tmp.append(k.toMap())
                            }
                            map["Tracks"] = tmp
                        }
                        if self.clipId != nil {
                            map["clipId"] = self.clipId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("FinegrainId") {
                            self.finegrainId = dict["FinegrainId"] as! String
                        }
                        if dict.keys.contains("FinegrainName") {
                            self.finegrainName = dict["FinegrainName"] as! String
                        }
                        if dict.keys.contains("From") {
                            self.from = dict["From"] as! Double
                        }
                        if dict.keys.contains("Image") {
                            self.image = dict["Image"] as! String
                        }
                        if dict.keys.contains("Score") {
                            self.score = dict["Score"] as! Double
                        }
                        if dict.keys.contains("TableBatchSeqId") {
                            self.tableBatchSeqId = dict["TableBatchSeqId"] as! String
                        }
                        if dict.keys.contains("To") {
                            self.to = dict["To"] as! Double
                        }
                        if dict.keys.contains("Tracks") {
                            var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences.Tracks] = []
                            for v in dict["Tracks"] as! [Any] {
                                var model = SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences.Tracks()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.tracks = tmp
                        }
                        if dict.keys.contains("clipId") {
                            self.clipId = dict["clipId"] as! String
                        }
                    }
                }
                public var category: String?

                public var faceId: String?

                public var labelId: String?

                public var labelName: String?

                public var labelType: String?

                public var occurrences: [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences]?

                public var source: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.faceId != nil {
                        map["FaceId"] = self.faceId!
                    }
                    if self.labelId != nil {
                        map["LabelId"] = self.labelId!
                    }
                    if self.labelName != nil {
                        map["LabelName"] = self.labelName!
                    }
                    if self.labelType != nil {
                        map["LabelType"] = self.labelType!
                    }
                    if self.occurrences != nil {
                        var tmp : [Any] = []
                        for k in self.occurrences! {
                            tmp.append(k.toMap())
                        }
                        map["Occurrences"] = tmp
                    }
                    if self.source != nil {
                        map["Source"] = self.source!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("FaceId") {
                        self.faceId = dict["FaceId"] as! String
                    }
                    if dict.keys.contains("LabelId") {
                        self.labelId = dict["LabelId"] as! String
                    }
                    if dict.keys.contains("LabelName") {
                        self.labelName = dict["LabelName"] as! String
                    }
                    if dict.keys.contains("LabelType") {
                        self.labelType = dict["LabelType"] as! String
                    }
                    if dict.keys.contains("Occurrences") {
                        var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences] = []
                        for v in dict["Occurrences"] as! [Any] {
                            var model = SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo.Occurrences()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.occurrences = tmp
                    }
                    if dict.keys.contains("Source") {
                        self.source = dict["Source"] as! String
                    }
                }
            }
            public class AsrInfo : Tea.TeaModel {
                public var clipId: String?

                public var content: String?

                public var from: Double?

                public var timestamp: Double?

                public var to: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clipId != nil {
                        map["ClipId"] = self.clipId!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.from != nil {
                        map["From"] = self.from!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.to != nil {
                        map["To"] = self.to!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClipId") {
                        self.clipId = dict["ClipId"] as! String
                    }
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("From") {
                        self.from = dict["From"] as! Double
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                    if dict.keys.contains("To") {
                        self.to = dict["To"] as! Double
                    }
                }
            }
            public class OcrInfo : Tea.TeaModel {
                public var clipId: String?

                public var content: String?

                public var from: Double?

                public var timestamp: Double?

                public var to: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clipId != nil {
                        map["ClipId"] = self.clipId!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.from != nil {
                        map["From"] = self.from!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.to != nil {
                        map["To"] = self.to!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClipId") {
                        self.clipId = dict["ClipId"] as! String
                    }
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("From") {
                        self.from = dict["From"] as! Double
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                    if dict.keys.contains("To") {
                        self.to = dict["To"] as! Double
                    }
                }
            }
            public var aiLabelInfo: [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo]?

            public var asrInfo: [SearchMediaResponseBody.MediaInfoList.AiData.AsrInfo]?

            public var ocrInfo: [SearchMediaResponseBody.MediaInfoList.AiData.OcrInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiLabelInfo != nil {
                    var tmp : [Any] = []
                    for k in self.aiLabelInfo! {
                        tmp.append(k.toMap())
                    }
                    map["AiLabelInfo"] = tmp
                }
                if self.asrInfo != nil {
                    var tmp : [Any] = []
                    for k in self.asrInfo! {
                        tmp.append(k.toMap())
                    }
                    map["AsrInfo"] = tmp
                }
                if self.ocrInfo != nil {
                    var tmp : [Any] = []
                    for k in self.ocrInfo! {
                        tmp.append(k.toMap())
                    }
                    map["OcrInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiLabelInfo") {
                    var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo] = []
                    for v in dict["AiLabelInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaInfoList.AiData.AiLabelInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.aiLabelInfo = tmp
                }
                if dict.keys.contains("AsrInfo") {
                    var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.AsrInfo] = []
                    for v in dict["AsrInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaInfoList.AiData.AsrInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.asrInfo = tmp
                }
                if dict.keys.contains("OcrInfo") {
                    var tmp : [SearchMediaResponseBody.MediaInfoList.AiData.OcrInfo] = []
                    for v in dict["OcrInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaInfoList.AiData.OcrInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ocrInfo = tmp
                }
            }
        }
        public class AiRoughData : Tea.TeaModel {
            public var aiCategory: String?

            public var aiJobId: String?

            public var result: String?

            public var saveType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiCategory != nil {
                    map["AiCategory"] = self.aiCategory!
                }
                if self.aiJobId != nil {
                    map["AiJobId"] = self.aiJobId!
                }
                if self.result != nil {
                    map["Result"] = self.result!
                }
                if self.saveType != nil {
                    map["SaveType"] = self.saveType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiCategory") {
                    self.aiCategory = dict["AiCategory"] as! String
                }
                if dict.keys.contains("AiJobId") {
                    self.aiJobId = dict["AiJobId"] as! String
                }
                if dict.keys.contains("Result") {
                    self.result = dict["Result"] as! String
                }
                if dict.keys.contains("SaveType") {
                    self.saveType = dict["SaveType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class FileInfoList : Tea.TeaModel {
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var createTime: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var modifiedTime: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var fileBasicInfo: SearchMediaResponseBody.MediaInfoList.FileInfoList.FileBasicInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileBasicInfo") {
                    var model = SearchMediaResponseBody.MediaInfoList.FileInfoList.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
            }
        }
        public class IndexStatusList : Tea.TeaModel {
            public var indexStatus: String?

            public var indexType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.indexStatus != nil {
                    map["IndexStatus"] = self.indexStatus!
                }
                if self.indexType != nil {
                    map["IndexType"] = self.indexType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IndexStatus") {
                    self.indexStatus = dict["IndexStatus"] as! String
                }
                if dict.keys.contains("IndexType") {
                    self.indexType = dict["IndexType"] as! String
                }
            }
        }
        public class MediaBasicInfo : Tea.TeaModel {
            public var biz: String?

            public var businessType: String?

            public var cateId: Int64?

            public var cateName: String?

            public var category: String?

            public var coverURL: String?

            public var createTime: String?

            public var deletedTime: String?

            public var description_: String?

            public var inputURL: String?

            public var mediaId: String?

            public var mediaTags: String?

            public var mediaType: String?

            public var modifiedTime: String?

            public var referenceId: String?

            public var snapshots: String?

            public var source: String?

            public var spriteImages: String?

            public var status: String?

            public var title: String?

            public var transcodeStatus: String?

            public var uploadSource: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.biz != nil {
                    map["Biz"] = self.biz!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deletedTime != nil {
                    map["DeletedTime"] = self.deletedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.inputURL != nil {
                    map["InputURL"] = self.inputURL!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaTags != nil {
                    map["MediaTags"] = self.mediaTags!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteImages != nil {
                    map["SpriteImages"] = self.spriteImages!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeStatus != nil {
                    map["TranscodeStatus"] = self.transcodeStatus!
                }
                if self.uploadSource != nil {
                    map["UploadSource"] = self.uploadSource!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Biz") {
                    self.biz = dict["Biz"] as! String
                }
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeletedTime") {
                    self.deletedTime = dict["DeletedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InputURL") {
                    self.inputURL = dict["InputURL"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaTags") {
                    self.mediaTags = dict["MediaTags"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteImages") {
                    self.spriteImages = dict["SpriteImages"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeStatus") {
                    self.transcodeStatus = dict["TranscodeStatus"] as! String
                }
                if dict.keys.contains("UploadSource") {
                    self.uploadSource = dict["UploadSource"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var aiData: SearchMediaResponseBody.MediaInfoList.AiData?

        public var aiRoughData: SearchMediaResponseBody.MediaInfoList.AiRoughData?

        public var fileInfoList: [SearchMediaResponseBody.MediaInfoList.FileInfoList]?

        public var indexStatusList: [SearchMediaResponseBody.MediaInfoList.IndexStatusList]?

        public var mediaBasicInfo: SearchMediaResponseBody.MediaInfoList.MediaBasicInfo?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.aiData?.validate()
            try self.aiRoughData?.validate()
            try self.mediaBasicInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiData != nil {
                map["AiData"] = self.aiData?.toMap()
            }
            if self.aiRoughData != nil {
                map["AiRoughData"] = self.aiRoughData?.toMap()
            }
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.indexStatusList != nil {
                var tmp : [Any] = []
                for k in self.indexStatusList! {
                    tmp.append(k.toMap())
                }
                map["IndexStatusList"] = tmp
            }
            if self.mediaBasicInfo != nil {
                map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiData") {
                var model = SearchMediaResponseBody.MediaInfoList.AiData()
                model.fromMap(dict["AiData"] as! [String: Any])
                self.aiData = model
            }
            if dict.keys.contains("AiRoughData") {
                var model = SearchMediaResponseBody.MediaInfoList.AiRoughData()
                model.fromMap(dict["AiRoughData"] as! [String: Any])
                self.aiRoughData = model
            }
            if dict.keys.contains("FileInfoList") {
                var tmp : [SearchMediaResponseBody.MediaInfoList.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = SearchMediaResponseBody.MediaInfoList.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("IndexStatusList") {
                var tmp : [SearchMediaResponseBody.MediaInfoList.IndexStatusList] = []
                for v in dict["IndexStatusList"] as! [Any] {
                    var model = SearchMediaResponseBody.MediaInfoList.IndexStatusList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.indexStatusList = tmp
            }
            if dict.keys.contains("MediaBasicInfo") {
                var model = SearchMediaResponseBody.MediaInfoList.MediaBasicInfo()
                model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                self.mediaBasicInfo = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var code: String?

    public var mediaInfoList: [SearchMediaResponseBody.MediaInfoList]?

    public var requestId: String?

    public var scrollToken: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaInfoList != nil {
            var tmp : [Any] = []
            for k in self.mediaInfoList! {
                tmp.append(k.toMap())
            }
            map["MediaInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scrollToken != nil {
            map["ScrollToken"] = self.scrollToken!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaInfoList") {
            var tmp : [SearchMediaResponseBody.MediaInfoList] = []
            for v in dict["MediaInfoList"] as! [Any] {
                var model = SearchMediaResponseBody.MediaInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfoList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScrollToken") {
            self.scrollToken = dict["ScrollToken"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaByAILabelRequest : Tea.TeaModel {
    public var matchingMode: String?

    public var mediaId: String?

    public var mediaType: String?

    public var multimodalSearchType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchLibName: String?

    public var sortBy: String?

    public var specificSearch: Bool?

    public var text: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.matchingMode != nil {
            map["MatchingMode"] = self.matchingMode!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.multimodalSearchType != nil {
            map["MultimodalSearchType"] = self.multimodalSearchType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.specificSearch != nil {
            map["SpecificSearch"] = self.specificSearch!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MatchingMode") {
            self.matchingMode = dict["MatchingMode"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("MultimodalSearchType") {
            self.multimodalSearchType = dict["MultimodalSearchType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("SpecificSearch") {
            self.specificSearch = dict["SpecificSearch"] as! Bool
        }
        if dict.keys.contains("Text") {
            self.text = dict["Text"] as! String
        }
    }
}

public class SearchMediaByAILabelResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class AiData : Tea.TeaModel {
            public class AiLabelInfo : Tea.TeaModel {
                public class Occurrences : Tea.TeaModel {
                    public class Tracks : Tea.TeaModel {
                        public var position: String?

                        public var size: Double?

                        public var timestamp: Double?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.position != nil {
                                map["Position"] = self.position!
                            }
                            if self.size != nil {
                                map["Size"] = self.size!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Position") {
                                self.position = dict["Position"] as! String
                            }
                            if dict.keys.contains("Size") {
                                self.size = dict["Size"] as! Double
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! Double
                            }
                        }
                    }
                    public var clipId: String?

                    public var content: String?

                    public var finegrainId: String?

                    public var finegrainName: String?

                    public var from: Double?

                    public var image: String?

                    public var score: Double?

                    public var tableBatchSeqId: String?

                    public var to: Double?

                    public var tracks: [SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo.Occurrences.Tracks]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.clipId != nil {
                            map["ClipId"] = self.clipId!
                        }
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.finegrainId != nil {
                            map["FinegrainId"] = self.finegrainId!
                        }
                        if self.finegrainName != nil {
                            map["FinegrainName"] = self.finegrainName!
                        }
                        if self.from != nil {
                            map["From"] = self.from!
                        }
                        if self.image != nil {
                            map["Image"] = self.image!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.tableBatchSeqId != nil {
                            map["TableBatchSeqId"] = self.tableBatchSeqId!
                        }
                        if self.to != nil {
                            map["To"] = self.to!
                        }
                        if self.tracks != nil {
                            var tmp : [Any] = []
                            for k in self.tracks! {
                                tmp.append(k.toMap())
                            }
                            map["Tracks"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClipId") {
                            self.clipId = dict["ClipId"] as! String
                        }
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("FinegrainId") {
                            self.finegrainId = dict["FinegrainId"] as! String
                        }
                        if dict.keys.contains("FinegrainName") {
                            self.finegrainName = dict["FinegrainName"] as! String
                        }
                        if dict.keys.contains("From") {
                            self.from = dict["From"] as! Double
                        }
                        if dict.keys.contains("Image") {
                            self.image = dict["Image"] as! String
                        }
                        if dict.keys.contains("Score") {
                            self.score = dict["Score"] as! Double
                        }
                        if dict.keys.contains("TableBatchSeqId") {
                            self.tableBatchSeqId = dict["TableBatchSeqId"] as! String
                        }
                        if dict.keys.contains("To") {
                            self.to = dict["To"] as! Double
                        }
                        if dict.keys.contains("Tracks") {
                            var tmp : [SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo.Occurrences.Tracks] = []
                            for v in dict["Tracks"] as! [Any] {
                                var model = SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo.Occurrences.Tracks()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.tracks = tmp
                        }
                    }
                }
                public var category: String?

                public var faceId: String?

                public var labelId: String?

                public var labelName: String?

                public var labelType: String?

                public var occurrences: [SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo.Occurrences]?

                public var source: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.faceId != nil {
                        map["FaceId"] = self.faceId!
                    }
                    if self.labelId != nil {
                        map["LabelId"] = self.labelId!
                    }
                    if self.labelName != nil {
                        map["LabelName"] = self.labelName!
                    }
                    if self.labelType != nil {
                        map["LabelType"] = self.labelType!
                    }
                    if self.occurrences != nil {
                        var tmp : [Any] = []
                        for k in self.occurrences! {
                            tmp.append(k.toMap())
                        }
                        map["Occurrences"] = tmp
                    }
                    if self.source != nil {
                        map["Source"] = self.source!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("FaceId") {
                        self.faceId = dict["FaceId"] as! String
                    }
                    if dict.keys.contains("LabelId") {
                        self.labelId = dict["LabelId"] as! String
                    }
                    if dict.keys.contains("LabelName") {
                        self.labelName = dict["LabelName"] as! String
                    }
                    if dict.keys.contains("LabelType") {
                        self.labelType = dict["LabelType"] as! String
                    }
                    if dict.keys.contains("Occurrences") {
                        var tmp : [SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo.Occurrences] = []
                        for v in dict["Occurrences"] as! [Any] {
                            var model = SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo.Occurrences()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.occurrences = tmp
                    }
                    if dict.keys.contains("Source") {
                        self.source = dict["Source"] as! String
                    }
                }
            }
            public class AsrInfo : Tea.TeaModel {
                public var clipId: String?

                public var content: String?

                public var from: Double?

                public var timestamp: Double?

                public var to: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clipId != nil {
                        map["ClipId"] = self.clipId!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.from != nil {
                        map["From"] = self.from!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.to != nil {
                        map["To"] = self.to!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClipId") {
                        self.clipId = dict["ClipId"] as! String
                    }
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("From") {
                        self.from = dict["From"] as! Double
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                    if dict.keys.contains("To") {
                        self.to = dict["To"] as! Double
                    }
                }
            }
            public class OcrInfo : Tea.TeaModel {
                public var clipId: String?

                public var content: String?

                public var from: Double?

                public var timestamp: Double?

                public var to: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clipId != nil {
                        map["ClipId"] = self.clipId!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.from != nil {
                        map["From"] = self.from!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.to != nil {
                        map["To"] = self.to!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClipId") {
                        self.clipId = dict["ClipId"] as! String
                    }
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("From") {
                        self.from = dict["From"] as! Double
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                    if dict.keys.contains("To") {
                        self.to = dict["To"] as! Double
                    }
                }
            }
            public var aiLabelInfo: [SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo]?

            public var asrInfo: [SearchMediaByAILabelResponseBody.MediaList.AiData.AsrInfo]?

            public var ocrInfo: [SearchMediaByAILabelResponseBody.MediaList.AiData.OcrInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiLabelInfo != nil {
                    var tmp : [Any] = []
                    for k in self.aiLabelInfo! {
                        tmp.append(k.toMap())
                    }
                    map["AiLabelInfo"] = tmp
                }
                if self.asrInfo != nil {
                    var tmp : [Any] = []
                    for k in self.asrInfo! {
                        tmp.append(k.toMap())
                    }
                    map["AsrInfo"] = tmp
                }
                if self.ocrInfo != nil {
                    var tmp : [Any] = []
                    for k in self.ocrInfo! {
                        tmp.append(k.toMap())
                    }
                    map["OcrInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiLabelInfo") {
                    var tmp : [SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo] = []
                    for v in dict["AiLabelInfo"] as! [Any] {
                        var model = SearchMediaByAILabelResponseBody.MediaList.AiData.AiLabelInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.aiLabelInfo = tmp
                }
                if dict.keys.contains("AsrInfo") {
                    var tmp : [SearchMediaByAILabelResponseBody.MediaList.AiData.AsrInfo] = []
                    for v in dict["AsrInfo"] as! [Any] {
                        var model = SearchMediaByAILabelResponseBody.MediaList.AiData.AsrInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.asrInfo = tmp
                }
                if dict.keys.contains("OcrInfo") {
                    var tmp : [SearchMediaByAILabelResponseBody.MediaList.AiData.OcrInfo] = []
                    for v in dict["OcrInfo"] as! [Any] {
                        var model = SearchMediaByAILabelResponseBody.MediaList.AiData.OcrInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ocrInfo = tmp
                }
            }
        }
        public var aiData: SearchMediaByAILabelResponseBody.MediaList.AiData?

        public var appId: String?

        public var coverUrl: String?

        public var creationTime: String?

        public var description_: String?

        public var duration: Double?

        public var mediaId: String?

        public var modificationTime: String?

        public var size: Int64?

        public var snapshots: [String]?

        public var status: String?

        public var storageLocation: String?

        public var tags: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.aiData?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiData != nil {
                map["AiData"] = self.aiData?.toMap()
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshots != nil {
                map["Snapshots"] = self.snapshots!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiData") {
                var model = SearchMediaByAILabelResponseBody.MediaList.AiData()
                model.fromMap(dict["AiData"] as! [String: Any])
                self.aiData = model
            }
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CoverUrl") {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Snapshots") {
                self.snapshots = dict["Snapshots"] as! [String]
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var code: String?

    public var mediaList: [SearchMediaByAILabelResponseBody.MediaList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaList != nil {
            var tmp : [Any] = []
            for k in self.mediaList! {
                tmp.append(k.toMap())
            }
            map["MediaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaList") {
            var tmp : [SearchMediaByAILabelResponseBody.MediaList] = []
            for v in dict["MediaList"] as! [Any] {
                var model = SearchMediaByAILabelResponseBody.MediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaByAILabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaByAILabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaByAILabelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaByFaceRequest : Tea.TeaModel {
    public var entityId: String?

    public var faceSearchToken: String?

    public var mediaType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var personImageUrl: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.faceSearchToken != nil {
            map["FaceSearchToken"] = self.faceSearchToken!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.personImageUrl != nil {
            map["PersonImageUrl"] = self.personImageUrl!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("FaceSearchToken") {
            self.faceSearchToken = dict["FaceSearchToken"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PersonImageUrl") {
            self.personImageUrl = dict["PersonImageUrl"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class SearchMediaByFaceResponseBody : Tea.TeaModel {
    public class MediaInfoList : Tea.TeaModel {
        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var code: String?

    public var mediaInfoList: [SearchMediaByFaceResponseBody.MediaInfoList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaInfoList != nil {
            var tmp : [Any] = []
            for k in self.mediaInfoList! {
                tmp.append(k.toMap())
            }
            map["MediaInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaInfoList") {
            var tmp : [SearchMediaByFaceResponseBody.MediaInfoList] = []
            for v in dict["MediaInfoList"] as! [Any] {
                var model = SearchMediaByFaceResponseBody.MediaInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaInfoList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaByFaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaByFaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaByFaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaByHybridRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchLibName: String?

    public var text: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("Text") {
            self.text = dict["Text"] as! String
        }
    }
}

public class SearchMediaByHybridResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class ClipInfo : Tea.TeaModel {
            public var from: Double?

            public var score: Double?

            public var to: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.from != nil {
                    map["From"] = self.from!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.to != nil {
                    map["To"] = self.to!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("From") {
                    self.from = dict["From"] as! Double
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Double
                }
                if dict.keys.contains("To") {
                    self.to = dict["To"] as! Double
                }
            }
        }
        public var clipInfo: [SearchMediaByHybridResponseBody.MediaList.ClipInfo]?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipInfo != nil {
                var tmp : [Any] = []
                for k in self.clipInfo! {
                    tmp.append(k.toMap())
                }
                map["ClipInfo"] = tmp
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipInfo") {
                var tmp : [SearchMediaByHybridResponseBody.MediaList.ClipInfo] = []
                for v in dict["ClipInfo"] as! [Any] {
                    var model = SearchMediaByHybridResponseBody.MediaList.ClipInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clipInfo = tmp
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var code: String?

    public var mediaList: [SearchMediaByHybridResponseBody.MediaList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaList != nil {
            var tmp : [Any] = []
            for k in self.mediaList! {
                tmp.append(k.toMap())
            }
            map["MediaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaList") {
            var tmp : [SearchMediaByHybridResponseBody.MediaList] = []
            for v in dict["MediaList"] as! [Any] {
                var model = SearchMediaByHybridResponseBody.MediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaByHybridResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaByHybridResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaByHybridResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaByMultimodalRequest : Tea.TeaModel {
    public var mediaType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchLibName: String?

    public var text: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
        if dict.keys.contains("Text") {
            self.text = dict["Text"] as! String
        }
    }
}

public class SearchMediaByMultimodalResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class ClipInfo : Tea.TeaModel {
            public var from: Double?

            public var score: Double?

            public var to: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.from != nil {
                    map["From"] = self.from!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.to != nil {
                    map["To"] = self.to!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("From") {
                    self.from = dict["From"] as! Double
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Double
                }
                if dict.keys.contains("To") {
                    self.to = dict["To"] as! Double
                }
            }
        }
        public var clipInfo: [SearchMediaByMultimodalResponseBody.MediaList.ClipInfo]?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clipInfo != nil {
                var tmp : [Any] = []
                for k in self.clipInfo! {
                    tmp.append(k.toMap())
                }
                map["ClipInfo"] = tmp
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClipInfo") {
                var tmp : [SearchMediaByMultimodalResponseBody.MediaList.ClipInfo] = []
                for v in dict["ClipInfo"] as! [Any] {
                    var model = SearchMediaByMultimodalResponseBody.MediaList.ClipInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clipInfo = tmp
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var code: String?

    public var mediaList: [SearchMediaByMultimodalResponseBody.MediaList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaList != nil {
            var tmp : [Any] = []
            for k in self.mediaList! {
                tmp.append(k.toMap())
            }
            map["MediaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaList") {
            var tmp : [SearchMediaByMultimodalResponseBody.MediaList] = []
            for v in dict["MediaList"] as! [Any] {
                var model = SearchMediaByMultimodalResponseBody.MediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaByMultimodalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaByMultimodalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaByMultimodalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaClipByFaceRequest : Tea.TeaModel {
    public var entityId: String?

    public var faceSearchToken: String?

    public var mediaId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.faceSearchToken != nil {
            map["FaceSearchToken"] = self.faceSearchToken!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("FaceSearchToken") {
            self.faceSearchToken = dict["FaceSearchToken"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class SearchMediaClipByFaceResponseBody : Tea.TeaModel {
    public class MediaClipList : Tea.TeaModel {
        public class OccurrencesInfos : Tea.TeaModel {
            public class TrackData : Tea.TeaModel {
                public class BoxPosition : Tea.TeaModel {
                    public var h: Int32?

                    public var w: Int32?

                    public var x: Int32?

                    public var y: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.h != nil {
                            map["H"] = self.h!
                        }
                        if self.w != nil {
                            map["W"] = self.w!
                        }
                        if self.x != nil {
                            map["X"] = self.x!
                        }
                        if self.y != nil {
                            map["Y"] = self.y!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("H") {
                            self.h = dict["H"] as! Int32
                        }
                        if dict.keys.contains("W") {
                            self.w = dict["W"] as! Int32
                        }
                        if dict.keys.contains("X") {
                            self.x = dict["X"] as! Int32
                        }
                        if dict.keys.contains("Y") {
                            self.y = dict["Y"] as! Int32
                        }
                    }
                }
                public var boxPosition: SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData.BoxPosition?

                public var timestamp: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.boxPosition?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.boxPosition != nil {
                        map["BoxPosition"] = self.boxPosition?.toMap()
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BoxPosition") {
                        var model = SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData.BoxPosition()
                        model.fromMap(dict["BoxPosition"] as! [String: Any])
                        self.boxPosition = model
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                }
            }
            public var endTime: Double?

            public var expression: String?

            public var startTime: Double?

            public var trackData: [SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.trackData != nil {
                    var tmp : [Any] = []
                    for k in self.trackData! {
                        tmp.append(k.toMap())
                    }
                    map["TrackData"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Double
                }
                if dict.keys.contains("Expression") {
                    self.expression = dict["Expression"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Double
                }
                if dict.keys.contains("TrackData") {
                    var tmp : [SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData] = []
                    for v in dict["TrackData"] as! [Any] {
                        var model = SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos.TrackData()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.trackData = tmp
                }
            }
        }
        public var category: String?

        public var entityId: String?

        public var labelName: String?

        public var occurrencesInfos: [SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos]?

        public var score: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.entityId != nil {
                map["EntityId"] = self.entityId!
            }
            if self.labelName != nil {
                map["LabelName"] = self.labelName!
            }
            if self.occurrencesInfos != nil {
                var tmp : [Any] = []
                for k in self.occurrencesInfos! {
                    tmp.append(k.toMap())
                }
                map["OccurrencesInfos"] = tmp
            }
            if self.score != nil {
                map["Score"] = self.score!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("EntityId") {
                self.entityId = dict["EntityId"] as! String
            }
            if dict.keys.contains("LabelName") {
                self.labelName = dict["LabelName"] as! String
            }
            if dict.keys.contains("OccurrencesInfos") {
                var tmp : [SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos] = []
                for v in dict["OccurrencesInfos"] as! [Any] {
                    var model = SearchMediaClipByFaceResponseBody.MediaClipList.OccurrencesInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.occurrencesInfos = tmp
            }
            if dict.keys.contains("Score") {
                self.score = dict["Score"] as! Double
            }
        }
    }
    public var code: String?

    public var mediaClipList: [SearchMediaClipByFaceResponseBody.MediaClipList]?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaClipList != nil {
            var tmp : [Any] = []
            for k in self.mediaClipList! {
                tmp.append(k.toMap())
            }
            map["MediaClipList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaClipList") {
            var tmp : [SearchMediaClipByFaceResponseBody.MediaClipList] = []
            for v in dict["MediaClipList"] as! [Any] {
                var model = SearchMediaClipByFaceResponseBody.MediaClipList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaClipList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaClipByFaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaClipByFaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaClipByFaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchPublicMediaInfoRequest : Tea.TeaModel {
    public var authorized: Bool?

    public var dynamicMetaDataMatchFields: String?

    public var entityId: String?

    public var favorite: Bool?

    public var mediaIds: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorized != nil {
            map["Authorized"] = self.authorized!
        }
        if self.dynamicMetaDataMatchFields != nil {
            map["DynamicMetaDataMatchFields"] = self.dynamicMetaDataMatchFields!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.favorite != nil {
            map["Favorite"] = self.favorite!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Authorized") {
            self.authorized = dict["Authorized"] as! Bool
        }
        if dict.keys.contains("DynamicMetaDataMatchFields") {
            self.dynamicMetaDataMatchFields = dict["DynamicMetaDataMatchFields"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("Favorite") {
            self.favorite = dict["Favorite"] as! Bool
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class SearchPublicMediaInfoResponseBody : Tea.TeaModel {
    public class PublicMediaInfos : Tea.TeaModel {
        public class MediaInfo : Tea.TeaModel {
            public class DynamicMetaData : Tea.TeaModel {
                public var data: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.data != nil {
                        map["Data"] = self.data!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Data") {
                        self.data = dict["Data"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class MediaBasicInfo : Tea.TeaModel {
                public var businessType: String?

                public var category: String?

                public var coverURL: String?

                public var createTime: String?

                public var deletedTime: String?

                public var description_: String?

                public var mediaId: String?

                public var mediaTags: String?

                public var mediaType: String?

                public var modifiedTime: String?

                public var source: String?

                public var spriteImages: String?

                public var status: String?

                public var title: String?

                public var userData: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.businessType != nil {
                        map["BusinessType"] = self.businessType!
                    }
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.coverURL != nil {
                        map["CoverURL"] = self.coverURL!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.deletedTime != nil {
                        map["DeletedTime"] = self.deletedTime!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.mediaTags != nil {
                        map["MediaTags"] = self.mediaTags!
                    }
                    if self.mediaType != nil {
                        map["MediaType"] = self.mediaType!
                    }
                    if self.modifiedTime != nil {
                        map["ModifiedTime"] = self.modifiedTime!
                    }
                    if self.source != nil {
                        map["Source"] = self.source!
                    }
                    if self.spriteImages != nil {
                        map["SpriteImages"] = self.spriteImages!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BusinessType") {
                        self.businessType = dict["BusinessType"] as! String
                    }
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("CoverURL") {
                        self.coverURL = dict["CoverURL"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("DeletedTime") {
                        self.deletedTime = dict["DeletedTime"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("MediaTags") {
                        self.mediaTags = dict["MediaTags"] as! String
                    }
                    if dict.keys.contains("MediaType") {
                        self.mediaType = dict["MediaType"] as! String
                    }
                    if dict.keys.contains("ModifiedTime") {
                        self.modifiedTime = dict["ModifiedTime"] as! String
                    }
                    if dict.keys.contains("Source") {
                        self.source = dict["Source"] as! String
                    }
                    if dict.keys.contains("SpriteImages") {
                        self.spriteImages = dict["SpriteImages"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Title") {
                        self.title = dict["Title"] as! String
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                }
            }
            public var dynamicMetaData: SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.DynamicMetaData?

            public var mediaBasicInfo: SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.MediaBasicInfo?

            public var mediaId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dynamicMetaData?.validate()
                try self.mediaBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dynamicMetaData != nil {
                    map["DynamicMetaData"] = self.dynamicMetaData?.toMap()
                }
                if self.mediaBasicInfo != nil {
                    map["MediaBasicInfo"] = self.mediaBasicInfo?.toMap()
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DynamicMetaData") {
                    var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.DynamicMetaData()
                    model.fromMap(dict["DynamicMetaData"] as! [String: Any])
                    self.dynamicMetaData = model
                }
                if dict.keys.contains("MediaBasicInfo") {
                    var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo.MediaBasicInfo()
                    model.fromMap(dict["MediaBasicInfo"] as! [String: Any])
                    self.mediaBasicInfo = model
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
            }
        }
        public var authorized: Bool?

        public var favorite: Bool?

        public var mediaInfo: SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo?

        public var remainingAuthTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorized != nil {
                map["Authorized"] = self.authorized!
            }
            if self.favorite != nil {
                map["Favorite"] = self.favorite!
            }
            if self.mediaInfo != nil {
                map["MediaInfo"] = self.mediaInfo?.toMap()
            }
            if self.remainingAuthTime != nil {
                map["RemainingAuthTime"] = self.remainingAuthTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Authorized") {
                self.authorized = dict["Authorized"] as! Bool
            }
            if dict.keys.contains("Favorite") {
                self.favorite = dict["Favorite"] as! Bool
            }
            if dict.keys.contains("MediaInfo") {
                var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos.MediaInfo()
                model.fromMap(dict["MediaInfo"] as! [String: Any])
                self.mediaInfo = model
            }
            if dict.keys.contains("RemainingAuthTime") {
                self.remainingAuthTime = dict["RemainingAuthTime"] as! String
            }
        }
    }
    public var publicMediaInfos: [SearchPublicMediaInfoResponseBody.PublicMediaInfos]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.publicMediaInfos != nil {
            var tmp : [Any] = []
            for k in self.publicMediaInfos! {
                tmp.append(k.toMap())
            }
            map["PublicMediaInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PublicMediaInfos") {
            var tmp : [SearchPublicMediaInfoResponseBody.PublicMediaInfos] = []
            for v in dict["PublicMediaInfos"] as! [Any] {
                var model = SearchPublicMediaInfoResponseBody.PublicMediaInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.publicMediaInfos = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchPublicMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchPublicMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchPublicMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendAIAgentDataChannelMessageRequest : Tea.TeaModel {
    public var instanceId: String?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
    }
}

public class SendAIAgentDataChannelMessageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendAIAgentDataChannelMessageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendAIAgentDataChannelMessageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendAIAgentDataChannelMessageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendAIAgentSpeechRequest : Tea.TeaModel {
    public var enableInterrupt: Bool?

    public var instanceId: String?

    public var text: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableInterrupt != nil {
            map["EnableInterrupt"] = self.enableInterrupt!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableInterrupt") {
            self.enableInterrupt = dict["EnableInterrupt"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Text") {
            self.text = dict["Text"] as! String
        }
    }
}

public class SendAIAgentSpeechResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendAIAgentSpeechResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendAIAgentSpeechResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendAIAgentSpeechResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendAIAgentTextRequest : Tea.TeaModel {
    public var instanceId: String?

    public var text: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Text") {
            self.text = dict["Text"] as! String
        }
    }
}

public class SendAIAgentTextResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendAIAgentTextResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendAIAgentTextResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendAIAgentTextResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendLiveSnapshotJobCommandRequest : Tea.TeaModel {
    public var command: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class SendLiveSnapshotJobCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendLiveSnapshotJobCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendLiveSnapshotJobCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendLiveSnapshotJobCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendLiveTranscodeJobCommandRequest : Tea.TeaModel {
    public var command: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class SendLiveTranscodeJobCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendLiveTranscodeJobCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendLiveTranscodeJobCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendLiveTranscodeJobCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendMessageChatTextRequest : Tea.TeaModel {
    public var AIAgentId: String?

    public var mode: String?

    public var needArchiving: Bool?

    public var receiverId: String?

    public var sessionId: String?

    public var text: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIAgentId != nil {
            map["AIAgentId"] = self.AIAgentId!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.needArchiving != nil {
            map["NeedArchiving"] = self.needArchiving!
        }
        if self.receiverId != nil {
            map["ReceiverId"] = self.receiverId!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIAgentId") {
            self.AIAgentId = dict["AIAgentId"] as! String
        }
        if dict.keys.contains("Mode") {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("NeedArchiving") {
            self.needArchiving = dict["NeedArchiving"] as! Bool
        }
        if dict.keys.contains("ReceiverId") {
            self.receiverId = dict["ReceiverId"] as! String
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
        if dict.keys.contains("Text") {
            self.text = dict["Text"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class SendMessageChatTextResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendMessageChatTextResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendMessageChatTextResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendMessageChatTextResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetContentAnalyzeConfigRequest : Tea.TeaModel {
    public var auto: Bool?

    public var saveType: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.auto != nil {
            map["Auto"] = self.auto!
        }
        if self.saveType != nil {
            map["SaveType"] = self.saveType!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Auto") {
            self.auto = dict["Auto"] as! Bool
        }
        if dict.keys.contains("SaveType") {
            self.saveType = dict["SaveType"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SetContentAnalyzeConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetContentAnalyzeConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetContentAnalyzeConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetContentAnalyzeConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultCustomTemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SetDefaultCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetDefaultCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDefaultCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultStorageLocationRequest : Tea.TeaModel {
    public var bucket: String?

    public var path: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class SetDefaultStorageLocationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetDefaultStorageLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultStorageLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDefaultStorageLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetEventCallbackRequest : Tea.TeaModel {
    public var authKey: String?

    public var authSwitch: String?

    public var callbackQueueName: String?

    public var callbackType: String?

    public var callbackURL: String?

    public var eventTypeList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.authSwitch != nil {
            map["AuthSwitch"] = self.authSwitch!
        }
        if self.callbackQueueName != nil {
            map["CallbackQueueName"] = self.callbackQueueName!
        }
        if self.callbackType != nil {
            map["CallbackType"] = self.callbackType!
        }
        if self.callbackURL != nil {
            map["CallbackURL"] = self.callbackURL!
        }
        if self.eventTypeList != nil {
            map["EventTypeList"] = self.eventTypeList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthKey") {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("AuthSwitch") {
            self.authSwitch = dict["AuthSwitch"] as! String
        }
        if dict.keys.contains("CallbackQueueName") {
            self.callbackQueueName = dict["CallbackQueueName"] as! String
        }
        if dict.keys.contains("CallbackType") {
            self.callbackType = dict["CallbackType"] as! String
        }
        if dict.keys.contains("CallbackURL") {
            self.callbackURL = dict["CallbackURL"] as! String
        }
        if dict.keys.contains("EventTypeList") {
            self.eventTypeList = dict["EventTypeList"] as! String
        }
    }
}

public class SetEventCallbackResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetEventCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetEventCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetEventCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetNotifyConfigRequest : Tea.TeaModel {
    public var AIAgentId: String?

    public var audioOssPath: String?

    public var callbackUrl: String?

    public var enableAudioRecording: Bool?

    public var enableNotify: Bool?

    public var eventTypes: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIAgentId != nil {
            map["AIAgentId"] = self.AIAgentId!
        }
        if self.audioOssPath != nil {
            map["AudioOssPath"] = self.audioOssPath!
        }
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.enableAudioRecording != nil {
            map["EnableAudioRecording"] = self.enableAudioRecording!
        }
        if self.enableNotify != nil {
            map["EnableNotify"] = self.enableNotify!
        }
        if self.eventTypes != nil {
            map["EventTypes"] = self.eventTypes!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIAgentId") {
            self.AIAgentId = dict["AIAgentId"] as! String
        }
        if dict.keys.contains("AudioOssPath") {
            self.audioOssPath = dict["AudioOssPath"] as! String
        }
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("EnableAudioRecording") {
            self.enableAudioRecording = dict["EnableAudioRecording"] as! Bool
        }
        if dict.keys.contains("EnableNotify") {
            self.enableNotify = dict["EnableNotify"] as! Bool
        }
        if dict.keys.contains("EventTypes") {
            self.eventTypes = dict["EventTypes"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class SetNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartAIAgentInstanceRequest : Tea.TeaModel {
    public class ChatSyncConfig : Tea.TeaModel {
        public var IMAIAgentId: String?

        public var receiverId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.IMAIAgentId != nil {
                map["IMAIAgentId"] = self.IMAIAgentId!
            }
            if self.receiverId != nil {
                map["ReceiverId"] = self.receiverId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IMAIAgentId") {
                self.IMAIAgentId = dict["IMAIAgentId"] as! String
            }
            if dict.keys.contains("ReceiverId") {
                self.receiverId = dict["ReceiverId"] as! String
            }
        }
    }
    public var AIAgentId: String?

    public var chatSyncConfig: StartAIAgentInstanceRequest.ChatSyncConfig?

    public var runtimeConfig: AIAgentRuntimeConfig?

    public var sessionId: String?

    public var templateConfig: AIAgentTemplateConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.chatSyncConfig?.validate()
        try self.runtimeConfig?.validate()
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIAgentId != nil {
            map["AIAgentId"] = self.AIAgentId!
        }
        if self.chatSyncConfig != nil {
            map["ChatSyncConfig"] = self.chatSyncConfig?.toMap()
        }
        if self.runtimeConfig != nil {
            map["RuntimeConfig"] = self.runtimeConfig?.toMap()
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIAgentId") {
            self.AIAgentId = dict["AIAgentId"] as! String
        }
        if dict.keys.contains("ChatSyncConfig") {
            var model = StartAIAgentInstanceRequest.ChatSyncConfig()
            model.fromMap(dict["ChatSyncConfig"] as! [String: Any])
            self.chatSyncConfig = model
        }
        if dict.keys.contains("RuntimeConfig") {
            var model = AIAgentRuntimeConfig()
            model.fromMap(dict["RuntimeConfig"] as! [String: Any])
            self.runtimeConfig = model
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            var model = AIAgentTemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class StartAIAgentInstanceShrinkRequest : Tea.TeaModel {
    public var AIAgentId: String?

    public var chatSyncConfigShrink: String?

    public var runtimeConfigShrink: String?

    public var sessionId: String?

    public var templateConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIAgentId != nil {
            map["AIAgentId"] = self.AIAgentId!
        }
        if self.chatSyncConfigShrink != nil {
            map["ChatSyncConfig"] = self.chatSyncConfigShrink!
        }
        if self.runtimeConfigShrink != nil {
            map["RuntimeConfig"] = self.runtimeConfigShrink!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIAgentId") {
            self.AIAgentId = dict["AIAgentId"] as! String
        }
        if dict.keys.contains("ChatSyncConfig") {
            self.chatSyncConfigShrink = dict["ChatSyncConfig"] as! String
        }
        if dict.keys.contains("RuntimeConfig") {
            self.runtimeConfigShrink = dict["RuntimeConfig"] as! String
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class StartAIAgentInstanceResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartAIAgentInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartAIAgentInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartAIAgentInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartChannelRequest : Tea.TeaModel {
    public var channelName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
    }
}

public class StartChannelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StartChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartMediaLiveChannelRequest : Tea.TeaModel {
    public var channelId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
    }
}

public class StartMediaLiveChannelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartMediaLiveChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartMediaLiveChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartMediaLiveChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartRtcRobotInstanceRequest : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public var asrMaxSilence: Int32?

        public var enableVoiceInterrupt: Bool?

        public var greeting: String?

        public var useVoiceprint: Bool?

        public var userOfflineTimeout: Int32?

        public var userOnlineTimeout: Int32?

        public var voiceId: String?

        public var voiceprintId: String?

        public var volume: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asrMaxSilence != nil {
                map["AsrMaxSilence"] = self.asrMaxSilence!
            }
            if self.enableVoiceInterrupt != nil {
                map["EnableVoiceInterrupt"] = self.enableVoiceInterrupt!
            }
            if self.greeting != nil {
                map["Greeting"] = self.greeting!
            }
            if self.useVoiceprint != nil {
                map["UseVoiceprint"] = self.useVoiceprint!
            }
            if self.userOfflineTimeout != nil {
                map["UserOfflineTimeout"] = self.userOfflineTimeout!
            }
            if self.userOnlineTimeout != nil {
                map["UserOnlineTimeout"] = self.userOnlineTimeout!
            }
            if self.voiceId != nil {
                map["VoiceId"] = self.voiceId!
            }
            if self.voiceprintId != nil {
                map["VoiceprintId"] = self.voiceprintId!
            }
            if self.volume != nil {
                map["Volume"] = self.volume!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsrMaxSilence") {
                self.asrMaxSilence = dict["AsrMaxSilence"] as! Int32
            }
            if dict.keys.contains("EnableVoiceInterrupt") {
                self.enableVoiceInterrupt = dict["EnableVoiceInterrupt"] as! Bool
            }
            if dict.keys.contains("Greeting") {
                self.greeting = dict["Greeting"] as! String
            }
            if dict.keys.contains("UseVoiceprint") {
                self.useVoiceprint = dict["UseVoiceprint"] as! Bool
            }
            if dict.keys.contains("UserOfflineTimeout") {
                self.userOfflineTimeout = dict["UserOfflineTimeout"] as! Int32
            }
            if dict.keys.contains("UserOnlineTimeout") {
                self.userOnlineTimeout = dict["UserOnlineTimeout"] as! Int32
            }
            if dict.keys.contains("VoiceId") {
                self.voiceId = dict["VoiceId"] as! String
            }
            if dict.keys.contains("VoiceprintId") {
                self.voiceprintId = dict["VoiceprintId"] as! String
            }
            if dict.keys.contains("Volume") {
                self.volume = dict["Volume"] as! Int64
            }
        }
    }
    public var authToken: String?

    public var channelId: String?

    public var config: StartRtcRobotInstanceRequest.Config?

    public var robotId: String?

    public var userData: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.config?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authToken != nil {
            map["AuthToken"] = self.authToken!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.config != nil {
            map["Config"] = self.config?.toMap()
        }
        if self.robotId != nil {
            map["RobotId"] = self.robotId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthToken") {
            self.authToken = dict["AuthToken"] as! String
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Config") {
            var model = StartRtcRobotInstanceRequest.Config()
            model.fromMap(dict["Config"] as! [String: Any])
            self.config = model
        }
        if dict.keys.contains("RobotId") {
            self.robotId = dict["RobotId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class StartRtcRobotInstanceShrinkRequest : Tea.TeaModel {
    public var authToken: String?

    public var channelId: String?

    public var configShrink: String?

    public var robotId: String?

    public var userData: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authToken != nil {
            map["AuthToken"] = self.authToken!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.configShrink != nil {
            map["Config"] = self.configShrink!
        }
        if self.robotId != nil {
            map["RobotId"] = self.robotId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthToken") {
            self.authToken = dict["AuthToken"] as! String
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Config") {
            self.configShrink = dict["Config"] as! String
        }
        if dict.keys.contains("RobotId") {
            self.robotId = dict["RobotId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class StartRtcRobotInstanceResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartRtcRobotInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartRtcRobotInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartRtcRobotInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartWorkflowRequest : Tea.TeaModel {
    public var taskInput: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskInput != nil {
            map["TaskInput"] = self.taskInput!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskInput") {
            self.taskInput = dict["TaskInput"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class StartWorkflowResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class StartWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopAIAgentInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class StopAIAgentInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopAIAgentInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopAIAgentInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopAIAgentInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopChannelRequest : Tea.TeaModel {
    public var channelName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
    }
}

public class StopChannelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StopChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopMediaLiveChannelRequest : Tea.TeaModel {
    public var channelId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
    }
}

public class StopMediaLiveChannelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopMediaLiveChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopMediaLiveChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopMediaLiveChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopRtcRobotInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class StopRtcRobotInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopRtcRobotInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopRtcRobotInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopRtcRobotInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitASRJobRequest : Tea.TeaModel {
    public var description_: String?

    public var duration: String?

    public var editingConfig: String?

    public var inputFile: String?

    public var startTime: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputFile != nil {
            map["InputFile"] = self.inputFile!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("EditingConfig") {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputFile") {
            self.inputFile = dict["InputFile"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitASRJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class SubmitASRJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitASRJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitASRJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAudioProduceJobRequest : Tea.TeaModel {
    public var description_: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var overwrite: Bool?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditingConfig") {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Overwrite") {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAudioProduceJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class SubmitAudioProduceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAudioProduceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAudioProduceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAvatarTrainingJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class SubmitAvatarTrainingJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitAvatarTrainingJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitAvatarTrainingJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitAvatarTrainingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAvatarTrainingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAvatarTrainingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAvatarVideoJobRequest : Tea.TeaModel {
    public var description_: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditingConfig") {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAvatarVideoJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAvatarVideoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAvatarVideoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAvatarVideoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitBatchMediaProducingJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var templateConfig: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EditingConfig") {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitBatchMediaProducingJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitBatchMediaProducingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitBatchMediaProducingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitBatchMediaProducingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitCopyrightExtractJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var input: SubmitCopyrightExtractJobRequest.Input?

    public var params: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitCopyrightExtractJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitCopyrightExtractJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var params: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitCopyrightExtractJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitCopyrightExtractJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitCopyrightExtractJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class SubmitCopyrightExtractJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitCopyrightExtractJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitCopyrightExtractJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitCopyrightJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var description_: String?

    public var input: SubmitCopyrightJobRequest.Input?

    public var level: Int64?

    public var message: String?

    public var output: SubmitCopyrightJobRequest.Output?

    public var params: String?

    public var startTime: String?

    public var totalTime: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalTime != nil {
            map["TotalTime"] = self.totalTime!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitCopyrightJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitCopyrightJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TotalTime") {
            self.totalTime = dict["TotalTime"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitCopyrightJobShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var inputShrink: String?

    public var level: Int64?

    public var message: String?

    public var outputShrink: String?

    public var params: String?

    public var startTime: String?

    public var totalTime: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalTime != nil {
            map["TotalTime"] = self.totalTime!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TotalTime") {
            self.totalTime = dict["TotalTime"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitCopyrightJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitCopyrightJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitCopyrightJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class SubmitCopyrightJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitCopyrightJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitCopyrightJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitCustomizedVoiceJobRequest : Tea.TeaModel {
    public var demoAudioMediaURL: String?

    public var voiceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.demoAudioMediaURL != nil {
            map["DemoAudioMediaURL"] = self.demoAudioMediaURL!
        }
        if self.voiceId != nil {
            map["VoiceId"] = self.voiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DemoAudioMediaURL") {
            self.demoAudioMediaURL = dict["DemoAudioMediaURL"] as! String
        }
        if dict.keys.contains("VoiceId") {
            self.voiceId = dict["VoiceId"] as! String
        }
    }
}

public class SubmitCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public var voiceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.voiceId != nil {
                map["VoiceId"] = self.voiceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("VoiceId") {
                self.voiceId = dict["VoiceId"] as! String
            }
        }
    }
    public var data: SubmitCustomizedVoiceJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitCustomizedVoiceJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDNAJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var config: String?

    public var DBId: String?

    public var input: SubmitDNAJobRequest.Input?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var primaryKey: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.primaryKey != nil {
            map["PrimaryKey"] = self.primaryKey!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("DBId") {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitDNAJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("PrimaryKey") {
            self.primaryKey = dict["PrimaryKey"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDNAJobShrinkRequest : Tea.TeaModel {
    public var config: String?

    public var DBId: String?

    public var inputShrink: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var primaryKey: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.DBId != nil {
            map["DBId"] = self.DBId!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.primaryKey != nil {
            map["PrimaryKey"] = self.primaryKey!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("DBId") {
            self.DBId = dict["DBId"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("PrimaryKey") {
            self.primaryKey = dict["PrimaryKey"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDNAJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDNAJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDNAJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitDNAJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDynamicChartJobRequest : Tea.TeaModel {
    public var axisParams: String?

    public var background: String?

    public var chartConfig: String?

    public var chartTitle: String?

    public var chartType: String?

    public var dataSource: String?

    public var description_: String?

    public var input: String?

    public var outputConfig: String?

    public var subtitle: String?

    public var title: String?

    public var unit: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.axisParams != nil {
            map["AxisParams"] = self.axisParams!
        }
        if self.background != nil {
            map["Background"] = self.background!
        }
        if self.chartConfig != nil {
            map["ChartConfig"] = self.chartConfig!
        }
        if self.chartTitle != nil {
            map["ChartTitle"] = self.chartTitle!
        }
        if self.chartType != nil {
            map["ChartType"] = self.chartType!
        }
        if self.dataSource != nil {
            map["DataSource"] = self.dataSource!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.subtitle != nil {
            map["Subtitle"] = self.subtitle!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.unit != nil {
            map["Unit"] = self.unit!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AxisParams") {
            self.axisParams = dict["AxisParams"] as! String
        }
        if dict.keys.contains("Background") {
            self.background = dict["Background"] as! String
        }
        if dict.keys.contains("ChartConfig") {
            self.chartConfig = dict["ChartConfig"] as! String
        }
        if dict.keys.contains("ChartTitle") {
            self.chartTitle = dict["ChartTitle"] as! String
        }
        if dict.keys.contains("ChartType") {
            self.chartType = dict["ChartType"] as! String
        }
        if dict.keys.contains("DataSource") {
            self.dataSource = dict["DataSource"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Subtitle") {
            self.subtitle = dict["Subtitle"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("Unit") {
            self.unit = dict["Unit"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDynamicChartJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDynamicChartJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDynamicChartJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitDynamicChartJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDynamicImageJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public class TemplateConfig : Tea.TeaModel {
        public class OverwriteParams : Tea.TeaModel {
            public class TimeSpan : Tea.TeaModel {
                public var duration: String?

                public var end: String?

                public var seek: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.end != nil {
                        map["End"] = self.end!
                    }
                    if self.seek != nil {
                        map["Seek"] = self.seek!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("End") {
                        self.end = dict["End"] as! String
                    }
                    if dict.keys.contains("Seek") {
                        self.seek = dict["Seek"] as! String
                    }
                }
            }
            public var format: String?

            public var fps: Int32?

            public var height: Int32?

            public var longShortMode: Bool?

            public var scanMode: String?

            public var timeSpan: SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams.TimeSpan?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.timeSpan?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.longShortMode != nil {
                    map["LongShortMode"] = self.longShortMode!
                }
                if self.scanMode != nil {
                    map["ScanMode"] = self.scanMode!
                }
                if self.timeSpan != nil {
                    map["TimeSpan"] = self.timeSpan?.toMap()
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! Int32
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("LongShortMode") {
                    self.longShortMode = dict["LongShortMode"] as! Bool
                }
                if dict.keys.contains("ScanMode") {
                    self.scanMode = dict["ScanMode"] as! String
                }
                if dict.keys.contains("TimeSpan") {
                    var model = SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams.TimeSpan()
                    model.fromMap(dict["TimeSpan"] as! [String: Any])
                    self.timeSpan = model
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var overwriteParams: SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.overwriteParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.overwriteParams != nil {
                map["OverwriteParams"] = self.overwriteParams?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OverwriteParams") {
                var model = SubmitDynamicImageJobRequest.TemplateConfig.OverwriteParams()
                model.fromMap(dict["OverwriteParams"] as! [String: Any])
                self.overwriteParams = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var input: SubmitDynamicImageJobRequest.Input?

    public var name: String?

    public var output: SubmitDynamicImageJobRequest.Output?

    public var scheduleConfig: SubmitDynamicImageJobRequest.ScheduleConfig?

    public var templateConfig: SubmitDynamicImageJobRequest.TemplateConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitDynamicImageJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitDynamicImageJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitDynamicImageJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateConfig") {
            var model = SubmitDynamicImageJobRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDynamicImageJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var templateConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitDynamicImageJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDynamicImageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDynamicImageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitDynamicImageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitHighlightExtractionJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitHighlightExtractionJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitHighlightExtractionJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitHighlightExtractionJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitHighlightExtractionJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitIProductionJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var biz: String?

        public var media: String?

        public var outputUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.biz != nil {
                map["Biz"] = self.biz!
            }
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.outputUrl != nil {
                map["OutputUrl"] = self.outputUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Biz") {
                self.biz = dict["Biz"] as! String
            }
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("OutputUrl") {
                self.outputUrl = dict["OutputUrl"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var functionName: String?

    public var input: SubmitIProductionJobRequest.Input?

    public var jobParams: String?

    public var modelId: String?

    public var name: String?

    public var output: SubmitIProductionJobRequest.Output?

    public var scheduleConfig: SubmitIProductionJobRequest.ScheduleConfig?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.modelId != nil {
            map["ModelId"] = self.modelId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitIProductionJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("JobParams") {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("ModelId") {
            self.modelId = dict["ModelId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitIProductionJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitIProductionJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitIProductionJobShrinkRequest : Tea.TeaModel {
    public var functionName: String?

    public var inputShrink: String?

    public var jobParams: String?

    public var modelId: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.modelId != nil {
            map["ModelId"] = self.modelId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("JobParams") {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("ModelId") {
            self.modelId = dict["ModelId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitIProductionJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitIProductionJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitIProductionJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitIProductionJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveEditingJobRequest : Tea.TeaModel {
    public var clips: String?

    public var liveStreamConfig: String?

    public var mediaProduceConfig: String?

    public var outputMediaConfig: String?

    public var outputMediaTarget: String?

    public var projectId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clips != nil {
            map["Clips"] = self.clips!
        }
        if self.liveStreamConfig != nil {
            map["LiveStreamConfig"] = self.liveStreamConfig!
        }
        if self.mediaProduceConfig != nil {
            map["MediaProduceConfig"] = self.mediaProduceConfig!
        }
        if self.outputMediaConfig != nil {
            map["OutputMediaConfig"] = self.outputMediaConfig!
        }
        if self.outputMediaTarget != nil {
            map["OutputMediaTarget"] = self.outputMediaTarget!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clips") {
            self.clips = dict["Clips"] as! String
        }
        if dict.keys.contains("LiveStreamConfig") {
            self.liveStreamConfig = dict["LiveStreamConfig"] as! String
        }
        if dict.keys.contains("MediaProduceConfig") {
            self.mediaProduceConfig = dict["MediaProduceConfig"] as! String
        }
        if dict.keys.contains("OutputMediaConfig") {
            self.outputMediaConfig = dict["OutputMediaConfig"] as! String
        }
        if dict.keys.contains("OutputMediaTarget") {
            self.outputMediaTarget = dict["OutputMediaTarget"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitLiveEditingJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var mediaURL: String?

    public var projectId: String?

    public var requestId: String?

    public var vodMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaURL != nil {
            map["MediaURL"] = self.mediaURL!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodMediaId != nil {
            map["VodMediaId"] = self.vodMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaURL") {
            self.mediaURL = dict["MediaURL"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodMediaId") {
            self.vodMediaId = dict["VodMediaId"] as! String
        }
    }
}

public class SubmitLiveEditingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveEditingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitLiveEditingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveRecordJobRequest : Tea.TeaModel {
    public class RecordOutput : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class StreamInput : Tea.TeaModel {
        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var name: String?

    public var notifyUrl: String?

    public var recordOutput: SubmitLiveRecordJobRequest.RecordOutput?

    public var streamInput: SubmitLiveRecordJobRequest.StreamInput?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordOutput?.validate()
        try self.streamInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.recordOutput != nil {
            map["RecordOutput"] = self.recordOutput?.toMap()
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("RecordOutput") {
            var model = SubmitLiveRecordJobRequest.RecordOutput()
            model.fromMap(dict["RecordOutput"] as! [String: Any])
            self.recordOutput = model
        }
        if dict.keys.contains("StreamInput") {
            var model = SubmitLiveRecordJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveRecordJobShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var notifyUrl: String?

    public var recordOutputShrink: String?

    public var streamInputShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.recordOutputShrink != nil {
            map["RecordOutput"] = self.recordOutputShrink!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("RecordOutput") {
            self.recordOutputShrink = dict["RecordOutput"] as! String
        }
        if dict.keys.contains("StreamInput") {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveRecordJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitLiveRecordJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveRecordJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitLiveRecordJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveSnapshotJobRequest : Tea.TeaModel {
    public class SnapshotOutput : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("StorageType") {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public class StreamInput : Tea.TeaModel {
        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var callbackUrl: String?

    public var jobName: String?

    public var snapshotOutput: SubmitLiveSnapshotJobRequest.SnapshotOutput?

    public var streamInput: SubmitLiveSnapshotJobRequest.StreamInput?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotOutput?.validate()
        try self.streamInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.snapshotOutput != nil {
            map["SnapshotOutput"] = self.snapshotOutput?.toMap()
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("SnapshotOutput") {
            var model = SubmitLiveSnapshotJobRequest.SnapshotOutput()
            model.fromMap(dict["SnapshotOutput"] as! [String: Any])
            self.snapshotOutput = model
        }
        if dict.keys.contains("StreamInput") {
            var model = SubmitLiveSnapshotJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveSnapshotJobShrinkRequest : Tea.TeaModel {
    public var callbackUrl: String?

    public var jobName: String?

    public var snapshotOutputShrink: String?

    public var streamInputShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.snapshotOutputShrink != nil {
            map["SnapshotOutput"] = self.snapshotOutputShrink!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("SnapshotOutput") {
            self.snapshotOutputShrink = dict["SnapshotOutput"] as! String
        }
        if dict.keys.contains("StreamInput") {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitLiveSnapshotJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitLiveSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitLiveSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitLiveTranscodeJobRequest : Tea.TeaModel {
    public class StreamInput : Tea.TeaModel {
        public var inputUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputUrl") {
                self.inputUrl = dict["InputUrl"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class TimedConfig : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class TranscodeOutput : Tea.TeaModel {
        public var domainName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var name: String?

    public var startMode: Int32?

    public var streamInput: SubmitLiveTranscodeJobRequest.StreamInput?

    public var templateId: String?

    public var timedConfig: SubmitLiveTranscodeJobRequest.TimedConfig?

    public var transcodeOutput: SubmitLiveTranscodeJobRequest.TranscodeOutput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamInput?.validate()
        try self.timedConfig?.validate()
        try self.transcodeOutput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.startMode != nil {
            map["StartMode"] = self.startMode!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timedConfig != nil {
            map["TimedConfig"] = self.timedConfig?.toMap()
        }
        if self.transcodeOutput != nil {
            map["TranscodeOutput"] = self.transcodeOutput?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StartMode") {
            self.startMode = dict["StartMode"] as! Int32
        }
        if dict.keys.contains("StreamInput") {
            var model = SubmitLiveTranscodeJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TimedConfig") {
            var model = SubmitLiveTranscodeJobRequest.TimedConfig()
            model.fromMap(dict["TimedConfig"] as! [String: Any])
            self.timedConfig = model
        }
        if dict.keys.contains("TranscodeOutput") {
            var model = SubmitLiveTranscodeJobRequest.TranscodeOutput()
            model.fromMap(dict["TranscodeOutput"] as! [String: Any])
            self.transcodeOutput = model
        }
    }
}

public class SubmitLiveTranscodeJobShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var startMode: Int32?

    public var streamInputShrink: String?

    public var templateId: String?

    public var timedConfigShrink: String?

    public var transcodeOutputShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.startMode != nil {
            map["StartMode"] = self.startMode!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timedConfigShrink != nil {
            map["TimedConfig"] = self.timedConfigShrink!
        }
        if self.transcodeOutputShrink != nil {
            map["TranscodeOutput"] = self.transcodeOutputShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StartMode") {
            self.startMode = dict["StartMode"] as! Int32
        }
        if dict.keys.contains("StreamInput") {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TimedConfig") {
            self.timedConfigShrink = dict["TimedConfig"] as! String
        }
        if dict.keys.contains("TranscodeOutput") {
            self.transcodeOutputShrink = dict["TranscodeOutput"] as! String
        }
    }
}

public class SubmitLiveTranscodeJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaAiAnalysisJobRequest : Tea.TeaModel {
    public var analysisParams: String?

    public var input: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analysisParams != nil {
            map["AnalysisParams"] = self.analysisParams!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnalysisParams") {
            self.analysisParams = dict["AnalysisParams"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaAiAnalysisJobResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaAiAnalysisJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaAiAnalysisJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaAiAnalysisJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaCensorJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var barrages: String?

    public var coverImages: String?

    public var description_: String?

    public var input: SubmitMediaCensorJobRequest.Input?

    public var notifyUrl: String?

    public var output: String?

    public var scheduleConfig: SubmitMediaCensorJobRequest.ScheduleConfig?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.barrages != nil {
            map["Barrages"] = self.barrages!
        }
        if self.coverImages != nil {
            map["CoverImages"] = self.coverImages!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Barrages") {
            self.barrages = dict["Barrages"] as! String
        }
        if dict.keys.contains("CoverImages") {
            self.coverImages = dict["CoverImages"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitMediaCensorJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitMediaCensorJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaCensorJobShrinkRequest : Tea.TeaModel {
    public var barrages: String?

    public var coverImages: String?

    public var description_: String?

    public var inputShrink: String?

    public var notifyUrl: String?

    public var output: String?

    public var scheduleConfigShrink: String?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.barrages != nil {
            map["Barrages"] = self.barrages!
        }
        if self.coverImages != nil {
            map["CoverImages"] = self.coverImages!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Barrages") {
            self.barrages = dict["Barrages"] as! String
        }
        if dict.keys.contains("CoverImages") {
            self.coverImages = dict["CoverImages"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaCensorJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaCensorJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaCensorJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaCensorJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaConvertJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var config: String?

    public var pipelineId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaConvertJobResponseBody : Tea.TeaModel {
    public class Job : Tea.TeaModel {
        public class Config : Tea.TeaModel {
            public var inputs: [MediaConvertInput]?

            public var outputGroups: [MediaConvertOutputGroup]?

            public var outputs: [MediaConvertOutput]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inputs != nil {
                    var tmp : [Any] = []
                    for k in self.inputs! {
                        tmp.append(k.toMap())
                    }
                    map["Inputs"] = tmp
                }
                if self.outputGroups != nil {
                    var tmp : [Any] = []
                    for k in self.outputGroups! {
                        tmp.append(k.toMap())
                    }
                    map["OutputGroups"] = tmp
                }
                if self.outputs != nil {
                    var tmp : [Any] = []
                    for k in self.outputs! {
                        tmp.append(k.toMap())
                    }
                    map["Outputs"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Inputs") {
                    var tmp : [MediaConvertInput] = []
                    for v in dict["Inputs"] as! [Any] {
                        var model = MediaConvertInput()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputs = tmp
                }
                if dict.keys.contains("OutputGroups") {
                    var tmp : [MediaConvertOutputGroup] = []
                    for v in dict["OutputGroups"] as! [Any] {
                        var model = MediaConvertOutputGroup()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.outputGroups = tmp
                }
                if dict.keys.contains("Outputs") {
                    var tmp : [MediaConvertOutput] = []
                    for v in dict["Outputs"] as! [Any] {
                        var model = MediaConvertOutput()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.outputs = tmp
                }
            }
        }
        public var clientToken: String?

        public var code: String?

        public var config: SubmitMediaConvertJobResponseBody.Job.Config?

        public var jobId: String?

        public var message: String?

        public var outputDetails: [MediaConvertOutputDetail]?

        public var outputGroupDetails: [MediaConvertOutputGroupDetail]?

        public var pipelineId: String?

        public var requestId: String?

        public var state: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.config?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientToken != nil {
                map["ClientToken"] = self.clientToken!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.config != nil {
                map["Config"] = self.config?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.outputDetails != nil {
                var tmp : [Any] = []
                for k in self.outputDetails! {
                    tmp.append(k.toMap())
                }
                map["OutputDetails"] = tmp
            }
            if self.outputGroupDetails != nil {
                var tmp : [Any] = []
                for k in self.outputGroupDetails! {
                    tmp.append(k.toMap())
                }
                map["OutputGroupDetails"] = tmp
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientToken") {
                self.clientToken = dict["ClientToken"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Config") {
                var model = SubmitMediaConvertJobResponseBody.Job.Config()
                model.fromMap(dict["Config"] as! [String: Any])
                self.config = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("OutputDetails") {
                var tmp : [MediaConvertOutputDetail] = []
                for v in dict["OutputDetails"] as! [Any] {
                    var model = MediaConvertOutputDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputDetails = tmp
            }
            if dict.keys.contains("OutputGroupDetails") {
                var tmp : [MediaConvertOutputGroupDetail] = []
                for v in dict["OutputGroupDetails"] as! [Any] {
                    var model = MediaConvertOutputGroupDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroupDetails = tmp
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var job: SubmitMediaConvertJobResponseBody.Job?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.job?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.job != nil {
            map["Job"] = self.job?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Job") {
            var model = SubmitMediaConvertJobResponseBody.Job()
            model.fromMap(dict["Job"] as! [String: Any])
            self.job = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaConvertJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaConvertJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaConvertJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaInfoJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var input: SubmitMediaInfoJobRequest.Input?

    public var name: String?

    public var scheduleConfig: SubmitMediaInfoJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitMediaInfoJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitMediaInfoJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaInfoJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    var tmp : [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    var tmp : [SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: SubmitMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var mediaInfoProperty: SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: SubmitMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: SubmitMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") {
            var model = SubmitMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaProducingJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var clipsParam: String?

    public var editingProduceConfig: String?

    public var mediaMetadata: String?

    public var outputMediaConfig: String?

    public var outputMediaTarget: String?

    public var projectId: String?

    public var projectMetadata: String?

    public var source: String?

    public var templateId: String?

    public var timeline: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clipsParam != nil {
            map["ClipsParam"] = self.clipsParam!
        }
        if self.editingProduceConfig != nil {
            map["EditingProduceConfig"] = self.editingProduceConfig!
        }
        if self.mediaMetadata != nil {
            map["MediaMetadata"] = self.mediaMetadata!
        }
        if self.outputMediaConfig != nil {
            map["OutputMediaConfig"] = self.outputMediaConfig!
        }
        if self.outputMediaTarget != nil {
            map["OutputMediaTarget"] = self.outputMediaTarget!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectMetadata != nil {
            map["ProjectMetadata"] = self.projectMetadata!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ClipsParam") {
            self.clipsParam = dict["ClipsParam"] as! String
        }
        if dict.keys.contains("EditingProduceConfig") {
            self.editingProduceConfig = dict["EditingProduceConfig"] as! String
        }
        if dict.keys.contains("MediaMetadata") {
            self.mediaMetadata = dict["MediaMetadata"] as! String
        }
        if dict.keys.contains("OutputMediaConfig") {
            self.outputMediaConfig = dict["OutputMediaConfig"] as! String
        }
        if dict.keys.contains("OutputMediaTarget") {
            self.outputMediaTarget = dict["OutputMediaTarget"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectMetadata") {
            self.projectMetadata = dict["ProjectMetadata"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaProducingJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var projectId: String?

    public var requestId: String?

    public var vodMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodMediaId != nil {
            map["VodMediaId"] = self.vodMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodMediaId") {
            self.vodMediaId = dict["VodMediaId"] as! String
        }
    }
}

public class SubmitMediaProducingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaProducingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaProducingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitPackageJobRequest : Tea.TeaModel {
    public class Inputs : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var input: SubmitPackageJobRequest.Inputs.Input?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Input") {
                var model = SubmitPackageJobRequest.Inputs.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var inputs: [SubmitPackageJobRequest.Inputs]?

    public var name: String?

    public var output: SubmitPackageJobRequest.Output?

    public var scheduleConfig: SubmitPackageJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.output?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputs != nil {
            var tmp : [Any] = []
            for k in self.inputs! {
                tmp.append(k.toMap())
            }
            map["Inputs"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Inputs") {
            var tmp : [SubmitPackageJobRequest.Inputs] = []
            for v in dict["Inputs"] as! [Any] {
                var model = SubmitPackageJobRequest.Inputs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inputs = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitPackageJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitPackageJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitPackageJobShrinkRequest : Tea.TeaModel {
    public var inputsShrink: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputsShrink != nil {
            map["Inputs"] = self.inputsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Inputs") {
            self.inputsShrink = dict["Inputs"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitPackageJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitPackageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitPackageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitPackageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitProjectExportJobRequest : Tea.TeaModel {
    public var exportType: String?

    public var outputMediaConfig: String?

    public var projectId: String?

    public var timeline: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exportType != nil {
            map["ExportType"] = self.exportType!
        }
        if self.outputMediaConfig != nil {
            map["OutputMediaConfig"] = self.outputMediaConfig!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExportType") {
            self.exportType = dict["ExportType"] as! String
        }
        if dict.keys.contains("OutputMediaConfig") {
            self.outputMediaConfig = dict["OutputMediaConfig"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitProjectExportJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitProjectExportJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitProjectExportJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitProjectExportJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitScreenMediaHighlightsJobRequest : Tea.TeaModel {
    public var editingConfig: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EditingConfig") {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitScreenMediaHighlightsJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitScreenMediaHighlightsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitScreenMediaHighlightsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitScreenMediaHighlightsJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSegmentationJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var inputConfig: String?

    public var jobParams: String?

    public var outputConfig: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("JobParams") {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSegmentationJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSegmentationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSegmentationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSegmentationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSmarttagJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
        }
    }
    public var content: String?

    public var contentAddr: String?

    public var contentType: String?

    public var input: SubmitSmarttagJobRequest.Input?

    public var notifyUrl: String?

    public var params: String?

    public var scheduleConfig: SubmitSmarttagJobRequest.ScheduleConfig?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentAddr != nil {
            map["ContentAddr"] = self.contentAddr!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentAddr") {
            self.contentAddr = dict["ContentAddr"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitSmarttagJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitSmarttagJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSmarttagJobShrinkRequest : Tea.TeaModel {
    public var content: String?

    public var contentAddr: String?

    public var contentType: String?

    public var inputShrink: String?

    public var notifyUrl: String?

    public var params: String?

    public var scheduleConfigShrink: String?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentAddr != nil {
            map["ContentAddr"] = self.contentAddr!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentAddr") {
            self.contentAddr = dict["ContentAddr"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSmarttagJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSmarttagJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSmarttagJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSmarttagJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSnapshotJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
        }
    }
    public class TemplateConfig : Tea.TeaModel {
        public class OverwriteParams : Tea.TeaModel {
            public class SpriteSnapshotConfig : Tea.TeaModel {
                public var cellHeight: Int32?

                public var cellWidth: Int32?

                public var color: String?

                public var columns: Int32?

                public var lines: Int32?

                public var margin: Int32?

                public var padding: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cellHeight != nil {
                        map["CellHeight"] = self.cellHeight!
                    }
                    if self.cellWidth != nil {
                        map["CellWidth"] = self.cellWidth!
                    }
                    if self.color != nil {
                        map["Color"] = self.color!
                    }
                    if self.columns != nil {
                        map["Columns"] = self.columns!
                    }
                    if self.lines != nil {
                        map["Lines"] = self.lines!
                    }
                    if self.margin != nil {
                        map["Margin"] = self.margin!
                    }
                    if self.padding != nil {
                        map["Padding"] = self.padding!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CellHeight") {
                        self.cellHeight = dict["CellHeight"] as! Int32
                    }
                    if dict.keys.contains("CellWidth") {
                        self.cellWidth = dict["CellWidth"] as! Int32
                    }
                    if dict.keys.contains("Color") {
                        self.color = dict["Color"] as! String
                    }
                    if dict.keys.contains("Columns") {
                        self.columns = dict["Columns"] as! Int32
                    }
                    if dict.keys.contains("Lines") {
                        self.lines = dict["Lines"] as! Int32
                    }
                    if dict.keys.contains("Margin") {
                        self.margin = dict["Margin"] as! Int32
                    }
                    if dict.keys.contains("Padding") {
                        self.padding = dict["Padding"] as! Int32
                    }
                }
            }
            public var blackLevel: Int32?

            public var count: Int64?

            public var frameType: String?

            public var height: Int32?

            public var interval: Int64?

            public var isSptFrag: Bool?

            public var pixelBlackThreshold: Int32?

            public var spriteSnapshotConfig: SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams.SpriteSnapshotConfig?

            public var time: Int64?

            public var type: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.spriteSnapshotConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blackLevel != nil {
                    map["BlackLevel"] = self.blackLevel!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.frameType != nil {
                    map["FrameType"] = self.frameType!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.isSptFrag != nil {
                    map["IsSptFrag"] = self.isSptFrag!
                }
                if self.pixelBlackThreshold != nil {
                    map["PixelBlackThreshold"] = self.pixelBlackThreshold!
                }
                if self.spriteSnapshotConfig != nil {
                    map["SpriteSnapshotConfig"] = self.spriteSnapshotConfig?.toMap()
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlackLevel") {
                    self.blackLevel = dict["BlackLevel"] as! Int32
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("FrameType") {
                    self.frameType = dict["FrameType"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("IsSptFrag") {
                    self.isSptFrag = dict["IsSptFrag"] as! Bool
                }
                if dict.keys.contains("PixelBlackThreshold") {
                    self.pixelBlackThreshold = dict["PixelBlackThreshold"] as! Int32
                }
                if dict.keys.contains("SpriteSnapshotConfig") {
                    var model = SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams.SpriteSnapshotConfig()
                    model.fromMap(dict["SpriteSnapshotConfig"] as! [String: Any])
                    self.spriteSnapshotConfig = model
                }
                if dict.keys.contains("Time") {
                    self.time = dict["Time"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var overwriteParams: SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.overwriteParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.overwriteParams != nil {
                map["OverwriteParams"] = self.overwriteParams?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OverwriteParams") {
                var model = SubmitSnapshotJobRequest.TemplateConfig.OverwriteParams()
                model.fromMap(dict["OverwriteParams"] as! [String: Any])
                self.overwriteParams = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var input: SubmitSnapshotJobRequest.Input?

    public var name: String?

    public var output: SubmitSnapshotJobRequest.Output?

    public var scheduleConfig: SubmitSnapshotJobRequest.ScheduleConfig?

    public var templateConfig: SubmitSnapshotJobRequest.TemplateConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
        try self.scheduleConfig?.validate()
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitSnapshotJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitSnapshotJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitSnapshotJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("TemplateConfig") {
            var model = SubmitSnapshotJobRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSnapshotJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var outputShrink: String?

    public var scheduleConfigShrink: String?

    public var templateConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSnapshotJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSportsHighlightsJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSportsHighlightsJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSportsHighlightsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSportsHighlightsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSportsHighlightsJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitStandardCustomizedVoiceJobRequest : Tea.TeaModel {
    public var audios: String?

    public var authentication: String?

    public var demoAudioMediaURL: String?

    public var gender: String?

    public var voiceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audios != nil {
            map["Audios"] = self.audios!
        }
        if self.authentication != nil {
            map["Authentication"] = self.authentication!
        }
        if self.demoAudioMediaURL != nil {
            map["DemoAudioMediaURL"] = self.demoAudioMediaURL!
        }
        if self.gender != nil {
            map["Gender"] = self.gender!
        }
        if self.voiceName != nil {
            map["VoiceName"] = self.voiceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Audios") {
            self.audios = dict["Audios"] as! String
        }
        if dict.keys.contains("Authentication") {
            self.authentication = dict["Authentication"] as! String
        }
        if dict.keys.contains("DemoAudioMediaURL") {
            self.demoAudioMediaURL = dict["DemoAudioMediaURL"] as! String
        }
        if dict.keys.contains("Gender") {
            self.gender = dict["Gender"] as! String
        }
        if dict.keys.contains("VoiceName") {
            self.voiceName = dict["VoiceName"] as! String
        }
    }
}

public class SubmitStandardCustomizedVoiceJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitStandardCustomizedVoiceJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitStandardCustomizedVoiceJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitStandardCustomizedVoiceJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitStandardCustomizedVoiceJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitStandardCustomizedVoiceJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSyncMediaInfoJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var input: SubmitSyncMediaInfoJobRequest.Input?

    public var name: String?

    public var scheduleConfig: SubmitSyncMediaInfoJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitSyncMediaInfoJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitSyncMediaInfoJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSyncMediaInfoJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var name: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSyncMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInfoProperty : Tea.TeaModel {
            public class AudioStreamInfoList : Tea.TeaModel {
                public var bitrate: String?

                public var channelLayout: String?

                public var channels: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var duration: String?

                public var index: String?

                public var lang: String?

                public var sampleFmt: String?

                public var sampleRate: String?

                public var startTime: String?

                public var timebase: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channelLayout != nil {
                        map["ChannelLayout"] = self.channelLayout!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codecLongName != nil {
                        map["CodecLongName"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["CodecName"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["CodecTag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["CodecTagString"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["CodecTimeBase"] = self.codecTimeBase!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.sampleFmt != nil {
                        map["SampleFmt"] = self.sampleFmt!
                    }
                    if self.sampleRate != nil {
                        map["SampleRate"] = self.sampleRate!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timebase != nil {
                        map["Timebase"] = self.timebase!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("ChannelLayout") {
                        self.channelLayout = dict["ChannelLayout"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("CodecLongName") {
                        self.codecLongName = dict["CodecLongName"] as! String
                    }
                    if dict.keys.contains("CodecName") {
                        self.codecName = dict["CodecName"] as! String
                    }
                    if dict.keys.contains("CodecTag") {
                        self.codecTag = dict["CodecTag"] as! String
                    }
                    if dict.keys.contains("CodecTagString") {
                        self.codecTagString = dict["CodecTagString"] as! String
                    }
                    if dict.keys.contains("CodecTimeBase") {
                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("SampleFmt") {
                        self.sampleFmt = dict["SampleFmt"] as! String
                    }
                    if dict.keys.contains("SampleRate") {
                        self.sampleRate = dict["SampleRate"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timebase") {
                        self.timebase = dict["Timebase"] as! String
                    }
                }
            }
            public class FileBasicInfo : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var fileName: String?

                public var fileSize: String?

                public var fileStatus: String?

                public var fileType: String?

                public var fileUrl: String?

                public var formatName: String?

                public var height: String?

                public var mediaId: String?

                public var region: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.fileStatus != nil {
                        map["FileStatus"] = self.fileStatus!
                    }
                    if self.fileType != nil {
                        map["FileType"] = self.fileType!
                    }
                    if self.fileUrl != nil {
                        map["FileUrl"] = self.fileUrl!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.mediaId != nil {
                        map["MediaId"] = self.mediaId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("FileStatus") {
                        self.fileStatus = dict["FileStatus"] as! String
                    }
                    if dict.keys.contains("FileType") {
                        self.fileType = dict["FileType"] as! String
                    }
                    if dict.keys.contains("FileUrl") {
                        self.fileUrl = dict["FileUrl"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MediaId") {
                        self.mediaId = dict["MediaId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class VideoStreamInfoList : Tea.TeaModel {
                public var avgFps: String?

                public var bitRate: String?

                public var codecLongName: String?

                public var codecName: String?

                public var codecTag: String?

                public var codecTagString: String?

                public var codecTimeBase: String?

                public var dar: String?

                public var duration: String?

                public var fps: String?

                public var hasBFrames: String?

                public var height: String?

                public var index: String?

                public var lang: String?

                public var level: String?

                public var numFrames: String?

                public var pixFmt: String?

                public var profile: String?

                public var rotate: String?

                public var sar: String?

                public var startTime: String?

                public var timeBase: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgFps != nil {
                        map["Avg_fps"] = self.avgFps!
                    }
                    if self.bitRate != nil {
                        map["Bit_rate"] = self.bitRate!
                    }
                    if self.codecLongName != nil {
                        map["Codec_long_name"] = self.codecLongName!
                    }
                    if self.codecName != nil {
                        map["Codec_name"] = self.codecName!
                    }
                    if self.codecTag != nil {
                        map["Codec_tag"] = self.codecTag!
                    }
                    if self.codecTagString != nil {
                        map["Codec_tag_string"] = self.codecTagString!
                    }
                    if self.codecTimeBase != nil {
                        map["Codec_time_base"] = self.codecTimeBase!
                    }
                    if self.dar != nil {
                        map["Dar"] = self.dar!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.hasBFrames != nil {
                        map["Has_b_frames"] = self.hasBFrames!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.lang != nil {
                        map["Lang"] = self.lang!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.numFrames != nil {
                        map["NumFrames"] = self.numFrames!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.sar != nil {
                        map["Sar"] = self.sar!
                    }
                    if self.startTime != nil {
                        map["Start_time"] = self.startTime!
                    }
                    if self.timeBase != nil {
                        map["Time_base"] = self.timeBase!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Avg_fps") {
                        self.avgFps = dict["Avg_fps"] as! String
                    }
                    if dict.keys.contains("Bit_rate") {
                        self.bitRate = dict["Bit_rate"] as! String
                    }
                    if dict.keys.contains("Codec_long_name") {
                        self.codecLongName = dict["Codec_long_name"] as! String
                    }
                    if dict.keys.contains("Codec_name") {
                        self.codecName = dict["Codec_name"] as! String
                    }
                    if dict.keys.contains("Codec_tag") {
                        self.codecTag = dict["Codec_tag"] as! String
                    }
                    if dict.keys.contains("Codec_tag_string") {
                        self.codecTagString = dict["Codec_tag_string"] as! String
                    }
                    if dict.keys.contains("Codec_time_base") {
                        self.codecTimeBase = dict["Codec_time_base"] as! String
                    }
                    if dict.keys.contains("Dar") {
                        self.dar = dict["Dar"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Has_b_frames") {
                        self.hasBFrames = dict["Has_b_frames"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Lang") {
                        self.lang = dict["Lang"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("NumFrames") {
                        self.numFrames = dict["NumFrames"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("Sar") {
                        self.sar = dict["Sar"] as! String
                    }
                    if dict.keys.contains("Start_time") {
                        self.startTime = dict["Start_time"] as! String
                    }
                    if dict.keys.contains("Time_base") {
                        self.timeBase = dict["Time_base"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audioStreamInfoList: [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList]?

            public var fileBasicInfo: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo?

            public var videoStreamInfoList: [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileBasicInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.audioStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["AudioStreamInfoList"] = tmp
                }
                if self.fileBasicInfo != nil {
                    map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                }
                if self.videoStreamInfoList != nil {
                    var tmp : [Any] = []
                    for k in self.videoStreamInfoList! {
                        tmp.append(k.toMap())
                    }
                    map["VideoStreamInfoList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioStreamInfoList") {
                    var tmp : [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList] = []
                    for v in dict["AudioStreamInfoList"] as! [Any] {
                        var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.AudioStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioStreamInfoList = tmp
                }
                if dict.keys.contains("FileBasicInfo") {
                    var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.FileBasicInfo()
                    model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                    self.fileBasicInfo = model
                }
                if dict.keys.contains("VideoStreamInfoList") {
                    var tmp : [SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList] = []
                    for v in dict["VideoStreamInfoList"] as! [Any] {
                        var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty.VideoStreamInfoList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.videoStreamInfoList = tmp
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public var async: Bool?

        public var finishTime: String?

        public var input: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var mediaInfoProperty: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty?

        public var name: String?

        public var requestId: String?

        public var scheduleConfig: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig?

        public var status: String?

        public var submitResultJson: [String: Any]?

        public var submitTime: String?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.mediaInfoProperty?.validate()
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaInfoProperty != nil {
                map["MediaInfoProperty"] = self.mediaInfoProperty?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitResultJson != nil {
                map["SubmitResultJson"] = self.submitResultJson!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaInfoProperty") {
                var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.MediaInfoProperty()
                model.fromMap(dict["MediaInfoProperty"] as! [String: Any])
                self.mediaInfoProperty = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitResultJson") {
                self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: SubmitSyncMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") {
            var model = SubmitSyncMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSyncMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSyncMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSyncMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTextGenerateJobRequest : Tea.TeaModel {
    public var description_: String?

    public var generateConfig: String?

    public var title: String?

    public var type: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.generateConfig != nil {
            map["GenerateConfig"] = self.generateConfig!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GenerateConfig") {
            self.generateConfig = dict["GenerateConfig"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTextGenerateJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitTextGenerateJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTextGenerateJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitTextGenerateJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTraceAbJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var cipherBase64ed: String?

    public var input: SubmitTraceAbJobRequest.Input?

    public var level: Int64?

    public var output: SubmitTraceAbJobRequest.Output?

    public var startTime: String?

    public var totalTime: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
        try self.output?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipherBase64ed != nil {
            map["CipherBase64ed"] = self.cipherBase64ed!
        }
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalTime != nil {
            map["TotalTime"] = self.totalTime!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CipherBase64ed") {
            self.cipherBase64ed = dict["CipherBase64ed"] as! String
        }
        if dict.keys.contains("Input") {
            var model = SubmitTraceAbJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! Int64
        }
        if dict.keys.contains("Output") {
            var model = SubmitTraceAbJobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TotalTime") {
            self.totalTime = dict["TotalTime"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTraceAbJobShrinkRequest : Tea.TeaModel {
    public var cipherBase64ed: String?

    public var inputShrink: String?

    public var level: Int64?

    public var outputShrink: String?

    public var startTime: String?

    public var totalTime: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipherBase64ed != nil {
            map["CipherBase64ed"] = self.cipherBase64ed!
        }
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalTime != nil {
            map["TotalTime"] = self.totalTime!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CipherBase64ed") {
            self.cipherBase64ed = dict["CipherBase64ed"] as! String
        }
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! Int64
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TotalTime") {
            self.totalTime = dict["TotalTime"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTraceAbJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public var traceMediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.traceMediaId != nil {
                map["TraceMediaId"] = self.traceMediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("TraceMediaId") {
                self.traceMediaId = dict["TraceMediaId"] as! String
            }
        }
    }
    public var data: SubmitTraceAbJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitTraceAbJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class SubmitTraceAbJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTraceAbJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitTraceAbJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTraceExtractJobRequest : Tea.TeaModel {
    public class Input : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var input: SubmitTraceExtractJobRequest.Input?

    public var params: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.input?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input?.toMap()
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            var model = SubmitTraceExtractJobRequest.Input()
            model.fromMap(dict["Input"] as! [String: Any])
            self.input = model
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTraceExtractJobShrinkRequest : Tea.TeaModel {
    public var inputShrink: String?

    public var params: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputShrink != nil {
            map["Input"] = self.inputShrink!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.inputShrink = dict["Input"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTraceExtractJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitTraceExtractJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitTraceExtractJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class SubmitTraceExtractJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTraceExtractJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitTraceExtractJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTraceM3u8JobRequest : Tea.TeaModel {
    public class Output : Tea.TeaModel {
        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var keyUri: String?

    public var output: SubmitTraceM3u8JobRequest.Output?

    public var params: String?

    public var trace: String?

    public var traceMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.output?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyUri != nil {
            map["KeyUri"] = self.keyUri!
        }
        if self.output != nil {
            map["Output"] = self.output?.toMap()
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.trace != nil {
            map["Trace"] = self.trace!
        }
        if self.traceMediaId != nil {
            map["TraceMediaId"] = self.traceMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyUri") {
            self.keyUri = dict["KeyUri"] as! String
        }
        if dict.keys.contains("Output") {
            var model = SubmitTraceM3u8JobRequest.Output()
            model.fromMap(dict["Output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("Trace") {
            self.trace = dict["Trace"] as! String
        }
        if dict.keys.contains("TraceMediaId") {
            self.traceMediaId = dict["TraceMediaId"] as! String
        }
    }
}

public class SubmitTraceM3u8JobShrinkRequest : Tea.TeaModel {
    public var keyUri: String?

    public var outputShrink: String?

    public var params: String?

    public var trace: String?

    public var traceMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyUri != nil {
            map["KeyUri"] = self.keyUri!
        }
        if self.outputShrink != nil {
            map["Output"] = self.outputShrink!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.trace != nil {
            map["Trace"] = self.trace!
        }
        if self.traceMediaId != nil {
            map["TraceMediaId"] = self.traceMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyUri") {
            self.keyUri = dict["KeyUri"] as! String
        }
        if dict.keys.contains("Output") {
            self.outputShrink = dict["Output"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("Trace") {
            self.trace = dict["Trace"] as! String
        }
        if dict.keys.contains("TraceMediaId") {
            self.traceMediaId = dict["TraceMediaId"] as! String
        }
    }
}

public class SubmitTraceM3u8JobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitTraceM3u8JobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitTraceM3u8JobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitTraceM3u8JobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTraceM3u8JobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitTraceM3u8JobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTranscodeJobRequest : Tea.TeaModel {
    public class InputGroup : Tea.TeaModel {
        public var inputUrl: String?

        public var media: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            if self.media != nil {
                map["Media"] = self.media!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputUrl") {
                self.inputUrl = dict["InputUrl"] as! String
            }
            if dict.keys.contains("Media") {
                self.media = dict["Media"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class OutputGroup : Tea.TeaModel {
        public class Output : Tea.TeaModel {
            public var media: String?

            public var outputUrl: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.outputUrl != nil {
                    map["OutputUrl"] = self.outputUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("OutputUrl") {
                    self.outputUrl = dict["OutputUrl"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class ProcessConfig : Tea.TeaModel {
            public class CombineConfigs : Tea.TeaModel {
                public var audioIndex: String?

                public var duration: Double?

                public var start: Double?

                public var videoIndex: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioIndex != nil {
                        map["AudioIndex"] = self.audioIndex!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.start != nil {
                        map["Start"] = self.start!
                    }
                    if self.videoIndex != nil {
                        map["VideoIndex"] = self.videoIndex!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioIndex") {
                        self.audioIndex = dict["AudioIndex"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Double
                    }
                    if dict.keys.contains("Start") {
                        self.start = dict["Start"] as! Double
                    }
                    if dict.keys.contains("VideoIndex") {
                        self.videoIndex = dict["VideoIndex"] as! String
                    }
                }
            }
            public class Encryption : Tea.TeaModel {
                public var cipherText: String?

                public var decryptKeyUri: String?

                public var encryptType: String?

                public var keyServiceType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cipherText != nil {
                        map["CipherText"] = self.cipherText!
                    }
                    if self.decryptKeyUri != nil {
                        map["DecryptKeyUri"] = self.decryptKeyUri!
                    }
                    if self.encryptType != nil {
                        map["EncryptType"] = self.encryptType!
                    }
                    if self.keyServiceType != nil {
                        map["KeyServiceType"] = self.keyServiceType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CipherText") {
                        self.cipherText = dict["CipherText"] as! String
                    }
                    if dict.keys.contains("DecryptKeyUri") {
                        self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                    }
                    if dict.keys.contains("EncryptType") {
                        self.encryptType = dict["EncryptType"] as! String
                    }
                    if dict.keys.contains("KeyServiceType") {
                        self.keyServiceType = dict["KeyServiceType"] as! String
                    }
                }
            }
            public class ImageWatermarks : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var media: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.media != nil {
                                map["Media"] = self.media!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Media") {
                                self.media = dict["Media"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public class Timeline : Tea.TeaModel {
                        public var duration: String?

                        public var start: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                        }
                    }
                    public var dx: String?

                    public var dy: String?

                    public var file: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                    public var height: String?

                    public var referPos: String?

                    public var timeline: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                        try self.timeline?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dx != nil {
                            map["Dx"] = self.dx!
                        }
                        if self.dy != nil {
                            map["Dy"] = self.dy!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.referPos != nil {
                            map["ReferPos"] = self.referPos!
                        }
                        if self.timeline != nil {
                            map["Timeline"] = self.timeline?.toMap()
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Dx") {
                            self.dx = dict["Dx"] as! String
                        }
                        if dict.keys.contains("Dy") {
                            self.dy = dict["Dy"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("ReferPos") {
                            self.referPos = dict["ReferPos"] as! String
                        }
                        if dict.keys.contains("Timeline") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                            model.fromMap(dict["Timeline"] as! [String: Any])
                            self.timeline = model
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public class Subtitles : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var media: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.media != nil {
                                map["Media"] = self.media!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Media") {
                                self.media = dict["Media"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public var charEnc: String?

                    public var file: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                    public var format: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.charEnc != nil {
                            map["CharEnc"] = self.charEnc!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CharEnc") {
                            self.charEnc = dict["CharEnc"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public class TextWatermarks : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public var adaptive: String?

                    public var borderColor: String?

                    public var borderWidth: Int32?

                    public var content: String?

                    public var fontAlpha: String?

                    public var fontColor: String?

                    public var fontName: String?

                    public var fontSize: Int32?

                    public var left_: String?

                    public var top: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adaptive != nil {
                            map["Adaptive"] = self.adaptive!
                        }
                        if self.borderColor != nil {
                            map["BorderColor"] = self.borderColor!
                        }
                        if self.borderWidth != nil {
                            map["BorderWidth"] = self.borderWidth!
                        }
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.fontAlpha != nil {
                            map["FontAlpha"] = self.fontAlpha!
                        }
                        if self.fontColor != nil {
                            map["FontColor"] = self.fontColor!
                        }
                        if self.fontName != nil {
                            map["FontName"] = self.fontName!
                        }
                        if self.fontSize != nil {
                            map["FontSize"] = self.fontSize!
                        }
                        if self.left_ != nil {
                            map["Left"] = self.left_!
                        }
                        if self.top != nil {
                            map["Top"] = self.top!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Adaptive") {
                            self.adaptive = dict["Adaptive"] as! String
                        }
                        if dict.keys.contains("BorderColor") {
                            self.borderColor = dict["BorderColor"] as! String
                        }
                        if dict.keys.contains("BorderWidth") {
                            self.borderWidth = dict["BorderWidth"] as! Int32
                        }
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("FontAlpha") {
                            self.fontAlpha = dict["FontAlpha"] as! String
                        }
                        if dict.keys.contains("FontColor") {
                            self.fontColor = dict["FontColor"] as! String
                        }
                        if dict.keys.contains("FontName") {
                            self.fontName = dict["FontName"] as! String
                        }
                        if dict.keys.contains("FontSize") {
                            self.fontSize = dict["FontSize"] as! Int32
                        }
                        if dict.keys.contains("Left") {
                            self.left_ = dict["Left"] as! String
                        }
                        if dict.keys.contains("Top") {
                            self.top = dict["Top"] as! String
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public class Transcode : Tea.TeaModel {
                public class OverwriteParams : Tea.TeaModel {
                    public class Audio : Tea.TeaModel {
                        public class Volume : Tea.TeaModel {
                            public var integratedLoudnessTarget: String?

                            public var loudnessRangeTarget: String?

                            public var method: String?

                            public var truePeak: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.integratedLoudnessTarget != nil {
                                    map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                }
                                if self.loudnessRangeTarget != nil {
                                    map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                }
                                if self.method != nil {
                                    map["Method"] = self.method!
                                }
                                if self.truePeak != nil {
                                    map["TruePeak"] = self.truePeak!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("IntegratedLoudnessTarget") {
                                    self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                }
                                if dict.keys.contains("LoudnessRangeTarget") {
                                    self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                }
                                if dict.keys.contains("Method") {
                                    self.method = dict["Method"] as! String
                                }
                                if dict.keys.contains("TruePeak") {
                                    self.truePeak = dict["TruePeak"] as! String
                                }
                            }
                        }
                        public var bitrate: String?

                        public var channels: String?

                        public var codec: String?

                        public var profile: String?

                        public var remove: String?

                        public var samplerate: String?

                        public var volume: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.volume?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.remove != nil {
                                map["Remove"] = self.remove!
                            }
                            if self.samplerate != nil {
                                map["Samplerate"] = self.samplerate!
                            }
                            if self.volume != nil {
                                map["Volume"] = self.volume?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Channels") {
                                self.channels = dict["Channels"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Remove") {
                                self.remove = dict["Remove"] as! String
                            }
                            if dict.keys.contains("Samplerate") {
                                self.samplerate = dict["Samplerate"] as! String
                            }
                            if dict.keys.contains("Volume") {
                                var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                model.fromMap(dict["Volume"] as! [String: Any])
                                self.volume = model
                            }
                        }
                    }
                    public class Container : Tea.TeaModel {
                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public class MuxConfig : Tea.TeaModel {
                        public class Segment : Tea.TeaModel {
                            public var duration: String?

                            public var forceSegTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.forceSegTime != nil {
                                    map["ForceSegTime"] = self.forceSegTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("ForceSegTime") {
                                    self.forceSegTime = dict["ForceSegTime"] as! String
                                }
                            }
                        }
                        public var segment: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.segment?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.segment != nil {
                                map["Segment"] = self.segment?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Segment") {
                                var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                model.fromMap(dict["Segment"] as! [String: Any])
                                self.segment = model
                            }
                        }
                    }
                    public class TransConfig : Tea.TeaModel {
                        public var adjDarMethod: String?

                        public var isCheckAudioBitrate: String?

                        public var isCheckAudioBitrateFail: String?

                        public var isCheckReso: String?

                        public var isCheckResoFail: String?

                        public var isCheckVideoBitrate: String?

                        public var isCheckVideoBitrateFail: String?

                        public var transMode: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adjDarMethod != nil {
                                map["AdjDarMethod"] = self.adjDarMethod!
                            }
                            if self.isCheckAudioBitrate != nil {
                                map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                            }
                            if self.isCheckAudioBitrateFail != nil {
                                map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                            }
                            if self.isCheckReso != nil {
                                map["IsCheckReso"] = self.isCheckReso!
                            }
                            if self.isCheckResoFail != nil {
                                map["IsCheckResoFail"] = self.isCheckResoFail!
                            }
                            if self.isCheckVideoBitrate != nil {
                                map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                            }
                            if self.isCheckVideoBitrateFail != nil {
                                map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                            }
                            if self.transMode != nil {
                                map["TransMode"] = self.transMode!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AdjDarMethod") {
                                self.adjDarMethod = dict["AdjDarMethod"] as! String
                            }
                            if dict.keys.contains("IsCheckAudioBitrate") {
                                self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                            }
                            if dict.keys.contains("IsCheckAudioBitrateFail") {
                                self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                            }
                            if dict.keys.contains("IsCheckReso") {
                                self.isCheckReso = dict["IsCheckReso"] as! String
                            }
                            if dict.keys.contains("IsCheckResoFail") {
                                self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                            }
                            if dict.keys.contains("IsCheckVideoBitrate") {
                                self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                            }
                            if dict.keys.contains("IsCheckVideoBitrateFail") {
                                self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                            }
                            if dict.keys.contains("TransMode") {
                                self.transMode = dict["TransMode"] as! String
                            }
                        }
                    }
                    public class Video : Tea.TeaModel {
                        public var abrMax: String?

                        public var bitrate: String?

                        public var bufsize: String?

                        public var codec: String?

                        public var crf: String?

                        public var crop: String?

                        public var fps: String?

                        public var gop: String?

                        public var height: String?

                        public var longShortMode: String?

                        public var maxrate: String?

                        public var pad: String?

                        public var pixFmt: String?

                        public var preset: String?

                        public var profile: String?

                        public var remove: String?

                        public var scanMode: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.abrMax != nil {
                                map["AbrMax"] = self.abrMax!
                            }
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.bufsize != nil {
                                map["Bufsize"] = self.bufsize!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.crf != nil {
                                map["Crf"] = self.crf!
                            }
                            if self.crop != nil {
                                map["Crop"] = self.crop!
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.gop != nil {
                                map["Gop"] = self.gop!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.longShortMode != nil {
                                map["LongShortMode"] = self.longShortMode!
                            }
                            if self.maxrate != nil {
                                map["Maxrate"] = self.maxrate!
                            }
                            if self.pad != nil {
                                map["Pad"] = self.pad!
                            }
                            if self.pixFmt != nil {
                                map["PixFmt"] = self.pixFmt!
                            }
                            if self.preset != nil {
                                map["Preset"] = self.preset!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.remove != nil {
                                map["Remove"] = self.remove!
                            }
                            if self.scanMode != nil {
                                map["ScanMode"] = self.scanMode!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AbrMax") {
                                self.abrMax = dict["AbrMax"] as! String
                            }
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Bufsize") {
                                self.bufsize = dict["Bufsize"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Crf") {
                                self.crf = dict["Crf"] as! String
                            }
                            if dict.keys.contains("Crop") {
                                self.crop = dict["Crop"] as! String
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("Gop") {
                                self.gop = dict["Gop"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("LongShortMode") {
                                self.longShortMode = dict["LongShortMode"] as! String
                            }
                            if dict.keys.contains("Maxrate") {
                                self.maxrate = dict["Maxrate"] as! String
                            }
                            if dict.keys.contains("Pad") {
                                self.pad = dict["Pad"] as! String
                            }
                            if dict.keys.contains("PixFmt") {
                                self.pixFmt = dict["PixFmt"] as! String
                            }
                            if dict.keys.contains("Preset") {
                                self.preset = dict["Preset"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Remove") {
                                self.remove = dict["Remove"] as! String
                            }
                            if dict.keys.contains("ScanMode") {
                                self.scanMode = dict["ScanMode"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var audio: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                    public var container: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                    public var muxConfig: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                    public var transConfig: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.TransConfig?

                    public var video: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audio?.validate()
                        try self.container?.validate()
                        try self.muxConfig?.validate()
                        try self.transConfig?.validate()
                        try self.video?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audio != nil {
                            map["Audio"] = self.audio?.toMap()
                        }
                        if self.container != nil {
                            map["Container"] = self.container?.toMap()
                        }
                        if self.muxConfig != nil {
                            map["MuxConfig"] = self.muxConfig?.toMap()
                        }
                        if self.transConfig != nil {
                            map["TransConfig"] = self.transConfig?.toMap()
                        }
                        if self.video != nil {
                            map["Video"] = self.video?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Audio") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                            model.fromMap(dict["Audio"] as! [String: Any])
                            self.audio = model
                        }
                        if dict.keys.contains("Container") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                            model.fromMap(dict["Container"] as! [String: Any])
                            self.container = model
                        }
                        if dict.keys.contains("MuxConfig") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                            model.fromMap(dict["MuxConfig"] as! [String: Any])
                            self.muxConfig = model
                        }
                        if dict.keys.contains("TransConfig") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.TransConfig()
                            model.fromMap(dict["TransConfig"] as! [String: Any])
                            self.transConfig = model
                        }
                        if dict.keys.contains("Video") {
                            var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                            model.fromMap(dict["Video"] as! [String: Any])
                            self.video = model
                        }
                    }
                }
                public var overwriteParams: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.overwriteParams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.overwriteParams != nil {
                        map["OverwriteParams"] = self.overwriteParams?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OverwriteParams") {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                        model.fromMap(dict["OverwriteParams"] as! [String: Any])
                        self.overwriteParams = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                }
            }
            public var combineConfigs: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.CombineConfigs]?

            public var encryption: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Encryption?

            public var imageWatermarks: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks]?

            public var subtitles: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles]?

            public var textWatermarks: [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks]?

            public var transcode: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.encryption?.validate()
                try self.transcode?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.combineConfigs != nil {
                    var tmp : [Any] = []
                    for k in self.combineConfigs! {
                        tmp.append(k.toMap())
                    }
                    map["CombineConfigs"] = tmp
                }
                if self.encryption != nil {
                    map["Encryption"] = self.encryption?.toMap()
                }
                if self.imageWatermarks != nil {
                    var tmp : [Any] = []
                    for k in self.imageWatermarks! {
                        tmp.append(k.toMap())
                    }
                    map["ImageWatermarks"] = tmp
                }
                if self.subtitles != nil {
                    var tmp : [Any] = []
                    for k in self.subtitles! {
                        tmp.append(k.toMap())
                    }
                    map["Subtitles"] = tmp
                }
                if self.textWatermarks != nil {
                    var tmp : [Any] = []
                    for k in self.textWatermarks! {
                        tmp.append(k.toMap())
                    }
                    map["TextWatermarks"] = tmp
                }
                if self.transcode != nil {
                    map["Transcode"] = self.transcode?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CombineConfigs") {
                    var tmp : [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.CombineConfigs] = []
                    for v in dict["CombineConfigs"] as! [Any] {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.CombineConfigs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.combineConfigs = tmp
                }
                if dict.keys.contains("Encryption") {
                    var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Encryption()
                    model.fromMap(dict["Encryption"] as! [String: Any])
                    self.encryption = model
                }
                if dict.keys.contains("ImageWatermarks") {
                    var tmp : [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks] = []
                    for v in dict["ImageWatermarks"] as! [Any] {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.ImageWatermarks()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.imageWatermarks = tmp
                }
                if dict.keys.contains("Subtitles") {
                    var tmp : [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles] = []
                    for v in dict["Subtitles"] as! [Any] {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Subtitles()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subtitles = tmp
                }
                if dict.keys.contains("TextWatermarks") {
                    var tmp : [SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks] = []
                    for v in dict["TextWatermarks"] as! [Any] {
                        var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.TextWatermarks()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.textWatermarks = tmp
                }
                if dict.keys.contains("Transcode") {
                    var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig.Transcode()
                    model.fromMap(dict["Transcode"] as! [String: Any])
                    self.transcode = model
                }
            }
        }
        public var output: SubmitTranscodeJobRequest.OutputGroup.Output?

        public var processConfig: SubmitTranscodeJobRequest.OutputGroup.ProcessConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.output?.validate()
            try self.processConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.output != nil {
                map["Output"] = self.output?.toMap()
            }
            if self.processConfig != nil {
                map["ProcessConfig"] = self.processConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Output") {
                var model = SubmitTranscodeJobRequest.OutputGroup.Output()
                model.fromMap(dict["Output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("ProcessConfig") {
                var model = SubmitTranscodeJobRequest.OutputGroup.ProcessConfig()
                model.fromMap(dict["ProcessConfig"] as! [String: Any])
                self.processConfig = model
            }
        }
    }
    public class ScheduleConfig : Tea.TeaModel {
        public var pipelineId: String?

        public var priority: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
        }
    }
    public var clientToken: String?

    public var inputGroup: [SubmitTranscodeJobRequest.InputGroup]?

    public var name: String?

    public var outputGroup: [SubmitTranscodeJobRequest.OutputGroup]?

    public var scheduleConfig: SubmitTranscodeJobRequest.ScheduleConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.inputGroup != nil {
            var tmp : [Any] = []
            for k in self.inputGroup! {
                tmp.append(k.toMap())
            }
            map["InputGroup"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputGroup != nil {
            var tmp : [Any] = []
            for k in self.outputGroup! {
                tmp.append(k.toMap())
            }
            map["OutputGroup"] = tmp
        }
        if self.scheduleConfig != nil {
            map["ScheduleConfig"] = self.scheduleConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InputGroup") {
            var tmp : [SubmitTranscodeJobRequest.InputGroup] = []
            for v in dict["InputGroup"] as! [Any] {
                var model = SubmitTranscodeJobRequest.InputGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inputGroup = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputGroup") {
            var tmp : [SubmitTranscodeJobRequest.OutputGroup] = []
            for v in dict["OutputGroup"] as! [Any] {
                var model = SubmitTranscodeJobRequest.OutputGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outputGroup = tmp
        }
        if dict.keys.contains("ScheduleConfig") {
            var model = SubmitTranscodeJobRequest.ScheduleConfig()
            model.fromMap(dict["ScheduleConfig"] as! [String: Any])
            self.scheduleConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTranscodeJobShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var inputGroupShrink: String?

    public var name: String?

    public var outputGroupShrink: String?

    public var scheduleConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.inputGroupShrink != nil {
            map["InputGroup"] = self.inputGroupShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputGroupShrink != nil {
            map["OutputGroup"] = self.outputGroupShrink!
        }
        if self.scheduleConfigShrink != nil {
            map["ScheduleConfig"] = self.scheduleConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InputGroup") {
            self.inputGroupShrink = dict["InputGroup"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputGroup") {
            self.outputGroupShrink = dict["OutputGroup"] as! String
        }
        if dict.keys.contains("ScheduleConfig") {
            self.scheduleConfigShrink = dict["ScheduleConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTranscodeJobResponseBody : Tea.TeaModel {
    public class TranscodeParentJob : Tea.TeaModel {
        public class InputGroup : Tea.TeaModel {
            public var media: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.media != nil {
                    map["Media"] = self.media!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Media") {
                    self.media = dict["Media"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class OutputGroup : Tea.TeaModel {
            public class Output : Tea.TeaModel {
                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public var keyServiceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        if self.keyServiceType != nil {
                            map["KeyServiceType"] = self.keyServiceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                        if dict.keys.contains("KeyServiceType") {
                            self.keyServiceType = dict["KeyServiceType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class TransConfig : Tea.TeaModel {
                            public var adjDarMethod: String?

                            public var isCheckAudioBitrate: String?

                            public var isCheckAudioBitrateFail: String?

                            public var isCheckReso: String?

                            public var isCheckResoFail: String?

                            public var isCheckVideoBitrate: String?

                            public var isCheckVideoBitrateFail: String?

                            public var transMode: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.adjDarMethod != nil {
                                    map["AdjDarMethod"] = self.adjDarMethod!
                                }
                                if self.isCheckAudioBitrate != nil {
                                    map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                                }
                                if self.isCheckAudioBitrateFail != nil {
                                    map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                                }
                                if self.isCheckReso != nil {
                                    map["IsCheckReso"] = self.isCheckReso!
                                }
                                if self.isCheckResoFail != nil {
                                    map["IsCheckResoFail"] = self.isCheckResoFail!
                                }
                                if self.isCheckVideoBitrate != nil {
                                    map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                                }
                                if self.isCheckVideoBitrateFail != nil {
                                    map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                                }
                                if self.transMode != nil {
                                    map["TransMode"] = self.transMode!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AdjDarMethod") {
                                    self.adjDarMethod = dict["AdjDarMethod"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrate") {
                                    self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrateFail") {
                                    self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                                }
                                if dict.keys.contains("IsCheckReso") {
                                    self.isCheckReso = dict["IsCheckReso"] as! String
                                }
                                if dict.keys.contains("IsCheckResoFail") {
                                    self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrate") {
                                    self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrateFail") {
                                    self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                                }
                                if dict.keys.contains("TransMode") {
                                    self.transMode = dict["TransMode"] as! String
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var transConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.TransConfig?

                        public var video: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.transConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.transConfig != nil {
                                map["TransConfig"] = self.transConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("TransConfig") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.TransConfig()
                                model.fromMap(dict["TransConfig"] as! [String: Any])
                                self.transConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs]?

                public var encryption: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption?

                public var imageWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks]?

                public var subtitles: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles]?

                public var textWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks]?

                public var transcode: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("Subtitles") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public var output: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output?

            public var processConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.output?.validate()
                try self.processConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Output") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
            }
        }
        public class ScheduleConfig : Tea.TeaModel {
            public var pipelineId: String?

            public var priority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
            }
        }
        public class TranscodeJobList : Tea.TeaModel {
            public class InputGroup : Tea.TeaModel {
                public var inputUrl: String?

                public var media: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inputUrl != nil {
                        map["InputUrl"] = self.inputUrl!
                    }
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InputUrl") {
                        self.inputUrl = dict["InputUrl"] as! String
                    }
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class OutFileMeta : Tea.TeaModel {
                public class AudioStreamInfoList : Tea.TeaModel {
                    public var bitrate: String?

                    public var channelLayout: String?

                    public var channels: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var duration: String?

                    public var index: String?

                    public var lang: String?

                    public var sampleFmt: String?

                    public var sampleRate: String?

                    public var startTime: String?

                    public var timebase: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channelLayout != nil {
                            map["ChannelLayout"] = self.channelLayout!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codecLongName != nil {
                            map["CodecLongName"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["CodecName"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["CodecTag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["CodecTagString"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["CodecTimeBase"] = self.codecTimeBase!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.sampleFmt != nil {
                            map["SampleFmt"] = self.sampleFmt!
                        }
                        if self.sampleRate != nil {
                            map["SampleRate"] = self.sampleRate!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.timebase != nil {
                            map["Timebase"] = self.timebase!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("ChannelLayout") {
                            self.channelLayout = dict["ChannelLayout"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("CodecLongName") {
                            self.codecLongName = dict["CodecLongName"] as! String
                        }
                        if dict.keys.contains("CodecName") {
                            self.codecName = dict["CodecName"] as! String
                        }
                        if dict.keys.contains("CodecTag") {
                            self.codecTag = dict["CodecTag"] as! String
                        }
                        if dict.keys.contains("CodecTagString") {
                            self.codecTagString = dict["CodecTagString"] as! String
                        }
                        if dict.keys.contains("CodecTimeBase") {
                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Index") {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("SampleFmt") {
                            self.sampleFmt = dict["SampleFmt"] as! String
                        }
                        if dict.keys.contains("SampleRate") {
                            self.sampleRate = dict["SampleRate"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("Timebase") {
                            self.timebase = dict["Timebase"] as! String
                        }
                    }
                }
                public class FileBasicInfo : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var fileName: String?

                    public var fileSize: String?

                    public var fileStatus: String?

                    public var fileType: String?

                    public var fileUrl: String?

                    public var formatName: String?

                    public var height: String?

                    public var mediaId: String?

                    public var region: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileName != nil {
                            map["FileName"] = self.fileName!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.fileStatus != nil {
                            map["FileStatus"] = self.fileStatus!
                        }
                        if self.fileType != nil {
                            map["FileType"] = self.fileType!
                        }
                        if self.fileUrl != nil {
                            map["FileUrl"] = self.fileUrl!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.mediaId != nil {
                            map["MediaId"] = self.mediaId!
                        }
                        if self.region != nil {
                            map["Region"] = self.region!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileName") {
                            self.fileName = dict["FileName"] as! String
                        }
                        if dict.keys.contains("FileSize") {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("FileStatus") {
                            self.fileStatus = dict["FileStatus"] as! String
                        }
                        if dict.keys.contains("FileType") {
                            self.fileType = dict["FileType"] as! String
                        }
                        if dict.keys.contains("FileUrl") {
                            self.fileUrl = dict["FileUrl"] as! String
                        }
                        if dict.keys.contains("FormatName") {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MediaId") {
                            self.mediaId = dict["MediaId"] as! String
                        }
                        if dict.keys.contains("Region") {
                            self.region = dict["Region"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class VideoStreamInfoList : Tea.TeaModel {
                    public var avgFps: String?

                    public var bitRate: String?

                    public var codecLongName: String?

                    public var codecName: String?

                    public var codecTag: String?

                    public var codecTagString: String?

                    public var codecTimeBase: String?

                    public var dar: String?

                    public var duration: String?

                    public var fps: String?

                    public var hasBFrames: String?

                    public var height: String?

                    public var index: String?

                    public var lang: String?

                    public var level: String?

                    public var numFrames: String?

                    public var pixFmt: String?

                    public var profile: String?

                    public var rotate: String?

                    public var sar: String?

                    public var startTime: String?

                    public var timeBase: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgFps != nil {
                            map["Avg_fps"] = self.avgFps!
                        }
                        if self.bitRate != nil {
                            map["Bit_rate"] = self.bitRate!
                        }
                        if self.codecLongName != nil {
                            map["Codec_long_name"] = self.codecLongName!
                        }
                        if self.codecName != nil {
                            map["Codec_name"] = self.codecName!
                        }
                        if self.codecTag != nil {
                            map["Codec_tag"] = self.codecTag!
                        }
                        if self.codecTagString != nil {
                            map["Codec_tag_string"] = self.codecTagString!
                        }
                        if self.codecTimeBase != nil {
                            map["Codec_time_base"] = self.codecTimeBase!
                        }
                        if self.dar != nil {
                            map["Dar"] = self.dar!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.hasBFrames != nil {
                            map["Has_b_frames"] = self.hasBFrames!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.index != nil {
                            map["Index"] = self.index!
                        }
                        if self.lang != nil {
                            map["Lang"] = self.lang!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.numFrames != nil {
                            map["NumFrames"] = self.numFrames!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.rotate != nil {
                            map["Rotate"] = self.rotate!
                        }
                        if self.sar != nil {
                            map["Sar"] = self.sar!
                        }
                        if self.startTime != nil {
                            map["Start_time"] = self.startTime!
                        }
                        if self.timeBase != nil {
                            map["Time_base"] = self.timeBase!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Avg_fps") {
                            self.avgFps = dict["Avg_fps"] as! String
                        }
                        if dict.keys.contains("Bit_rate") {
                            self.bitRate = dict["Bit_rate"] as! String
                        }
                        if dict.keys.contains("Codec_long_name") {
                            self.codecLongName = dict["Codec_long_name"] as! String
                        }
                        if dict.keys.contains("Codec_name") {
                            self.codecName = dict["Codec_name"] as! String
                        }
                        if dict.keys.contains("Codec_tag") {
                            self.codecTag = dict["Codec_tag"] as! String
                        }
                        if dict.keys.contains("Codec_tag_string") {
                            self.codecTagString = dict["Codec_tag_string"] as! String
                        }
                        if dict.keys.contains("Codec_time_base") {
                            self.codecTimeBase = dict["Codec_time_base"] as! String
                        }
                        if dict.keys.contains("Dar") {
                            self.dar = dict["Dar"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Has_b_frames") {
                            self.hasBFrames = dict["Has_b_frames"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Index") {
                            self.index = dict["Index"] as! String
                        }
                        if dict.keys.contains("Lang") {
                            self.lang = dict["Lang"] as! String
                        }
                        if dict.keys.contains("Level") {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("NumFrames") {
                            self.numFrames = dict["NumFrames"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Rotate") {
                            self.rotate = dict["Rotate"] as! String
                        }
                        if dict.keys.contains("Sar") {
                            self.sar = dict["Sar"] as! String
                        }
                        if dict.keys.contains("Start_time") {
                            self.startTime = dict["Start_time"] as! String
                        }
                        if dict.keys.contains("Time_base") {
                            self.timeBase = dict["Time_base"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var audioStreamInfoList: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList]?

                public var fileBasicInfo: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo?

                public var videoStreamInfoList: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.fileBasicInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.audioStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["AudioStreamInfoList"] = tmp
                    }
                    if self.fileBasicInfo != nil {
                        map["FileBasicInfo"] = self.fileBasicInfo?.toMap()
                    }
                    if self.videoStreamInfoList != nil {
                        var tmp : [Any] = []
                        for k in self.videoStreamInfoList! {
                            tmp.append(k.toMap())
                        }
                        map["VideoStreamInfoList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioStreamInfoList") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList] = []
                        for v in dict["AudioStreamInfoList"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.AudioStreamInfoList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.audioStreamInfoList = tmp
                    }
                    if dict.keys.contains("FileBasicInfo") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.FileBasicInfo()
                        model.fromMap(dict["FileBasicInfo"] as! [String: Any])
                        self.fileBasicInfo = model
                    }
                    if dict.keys.contains("VideoStreamInfoList") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList] = []
                        for v in dict["VideoStreamInfoList"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta.VideoStreamInfoList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.videoStreamInfoList = tmp
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public var media: String?

                public var outputUrl: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.media != nil {
                        map["Media"] = self.media!
                    }
                    if self.outputUrl != nil {
                        map["OutputUrl"] = self.outputUrl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Media") {
                        self.media = dict["Media"] as! String
                    }
                    if dict.keys.contains("OutputUrl") {
                        self.outputUrl = dict["OutputUrl"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ProcessConfig : Tea.TeaModel {
                public class CombineConfigs : Tea.TeaModel {
                    public var audioIndex: String?

                    public var duration: Double?

                    public var start: Double?

                    public var videoIndex: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioIndex != nil {
                            map["AudioIndex"] = self.audioIndex!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        if self.videoIndex != nil {
                            map["VideoIndex"] = self.videoIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioIndex") {
                            self.audioIndex = dict["AudioIndex"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! Double
                        }
                        if dict.keys.contains("VideoIndex") {
                            self.videoIndex = dict["VideoIndex"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var cipherText: String?

                    public var decryptKeyUri: String?

                    public var encryptType: String?

                    public var keyServiceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cipherText != nil {
                            map["CipherText"] = self.cipherText!
                        }
                        if self.decryptKeyUri != nil {
                            map["DecryptKeyUri"] = self.decryptKeyUri!
                        }
                        if self.encryptType != nil {
                            map["EncryptType"] = self.encryptType!
                        }
                        if self.keyServiceType != nil {
                            map["KeyServiceType"] = self.keyServiceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CipherText") {
                            self.cipherText = dict["CipherText"] as! String
                        }
                        if dict.keys.contains("DecryptKeyUri") {
                            self.decryptKeyUri = dict["DecryptKeyUri"] as! String
                        }
                        if dict.keys.contains("EncryptType") {
                            self.encryptType = dict["EncryptType"] as! String
                        }
                        if dict.keys.contains("KeyServiceType") {
                            self.keyServiceType = dict["KeyServiceType"] as! String
                        }
                    }
                }
                public class ImageWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public var duration: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File?

                        public var height: String?

                        public var referPos: String?

                        public var timeline: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Timeline") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Subtitles : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class File : Tea.TeaModel {
                            public var media: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.media != nil {
                                    map["Media"] = self.media!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Media") {
                                    self.media = dict["Media"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var charEnc: String?

                        public var file: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File?

                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.file?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.charEnc != nil {
                                map["CharEnc"] = self.charEnc!
                            }
                            if self.file != nil {
                                map["File"] = self.file?.toMap()
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CharEnc") {
                                self.charEnc = dict["CharEnc"] as! String
                            }
                            if dict.keys.contains("File") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams.File()
                                model.fromMap(dict["File"] as! [String: Any])
                                self.file = model
                            }
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class TextWatermarks : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public var adaptive: String?

                        public var borderColor: String?

                        public var borderWidth: Int32?

                        public var content: String?

                        public var fontAlpha: String?

                        public var fontColor: String?

                        public var fontName: String?

                        public var fontSize: Int32?

                        public var left_: String?

                        public var top: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adaptive != nil {
                                map["Adaptive"] = self.adaptive!
                            }
                            if self.borderColor != nil {
                                map["BorderColor"] = self.borderColor!
                            }
                            if self.borderWidth != nil {
                                map["BorderWidth"] = self.borderWidth!
                            }
                            if self.content != nil {
                                map["Content"] = self.content!
                            }
                            if self.fontAlpha != nil {
                                map["FontAlpha"] = self.fontAlpha!
                            }
                            if self.fontColor != nil {
                                map["FontColor"] = self.fontColor!
                            }
                            if self.fontName != nil {
                                map["FontName"] = self.fontName!
                            }
                            if self.fontSize != nil {
                                map["FontSize"] = self.fontSize!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Adaptive") {
                                self.adaptive = dict["Adaptive"] as! String
                            }
                            if dict.keys.contains("BorderColor") {
                                self.borderColor = dict["BorderColor"] as! String
                            }
                            if dict.keys.contains("BorderWidth") {
                                self.borderWidth = dict["BorderWidth"] as! Int32
                            }
                            if dict.keys.contains("Content") {
                                self.content = dict["Content"] as! String
                            }
                            if dict.keys.contains("FontAlpha") {
                                self.fontAlpha = dict["FontAlpha"] as! String
                            }
                            if dict.keys.contains("FontColor") {
                                self.fontColor = dict["FontColor"] as! String
                            }
                            if dict.keys.contains("FontName") {
                                self.fontName = dict["FontName"] as! String
                            }
                            if dict.keys.contains("FontSize") {
                                self.fontSize = dict["FontSize"] as! Int32
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public class Transcode : Tea.TeaModel {
                    public class OverwriteParams : Tea.TeaModel {
                        public class Audio : Tea.TeaModel {
                            public class Volume : Tea.TeaModel {
                                public var integratedLoudnessTarget: String?

                                public var loudnessRangeTarget: String?

                                public var method: String?

                                public var truePeak: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.integratedLoudnessTarget != nil {
                                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                                    }
                                    if self.loudnessRangeTarget != nil {
                                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                                    }
                                    if self.method != nil {
                                        map["Method"] = self.method!
                                    }
                                    if self.truePeak != nil {
                                        map["TruePeak"] = self.truePeak!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("IntegratedLoudnessTarget") {
                                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                                    }
                                    if dict.keys.contains("LoudnessRangeTarget") {
                                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                                    }
                                    if dict.keys.contains("Method") {
                                        self.method = dict["Method"] as! String
                                    }
                                    if dict.keys.contains("TruePeak") {
                                        self.truePeak = dict["TruePeak"] as! String
                                    }
                                }
                            }
                            public var bitrate: String?

                            public var channels: String?

                            public var codec: String?

                            public var profile: String?

                            public var remove: String?

                            public var samplerate: String?

                            public var volume: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.volume?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.volume != nil {
                                    map["Volume"] = self.volume?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("Volume") {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio.Volume()
                                    model.fromMap(dict["Volume"] as! [String: Any])
                                    self.volume = model
                                }
                            }
                        }
                        public class Container : Tea.TeaModel {
                            public var format: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.format != nil {
                                    map["Format"] = self.format!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Format") {
                                    self.format = dict["Format"] as! String
                                }
                            }
                        }
                        public class MuxConfig : Tea.TeaModel {
                            public class Segment : Tea.TeaModel {
                                public var duration: String?

                                public var forceSegTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.forceSegTime != nil {
                                        map["ForceSegTime"] = self.forceSegTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("ForceSegTime") {
                                        self.forceSegTime = dict["ForceSegTime"] as! String
                                    }
                                }
                            }
                            public var segment: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.segment?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.segment != nil {
                                    map["Segment"] = self.segment?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Segment") {
                                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig.Segment()
                                    model.fromMap(dict["Segment"] as! [String: Any])
                                    self.segment = model
                                }
                            }
                        }
                        public class TransConfig : Tea.TeaModel {
                            public var adjDarMethod: String?

                            public var isCheckAudioBitrate: String?

                            public var isCheckAudioBitrateFail: String?

                            public var isCheckReso: String?

                            public var isCheckResoFail: String?

                            public var isCheckVideoBitrate: String?

                            public var isCheckVideoBitrateFail: String?

                            public var transMode: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.adjDarMethod != nil {
                                    map["AdjDarMethod"] = self.adjDarMethod!
                                }
                                if self.isCheckAudioBitrate != nil {
                                    map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                                }
                                if self.isCheckAudioBitrateFail != nil {
                                    map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                                }
                                if self.isCheckReso != nil {
                                    map["IsCheckReso"] = self.isCheckReso!
                                }
                                if self.isCheckResoFail != nil {
                                    map["IsCheckResoFail"] = self.isCheckResoFail!
                                }
                                if self.isCheckVideoBitrate != nil {
                                    map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                                }
                                if self.isCheckVideoBitrateFail != nil {
                                    map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                                }
                                if self.transMode != nil {
                                    map["TransMode"] = self.transMode!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AdjDarMethod") {
                                    self.adjDarMethod = dict["AdjDarMethod"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrate") {
                                    self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckAudioBitrateFail") {
                                    self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                                }
                                if dict.keys.contains("IsCheckReso") {
                                    self.isCheckReso = dict["IsCheckReso"] as! String
                                }
                                if dict.keys.contains("IsCheckResoFail") {
                                    self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrate") {
                                    self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                                }
                                if dict.keys.contains("IsCheckVideoBitrateFail") {
                                    self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                                }
                                if dict.keys.contains("TransMode") {
                                    self.transMode = dict["TransMode"] as! String
                                }
                            }
                        }
                        public class Video : Tea.TeaModel {
                            public var abrMax: String?

                            public var bitrate: String?

                            public var bufsize: String?

                            public var codec: String?

                            public var crf: String?

                            public var crop: String?

                            public var fps: String?

                            public var gop: String?

                            public var height: String?

                            public var longShortMode: String?

                            public var maxrate: String?

                            public var pad: String?

                            public var pixFmt: String?

                            public var preset: String?

                            public var profile: String?

                            public var remove: String?

                            public var scanMode: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.abrMax != nil {
                                    map["AbrMax"] = self.abrMax!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.bufsize != nil {
                                    map["Bufsize"] = self.bufsize!
                                }
                                if self.codec != nil {
                                    map["Codec"] = self.codec!
                                }
                                if self.crf != nil {
                                    map["Crf"] = self.crf!
                                }
                                if self.crop != nil {
                                    map["Crop"] = self.crop!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.gop != nil {
                                    map["Gop"] = self.gop!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.longShortMode != nil {
                                    map["LongShortMode"] = self.longShortMode!
                                }
                                if self.maxrate != nil {
                                    map["Maxrate"] = self.maxrate!
                                }
                                if self.pad != nil {
                                    map["Pad"] = self.pad!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.preset != nil {
                                    map["Preset"] = self.preset!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.remove != nil {
                                    map["Remove"] = self.remove!
                                }
                                if self.scanMode != nil {
                                    map["ScanMode"] = self.scanMode!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AbrMax") {
                                    self.abrMax = dict["AbrMax"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Bufsize") {
                                    self.bufsize = dict["Bufsize"] as! String
                                }
                                if dict.keys.contains("Codec") {
                                    self.codec = dict["Codec"] as! String
                                }
                                if dict.keys.contains("Crf") {
                                    self.crf = dict["Crf"] as! String
                                }
                                if dict.keys.contains("Crop") {
                                    self.crop = dict["Crop"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("Gop") {
                                    self.gop = dict["Gop"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("LongShortMode") {
                                    self.longShortMode = dict["LongShortMode"] as! String
                                }
                                if dict.keys.contains("Maxrate") {
                                    self.maxrate = dict["Maxrate"] as! String
                                }
                                if dict.keys.contains("Pad") {
                                    self.pad = dict["Pad"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Preset") {
                                    self.preset = dict["Preset"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Remove") {
                                    self.remove = dict["Remove"] as! String
                                }
                                if dict.keys.contains("ScanMode") {
                                    self.scanMode = dict["ScanMode"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var audio: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio?

                        public var container: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container?

                        public var muxConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig?

                        public var transConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.TransConfig?

                        public var video: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audio?.validate()
                            try self.container?.validate()
                            try self.muxConfig?.validate()
                            try self.transConfig?.validate()
                            try self.video?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audio != nil {
                                map["Audio"] = self.audio?.toMap()
                            }
                            if self.container != nil {
                                map["Container"] = self.container?.toMap()
                            }
                            if self.muxConfig != nil {
                                map["MuxConfig"] = self.muxConfig?.toMap()
                            }
                            if self.transConfig != nil {
                                map["TransConfig"] = self.transConfig?.toMap()
                            }
                            if self.video != nil {
                                map["Video"] = self.video?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Audio") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Audio()
                                model.fromMap(dict["Audio"] as! [String: Any])
                                self.audio = model
                            }
                            if dict.keys.contains("Container") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Container()
                                model.fromMap(dict["Container"] as! [String: Any])
                                self.container = model
                            }
                            if dict.keys.contains("MuxConfig") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.MuxConfig()
                                model.fromMap(dict["MuxConfig"] as! [String: Any])
                                self.muxConfig = model
                            }
                            if dict.keys.contains("TransConfig") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.TransConfig()
                                model.fromMap(dict["TransConfig"] as! [String: Any])
                                self.transConfig = model
                            }
                            if dict.keys.contains("Video") {
                                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams.Video()
                                model.fromMap(dict["Video"] as! [String: Any])
                                self.video = model
                            }
                        }
                    }
                    public var overwriteParams: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams?

                    public var templateId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.overwriteParams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.overwriteParams != nil {
                            map["OverwriteParams"] = self.overwriteParams?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OverwriteParams") {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode.OverwriteParams()
                            model.fromMap(dict["OverwriteParams"] as! [String: Any])
                            self.overwriteParams = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                    }
                }
                public var combineConfigs: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs]?

                public var encryption: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption?

                public var imageWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks]?

                public var subtitles: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles]?

                public var textWatermarks: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks]?

                public var transcode: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.encryption?.validate()
                    try self.transcode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.combineConfigs != nil {
                        var tmp : [Any] = []
                        for k in self.combineConfigs! {
                            tmp.append(k.toMap())
                        }
                        map["CombineConfigs"] = tmp
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.imageWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.imageWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["ImageWatermarks"] = tmp
                    }
                    if self.subtitles != nil {
                        var tmp : [Any] = []
                        for k in self.subtitles! {
                            tmp.append(k.toMap())
                        }
                        map["Subtitles"] = tmp
                    }
                    if self.textWatermarks != nil {
                        var tmp : [Any] = []
                        for k in self.textWatermarks! {
                            tmp.append(k.toMap())
                        }
                        map["TextWatermarks"] = tmp
                    }
                    if self.transcode != nil {
                        map["Transcode"] = self.transcode?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CombineConfigs") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs] = []
                        for v in dict["CombineConfigs"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.CombineConfigs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.combineConfigs = tmp
                    }
                    if dict.keys.contains("Encryption") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ImageWatermarks") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks] = []
                        for v in dict["ImageWatermarks"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.ImageWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.imageWatermarks = tmp
                    }
                    if dict.keys.contains("Subtitles") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles] = []
                        for v in dict["Subtitles"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Subtitles()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subtitles = tmp
                    }
                    if dict.keys.contains("TextWatermarks") {
                        var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks] = []
                        for v in dict["TextWatermarks"] as! [Any] {
                            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.TextWatermarks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.textWatermarks = tmp
                    }
                    if dict.keys.contains("Transcode") {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig.Transcode()
                        model.fromMap(dict["Transcode"] as! [String: Any])
                        self.transcode = model
                    }
                }
            }
            public class ScheduleConfig : Tea.TeaModel {
                public var pipelineId: String?

                public var priority: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PipelineId") {
                        self.pipelineId = dict["PipelineId"] as! String
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! Int32
                    }
                }
            }
            public var createTime: String?

            public var finishTime: String?

            public var inputGroup: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup]?

            public var jobId: String?

            public var jobIndex: Int32?

            public var name: String?

            public var outFileMeta: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta?

            public var output: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output?

            public var parentJobId: String?

            public var processConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig?

            public var requestId: String?

            public var scheduleConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig?

            public var status: String?

            public var submitResultJson: [String: Any]?

            public var submitTime: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outFileMeta?.validate()
                try self.output?.validate()
                try self.processConfig?.validate()
                try self.scheduleConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inputGroup != nil {
                    var tmp : [Any] = []
                    for k in self.inputGroup! {
                        tmp.append(k.toMap())
                    }
                    map["InputGroup"] = tmp
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobIndex != nil {
                    map["JobIndex"] = self.jobIndex!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outFileMeta != nil {
                    map["OutFileMeta"] = self.outFileMeta?.toMap()
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.parentJobId != nil {
                    map["ParentJobId"] = self.parentJobId!
                }
                if self.processConfig != nil {
                    map["ProcessConfig"] = self.processConfig?.toMap()
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.scheduleConfig != nil {
                    map["ScheduleConfig"] = self.scheduleConfig?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitResultJson != nil {
                    map["SubmitResultJson"] = self.submitResultJson!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("InputGroup") {
                    var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup] = []
                    for v in dict["InputGroup"] as! [Any] {
                        var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.InputGroup()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputGroup = tmp
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobIndex") {
                    self.jobIndex = dict["JobIndex"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OutFileMeta") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.OutFileMeta()
                    model.fromMap(dict["OutFileMeta"] as! [String: Any])
                    self.outFileMeta = model
                }
                if dict.keys.contains("Output") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("ParentJobId") {
                    self.parentJobId = dict["ParentJobId"] as! String
                }
                if dict.keys.contains("ProcessConfig") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ProcessConfig()
                    model.fromMap(dict["ProcessConfig"] as! [String: Any])
                    self.processConfig = model
                }
                if dict.keys.contains("RequestId") {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ScheduleConfig") {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList.ScheduleConfig()
                    model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                    self.scheduleConfig = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitResultJson") {
                    self.submitResultJson = dict["SubmitResultJson"] as! [String: Any]
                }
                if dict.keys.contains("SubmitTime") {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var createTime: String?

        public var finishTime: String?

        public var inputGroup: [SubmitTranscodeJobResponseBody.TranscodeParentJob.InputGroup]?

        public var jobCount: Int32?

        public var name: String?

        public var outputGroup: [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup]?

        public var parentJobId: String?

        public var percent: Int32?

        public var requestId: String?

        public var scheduleConfig: SubmitTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig?

        public var status: String?

        public var submitTime: String?

        public var transcodeJobList: [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList]?

        public var triggerSource: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scheduleConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inputGroup != nil {
                var tmp : [Any] = []
                for k in self.inputGroup! {
                    tmp.append(k.toMap())
                }
                map["InputGroup"] = tmp
            }
            if self.jobCount != nil {
                map["JobCount"] = self.jobCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputGroup != nil {
                var tmp : [Any] = []
                for k in self.outputGroup! {
                    tmp.append(k.toMap())
                }
                map["OutputGroup"] = tmp
            }
            if self.parentJobId != nil {
                map["ParentJobId"] = self.parentJobId!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.scheduleConfig != nil {
                map["ScheduleConfig"] = self.scheduleConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.transcodeJobList != nil {
                var tmp : [Any] = []
                for k in self.transcodeJobList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJobList"] = tmp
            }
            if self.triggerSource != nil {
                map["TriggerSource"] = self.triggerSource!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("InputGroup") {
                var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.InputGroup] = []
                for v in dict["InputGroup"] as! [Any] {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.InputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputGroup = tmp
            }
            if dict.keys.contains("JobCount") {
                self.jobCount = dict["JobCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OutputGroup") {
                var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup] = []
                for v in dict["OutputGroup"] as! [Any] {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.OutputGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputGroup = tmp
            }
            if dict.keys.contains("ParentJobId") {
                self.parentJobId = dict["ParentJobId"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ScheduleConfig") {
                var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.ScheduleConfig()
                model.fromMap(dict["ScheduleConfig"] as! [String: Any])
                self.scheduleConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubmitTime") {
                self.submitTime = dict["SubmitTime"] as! String
            }
            if dict.keys.contains("TranscodeJobList") {
                var tmp : [SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList] = []
                for v in dict["TranscodeJobList"] as! [Any] {
                    var model = SubmitTranscodeJobResponseBody.TranscodeParentJob.TranscodeJobList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeJobList = tmp
            }
            if dict.keys.contains("TriggerSource") {
                self.triggerSource = dict["TriggerSource"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeParentJob: SubmitTranscodeJobResponseBody.TranscodeParentJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeParentJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeParentJob != nil {
            map["TranscodeParentJob"] = self.transcodeParentJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeParentJob") {
            var model = SubmitTranscodeJobResponseBody.TranscodeParentJob()
            model.fromMap(dict["TranscodeParentJob"] as! [String: Any])
            self.transcodeParentJob = model
        }
    }
}

public class SubmitTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitVideoTranslationJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var editingConfig: String?

    public var inputConfig: String?

    public var outputConfig: String?

    public var signature: String?

    public var signatureMehtod: String?

    public var signatureNonce: String?

    public var signatureType: String?

    public var signatureVersion: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editingConfig != nil {
            map["EditingConfig"] = self.editingConfig!
        }
        if self.inputConfig != nil {
            map["InputConfig"] = self.inputConfig!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.signature != nil {
            map["Signature"] = self.signature!
        }
        if self.signatureMehtod != nil {
            map["SignatureMehtod"] = self.signatureMehtod!
        }
        if self.signatureNonce != nil {
            map["SignatureNonce"] = self.signatureNonce!
        }
        if self.signatureType != nil {
            map["SignatureType"] = self.signatureType!
        }
        if self.signatureVersion != nil {
            map["SignatureVersion"] = self.signatureVersion!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditingConfig") {
            self.editingConfig = dict["EditingConfig"] as! String
        }
        if dict.keys.contains("InputConfig") {
            self.inputConfig = dict["InputConfig"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("Signature") {
            self.signature = dict["Signature"] as! String
        }
        if dict.keys.contains("SignatureMehtod") {
            self.signatureMehtod = dict["SignatureMehtod"] as! String
        }
        if dict.keys.contains("SignatureNonce") {
            self.signatureNonce = dict["SignatureNonce"] as! String
        }
        if dict.keys.contains("SignatureType") {
            self.signatureType = dict["SignatureType"] as! String
        }
        if dict.keys.contains("SignatureVersion") {
            self.signatureVersion = dict["SignatureVersion"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitVideoTranslationJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitVideoTranslationJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitVideoTranslationJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitVideoTranslationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitVideoTranslationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitVideoTranslationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TakeoverAIAgentCallRequest : Tea.TeaModel {
    public var humanAgentUserId: String?

    public var instanceId: String?

    public var requireToken: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.humanAgentUserId != nil {
            map["HumanAgentUserId"] = self.humanAgentUserId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requireToken != nil {
            map["RequireToken"] = self.requireToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HumanAgentUserId") {
            self.humanAgentUserId = dict["HumanAgentUserId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequireToken") {
            self.requireToken = dict["RequireToken"] as! Bool
        }
    }
}

public class TakeoverAIAgentCallResponseBody : Tea.TeaModel {
    public var channelId: String?

    public var humanAgentUserId: String?

    public var requestId: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.humanAgentUserId != nil {
            map["HumanAgentUserId"] = self.humanAgentUserId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("HumanAgentUserId") {
            self.humanAgentUserId = dict["HumanAgentUserId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class TakeoverAIAgentCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TakeoverAIAgentCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TakeoverAIAgentCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAIAgentInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var templateConfig: AIAgentTemplateConfig?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            var model = AIAgentTemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UpdateAIAgentInstanceShrinkRequest : Tea.TeaModel {
    public var instanceId: String?

    public var templateConfigShrink: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UpdateAIAgentInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAIAgentInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAIAgentInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAIAgentInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAdInsertionRequest : Tea.TeaModel {
    public var adMarkerPassthrough: String?

    public var adsUrl: String?

    public var cdnAdSegmentUrlPrefix: String?

    public var cdnContentSegmentUrlPrefix: String?

    public var configAliases: String?

    public var contentUrlPrefix: String?

    public var name: String?

    public var personalizationThreshold: Int32?

    public var slateAdUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adMarkerPassthrough != nil {
            map["AdMarkerPassthrough"] = self.adMarkerPassthrough!
        }
        if self.adsUrl != nil {
            map["AdsUrl"] = self.adsUrl!
        }
        if self.cdnAdSegmentUrlPrefix != nil {
            map["CdnAdSegmentUrlPrefix"] = self.cdnAdSegmentUrlPrefix!
        }
        if self.cdnContentSegmentUrlPrefix != nil {
            map["CdnContentSegmentUrlPrefix"] = self.cdnContentSegmentUrlPrefix!
        }
        if self.configAliases != nil {
            map["ConfigAliases"] = self.configAliases!
        }
        if self.contentUrlPrefix != nil {
            map["ContentUrlPrefix"] = self.contentUrlPrefix!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.personalizationThreshold != nil {
            map["PersonalizationThreshold"] = self.personalizationThreshold!
        }
        if self.slateAdUrl != nil {
            map["SlateAdUrl"] = self.slateAdUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdMarkerPassthrough") {
            self.adMarkerPassthrough = dict["AdMarkerPassthrough"] as! String
        }
        if dict.keys.contains("AdsUrl") {
            self.adsUrl = dict["AdsUrl"] as! String
        }
        if dict.keys.contains("CdnAdSegmentUrlPrefix") {
            self.cdnAdSegmentUrlPrefix = dict["CdnAdSegmentUrlPrefix"] as! String
        }
        if dict.keys.contains("CdnContentSegmentUrlPrefix") {
            self.cdnContentSegmentUrlPrefix = dict["CdnContentSegmentUrlPrefix"] as! String
        }
        if dict.keys.contains("ConfigAliases") {
            self.configAliases = dict["ConfigAliases"] as! String
        }
        if dict.keys.contains("ContentUrlPrefix") {
            self.contentUrlPrefix = dict["ContentUrlPrefix"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PersonalizationThreshold") {
            self.personalizationThreshold = dict["PersonalizationThreshold"] as! Int32
        }
        if dict.keys.contains("SlateAdUrl") {
            self.slateAdUrl = dict["SlateAdUrl"] as! String
        }
    }
}

public class UpdateAdInsertionResponseBody : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public class CdnConfig : Tea.TeaModel {
            public var adSegmentUrlPrefix: String?

            public var contentSegmentUrlPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adSegmentUrlPrefix != nil {
                    map["AdSegmentUrlPrefix"] = self.adSegmentUrlPrefix!
                }
                if self.contentSegmentUrlPrefix != nil {
                    map["ContentSegmentUrlPrefix"] = self.contentSegmentUrlPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdSegmentUrlPrefix") {
                    self.adSegmentUrlPrefix = dict["AdSegmentUrlPrefix"] as! String
                }
                if dict.keys.contains("ContentSegmentUrlPrefix") {
                    self.contentSegmentUrlPrefix = dict["ContentSegmentUrlPrefix"] as! String
                }
            }
        }
        public class ManifestEndpointConfig : Tea.TeaModel {
            public var hlsPrefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hlsPrefix != nil {
                    map["HlsPrefix"] = self.hlsPrefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HlsPrefix") {
                    self.hlsPrefix = dict["HlsPrefix"] as! String
                }
            }
        }
        public var adMarkerPassthrough: String?

        public var adsUrl: String?

        public var cdnConfig: UpdateAdInsertionResponseBody.Config.CdnConfig?

        public var configAliases: String?

        public var contentUrlPrefix: String?

        public var createTime: String?

        public var lastModified: String?

        public var manifestEndpointConfig: UpdateAdInsertionResponseBody.Config.ManifestEndpointConfig?

        public var name: String?

        public var personalizationThreshold: Int32?

        public var slateAdUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cdnConfig?.validate()
            try self.manifestEndpointConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adMarkerPassthrough != nil {
                map["AdMarkerPassthrough"] = self.adMarkerPassthrough!
            }
            if self.adsUrl != nil {
                map["AdsUrl"] = self.adsUrl!
            }
            if self.cdnConfig != nil {
                map["CdnConfig"] = self.cdnConfig?.toMap()
            }
            if self.configAliases != nil {
                map["ConfigAliases"] = self.configAliases!
            }
            if self.contentUrlPrefix != nil {
                map["ContentUrlPrefix"] = self.contentUrlPrefix!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.manifestEndpointConfig != nil {
                map["ManifestEndpointConfig"] = self.manifestEndpointConfig?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.personalizationThreshold != nil {
                map["PersonalizationThreshold"] = self.personalizationThreshold!
            }
            if self.slateAdUrl != nil {
                map["SlateAdUrl"] = self.slateAdUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AdMarkerPassthrough") {
                self.adMarkerPassthrough = dict["AdMarkerPassthrough"] as! String
            }
            if dict.keys.contains("AdsUrl") {
                self.adsUrl = dict["AdsUrl"] as! String
            }
            if dict.keys.contains("CdnConfig") {
                var model = UpdateAdInsertionResponseBody.Config.CdnConfig()
                model.fromMap(dict["CdnConfig"] as! [String: Any])
                self.cdnConfig = model
            }
            if dict.keys.contains("ConfigAliases") {
                self.configAliases = dict["ConfigAliases"] as! String
            }
            if dict.keys.contains("ContentUrlPrefix") {
                self.contentUrlPrefix = dict["ContentUrlPrefix"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("ManifestEndpointConfig") {
                var model = UpdateAdInsertionResponseBody.Config.ManifestEndpointConfig()
                model.fromMap(dict["ManifestEndpointConfig"] as! [String: Any])
                self.manifestEndpointConfig = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PersonalizationThreshold") {
                self.personalizationThreshold = dict["PersonalizationThreshold"] as! Int32
            }
            if dict.keys.contains("SlateAdUrl") {
                self.slateAdUrl = dict["SlateAdUrl"] as! String
            }
        }
    }
    public var config: UpdateAdInsertionResponseBody.Config?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.config?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            var model = UpdateAdInsertionResponseBody.Config()
            model.fromMap(dict["Config"] as! [String: Any])
            self.config = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAdInsertionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAdInsertionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAdInsertionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAvatarTrainingJobRequest : Tea.TeaModel {
    public var avatarDescription: String?

    public var avatarName: String?

    public var jobId: String?

    public var portrait: String?

    public var thumbnail: String?

    public var transparent: Bool?

    public var video: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarDescription != nil {
            map["AvatarDescription"] = self.avatarDescription!
        }
        if self.avatarName != nil {
            map["AvatarName"] = self.avatarName!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.portrait != nil {
            map["Portrait"] = self.portrait!
        }
        if self.thumbnail != nil {
            map["Thumbnail"] = self.thumbnail!
        }
        if self.transparent != nil {
            map["Transparent"] = self.transparent!
        }
        if self.video != nil {
            map["Video"] = self.video!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarDescription") {
            self.avatarDescription = dict["AvatarDescription"] as! String
        }
        if dict.keys.contains("AvatarName") {
            self.avatarName = dict["AvatarName"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Portrait") {
            self.portrait = dict["Portrait"] as! String
        }
        if dict.keys.contains("Thumbnail") {
            self.thumbnail = dict["Thumbnail"] as! String
        }
        if dict.keys.contains("Transparent") {
            self.transparent = dict["Transparent"] as! Bool
        }
        if dict.keys.contains("Video") {
            self.video = dict["Video"] as! String
        }
    }
}

public class UpdateAvatarTrainingJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: UpdateAvatarTrainingJobResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = UpdateAvatarTrainingJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateAvatarTrainingJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAvatarTrainingJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAvatarTrainingJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var cateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CateName") {
            self.cateName = dict["CateName"] as! String
        }
    }
}

public class UpdateCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateChannelRequest : Tea.TeaModel {
    public var accessPolicy: Bool?

    public var accessToken: String?

    public var channelName: String?

    public var fillerSourceLocationName: String?

    public var fillerSourceName: String?

    public var outPutConfigList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPolicy != nil {
            map["AccessPolicy"] = self.accessPolicy!
        }
        if self.accessToken != nil {
            map["AccessToken"] = self.accessToken!
        }
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.fillerSourceLocationName != nil {
            map["FillerSourceLocationName"] = self.fillerSourceLocationName!
        }
        if self.fillerSourceName != nil {
            map["FillerSourceName"] = self.fillerSourceName!
        }
        if self.outPutConfigList != nil {
            map["OutPutConfigList"] = self.outPutConfigList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessPolicy") {
            self.accessPolicy = dict["AccessPolicy"] as! Bool
        }
        if dict.keys.contains("AccessToken") {
            self.accessToken = dict["AccessToken"] as! String
        }
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("FillerSourceLocationName") {
            self.fillerSourceLocationName = dict["FillerSourceLocationName"] as! String
        }
        if dict.keys.contains("FillerSourceName") {
            self.fillerSourceName = dict["FillerSourceName"] as! String
        }
        if dict.keys.contains("OutPutConfigList") {
            self.outPutConfigList = dict["OutPutConfigList"] as! String
        }
    }
}

public class UpdateChannelResponseBody : Tea.TeaModel {
    public var channel: ChannelAssemblyChannel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.channel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channel != nil {
            map["Channel"] = self.channel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Channel") {
            var model = ChannelAssemblyChannel()
            model.fromMap(dict["Channel"] as! [String: Any])
            self.channel = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCustomTemplateRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfig: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCustomizedVoiceRequest : Tea.TeaModel {
    public var demoAudioMediaId: String?

    public var voiceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.demoAudioMediaId != nil {
            map["DemoAudioMediaId"] = self.demoAudioMediaId!
        }
        if self.voiceId != nil {
            map["VoiceId"] = self.voiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DemoAudioMediaId") {
            self.demoAudioMediaId = dict["DemoAudioMediaId"] as! String
        }
        if dict.keys.contains("VoiceId") {
            self.voiceId = dict["VoiceId"] as! String
        }
    }
}

public class UpdateCustomizedVoiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCustomizedVoiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomizedVoiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCustomizedVoiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEditingProjectRequest : Tea.TeaModel {
    public var businessStatus: String?

    public var clipsParam: String?

    public var coverURL: String?

    public var description_: String?

    public var projectId: String?

    public var templateId: String?

    public var timeline: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.clipsParam != nil {
            map["ClipsParam"] = self.clipsParam!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessStatus") {
            self.businessStatus = dict["BusinessStatus"] as! String
        }
        if dict.keys.contains("ClipsParam") {
            self.clipsParam = dict["ClipsParam"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateEditingProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLivePackageChannelRequest : Tea.TeaModel {
    public var channelName: String?

    public var description_: String?

    public var groupName: String?

    public var protocol_: String?

    public var segmentCount: Int32?

    public var segmentDuration: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.segmentCount != nil {
            map["SegmentCount"] = self.segmentCount!
        }
        if self.segmentDuration != nil {
            map["SegmentDuration"] = self.segmentDuration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("SegmentCount") {
            self.segmentCount = dict["SegmentCount"] as! Int32
        }
        if dict.keys.contains("SegmentDuration") {
            self.segmentDuration = dict["SegmentDuration"] as! Int32
        }
    }
}

public class UpdateLivePackageChannelResponseBody : Tea.TeaModel {
    public class LivePackageChannel : Tea.TeaModel {
        public class IngestEndpoints : Tea.TeaModel {
            public var id: String?

            public var password: String?

            public var url: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public var channelName: String?

        public var createTime: String?

        public var description_: String?

        public var groupName: String?

        public var ingestEndpoints: [UpdateLivePackageChannelResponseBody.LivePackageChannel.IngestEndpoints]?

        public var lastModified: String?

        public var protocol_: String?

        public var segmentCount: Int32?

        public var segmentDuration: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.ingestEndpoints != nil {
                var tmp : [Any] = []
                for k in self.ingestEndpoints! {
                    tmp.append(k.toMap())
                }
                map["IngestEndpoints"] = tmp
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.segmentCount != nil {
                map["SegmentCount"] = self.segmentCount!
            }
            if self.segmentDuration != nil {
                map["SegmentDuration"] = self.segmentDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("IngestEndpoints") {
                var tmp : [UpdateLivePackageChannelResponseBody.LivePackageChannel.IngestEndpoints] = []
                for v in dict["IngestEndpoints"] as! [Any] {
                    var model = UpdateLivePackageChannelResponseBody.LivePackageChannel.IngestEndpoints()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ingestEndpoints = tmp
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("SegmentCount") {
                self.segmentCount = dict["SegmentCount"] as! Int32
            }
            if dict.keys.contains("SegmentDuration") {
                self.segmentDuration = dict["SegmentDuration"] as! Int32
            }
        }
    }
    public var livePackageChannel: UpdateLivePackageChannelResponseBody.LivePackageChannel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.livePackageChannel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageChannel != nil {
            map["LivePackageChannel"] = self.livePackageChannel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LivePackageChannel") {
            var model = UpdateLivePackageChannelResponseBody.LivePackageChannel()
            model.fromMap(dict["LivePackageChannel"] as! [String: Any])
            self.livePackageChannel = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLivePackageChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLivePackageChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLivePackageChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLivePackageChannelCredentialsRequest : Tea.TeaModel {
    public var channelName: String?

    public var groupName: String?

    public var rotateCredentials: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.rotateCredentials != nil {
            map["RotateCredentials"] = self.rotateCredentials!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RotateCredentials") {
            self.rotateCredentials = dict["RotateCredentials"] as! Int32
        }
    }
}

public class UpdateLivePackageChannelCredentialsResponseBody : Tea.TeaModel {
    public class IngestEndpoints : Tea.TeaModel {
        public var id: String?

        public var password: String?

        public var url: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.username != nil {
                map["Username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("Username") {
                self.username = dict["Username"] as! String
            }
        }
    }
    public var ingestEndpoints: [UpdateLivePackageChannelCredentialsResponseBody.IngestEndpoints]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ingestEndpoints != nil {
            var tmp : [Any] = []
            for k in self.ingestEndpoints! {
                tmp.append(k.toMap())
            }
            map["IngestEndpoints"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IngestEndpoints") {
            var tmp : [UpdateLivePackageChannelCredentialsResponseBody.IngestEndpoints] = []
            for v in dict["IngestEndpoints"] as! [Any] {
                var model = UpdateLivePackageChannelCredentialsResponseBody.IngestEndpoints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ingestEndpoints = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLivePackageChannelCredentialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLivePackageChannelCredentialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLivePackageChannelCredentialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLivePackageChannelGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class UpdateLivePackageChannelGroupResponseBody : Tea.TeaModel {
    public class LivePackageChannelGroup : Tea.TeaModel {
        public var createTime: String?

        public var description_: String?

        public var groupName: String?

        public var lastModified: String?

        public var originDomain: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.originDomain != nil {
                map["OriginDomain"] = self.originDomain!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("OriginDomain") {
                self.originDomain = dict["OriginDomain"] as! String
            }
        }
    }
    public var livePackageChannelGroup: UpdateLivePackageChannelGroupResponseBody.LivePackageChannelGroup?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.livePackageChannelGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageChannelGroup != nil {
            map["LivePackageChannelGroup"] = self.livePackageChannelGroup?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LivePackageChannelGroup") {
            var model = UpdateLivePackageChannelGroupResponseBody.LivePackageChannelGroup()
            model.fromMap(dict["LivePackageChannelGroup"] as! [String: Any])
            self.livePackageChannelGroup = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLivePackageChannelGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLivePackageChannelGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLivePackageChannelGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLivePackageOriginEndpointRequest : Tea.TeaModel {
    public var authorizationCode: String?

    public var channelName: String?

    public var description_: String?

    public var endpointName: String?

    public var groupName: String?

    public var ipBlacklist: String?

    public var ipWhitelist: String?

    public var manifestName: String?

    public var protocol_: String?

    public var timeshiftVision: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizationCode != nil {
            map["AuthorizationCode"] = self.authorizationCode!
        }
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.ipBlacklist != nil {
            map["IpBlacklist"] = self.ipBlacklist!
        }
        if self.ipWhitelist != nil {
            map["IpWhitelist"] = self.ipWhitelist!
        }
        if self.manifestName != nil {
            map["ManifestName"] = self.manifestName!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.timeshiftVision != nil {
            map["TimeshiftVision"] = self.timeshiftVision!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizationCode") {
            self.authorizationCode = dict["AuthorizationCode"] as! String
        }
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndpointName") {
            self.endpointName = dict["EndpointName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("IpBlacklist") {
            self.ipBlacklist = dict["IpBlacklist"] as! String
        }
        if dict.keys.contains("IpWhitelist") {
            self.ipWhitelist = dict["IpWhitelist"] as! String
        }
        if dict.keys.contains("ManifestName") {
            self.manifestName = dict["ManifestName"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("TimeshiftVision") {
            self.timeshiftVision = dict["TimeshiftVision"] as! Int32
        }
    }
}

public class UpdateLivePackageOriginEndpointResponseBody : Tea.TeaModel {
    public class LivePackageOriginEndpoint : Tea.TeaModel {
        public var authorizationCode: String?

        public var channelName: String?

        public var createTime: String?

        public var description_: String?

        public var endpointName: String?

        public var endpointUrl: String?

        public var groupName: String?

        public var ipBlacklist: String?

        public var ipWhitelist: String?

        public var lastModified: String?

        public var manifestName: String?

        public var protocol_: String?

        public var timeshiftVision: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizationCode != nil {
                map["AuthorizationCode"] = self.authorizationCode!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.endpointName != nil {
                map["EndpointName"] = self.endpointName!
            }
            if self.endpointUrl != nil {
                map["EndpointUrl"] = self.endpointUrl!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.ipBlacklist != nil {
                map["IpBlacklist"] = self.ipBlacklist!
            }
            if self.ipWhitelist != nil {
                map["IpWhitelist"] = self.ipWhitelist!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.manifestName != nil {
                map["ManifestName"] = self.manifestName!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.timeshiftVision != nil {
                map["TimeshiftVision"] = self.timeshiftVision!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizationCode") {
                self.authorizationCode = dict["AuthorizationCode"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EndpointName") {
                self.endpointName = dict["EndpointName"] as! String
            }
            if dict.keys.contains("EndpointUrl") {
                self.endpointUrl = dict["EndpointUrl"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("IpBlacklist") {
                self.ipBlacklist = dict["IpBlacklist"] as! String
            }
            if dict.keys.contains("IpWhitelist") {
                self.ipWhitelist = dict["IpWhitelist"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("ManifestName") {
                self.manifestName = dict["ManifestName"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("TimeshiftVision") {
                self.timeshiftVision = dict["TimeshiftVision"] as! Int32
            }
        }
    }
    public var livePackageOriginEndpoint: UpdateLivePackageOriginEndpointResponseBody.LivePackageOriginEndpoint?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.livePackageOriginEndpoint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageOriginEndpoint != nil {
            map["LivePackageOriginEndpoint"] = self.livePackageOriginEndpoint?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LivePackageOriginEndpoint") {
            var model = UpdateLivePackageOriginEndpointResponseBody.LivePackageOriginEndpoint()
            model.fromMap(dict["LivePackageOriginEndpoint"] as! [String: Any])
            self.livePackageOriginEndpoint = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLivePackageOriginEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLivePackageOriginEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLivePackageOriginEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveRecordTemplateRequest : Tea.TeaModel {
    public class RecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var ossObjectPrefix: String?

        public var sliceDuration: Int32?

        public var sliceOssObjectPrefix: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.ossObjectPrefix != nil {
                map["OssObjectPrefix"] = self.ossObjectPrefix!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            if self.sliceOssObjectPrefix != nil {
                map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CycleDuration") {
                self.cycleDuration = dict["CycleDuration"] as! Int32
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("OssObjectPrefix") {
                self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
            }
            if dict.keys.contains("SliceDuration") {
                self.sliceDuration = dict["SliceDuration"] as! Int32
            }
            if dict.keys.contains("SliceOssObjectPrefix") {
                self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
            }
        }
    }
    public var name: String?

    public var recordFormat: [UpdateLiveRecordTemplateRequest.RecordFormat]?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormat != nil {
            var tmp : [Any] = []
            for k in self.recordFormat! {
                tmp.append(k.toMap())
            }
            map["RecordFormat"] = tmp
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") {
            var tmp : [UpdateLiveRecordTemplateRequest.RecordFormat] = []
            for v in dict["RecordFormat"] as! [Any] {
                var model = UpdateLiveRecordTemplateRequest.RecordFormat()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordFormat = tmp
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveRecordTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var recordFormatShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordFormatShrink != nil {
            map["RecordFormat"] = self.recordFormatShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecordFormat") {
            self.recordFormatShrink = dict["RecordFormat"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveRecordTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveRecordTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveRecordTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveRecordTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveSnapshotTemplateRequest : Tea.TeaModel {
    public var overwriteFormat: String?

    public var sequenceFormat: String?

    public var templateId: String?

    public var templateName: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.overwriteFormat != nil {
            map["OverwriteFormat"] = self.overwriteFormat!
        }
        if self.sequenceFormat != nil {
            map["SequenceFormat"] = self.sequenceFormat!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OverwriteFormat") {
            self.overwriteFormat = dict["OverwriteFormat"] as! String
        }
        if dict.keys.contains("SequenceFormat") {
            self.sequenceFormat = dict["SequenceFormat"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class UpdateLiveSnapshotTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveSnapshotTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveSnapshotTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveSnapshotTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveTranscodeJobRequest : Tea.TeaModel {
    public class StreamInput : Tea.TeaModel {
        public var inputUrl: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inputUrl != nil {
                map["InputUrl"] = self.inputUrl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InputUrl") {
                self.inputUrl = dict["InputUrl"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class TimedConfig : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class TranscodeOutput : Tea.TeaModel {
        public var domainName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var jobId: String?

    public var name: String?

    public var streamInput: UpdateLiveTranscodeJobRequest.StreamInput?

    public var timedConfig: UpdateLiveTranscodeJobRequest.TimedConfig?

    public var transcodeOutput: UpdateLiveTranscodeJobRequest.TranscodeOutput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamInput?.validate()
        try self.timedConfig?.validate()
        try self.transcodeOutput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput?.toMap()
        }
        if self.timedConfig != nil {
            map["TimedConfig"] = self.timedConfig?.toMap()
        }
        if self.transcodeOutput != nil {
            map["TranscodeOutput"] = self.transcodeOutput?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StreamInput") {
            var model = UpdateLiveTranscodeJobRequest.StreamInput()
            model.fromMap(dict["StreamInput"] as! [String: Any])
            self.streamInput = model
        }
        if dict.keys.contains("TimedConfig") {
            var model = UpdateLiveTranscodeJobRequest.TimedConfig()
            model.fromMap(dict["TimedConfig"] as! [String: Any])
            self.timedConfig = model
        }
        if dict.keys.contains("TranscodeOutput") {
            var model = UpdateLiveTranscodeJobRequest.TranscodeOutput()
            model.fromMap(dict["TranscodeOutput"] as! [String: Any])
            self.transcodeOutput = model
        }
    }
}

public class UpdateLiveTranscodeJobShrinkRequest : Tea.TeaModel {
    public var jobId: String?

    public var name: String?

    public var streamInputShrink: String?

    public var timedConfigShrink: String?

    public var transcodeOutputShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.streamInputShrink != nil {
            map["StreamInput"] = self.streamInputShrink!
        }
        if self.timedConfigShrink != nil {
            map["TimedConfig"] = self.timedConfigShrink!
        }
        if self.transcodeOutputShrink != nil {
            map["TranscodeOutput"] = self.transcodeOutputShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StreamInput") {
            self.streamInputShrink = dict["StreamInput"] as! String
        }
        if dict.keys.contains("TimedConfig") {
            self.timedConfigShrink = dict["TimedConfig"] as! String
        }
        if dict.keys.contains("TranscodeOutput") {
            self.transcodeOutputShrink = dict["TranscodeOutput"] as! String
        }
    }
}

public class UpdateLiveTranscodeJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveTranscodeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveTranscodeTemplateRequest : Tea.TeaModel {
    public class TemplateConfig : Tea.TeaModel {
        public class AudioParams : Tea.TeaModel {
            public var bitrate: String?

            public var channels: String?

            public var codec: String?

            public var profile: String?

            public var samplerate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.samplerate != nil {
                    map["Samplerate"] = self.samplerate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Samplerate") {
                    self.samplerate = dict["Samplerate"] as! String
                }
            }
        }
        public class VideoParams : Tea.TeaModel {
            public var bitrate: String?

            public var codec: String?

            public var fps: String?

            public var gop: String?

            public var height: String?

            public var profile: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Gop") {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audioParams: UpdateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams?

        public var videoParams: UpdateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audioParams?.validate()
            try self.videoParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioParams != nil {
                map["AudioParams"] = self.audioParams?.toMap()
            }
            if self.videoParams != nil {
                map["VideoParams"] = self.videoParams?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioParams") {
                var model = UpdateLiveTranscodeTemplateRequest.TemplateConfig.AudioParams()
                model.fromMap(dict["AudioParams"] as! [String: Any])
                self.audioParams = model
            }
            if dict.keys.contains("VideoParams") {
                var model = UpdateLiveTranscodeTemplateRequest.TemplateConfig.VideoParams()
                model.fromMap(dict["VideoParams"] as! [String: Any])
                self.videoParams = model
            }
        }
    }
    public var name: String?

    public var templateConfig: UpdateLiveTranscodeTemplateRequest.TemplateConfig?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig?.toMap()
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            var model = UpdateLiveTranscodeTemplateRequest.TemplateConfig()
            model.fromMap(dict["TemplateConfig"] as! [String: Any])
            self.templateConfig = model
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveTranscodeTemplateShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfigShrink: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfigShrink != nil {
            map["TemplateConfig"] = self.templateConfigShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfigShrink = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaConnectFlowInputRequest : Tea.TeaModel {
    public var cidrs: String?

    public var flowId: String?

    public var inputFromUrl: String?

    public var inputName: String?

    public var maxBitrate: Int32?

    public var srtLatency: Int32?

    public var srtPassphrase: String?

    public var srtPbkeyLen: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrs != nil {
            map["Cidrs"] = self.cidrs!
        }
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.inputFromUrl != nil {
            map["InputFromUrl"] = self.inputFromUrl!
        }
        if self.inputName != nil {
            map["InputName"] = self.inputName!
        }
        if self.maxBitrate != nil {
            map["MaxBitrate"] = self.maxBitrate!
        }
        if self.srtLatency != nil {
            map["SrtLatency"] = self.srtLatency!
        }
        if self.srtPassphrase != nil {
            map["SrtPassphrase"] = self.srtPassphrase!
        }
        if self.srtPbkeyLen != nil {
            map["SrtPbkeyLen"] = self.srtPbkeyLen!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cidrs") {
            self.cidrs = dict["Cidrs"] as! String
        }
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
        if dict.keys.contains("InputFromUrl") {
            self.inputFromUrl = dict["InputFromUrl"] as! String
        }
        if dict.keys.contains("InputName") {
            self.inputName = dict["InputName"] as! String
        }
        if dict.keys.contains("MaxBitrate") {
            self.maxBitrate = dict["MaxBitrate"] as! Int32
        }
        if dict.keys.contains("SrtLatency") {
            self.srtLatency = dict["SrtLatency"] as! Int32
        }
        if dict.keys.contains("SrtPassphrase") {
            self.srtPassphrase = dict["SrtPassphrase"] as! String
        }
        if dict.keys.contains("SrtPbkeyLen") {
            self.srtPbkeyLen = dict["SrtPbkeyLen"] as! Int32
        }
    }
}

public class UpdateMediaConnectFlowInputResponseBody : Tea.TeaModel {
    public var content: String?

    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetCode") {
            self.retCode = dict["RetCode"] as! Int32
        }
    }
}

public class UpdateMediaConnectFlowInputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaConnectFlowInputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaConnectFlowInputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaConnectFlowOutputRequest : Tea.TeaModel {
    public var cidrs: String?

    public var flowId: String?

    public var outputName: String?

    public var outputToUrl: String?

    public var playerLimit: String?

    public var srtLatency: String?

    public var srtPassphrase: String?

    public var srtPbkeyLen: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrs != nil {
            map["Cidrs"] = self.cidrs!
        }
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.outputName != nil {
            map["OutputName"] = self.outputName!
        }
        if self.outputToUrl != nil {
            map["OutputToUrl"] = self.outputToUrl!
        }
        if self.playerLimit != nil {
            map["PlayerLimit"] = self.playerLimit!
        }
        if self.srtLatency != nil {
            map["SrtLatency"] = self.srtLatency!
        }
        if self.srtPassphrase != nil {
            map["SrtPassphrase"] = self.srtPassphrase!
        }
        if self.srtPbkeyLen != nil {
            map["SrtPbkeyLen"] = self.srtPbkeyLen!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cidrs") {
            self.cidrs = dict["Cidrs"] as! String
        }
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
        if dict.keys.contains("OutputName") {
            self.outputName = dict["OutputName"] as! String
        }
        if dict.keys.contains("OutputToUrl") {
            self.outputToUrl = dict["OutputToUrl"] as! String
        }
        if dict.keys.contains("PlayerLimit") {
            self.playerLimit = dict["PlayerLimit"] as! String
        }
        if dict.keys.contains("SrtLatency") {
            self.srtLatency = dict["SrtLatency"] as! String
        }
        if dict.keys.contains("SrtPassphrase") {
            self.srtPassphrase = dict["SrtPassphrase"] as! String
        }
        if dict.keys.contains("SrtPbkeyLen") {
            self.srtPbkeyLen = dict["SrtPbkeyLen"] as! String
        }
    }
}

public class UpdateMediaConnectFlowOutputResponseBody : Tea.TeaModel {
    public var content: String?

    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetCode") {
            self.retCode = dict["RetCode"] as! Int32
        }
    }
}

public class UpdateMediaConnectFlowOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaConnectFlowOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaConnectFlowOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaConnectFlowStatusRequest : Tea.TeaModel {
    public var flowId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdateMediaConnectFlowStatusResponseBody : Tea.TeaModel {
    public var content: String?

    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetCode") {
            self.retCode = dict["RetCode"] as! Int32
        }
    }
}

public class UpdateMediaConnectFlowStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaConnectFlowStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaConnectFlowStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaInfoRequest : Tea.TeaModel {
    public var appendTags: Bool?

    public var businessType: String?

    public var cateId: Int64?

    public var category: String?

    public var coverURL: String?

    public var description_: String?

    public var inputURL: String?

    public var mediaId: String?

    public var mediaTags: String?

    public var referenceId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appendTags != nil {
            map["AppendTags"] = self.appendTags!
        }
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.inputURL != nil {
            map["InputURL"] = self.inputURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaTags != nil {
            map["MediaTags"] = self.mediaTags!
        }
        if self.referenceId != nil {
            map["ReferenceId"] = self.referenceId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppendTags") {
            self.appendTags = dict["AppendTags"] as! Bool
        }
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InputURL") {
            self.inputURL = dict["InputURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaTags") {
            self.mediaTags = dict["MediaTags"] as! String
        }
        if dict.keys.contains("ReferenceId") {
            self.referenceId = dict["ReferenceId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UpdateMediaInfoResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaLiveChannelRequest : Tea.TeaModel {
    public class AudioSettings : Tea.TeaModel {
        public class AudioCodecSetting : Tea.TeaModel {
            public var bitrate: Int32?

            public var profile: String?

            public var sampleRate: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.sampleRate != nil {
                    map["SampleRate"] = self.sampleRate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! Int32
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("SampleRate") {
                    self.sampleRate = dict["SampleRate"] as! Int32
                }
            }
        }
        public var audioCodec: String?

        public var audioCodecSetting: UpdateMediaLiveChannelRequest.AudioSettings.AudioCodecSetting?

        public var audioSelectorName: String?

        public var languageCode: String?

        public var languageName: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audioCodecSetting?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioCodec != nil {
                map["AudioCodec"] = self.audioCodec!
            }
            if self.audioCodecSetting != nil {
                map["AudioCodecSetting"] = self.audioCodecSetting?.toMap()
            }
            if self.audioSelectorName != nil {
                map["AudioSelectorName"] = self.audioSelectorName!
            }
            if self.languageCode != nil {
                map["LanguageCode"] = self.languageCode!
            }
            if self.languageName != nil {
                map["LanguageName"] = self.languageName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioCodec") {
                self.audioCodec = dict["AudioCodec"] as! String
            }
            if dict.keys.contains("AudioCodecSetting") {
                var model = UpdateMediaLiveChannelRequest.AudioSettings.AudioCodecSetting()
                model.fromMap(dict["AudioCodecSetting"] as! [String: Any])
                self.audioCodecSetting = model
            }
            if dict.keys.contains("AudioSelectorName") {
                self.audioSelectorName = dict["AudioSelectorName"] as! String
            }
            if dict.keys.contains("LanguageCode") {
                self.languageCode = dict["LanguageCode"] as! String
            }
            if dict.keys.contains("LanguageName") {
                self.languageName = dict["LanguageName"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public class InputAttachments : Tea.TeaModel {
        public class AudioSelectors : Tea.TeaModel {
            public class AudioLanguageSelection : Tea.TeaModel {
                public var languageCode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.languageCode != nil {
                        map["LanguageCode"] = self.languageCode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LanguageCode") {
                        self.languageCode = dict["LanguageCode"] as! String
                    }
                }
            }
            public class AudioPidSelection : Tea.TeaModel {
                public var pid: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pid != nil {
                        map["Pid"] = self.pid!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Pid") {
                        self.pid = dict["Pid"] as! Int64
                    }
                }
            }
            public class AudioTrackSelection : Tea.TeaModel {
                public var trackId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.trackId != nil {
                        map["TrackId"] = self.trackId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TrackId") {
                        self.trackId = dict["TrackId"] as! Int64
                    }
                }
            }
            public var audioLanguageSelection: UpdateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioLanguageSelection?

            public var audioPidSelection: UpdateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioPidSelection?

            public var audioTrackSelection: [UpdateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioTrackSelection]?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioLanguageSelection?.validate()
                try self.audioPidSelection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioLanguageSelection != nil {
                    map["AudioLanguageSelection"] = self.audioLanguageSelection?.toMap()
                }
                if self.audioPidSelection != nil {
                    map["AudioPidSelection"] = self.audioPidSelection?.toMap()
                }
                if self.audioTrackSelection != nil {
                    var tmp : [Any] = []
                    for k in self.audioTrackSelection! {
                        tmp.append(k.toMap())
                    }
                    map["AudioTrackSelection"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioLanguageSelection") {
                    var model = UpdateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioLanguageSelection()
                    model.fromMap(dict["AudioLanguageSelection"] as! [String: Any])
                    self.audioLanguageSelection = model
                }
                if dict.keys.contains("AudioPidSelection") {
                    var model = UpdateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioPidSelection()
                    model.fromMap(dict["AudioPidSelection"] as! [String: Any])
                    self.audioPidSelection = model
                }
                if dict.keys.contains("AudioTrackSelection") {
                    var tmp : [UpdateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioTrackSelection] = []
                    for v in dict["AudioTrackSelection"] as! [Any] {
                        var model = UpdateMediaLiveChannelRequest.InputAttachments.AudioSelectors.AudioTrackSelection()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioTrackSelection = tmp
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var audioSelectors: [UpdateMediaLiveChannelRequest.InputAttachments.AudioSelectors]?

        public var inputId: String?

        public var languageName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioSelectors != nil {
                var tmp : [Any] = []
                for k in self.audioSelectors! {
                    tmp.append(k.toMap())
                }
                map["AudioSelectors"] = tmp
            }
            if self.inputId != nil {
                map["InputId"] = self.inputId!
            }
            if self.languageName != nil {
                map["LanguageName"] = self.languageName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioSelectors") {
                var tmp : [UpdateMediaLiveChannelRequest.InputAttachments.AudioSelectors] = []
                for v in dict["AudioSelectors"] as! [Any] {
                    var model = UpdateMediaLiveChannelRequest.InputAttachments.AudioSelectors()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.audioSelectors = tmp
            }
            if dict.keys.contains("InputId") {
                self.inputId = dict["InputId"] as! String
            }
            if dict.keys.contains("LanguageName") {
                self.languageName = dict["LanguageName"] as! String
            }
        }
    }
    public class OutputGroups : Tea.TeaModel {
        public class MediaPackageGroupSetting : Tea.TeaModel {
            public var channelName: String?

            public var groupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelName != nil {
                    map["ChannelName"] = self.channelName!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelName") {
                    self.channelName = dict["ChannelName"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
            }
        }
        public class Outputs : Tea.TeaModel {
            public class MediaPackageOutputSetting : Tea.TeaModel {
                public var audioGroupId: String?

                public var nameModifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioGroupId != nil {
                        map["AudioGroupId"] = self.audioGroupId!
                    }
                    if self.nameModifier != nil {
                        map["NameModifier"] = self.nameModifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioGroupId") {
                        self.audioGroupId = dict["AudioGroupId"] as! String
                    }
                    if dict.keys.contains("NameModifier") {
                        self.nameModifier = dict["NameModifier"] as! String
                    }
                }
            }
            public var audioSettingNames: [String]?

            public var mediaPackageOutputSetting: UpdateMediaLiveChannelRequest.OutputGroups.Outputs.MediaPackageOutputSetting?

            public var mediaType: Int32?

            public var name: String?

            public var videoSettingName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.mediaPackageOutputSetting?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioSettingNames != nil {
                    map["AudioSettingNames"] = self.audioSettingNames!
                }
                if self.mediaPackageOutputSetting != nil {
                    map["MediaPackageOutputSetting"] = self.mediaPackageOutputSetting?.toMap()
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.videoSettingName != nil {
                    map["VideoSettingName"] = self.videoSettingName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioSettingNames") {
                    self.audioSettingNames = dict["AudioSettingNames"] as! [String]
                }
                if dict.keys.contains("MediaPackageOutputSetting") {
                    var model = UpdateMediaLiveChannelRequest.OutputGroups.Outputs.MediaPackageOutputSetting()
                    model.fromMap(dict["MediaPackageOutputSetting"] as! [String: Any])
                    self.mediaPackageOutputSetting = model
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("VideoSettingName") {
                    self.videoSettingName = dict["VideoSettingName"] as! String
                }
            }
        }
        public var mediaPackageGroupSetting: UpdateMediaLiveChannelRequest.OutputGroups.MediaPackageGroupSetting?

        public var name: String?

        public var outputs: [UpdateMediaLiveChannelRequest.OutputGroups.Outputs]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mediaPackageGroupSetting?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaPackageGroupSetting != nil {
                map["MediaPackageGroupSetting"] = self.mediaPackageGroupSetting?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputs != nil {
                var tmp : [Any] = []
                for k in self.outputs! {
                    tmp.append(k.toMap())
                }
                map["Outputs"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaPackageGroupSetting") {
                var model = UpdateMediaLiveChannelRequest.OutputGroups.MediaPackageGroupSetting()
                model.fromMap(dict["MediaPackageGroupSetting"] as! [String: Any])
                self.mediaPackageGroupSetting = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Outputs") {
                var tmp : [UpdateMediaLiveChannelRequest.OutputGroups.Outputs] = []
                for v in dict["Outputs"] as! [Any] {
                    var model = UpdateMediaLiveChannelRequest.OutputGroups.Outputs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outputs = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class VideoSettings : Tea.TeaModel {
        public class VideoCodecSetting : Tea.TeaModel {
            public class CodecDetail : Tea.TeaModel {
                public var level: String?

                public var profile: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                }
            }
            public class Framerate : Tea.TeaModel {
                public var framerateControl: String?

                public var framerateDenominator: Int32?

                public var framerateNumerator: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.framerateControl != nil {
                        map["FramerateControl"] = self.framerateControl!
                    }
                    if self.framerateDenominator != nil {
                        map["FramerateDenominator"] = self.framerateDenominator!
                    }
                    if self.framerateNumerator != nil {
                        map["FramerateNumerator"] = self.framerateNumerator!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FramerateControl") {
                        self.framerateControl = dict["FramerateControl"] as! String
                    }
                    if dict.keys.contains("FramerateDenominator") {
                        self.framerateDenominator = dict["FramerateDenominator"] as! Int32
                    }
                    if dict.keys.contains("FramerateNumerator") {
                        self.framerateNumerator = dict["FramerateNumerator"] as! Int32
                    }
                }
            }
            public class Gop : Tea.TeaModel {
                public var bframesNum: Int32?

                public var gopSize: Int32?

                public var gopSizeUnits: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bframesNum != nil {
                        map["BframesNum"] = self.bframesNum!
                    }
                    if self.gopSize != nil {
                        map["GopSize"] = self.gopSize!
                    }
                    if self.gopSizeUnits != nil {
                        map["GopSizeUnits"] = self.gopSizeUnits!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BframesNum") {
                        self.bframesNum = dict["BframesNum"] as! Int32
                    }
                    if dict.keys.contains("GopSize") {
                        self.gopSize = dict["GopSize"] as! Int32
                    }
                    if dict.keys.contains("GopSizeUnits") {
                        self.gopSizeUnits = dict["GopSizeUnits"] as! String
                    }
                }
            }
            public class Rate : Tea.TeaModel {
                public var bitrate: Int32?

                public var bufferSize: Int32?

                public var maxBitrate: Int32?

                public var rateControlMode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.bufferSize != nil {
                        map["BufferSize"] = self.bufferSize!
                    }
                    if self.maxBitrate != nil {
                        map["MaxBitrate"] = self.maxBitrate!
                    }
                    if self.rateControlMode != nil {
                        map["RateControlMode"] = self.rateControlMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! Int32
                    }
                    if dict.keys.contains("BufferSize") {
                        self.bufferSize = dict["BufferSize"] as! Int32
                    }
                    if dict.keys.contains("MaxBitrate") {
                        self.maxBitrate = dict["MaxBitrate"] as! Int32
                    }
                    if dict.keys.contains("RateControlMode") {
                        self.rateControlMode = dict["RateControlMode"] as! String
                    }
                }
            }
            public var codecDetail: UpdateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.CodecDetail?

            public var framerate: UpdateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.Framerate?

            public var gop: UpdateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.Gop?

            public var rate: UpdateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.Rate?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.codecDetail?.validate()
                try self.framerate?.validate()
                try self.gop?.validate()
                try self.rate?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.codecDetail != nil {
                    map["CodecDetail"] = self.codecDetail?.toMap()
                }
                if self.framerate != nil {
                    map["Framerate"] = self.framerate?.toMap()
                }
                if self.gop != nil {
                    map["Gop"] = self.gop?.toMap()
                }
                if self.rate != nil {
                    map["Rate"] = self.rate?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CodecDetail") {
                    var model = UpdateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.CodecDetail()
                    model.fromMap(dict["CodecDetail"] as! [String: Any])
                    self.codecDetail = model
                }
                if dict.keys.contains("Framerate") {
                    var model = UpdateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.Framerate()
                    model.fromMap(dict["Framerate"] as! [String: Any])
                    self.framerate = model
                }
                if dict.keys.contains("Gop") {
                    var model = UpdateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.Gop()
                    model.fromMap(dict["Gop"] as! [String: Any])
                    self.gop = model
                }
                if dict.keys.contains("Rate") {
                    var model = UpdateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting.Rate()
                    model.fromMap(dict["Rate"] as! [String: Any])
                    self.rate = model
                }
            }
        }
        public var height: Int32?

        public var name: String?

        public var videoCodec: String?

        public var videoCodecSetting: UpdateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting?

        public var width: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.videoCodecSetting?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.videoCodec != nil {
                map["VideoCodec"] = self.videoCodec!
            }
            if self.videoCodecSetting != nil {
                map["VideoCodecSetting"] = self.videoCodecSetting?.toMap()
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("VideoCodec") {
                self.videoCodec = dict["VideoCodec"] as! String
            }
            if dict.keys.contains("VideoCodecSetting") {
                var model = UpdateMediaLiveChannelRequest.VideoSettings.VideoCodecSetting()
                model.fromMap(dict["VideoCodecSetting"] as! [String: Any])
                self.videoCodecSetting = model
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int32
            }
        }
    }
    public var audioSettings: [UpdateMediaLiveChannelRequest.AudioSettings]?

    public var channelId: String?

    public var inputAttachments: [UpdateMediaLiveChannelRequest.InputAttachments]?

    public var name: String?

    public var outputGroups: [UpdateMediaLiveChannelRequest.OutputGroups]?

    public var videoSettings: [UpdateMediaLiveChannelRequest.VideoSettings]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioSettings != nil {
            var tmp : [Any] = []
            for k in self.audioSettings! {
                tmp.append(k.toMap())
            }
            map["AudioSettings"] = tmp
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.inputAttachments != nil {
            var tmp : [Any] = []
            for k in self.inputAttachments! {
                tmp.append(k.toMap())
            }
            map["InputAttachments"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputGroups != nil {
            var tmp : [Any] = []
            for k in self.outputGroups! {
                tmp.append(k.toMap())
            }
            map["OutputGroups"] = tmp
        }
        if self.videoSettings != nil {
            var tmp : [Any] = []
            for k in self.videoSettings! {
                tmp.append(k.toMap())
            }
            map["VideoSettings"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioSettings") {
            var tmp : [UpdateMediaLiveChannelRequest.AudioSettings] = []
            for v in dict["AudioSettings"] as! [Any] {
                var model = UpdateMediaLiveChannelRequest.AudioSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.audioSettings = tmp
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("InputAttachments") {
            var tmp : [UpdateMediaLiveChannelRequest.InputAttachments] = []
            for v in dict["InputAttachments"] as! [Any] {
                var model = UpdateMediaLiveChannelRequest.InputAttachments()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inputAttachments = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputGroups") {
            var tmp : [UpdateMediaLiveChannelRequest.OutputGroups] = []
            for v in dict["OutputGroups"] as! [Any] {
                var model = UpdateMediaLiveChannelRequest.OutputGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outputGroups = tmp
        }
        if dict.keys.contains("VideoSettings") {
            var tmp : [UpdateMediaLiveChannelRequest.VideoSettings] = []
            for v in dict["VideoSettings"] as! [Any] {
                var model = UpdateMediaLiveChannelRequest.VideoSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.videoSettings = tmp
        }
    }
}

public class UpdateMediaLiveChannelShrinkRequest : Tea.TeaModel {
    public var audioSettingsShrink: String?

    public var channelId: String?

    public var inputAttachmentsShrink: String?

    public var name: String?

    public var outputGroupsShrink: String?

    public var videoSettingsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioSettingsShrink != nil {
            map["AudioSettings"] = self.audioSettingsShrink!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.inputAttachmentsShrink != nil {
            map["InputAttachments"] = self.inputAttachmentsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputGroupsShrink != nil {
            map["OutputGroups"] = self.outputGroupsShrink!
        }
        if self.videoSettingsShrink != nil {
            map["VideoSettings"] = self.videoSettingsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioSettings") {
            self.audioSettingsShrink = dict["AudioSettings"] as! String
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("InputAttachments") {
            self.inputAttachmentsShrink = dict["InputAttachments"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputGroups") {
            self.outputGroupsShrink = dict["OutputGroups"] as! String
        }
        if dict.keys.contains("VideoSettings") {
            self.videoSettingsShrink = dict["VideoSettings"] as! String
        }
    }
}

public class UpdateMediaLiveChannelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaLiveChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaLiveChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaLiveChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaLiveInputRequest : Tea.TeaModel {
    public class InputSettings : Tea.TeaModel {
        public var flowId: String?

        public var flowOutputName: String?

        public var sourceUrl: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flowId != nil {
                map["FlowId"] = self.flowId!
            }
            if self.flowOutputName != nil {
                map["FlowOutputName"] = self.flowOutputName!
            }
            if self.sourceUrl != nil {
                map["SourceUrl"] = self.sourceUrl!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FlowId") {
                self.flowId = dict["FlowId"] as! String
            }
            if dict.keys.contains("FlowOutputName") {
                self.flowOutputName = dict["FlowOutputName"] as! String
            }
            if dict.keys.contains("SourceUrl") {
                self.sourceUrl = dict["SourceUrl"] as! String
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
        }
    }
    public var inputId: String?

    public var inputSettings: [UpdateMediaLiveInputRequest.InputSettings]?

    public var name: String?

    public var securityGroupIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputId != nil {
            map["InputId"] = self.inputId!
        }
        if self.inputSettings != nil {
            var tmp : [Any] = []
            for k in self.inputSettings! {
                tmp.append(k.toMap())
            }
            map["InputSettings"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputId") {
            self.inputId = dict["InputId"] as! String
        }
        if dict.keys.contains("InputSettings") {
            var tmp : [UpdateMediaLiveInputRequest.InputSettings] = []
            for v in dict["InputSettings"] as! [Any] {
                var model = UpdateMediaLiveInputRequest.InputSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inputSettings = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
    }
}

public class UpdateMediaLiveInputShrinkRequest : Tea.TeaModel {
    public var inputId: String?

    public var inputSettingsShrink: String?

    public var name: String?

    public var securityGroupIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputId != nil {
            map["InputId"] = self.inputId!
        }
        if self.inputSettingsShrink != nil {
            map["InputSettings"] = self.inputSettingsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.securityGroupIdsShrink != nil {
            map["SecurityGroupIds"] = self.securityGroupIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputId") {
            self.inputId = dict["InputId"] as! String
        }
        if dict.keys.contains("InputSettings") {
            self.inputSettingsShrink = dict["InputSettings"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIdsShrink = dict["SecurityGroupIds"] as! String
        }
    }
}

public class UpdateMediaLiveInputResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaLiveInputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaLiveInputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaLiveInputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaLiveInputSecurityGroupRequest : Tea.TeaModel {
    public var name: String?

    public var securityGroupId: String?

    public var whitelistRules: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.whitelistRules != nil {
            map["WhitelistRules"] = self.whitelistRules!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("WhitelistRules") {
            self.whitelistRules = dict["WhitelistRules"] as! [String]
        }
    }
}

public class UpdateMediaLiveInputSecurityGroupShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var securityGroupId: String?

    public var whitelistRulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.whitelistRulesShrink != nil {
            map["WhitelistRules"] = self.whitelistRulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("WhitelistRules") {
            self.whitelistRulesShrink = dict["WhitelistRules"] as! String
        }
    }
}

public class UpdateMediaLiveInputSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaLiveInputSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaLiveInputSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaLiveInputSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaMarksRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarks != nil {
            map["MediaMarks"] = self.mediaMarks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarks") {
            self.mediaMarks = dict["MediaMarks"] as! String
        }
    }
}

public class UpdateMediaMarksResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var mediaMarkIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaMarkIds != nil {
            map["MediaMarkIds"] = self.mediaMarkIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaMarkIds") {
            self.mediaMarkIds = dict["MediaMarkIds"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaMarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaMarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaMarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaToSearchLibRequest : Tea.TeaModel {
    public var mediaId: String?

    public var msgBody: String?

    public var searchLibName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.msgBody != nil {
            map["MsgBody"] = self.msgBody!
        }
        if self.searchLibName != nil {
            map["SearchLibName"] = self.searchLibName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MsgBody") {
            self.msgBody = dict["MsgBody"] as! String
        }
        if dict.keys.contains("SearchLibName") {
            self.searchLibName = dict["SearchLibName"] as! String
        }
    }
}

public class UpdateMediaToSearchLibResponseBody : Tea.TeaModel {
    public var code: String?

    public var mediaId: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class UpdateMediaToSearchLibResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaToSearchLibResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaToSearchLibResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePipelineRequest : Tea.TeaModel {
    public var name: String?

    public var pipelineId: String?

    public var priority: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdatePipelineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProgramRequest : Tea.TeaModel {
    public var adBreaks: String?

    public var channelName: String?

    public var clipRange: String?

    public var programName: String?

    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public var transition: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adBreaks != nil {
            map["AdBreaks"] = self.adBreaks!
        }
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.clipRange != nil {
            map["ClipRange"] = self.clipRange!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.transition != nil {
            map["Transition"] = self.transition!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdBreaks") {
            self.adBreaks = dict["AdBreaks"] as! String
        }
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ClipRange") {
            self.clipRange = dict["ClipRange"] as! String
        }
        if dict.keys.contains("ProgramName") {
            self.programName = dict["ProgramName"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("Transition") {
            self.transition = dict["Transition"] as! String
        }
    }
}

public class UpdateProgramResponseBody : Tea.TeaModel {
    public var program: ChannelAssemblyProgram?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.program?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.program != nil {
            map["Program"] = self.program?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Program") {
            var model = ChannelAssemblyProgram()
            model.fromMap(dict["Program"] as! [String: Any])
            self.program = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateProgramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProgramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateProgramResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRtcRobotInstanceRequest : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public var enableVoiceInterrupt: Bool?

        public var greeting: String?

        public var voiceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableVoiceInterrupt != nil {
                map["EnableVoiceInterrupt"] = self.enableVoiceInterrupt!
            }
            if self.greeting != nil {
                map["Greeting"] = self.greeting!
            }
            if self.voiceId != nil {
                map["VoiceId"] = self.voiceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableVoiceInterrupt") {
                self.enableVoiceInterrupt = dict["EnableVoiceInterrupt"] as! Bool
            }
            if dict.keys.contains("Greeting") {
                self.greeting = dict["Greeting"] as! String
            }
            if dict.keys.contains("VoiceId") {
                self.voiceId = dict["VoiceId"] as! String
            }
        }
    }
    public var config: UpdateRtcRobotInstanceRequest.Config?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.config?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config?.toMap()
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            var model = UpdateRtcRobotInstanceRequest.Config()
            model.fromMap(dict["Config"] as! [String: Any])
            self.config = model
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class UpdateRtcRobotInstanceShrinkRequest : Tea.TeaModel {
    public var configShrink: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configShrink != nil {
            map["Config"] = self.configShrink!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.configShrink = dict["Config"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class UpdateRtcRobotInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateRtcRobotInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRtcRobotInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateRtcRobotInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSourceRequest : Tea.TeaModel {
    public var httpPackageConfigurations: String?

    public var sourceLocationName: String?

    public var sourceName: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.httpPackageConfigurations != nil {
            map["HttpPackageConfigurations"] = self.httpPackageConfigurations!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        if self.sourceName != nil {
            map["SourceName"] = self.sourceName!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HttpPackageConfigurations") {
            self.httpPackageConfigurations = dict["HttpPackageConfigurations"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
        if dict.keys.contains("SourceName") {
            self.sourceName = dict["SourceName"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class UpdateSourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var source: ChannelAssemblySource?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.source?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.source != nil {
            map["Source"] = self.source?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Source") {
            var model = ChannelAssemblySource()
            model.fromMap(dict["Source"] as! [String: Any])
            self.source = model
        }
    }
}

public class UpdateSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSourceLocationRequest : Tea.TeaModel {
    public var baseUrl: String?

    public var enableSegmentDelivery: Bool?

    public var segmentDeliveryUrl: String?

    public var sourceLocationName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseUrl != nil {
            map["BaseUrl"] = self.baseUrl!
        }
        if self.enableSegmentDelivery != nil {
            map["EnableSegmentDelivery"] = self.enableSegmentDelivery!
        }
        if self.segmentDeliveryUrl != nil {
            map["SegmentDeliveryUrl"] = self.segmentDeliveryUrl!
        }
        if self.sourceLocationName != nil {
            map["SourceLocationName"] = self.sourceLocationName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseUrl") {
            self.baseUrl = dict["BaseUrl"] as! String
        }
        if dict.keys.contains("EnableSegmentDelivery") {
            self.enableSegmentDelivery = dict["EnableSegmentDelivery"] as! Bool
        }
        if dict.keys.contains("SegmentDeliveryUrl") {
            self.segmentDeliveryUrl = dict["SegmentDeliveryUrl"] as! String
        }
        if dict.keys.contains("SourceLocationName") {
            self.sourceLocationName = dict["SourceLocationName"] as! String
        }
    }
}

public class UpdateSourceLocationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var sourceLocation: ChannelAssemblySourceLocation?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sourceLocation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceLocation != nil {
            map["SourceLocation"] = self.sourceLocation?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceLocation") {
            var model = ChannelAssemblySourceLocation()
            model.fromMap(dict["SourceLocation"] as! [String: Any])
            self.sourceLocation = model
        }
    }
}

public class UpdateSourceLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSourceLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSourceLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTemplateRequest : Tea.TeaModel {
    public var config: String?

    public var coverUrl: String?

    public var name: String?

    public var previewMedia: String?

    public var relatedMediaids: String?

    public var source: String?

    public var status: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.previewMedia != nil {
            map["PreviewMedia"] = self.previewMedia!
        }
        if self.relatedMediaids != nil {
            map["RelatedMediaids"] = self.relatedMediaids!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("CoverUrl") {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PreviewMedia") {
            self.previewMedia = dict["PreviewMedia"] as! String
        }
        if dict.keys.contains("RelatedMediaids") {
            self.relatedMediaids = dict["RelatedMediaids"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadMediaByURLRequest : Tea.TeaModel {
    public var appId: String?

    public var entityId: String?

    public var mediaMetaData: String?

    public var postProcessConfig: String?

    public var uploadTargetConfig: String?

    public var uploadURLs: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.mediaMetaData != nil {
            map["MediaMetaData"] = self.mediaMetaData!
        }
        if self.postProcessConfig != nil {
            map["PostProcessConfig"] = self.postProcessConfig!
        }
        if self.uploadTargetConfig != nil {
            map["UploadTargetConfig"] = self.uploadTargetConfig!
        }
        if self.uploadURLs != nil {
            map["UploadURLs"] = self.uploadURLs!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! String
        }
        if dict.keys.contains("MediaMetaData") {
            self.mediaMetaData = dict["MediaMetaData"] as! String
        }
        if dict.keys.contains("PostProcessConfig") {
            self.postProcessConfig = dict["PostProcessConfig"] as! String
        }
        if dict.keys.contains("UploadTargetConfig") {
            self.uploadTargetConfig = dict["UploadTargetConfig"] as! String
        }
        if dict.keys.contains("UploadURLs") {
            self.uploadURLs = dict["UploadURLs"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UploadMediaByURLResponseBody : Tea.TeaModel {
    public class UploadJobs : Tea.TeaModel {
        public var jobId: String?

        public var mediaId: String?

        public var sourceURL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.sourceURL != nil {
                map["SourceURL"] = self.sourceURL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("SourceURL") {
                self.sourceURL = dict["SourceURL"] as! String
            }
        }
    }
    public var requestId: String?

    public var uploadJobs: [UploadMediaByURLResponseBody.UploadJobs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadJobs != nil {
            var tmp : [Any] = []
            for k in self.uploadJobs! {
                tmp.append(k.toMap())
            }
            map["UploadJobs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadJobs") {
            var tmp : [UploadMediaByURLResponseBody.UploadJobs] = []
            for v in dict["UploadJobs"] as! [Any] {
                var model = UploadMediaByURLResponseBody.UploadJobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uploadJobs = tmp
        }
    }
}

public class UploadMediaByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadMediaByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadMediaByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadStreamByURLRequest : Tea.TeaModel {
    public var definition: String?

    public var fileExtension: String?

    public var HDRType: String?

    public var mediaId: String?

    public var streamURL: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.fileExtension != nil {
            map["FileExtension"] = self.fileExtension!
        }
        if self.HDRType != nil {
            map["HDRType"] = self.HDRType!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.streamURL != nil {
            map["StreamURL"] = self.streamURL!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("FileExtension") {
            self.fileExtension = dict["FileExtension"] as! String
        }
        if dict.keys.contains("HDRType") {
            self.HDRType = dict["HDRType"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("StreamURL") {
            self.streamURL = dict["StreamURL"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UploadStreamByURLResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var jobId: String?

    public var mediaId: String?

    public var requestId: String?

    public var sourceURL: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceURL != nil {
            map["SourceURL"] = self.sourceURL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceURL") {
            self.sourceURL = dict["SourceURL"] as! String
        }
    }
}

public class UploadStreamByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadStreamByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadStreamByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
